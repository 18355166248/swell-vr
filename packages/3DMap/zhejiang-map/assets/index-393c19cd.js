import {
  u as d8,
  s as hh,
  o as Ea,
  a as Da,
  b as en,
  c as sn,
  d as wt,
  t as Si,
  r as Bh,
  e as ye,
  n as fh,
  f as La,
  g as je,
  p as HE,
  w as Td,
  i as dh,
  h as Ql,
  j as fy,
  k as p8,
  l as v8,
  m as g8,
  q as WE,
  v as XE,
  x as so,
  y as m8,
  z as Qn,
  A as yM,
  B as ko,
  F as _M,
  C as xM,
  D as Of,
  E as y8,
  G as _8,
  H as Nf,
} from './index-7acb3ea1.js'
const YE = './assets/bottom-menu-arrow-big-180b7071.svg',
  $E = './assets/bottom-menu-arrow-small-19304179.svg'

const VZ = rT
class GZ {
  constructor(t = !1) {
    ;(this.active = t),
      window.location.hash === '#debug' && (this.active = !0),
      this.active && ((this.instance = new VZ()), this.instance.close())
  }
  update() {}
  destroy() {
    this.active && this.instance.destroy()
  }
}
const jD = new U(),
  HZ = new wa(),
  JD = new U()
class YB extends Fe {
  constructor(t = document.createElement('div')) {
    super(),
      (this.isCSS3DObject = !0),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.pointerEvents = 'auto'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      this.addEventListener('removed', function () {
        this.traverse(function (e) {
          e.element instanceof Element &&
            e.element.parentNode !== null &&
            e.element.parentNode.removeChild(e.element)
        })
      })
  }
  copy(t, e) {
    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this
  }
}
class WZ extends YB {
  constructor(t) {
    super(t), (this.isCSS3DSprite = !0), (this.rotation2D = 0)
  }
  copy(t, e) {
    return super.copy(t, e), (this.rotation2D = t.rotation2D), this
  }
}
const Ia = new ae(),
  XZ = new ae()
class YZ {
  constructor(t = {}) {
    const e = this
    let n, i, a, o
    const s = {
        camera: {
          style: '',
        },
        objects: new WeakMap(),
      },
      l = t.element !== void 0 ? t.element : document.createElement('div')
    ;(l.style.overflow = 'hidden'), (this.domElement = l)
    const u = document.createElement('div')
    ;(u.style.transformOrigin = '0 0'),
      (u.style.pointerEvents = 'none'),
      l.appendChild(u)
    const c = document.createElement('div')
    ;(c.style.transformStyle = 'preserve-3d'),
      u.appendChild(c),
      (this.getSize = function () {
        return {
          width: n,
          height: i,
        }
      }),
      (this.render = function (v, m) {
        const y = m.projectionMatrix.elements[5] * o
        m.view && m.view.enabled
          ? ((u.style.transform = `translate( ${
              -m.view.offsetX * (n / m.view.width)
            }px, ${-m.view.offsetY * (i / m.view.height)}px )`),
            (u.style.transform += `scale( ${m.view.fullWidth / m.view.width}, ${
              m.view.fullHeight / m.view.height
            } )`))
          : (u.style.transform = ''),
          v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(),
          m.parent === null &&
            m.matrixWorldAutoUpdate === !0 &&
            m.updateMatrixWorld()
        let _, x
        m.isOrthographicCamera &&
          ((_ = -(m.right + m.left) / 2), (x = (m.top + m.bottom) / 2))
        const A =
            m.view && m.view.enabled ? m.view.height / m.view.fullHeight : 1,
          S = m.isOrthographicCamera
            ? `scale( ${A} )scale(` +
              y +
              ')translate(' +
              h(_) +
              'px,' +
              h(x) +
              'px)' +
              f(m.matrixWorldInverse)
            : `scale( ${A} )translateZ(` + y + 'px)' + f(m.matrixWorldInverse),
          T =
            (m.isPerspectiveCamera ? 'perspective(' + y + 'px) ' : '') +
            S +
            'translate(' +
            a +
            'px,' +
            o +
            'px)'
        s.camera.style !== T && ((c.style.transform = T), (s.camera.style = T)),
          g(v, v, m)
      }),
      (this.setSize = function (v, m) {
        ;(n = v),
          (i = m),
          (a = n / 2),
          (o = i / 2),
          (l.style.width = v + 'px'),
          (l.style.height = m + 'px'),
          (u.style.width = v + 'px'),
          (u.style.height = m + 'px'),
          (c.style.width = v + 'px'),
          (c.style.height = m + 'px')
      })
    function h(v) {
      return Math.abs(v) < 1e-10 ? 0 : v
    }
    function f(v) {
      const m = v.elements
      return (
        'matrix3d(' +
        h(m[0]) +
        ',' +
        h(-m[1]) +
        ',' +
        h(m[2]) +
        ',' +
        h(m[3]) +
        ',' +
        h(m[4]) +
        ',' +
        h(-m[5]) +
        ',' +
        h(m[6]) +
        ',' +
        h(m[7]) +
        ',' +
        h(m[8]) +
        ',' +
        h(-m[9]) +
        ',' +
        h(m[10]) +
        ',' +
        h(m[11]) +
        ',' +
        h(m[12]) +
        ',' +
        h(-m[13]) +
        ',' +
        h(m[14]) +
        ',' +
        h(m[15]) +
        ')'
      )
    }
    function d(v) {
      const m = v.elements
      return (
        'translate(-50%,-50%)' +
        ('matrix3d(' +
          h(m[0]) +
          ',' +
          h(m[1]) +
          ',' +
          h(m[2]) +
          ',' +
          h(m[3]) +
          ',' +
          h(-m[4]) +
          ',' +
          h(-m[5]) +
          ',' +
          h(-m[6]) +
          ',' +
          h(-m[7]) +
          ',' +
          h(m[8]) +
          ',' +
          h(m[9]) +
          ',' +
          h(m[10]) +
          ',' +
          h(m[11]) +
          ',' +
          h(m[12]) +
          ',' +
          h(m[13]) +
          ',' +
          h(m[14]) +
          ',' +
          h(m[15]) +
          ')')
      )
    }
    function p(v) {
      v.isCSS3DObject && (v.element.style.display = 'none')
      for (let m = 0, y = v.children.length; m < y; m++) p(v.children[m])
    }
    function g(v, m, y, _) {
      if (v.visible === !1) {
        p(v)
        return
      }
      if (v.isCSS3DObject) {
        const x = v.layers.test(y.layers) === !0,
          A = v.element
        if (((A.style.display = x === !0 ? '' : 'none'), x === !0)) {
          v.onBeforeRender(e, m, y)
          let S
          v.isCSS3DSprite
            ? (Ia.copy(y.matrixWorldInverse),
              Ia.transpose(),
              v.rotation2D !== 0 && Ia.multiply(XZ.makeRotationZ(v.rotation2D)),
              v.matrixWorld.decompose(jD, HZ, JD),
              Ia.setPosition(jD),
              Ia.scale(JD),
              (Ia.elements[3] = 0),
              (Ia.elements[7] = 0),
              (Ia.elements[11] = 0),
              (Ia.elements[15] = 1),
              (S = d(Ia)))
            : (S = d(v.matrixWorld))
          const b = s.objects.get(v)
          if (b === void 0 || b.style !== S) {
            A.style.transform = S
            const T = {
              style: S,
            }
            s.objects.set(v, T)
          }
          A.parentNode !== c && c.appendChild(A), v.onAfterRender(e, m, y)
        }
      }
      for (let x = 0, A = v.children.length; x < A; x++) g(v.children[x], m, y)
    }
  }
}
class $Z {
  constructor({scene: t, camera: e, time: n, sizes: i, canvas: a}) {
    ;(this.scene = t),
      (this.camera = e),
      (this.time = n),
      (this.sizes = i),
      (this.canvas = a),
      (this.parent = null)
    let {width: o, height: s} = this.sizes,
      l = new YZ()
    ;(this.css3dRender = l),
      l.setSize(o, s),
      (l.domElement.style.position = 'absolute'),
      (l.domElement.style.left = '0px'),
      (l.domElement.style.top = '0px'),
      (l.domElement.style.pointerEvents = 'none'),
      (l.domElement.className = 'label3d-' + BB()),
      this.canvas.parentNode.appendChild(l.domElement),
      this.time.on('tick', () => {
        this.update()
      }),
      this.sizes.on('resize', () => {
        this.resize()
      })
  }
  create(t = '', e = '', n = !1) {
    let i = document.createElement('div')
    ;(i.innerHTML = t),
      (i.className = e),
      (i.style.visibility = 'hidden'),
      (i.style.position = 'absolute'),
      e ||
        ((i.style.padding = '10px'),
        (i.style.color = '#fff'),
        (i.style.fontSize = '12px'),
        (i.style.textAlign = 'center'),
        (i.style.background = 'rgba(0,0,0,0.6)'),
        (i.style.borderRadius = '4px'))
    let a = null
    return (
      n ? (a = new WZ(i)) : (a = new YB(i)),
      (a.init = (o, s) => {
        ;(a.element.innerHTML = o),
          (a.element.style.visibility = 'visible'),
          a.position.copy(s)
      }),
      (a.hide = () => {
        a.element.style.visibility = 'hidden'
      }),
      (a.scaleHide = () => {
        a.element.classList.add('scale-hidden')
      }),
      (a.show = () => {
        ;(a.element.style.visibility = 'visible'),
          a.element.classList.remove('scale-hidden')
      }),
      (a.setParent = o => {
        ;(this.parent = o), o.add(a)
      }),
      (a.remove = () => {
        this.parent.remove(a)
      }),
      a
    )
  }
  setLabelStyle(t, e = 0.1, n = 'x', i = Math.PI / 2, a = 'none') {
    ;(t.element.style.pointerEvents = a),
      t.scale.set(e, e, e),
      (t.rotation[n] = i)
  }
  setRenderLevel(t) {
    this.css3dRender.domElement.style.zIndex = t
  }
  update() {
    this.css3dRender.render(this.scene, this.camera.instance)
  }
  destroy() {
    if (this.css3dRender) {
      let t = this.css3dRender.domElement
      t.parentNode.removeChild(t)
    }
  }
  resize() {
    let {width: t, height: e} = this.sizes
    this.css3dRender.setSize(t, e)
  }
}
class qZ extends Fe {
  constructor(t = document.createElement('div')) {
    super(),
      (this.isCSS2DObject = !0),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      (this.center = new pt(0.5, 0.5)),
      this.addEventListener('removed', function () {
        this.traverse(function (e) {
          e.element instanceof Element &&
            e.element.parentNode !== null &&
            e.element.parentNode.removeChild(e.element)
        })
      })
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.element = t.element.cloneNode(!0)),
      (this.center = t.center),
      this
    )
  }
}
const Nc = new U(),
  QD = new ae(),
  tL = new ae(),
  eL = new U(),
  nL = new U()
class ZZ {
  constructor(t = {}) {
    const e = this
    let n, i, a, o
    const s = {
        objects: new WeakMap(),
      },
      l = t.element !== void 0 ? t.element : document.createElement('div')
    ;(l.style.overflow = 'hidden'),
      (this.domElement = l),
      (this.getSize = function () {
        return {
          width: n,
          height: i,
        }
      }),
      (this.render = function (p, g) {
        p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(),
          g.parent === null &&
            g.matrixWorldAutoUpdate === !0 &&
            g.updateMatrixWorld(),
          QD.copy(g.matrixWorldInverse),
          tL.multiplyMatrices(g.projectionMatrix, QD),
          c(p, p, g),
          d(p)
      }),
      (this.setSize = function (p, g) {
        ;(n = p),
          (i = g),
          (a = n / 2),
          (o = i / 2),
          (l.style.width = p + 'px'),
          (l.style.height = g + 'px')
      })
    function u(p) {
      p.isCSS2DObject && (p.element.style.display = 'none')
      for (let g = 0, v = p.children.length; g < v; g++) u(p.children[g])
    }
    function c(p, g, v) {
      if (p.visible === !1) {
        u(p)
        return
      }
      if (p.isCSS2DObject) {
        Nc.setFromMatrixPosition(p.matrixWorld), Nc.applyMatrix4(tL)
        const m = Nc.z >= -1 && Nc.z <= 1 && p.layers.test(v.layers) === !0,
          y = p.element
        ;(y.style.display = m === !0 ? '' : 'none'),
          m === !0 &&
            (p.onBeforeRender(e, g, v),
            (y.style.transform =
              'translate(' +
              -100 * p.center.x +
              '%,' +
              -100 * p.center.y +
              '%)translate(' +
              (Nc.x * a + a) +
              'px,' +
              (-Nc.y * o + o) +
              'px)'),
            y.parentNode !== l && l.appendChild(y),
            p.onAfterRender(e, g, v))
        const _ = {
          distanceToCameraSquared: h(v, p),
        }
        s.objects.set(p, _)
      }
      for (let m = 0, y = p.children.length; m < y; m++) c(p.children[m], g, v)
    }
    function h(p, g) {
      return (
        eL.setFromMatrixPosition(p.matrixWorld),
        nL.setFromMatrixPosition(g.matrixWorld),
        eL.distanceToSquared(nL)
      )
    }
    function f(p) {
      const g = []
      return (
        p.traverseVisible(function (v) {
          v.isCSS2DObject && g.push(v)
        }),
        g
      )
    }
    function d(p) {
      const g = f(p).sort(function (m, y) {
          if (m.renderOrder !== y.renderOrder)
            return y.renderOrder - m.renderOrder
          const _ = s.objects.get(m).distanceToCameraSquared,
            x = s.objects.get(y).distanceToCameraSquared
          return _ - x
        }),
        v = g.length
      for (let m = 0, y = g.length; m < y; m++)
        g[m].element.style.zIndex = v - m
    }
  }
}
class KZ {
  constructor({scene: t, camera: e, time: n, sizes: i, canvas: a}) {
    ;(this.scene = t),
      (this.camera = e),
      (this.time = n),
      (this.sizes = i),
      (this.canvas = a),
      (this.parent = null)
    let {width: o, height: s} = this.sizes,
      l = new ZZ()
    ;(this.css2dRender = l),
      l.setSize(o, s),
      (l.domElement.style.position = 'absolute'),
      (l.domElement.style.left = '0px'),
      (l.domElement.style.top = '0px'),
      (l.domElement.style.pointerEvents = 'none'),
      (l.domElement.className = 'label3d-' + BB()),
      this.canvas.parentNode.appendChild(l.domElement),
      this.time.on('tick', () => {
        this.update()
      }),
      this.sizes.on('resize', () => {
        this.resize()
      })
  }
  create(t = '', e = '') {
    let n = document.createElement('div')
    ;(n.innerHTML = t),
      (n.className = e),
      (n.style.visibility = 'hidden'),
      (n.style.position = 'absolute'),
      e ||
        ((n.style.padding = '10px'),
        (n.style.color = '#fff'),
        (n.style.fontSize = '12px'),
        (n.style.textAlign = 'center'),
        (n.style.background = 'rgba(0,0,0,0.6)'),
        (n.style.borderRadius = '4px'))
    let i = null
    return (
      (i = new qZ(n)),
      (i.init = (a, o) => {
        ;(i.element.innerHTML = a),
          (i.element.style.visibility = 'visible'),
          i.position.copy(o)
      }),
      (i.hide = () => {
        i.element.style.visibility = 'hidden'
      }),
      (i.scaleHide = () => {
        i.element.classList.add('scale-hidden')
      }),
      (i.show = () => {
        ;(i.element.style.visibility = 'visible'),
          i.element.classList.remove('scale-hidden')
      }),
      (i.setParent = a => {
        ;(this.parent = a), a.add(i)
      }),
      (i.remove = () => {
        this.parent.remove(i)
      }),
      i
    )
  }
  setLabelStyle(t, e = 'none') {
    t.element.style.pointerEvents = e
  }
  setRenderLevel(t) {
    this.css2dRender.domElement.style.zIndex = t
  }
  update() {
    this.css2dRender.render(this.scene, this.camera.instance)
  }
  destroy() {
    if (this.css2dRender) {
      let t = this.css2dRender.domElement
      t.parentNode.removeChild(t)
    }
  }
  resize() {
    let {width: t, height: e} = this.sizes
    this.css2dRender.setSize(t, e)
  }
}
class jZ {
  constructor({time: t}, e) {
    ;(this.time = t),
      (this.options = Object.assign(
        {},
        {
          width: 10,
          scale: 1,
          position: new U(0, 0, 0),
          needRotate: !1,
          rotateSpeed: 0.001,
          material: new on({
            transparent: !0,
            opacity: 1,
            depthTest: !0,
          }),
        },
        e,
      ))
    let n = new Ti(this.options.width, this.options.width),
      i = new De(n, this.options.material)
    i.position.copy(this.options.position),
      i.scale.set(this.options.scale, this.options.scale, this.options.scale),
      (this.instance = i)
  }
  setParent(t) {
    t.add(this.instance),
      this.time.on('tick', () => {
        this.update()
      })
  }
  update() {
    this.options.needRotate &&
      (this.instance.rotation.z += this.options.rotateSpeed)
  }
}
class JZ extends Fe {
  constructor(t, e) {
    super(),
      (this.assets = t.assets),
      (this.config = Object.assign(
        {
          size: 10,
          color: 65535,
          renderOrder: 99,
        },
        e,
      )),
      (this.material = null),
      this.init()
  }
  init() {
    const {size: t, color: e} = this.config,
      n = new Ti(t, t, 1),
      i = new lo({
        vertexShader: `
        varying vec2 vUv;
        void main() {
            vec4 modelPosition = modelMatrix * vec4(position, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectionPosition = projectionMatrix * viewPosition;
            gl_Position = projectionPosition;
            vUv = uv;

        }
      `,
        fragmentShader: `
        uniform vec3 iResolution;           // viewport resolution (in pixels)
        uniform float iTime;                 // shader playback time (in seconds)
        varying vec2 vUv;
        uniform vec3 iColor;
        uniform float iAlpha;

        // returns a vec3 color from every pixel requested.
        // Generates a BnW Ping on normalized 2d coordinate system
        vec3 RadarPing(
            in vec2 uv,
            in vec2 center,
            in float innerTail,
            in float frontierBorder,
            in float timeResetSeconds,
            in float radarPingSpeed,
            in float fadeDistance,
            float t
        ) {
            vec2 diff = center - uv;
            float r = length(diff);
            float time = mod(t, timeResetSeconds) * radarPingSpeed;

            float circle;
            // r is the distance to the center.
            // circle = BipCenter---//---innerTail---time---frontierBorder
            //illustration
            //https://sketch.io/render/sk-14b54f90080084bad1602f81cadd4d07.jpeg
            circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder, time, r);
            circle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance

            return vec3(circle);
        }

        void main() {

            //normalize coordinates
            vec2 uv = vUv; //move coordinates to 0..1
            uv = uv.xy * 2.; // translate to the center
            uv += vec2(-1.0, -1.0);
            // uv.x *= iResolution.x / iResolution.y; //correct the aspect ratio

            vec3 color;
            // generate some radar pings
            float fadeDistance = 0.6;
            float resetTimeSec = 3.0;
            float radarPingSpeed = 0.2;
            vec2 greenPing = vec2(0.0, 0.0);
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime) * iColor;
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 1.) * iColor;
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 2.) * iColor;
            //return the new color
            gl_FragColor = vec4(color, iAlpha);
        }
      `,
        side: dr,
        transparent: !0,
        blending: $r,
        depthWrite: !1,
        uniforms: {
          iResolution: {
            value: new pt(t, t),
          },
          iTime: {
            value: 0,
          },
          iAlpha: {
            value: 1,
          },
          iColor: {
            value: new qt(e),
          },
        },
      })
    this.material = i
    let a = new De(n, i)
    a.rotateX(-Math.PI / 2), this.add(a), this.createMidPoint()
  }
  createMidPoint() {
    const {size: t, color: e} = this.config,
      n = new Ti(t, t, 1)
    let i = this.assets.instance.getResource('particle')
    ;(i.colorSpace = cn), (i.wrapS = i.wrapT = Jn)
    let a = new on({
        map: i,
        alphaMap: i,
        color: e,
        transparent: !0,
        opacity: 1,
        blending: $r,
        depthWrite: !1,
      }),
      o = new De(n, a)
    o.rotateX(-Math.PI / 2), this.add(o)
  }
  update(t) {
    this.material && (this.material.uniforms.iTime.value += t)
  }
}
class QZ {
  constructor({}, t = {}) {
    ;(this.mapGroup = new un()),
      (this.coordinates = []),
      (this.config = Object.assign(
        {
          position: new U(0, 0, 0),
          geoProjectionCenter: new pt(0, 0),
          geoProjectionScale: 120,
          data: '',
          renderOrder: 1,
          merge: !1,
          material: new on({
            color: 1582651,
            transparent: !0,
            opacity: 1,
          }),
        },
        t,
      )),
      this.mapGroup.position.copy(this.config.position)
    let e = QM(this.config.data)
    this.create(e)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    let {merge: e} = this.config,
      n = []
    if (
      (t.features.forEach(i => {
        const a = new Fe()
        let {name: o, center: s = [], centroid: l = []} = i.properties
        this.coordinates.push({
          name: o,
          center: s,
          centroid: l,
        }),
          (a.userData.name = o),
          i.geometry.coordinates.forEach(u => {
            u.forEach(c => {
              const h = new wu()
              for (let d = 0; d < c.length; d++) {
                if (!c[d][0] || !c[d][1]) return !1
                const [p, g] = this.geoProjection(c[d])
                d === 0 && h.moveTo(p, -g), h.lineTo(p, -g)
              }
              const f = new qM(h)
              if (e) n.push(f)
              else {
                const d = new De(f, this.config.material)
                ;(d.renderOrder = this.config.renderOrder),
                  (d.userData.name = o),
                  a.add(d)
              }
            })
          }),
          e || this.mapGroup.add(a)
      }),
      e)
    ) {
      let i = iq(n)
      const a = new De(i, this.config.material)
      ;(a.renderOrder = this.config.renderOrder), this.mapGroup.add(a)
    }
  }
  getCoordinates() {
    return this.coordinates
  }
  setParent(t) {
    t.add(this.mapGroup)
  }
}
class tK {
  constructor({assets: t, time: e}, n = {}) {
    ;(this.mapGroup = new un()),
      (this.assets = t),
      (this.time = e),
      (this.coordinates = []),
      (this.config = Object.assign(
        {
          position: new U(0, 0, 0),
          geoProjectionCenter: new pt(0, 0),
          geoProjectionScale: 120,
          data: '',
          renderOrder: 1,
          topFaceMaterial: new on({
            color: 1582651,
            transparent: !0,
            opacity: 1,
          }),
          sideMaterial: new on({
            color: 464171,
            transparent: !0,
            opacity: 1,
          }),
          depth: 0.1,
        },
        n,
      )),
      this.mapGroup.position.copy(this.config.position)
    let i = QM(this.config.data)
    this.create(i)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    t.features.forEach(e => {
      const n = new Fe()
      let {name: i, center: a = [], centroid: o = []} = e.properties
      this.coordinates.push({
        name: i,
        center: a,
        centroid: o,
      })
      const s = {
        depth: this.config.depth,
        bevelEnabled: !0,
        bevelSegments: 1,
        bevelThickness: 0.1,
      }
      let l = [this.config.topFaceMaterial, this.config.sideMaterial]
      e.geometry.coordinates.forEach(u => {
        u.forEach((c, h) => {
          const f = new wu()
          for (let g = 0; g < c.length; g++) {
            if (!c[g][0] || !c[g][1]) return !1
            const [v, m] = this.geoProjection(c[g])
            g === 0 && f.moveTo(v, -m), f.lineTo(v, -m)
          }
          const d = new B0(f, s),
            p = new De(d, l)
          n.add(p)
        })
      }),
        this.mapGroup.add(n)
    })
  }
  getCoordinates() {
    return this.coordinates
  }
  setParent(t) {
    t.add(this.mapGroup)
  }
}


let Dx = class {
  constructor({}, t = {}) {
    this.config = Object.assign(
      {
        visibelProvince: '',
        geoProjectionCenter: [0, 0],
        geoProjectionScale: 120,
        position: new U(0, 0, 0),
        data: '',
        material: new dv({
          color: 16777215,
        }),
        type: 'LineLoop',
        renderOrder: 1,
        tubeRadius: 0.2,
      },
      t,
    )
    let e = QM(this.config.data),
      n = this.create(e)
    ;(this.lineGroup = n), this.lineGroup.position.copy(this.config.position)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    const {type: e, visibelProvince: n} = this.config
    let i = t.features,
      a = new un()
    for (let o = 0; o < i.length; o++) {
      const s = i[o]
      let l = new un()
      if (((l.name = 'meshLineGroup' + o), s.properties.name === n)) {
        console.log(n)
        continue
      }
      s.geometry.coordinates.forEach(u => {
        const c = []
        let h = null
        e === 'Line2'
          ? (u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(d, -p, 0)
            }),
            (h = this.createLine2(c)))
          : e === 'Line3'
          ? (u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(new U(d, -p, 0))
            }),
            (h = this.createLine3(c)))
          : u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(new U(d, -p, 0)), (h = this.createLine(c))
            }),
          l.add(h)
      }),
        a.add(l)
    }
    return a
  }
  createLine3(t) {
    const e = this.config.tubeRadius,
      n = 256 * 10,
      i = 4,
      a = !1,
      {material: o, renderOrder: s} = this.config,
      l = new _B(t),
      u = new bp(l, n, e, i, a),
      c = new De(u, o)
    return (c.name = 'mapLine3'), (c.renderOrder = s), c
  }
  createLine2(t) {
    const {material: e, renderOrder: n} = this.config,
      i = new ZB()
    i.setPositions(t)
    let a = new iK(i, e)
    return (
      (a.name = 'mapLine2'), (a.renderOrder = n), a.computeLineDistances(), a
    )
  }
  createLine(t) {
    const {material: e, renderOrder: n, type: i} = this.config,
      a = new Mn()
    a.setFromPoints(t)
    let o = new mB(a, e)
    return (o.renderOrder = n), (o.name = 'mapLine'), o
  }
  setParent(t) {
    t.add(this.lineGroup)
  }
}



class _j extends Fe {
  constructor(t, e) {
    super(),
      (this.config = Object.assign(
        {
          color1: 16566615,
          color2: 16777215,
        },
        e,
      )),
      (this.assets = {
        instance: null,
      }),
      (this.assets.instance = t.assets.instance),
      (this.sceneGroup = t.sceneGroup),
      (this.gsapObjects = []),
      (this.animateElements = {}),
      this.init()
  }
  init() {
    let t = this.config.color1,
      e = new Ti(1.5, 1.5, 1),
      n = new Ti(0.3, 3, 1)
    n.translate(0, 1, 0)
    let i = new on({
        color: t,
        transparent: !0,
        fog: !1,
        side: dr,
        depthWrite: !1,
      }),
      a = i.clone()
    a.map = this.assets.instance.getResource('focusArrows')
    let o = i.clone()
    o.map = this.assets.instance.getResource('focusBar')
    let s = i.clone()
    s.map = this.assets.instance.getResource('focusBg')
    let l = i.clone()
    ;(l.color = new qt(this.config.color2)),
      (l.map = this.assets.instance.getResource('focusMidQuan'))
    let u = i.clone()
    ;(u.map = this.assets.instance.getResource('focusMoveBg')),
      (u.blending = $r)
    let c = new De(e, a),
      h = new De(n, o)
    h.rotation.x = Math.PI / 2
    let f = h.clone()
    f.rotation.y = Math.PI / 2
    let d = new De(e, s),
      p = new De(e, l),
      g = new De(e, u),
      v = [p, d, c, g, h, f]
    v.map(y => {
      y.renderOrder = 99
    }),
      this.add(...v)
    let m = 0
    g.scale.setScalar(m),
      (this.animateElements = {
        focusMidQuan: p,
        focusArrows: c,
        focusMoveBg: g,
      }),
      this.startAnimate()
  }
  startAnimate() {
    let t = Sn.to(this.animateElements.focusMidQuan.rotation, {
        z: 2 * Math.PI,
        duration: 8,
        repeat: -1,
        ease: 'none',
      }),
      e = Sn.to(this.animateElements.focusArrows.rotation, {
        z: 2 * Math.PI,
        duration: 5,
        repeat: -1,
        ease: 'none',
      }),
      n = Sn.to(this.animateElements.focusMoveBg.scale, {
        x: 1.5,
        y: 1.5,
        z: 1.5,
        duration: 2.5,
        repeat: -1,
        ease: 'none',
      }),
      i = Sn.to(this.animateElements.focusMoveBg.material, {
        opacity: 0,
        duration: 2.5,
        repeat: -1,
        ease: 'none',
      })
    this.gsapObjects = [t, e, n, i]
  }
  pausedAnimate() {
    this.gsapObjects.map(t => {
      t.paused = !0
    })
  }
  destroy() {
    this.gsapObjects.map(t => {
      t.kill()
    }),
      va(this)
  }
}
var Mb =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function ZF(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, 'default')
    ? r.default
    : r
}
var KF = {
  exports: {},
}
;(function (r) {
  ;(function (t, e, n) {
    r.exports ? (r.exports = n()) : (e[t] = n())
  })('h337', Mb, function () {
    var t = {
        defaultRadius: 40,
        defaultRenderer: 'canvas2d',
        defaultGradient: {
          0.25: 'rgb(0,0,255)',
          0.55: 'rgb(0,255,0)',
          0.85: 'yellow',
          1: 'rgb(255,0,0)',
        },
        defaultMaxOpacity: 1,
        defaultMinOpacity: 0,
        defaultBlur: 0.85,
        defaultXField: 'x',
        defaultYField: 'y',
        defaultValueField: 'value',
        plugins: {},
      },
      e = (function () {
        var u = function (f) {
            ;(this._coordinator = {}),
              (this._data = []),
              (this._radi = []),
              (this._min = 10),
              (this._max = 1),
              (this._xField = f.xField || f.defaultXField),
              (this._yField = f.yField || f.defaultYField),
              (this._valueField = f.valueField || f.defaultValueField),
              f.radius && (this._cfgRadius = f.radius)
          },
          c = t.defaultRadius
        return (
          (u.prototype = {
            _organiseData: function (h, f) {
              var d = h[this._xField],
                p = h[this._yField],
                g = this._radi,
                v = this._data,
                m = this._max,
                y = this._min,
                _ = h[this._valueField] || 1,
                x = h.radius || this._cfgRadius || c
              v[d] || ((v[d] = []), (g[d] = [])),
                v[d][p] ? (v[d][p] += _) : ((v[d][p] = _), (g[d][p] = x))
              var A = v[d][p]
              return A > m
                ? (f ? this.setDataMax(A) : (this._max = A), !1)
                : A < y
                ? (f ? this.setDataMin(A) : (this._min = A), !1)
                : {
                    x: d,
                    y: p,
                    value: _,
                    radius: x,
                    min: y,
                    max: m,
                  }
            },
            _unOrganizeData: function () {
              var h = [],
                f = this._data,
                d = this._radi
              for (var p in f)
                for (var g in f[p])
                  h.push({
                    x: p,
                    y: g,
                    radius: d[p][g],
                    value: f[p][g],
                  })
              return {
                min: this._min,
                max: this._max,
                data: h,
              }
            },
            _onExtremaChange: function () {
              this._coordinator.emit('extremachange', {
                min: this._min,
                max: this._max,
              })
            },
            addData: function () {
              if (arguments[0].length > 0)
                for (var h = arguments[0], f = h.length; f--; )
                  this.addData.call(this, h[f])
              else {
                var d = this._organiseData(arguments[0], !0)
                d &&
                  (this._data.length === 0 && (this._min = this._max = d.value),
                  this._coordinator.emit('renderpartial', {
                    min: this._min,
                    max: this._max,
                    data: [d],
                  }))
              }
              return this
            },
            setData: function (h) {
              var f = h.data,
                d = f.length
              ;(this._data = []), (this._radi = [])
              for (var p = 0; p < d; p++) this._organiseData(f[p], !1)
              return (
                (this._max = h.max),
                (this._min = h.min || 0),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            removeData: function () {},
            setDataMax: function (h) {
              return (
                (this._max = h),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            setDataMin: function (h) {
              return (
                (this._min = h),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            setCoordinator: function (h) {
              this._coordinator = h
            },
            _getInternalData: function () {
              return {
                max: this._max,
                min: this._min,
                data: this._data,
                radi: this._radi,
              }
            },
            getData: function () {
              return this._unOrganizeData()
            },
          }),
          u
        )
      })(),
      n = (function () {
        var u = function (d) {
            var p = d.gradient || d.defaultGradient,
              g = document.createElement('canvas'),
              v = g.getContext('2d')
            ;(g.width = 256), (g.height = 1)
            var m = v.createLinearGradient(0, 0, 256, 1)
            for (var y in p) m.addColorStop(y, p[y])
            return (
              (v.fillStyle = m),
              v.fillRect(0, 0, 256, 1),
              v.getImageData(0, 0, 256, 1).data
            )
          },
          c = function (d, p) {
            var g = document.createElement('canvas'),
              v = g.getContext('2d'),
              m = d,
              y = d
            if (((g.width = g.height = d * 2), p == 1))
              v.beginPath(),
                v.arc(m, y, d, 0, 2 * Math.PI, !1),
                (v.fillStyle = 'rgba(0,0,0,1)'),
                v.fill()
            else {
              var _ = v.createRadialGradient(m, y, d * p, m, y, d)
              _.addColorStop(0, 'rgba(0,0,0,1)'),
                _.addColorStop(1, 'rgba(0,0,0,0)'),
                (v.fillStyle = _),
                v.fillRect(0, 0, 2 * d, 2 * d)
            }
            return g
          },
          h = function (y) {
            for (
              var p = [],
                g = y.min,
                v = y.max,
                m = y.radi,
                y = y.data,
                _ = Object.keys(y),
                x = _.length;
              x--;

            )
              for (var A = _[x], S = Object.keys(y[A]), b = S.length; b--; ) {
                var T = S[b],
                  w = y[A][T],
                  M = m[A][T]
                p.push({
                  x: A,
                  y: T,
                  value: w,
                  radius: M,
                })
              }
            return {
              min: g,
              max: v,
              data: p,
            }
          }
        function f(d) {
          var p = d.container,
            g = (this.shadowCanvas = document.createElement('canvas')),
            v = (this.canvas = d.canvas || document.createElement('canvas'))
          this._renderBoundaries = [1e4, 1e4, 0, 0]
          var m = getComputedStyle(d.container) || {}
          ;(v.className = 'heatmap-canvas'),
            (this._width =
              v.width =
              g.width =
                d.width || +m.width.replace(/px/, '')),
            (this._height =
              v.height =
              g.height =
                d.height || +m.height.replace(/px/, '')),
            (this.shadowCtx = g.getContext('2d')),
            (this.ctx = v.getContext('2d')),
            (v.style.cssText = g.style.cssText =
              'position:absolute;left:0;top:0;'),
            (p.style.position = 'relative'),
            p.appendChild(v),
            (this._palette = u(d)),
            (this._templates = {}),
            this._setStyles(d)
        }
        return (
          (f.prototype = {
            renderPartial: function (d) {
              d.data.length > 0 && (this._drawAlpha(d), this._colorize())
            },
            renderAll: function (d) {
              this._clear(),
                d.data.length > 0 && (this._drawAlpha(h(d)), this._colorize())
            },
            _updateGradient: function (d) {
              this._palette = u(d)
            },
            updateConfig: function (d) {
              d.gradient && this._updateGradient(d), this._setStyles(d)
            },
            setDimensions: function (d, p) {
              ;(this._width = d),
                (this._height = p),
                (this.canvas.width = this.shadowCanvas.width = d),
                (this.canvas.height = this.shadowCanvas.height = p)
            },
            _clear: function () {
              this.shadowCtx.clearRect(0, 0, this._width, this._height),
                this.ctx.clearRect(0, 0, this._width, this._height)
            },
            _setStyles: function (d) {
              ;(this._blur = d.blur == 0 ? 0 : d.blur || d.defaultBlur),
                d.backgroundColor &&
                  (this.canvas.style.backgroundColor = d.backgroundColor),
                (this._width =
                  this.canvas.width =
                  this.shadowCanvas.width =
                    d.width || this._width),
                (this._height =
                  this.canvas.height =
                  this.shadowCanvas.height =
                    d.height || this._height),
                (this._opacity = (d.opacity || 0) * 255),
                (this._maxOpacity =
                  (d.maxOpacity || d.defaultMaxOpacity) * 255),
                (this._minOpacity =
                  (d.minOpacity || d.defaultMinOpacity) * 255),
                (this._useGradientOpacity = !!d.useGradientOpacity)
            },
            _drawAlpha: function (v) {
              for (
                var p = (this._min = v.min),
                  g = (this._max = v.max),
                  v = v.data || [],
                  m = v.length,
                  y = 1 - this._blur;
                m--;

              ) {
                var _ = v[m],
                  x = _.x,
                  A = _.y,
                  S = _.radius,
                  b = Math.min(_.value, g),
                  T = x - S,
                  w = A - S,
                  M = this.shadowCtx,
                  C
                this._templates[S]
                  ? (C = this._templates[S])
                  : (this._templates[S] = C = c(S, y))
                var E = (b - p) / (g - p)
                ;(M.globalAlpha = E < 0.01 ? 0.01 : E),
                  M.drawImage(C, T, w),
                  T < this._renderBoundaries[0] &&
                    (this._renderBoundaries[0] = T),
                  w < this._renderBoundaries[1] &&
                    (this._renderBoundaries[1] = w),
                  T + 2 * S > this._renderBoundaries[2] &&
                    (this._renderBoundaries[2] = T + 2 * S),
                  w + 2 * S > this._renderBoundaries[3] &&
                    (this._renderBoundaries[3] = w + 2 * S)
              }
            },
            _colorize: function () {
              var d = this._renderBoundaries[0],
                p = this._renderBoundaries[1],
                g = this._renderBoundaries[2] - d,
                v = this._renderBoundaries[3] - p,
                m = this._width,
                y = this._height,
                _ = this._opacity,
                x = this._maxOpacity,
                A = this._minOpacity,
                S = this._useGradientOpacity
              d < 0 && (d = 0),
                p < 0 && (p = 0),
                d + g > m && (g = m - d),
                p + v > y && (v = y - p)
              for (
                var b = this.shadowCtx.getImageData(d, p, g, v),
                  T = b.data,
                  w = T.length,
                  M = this._palette,
                  C = 3;
                C < w;
                C += 4
              ) {
                var E = T[C],
                  D = E * 4
                if (D) {
                  var P
                  _ > 0
                    ? (P = _)
                    : E < x
                    ? E < A
                      ? (P = A)
                      : (P = E)
                    : (P = x),
                    (T[C - 3] = M[D]),
                    (T[C - 2] = M[D + 1]),
                    (T[C - 1] = M[D + 2]),
                    (T[C] = S ? M[D + 3] : P)
                }
              }
              this.ctx.putImageData(b, d, p),
                (this._renderBoundaries = [1e3, 1e3, 0, 0])
            },
            getValueAt: function (d) {
              var p,
                g = this.shadowCtx,
                v = g.getImageData(d.x, d.y, 1, 1),
                m = v.data[3],
                y = this._max,
                _ = this._min
              return (p = (Math.abs(y - _) * (m / 255)) >> 0), p
            },
            getDataURL: function () {
              return this.canvas.toDataURL()
            },
          }),
          f
        )
      })(),
      i = (function () {
        var u = !1
        return t.defaultRenderer === 'canvas2d' && (u = n), u
      })(),
      a = {
        merge: function () {
          for (var l = {}, u = arguments.length, c = 0; c < u; c++) {
            var h = arguments[c]
            for (var f in h) l[f] = h[f]
          }
          return l
        },
      },
      o = (function () {
        var u = (function () {
            function d() {
              this.cStore = {}
            }
            return (
              (d.prototype = {
                on: function (p, g, v) {
                  var m = this.cStore
                  m[p] || (m[p] = []),
                    m[p].push(function (y) {
                      return g.call(v, y)
                    })
                },
                emit: function (p, g) {
                  var v = this.cStore
                  if (v[p])
                    for (var m = v[p].length, y = 0; y < m; y++) {
                      var _ = v[p][y]
                      _(g)
                    }
                },
              }),
              d
            )
          })(),
          c = function (f) {
            var d = f._renderer,
              p = f._coordinator,
              g = f._store
            p.on('renderpartial', d.renderPartial, d),
              p.on('renderall', d.renderAll, d),
              p.on('extremachange', function (v) {
                f._config.onExtremaChange &&
                  f._config.onExtremaChange({
                    min: v.min,
                    max: v.max,
                    gradient: f._config.gradient || f._config.defaultGradient,
                  })
              }),
              g.setCoordinator(p)
          }
        function h() {
          var f = (this._config = a.merge(t, arguments[0] || {}))
          if (((this._coordinator = new u()), f.plugin)) {
            var d = f.plugin
            if (t.plugins[d]) {
              var p = t.plugins[d]
              ;(this._renderer = new p.renderer(f)),
                (this._store = new p.store(f))
            } else
              throw new Error(
                "Plugin '" + d + "' not found. Maybe it was not registered.",
              )
          } else (this._renderer = new i(f)), (this._store = new e(f))
          c(this)
        }
        return (
          (h.prototype = {
            addData: function () {
              return this._store.addData.apply(this._store, arguments), this
            },
            removeData: function () {
              return (
                this._store.removeData &&
                  this._store.removeData.apply(this._store, arguments),
                this
              )
            },
            setData: function () {
              return this._store.setData.apply(this._store, arguments), this
            },
            setDataMax: function () {
              return this._store.setDataMax.apply(this._store, arguments), this
            },
            setDataMin: function () {
              return this._store.setDataMin.apply(this._store, arguments), this
            },
            configure: function (f) {
              return (
                (this._config = a.merge(this._config, f)),
                this._renderer.updateConfig(this._config),
                this._coordinator.emit(
                  'renderall',
                  this._store._getInternalData(),
                ),
                this
              )
            },
            repaint: function () {
              return (
                this._coordinator.emit(
                  'renderall',
                  this._store._getInternalData(),
                ),
                this
              )
            },
            getData: function () {
              return this._store.getData()
            },
            getDataURL: function () {
              return this._renderer.getDataURL()
            },
            getValueAt: function (f) {
              return this._store.getValueAt
                ? this._store.getValueAt(f)
                : this._renderer.getValueAt
                ? this._renderer.getValueAt(f)
                : null
            },
          }),
          h
        )
      })(),
      s = {
        create: function (l) {
          return new o(l)
        },
        register: function (l, u) {
          t.plugins[l] = u
        },
      }
    return s
  })
})(KF)
var xj = KF.exports
const Sj = ZF(xj)
class Aj extends Fe {
  constructor(t, e) {
    super(),
      (this.self = t),
      (this.config = Object.assign(
        {
          data: [],
          width: 10,
          height: 10,
          z: 1,
          renderOrder: 22,
          showDot: !1,
          radius: 70,
          pointsMaterial: new HM({
            size: 0.2,
            color: 16777215,
          }),
        },
        e,
      )),
      this.init()
  }
  init() {
    const e = this.config.width * 100,
      n = this.config.height * 100,
      i = [],
      a = this.config.data.map(p => {
        let [g, v] = this.self.geoProjection(p)
        return (
          i.push(g, -v, this.config.z),
          {
            value: p.value,
            x: Math.floor(g * 100 + e / 2),
            y: Math.floor(-v * 100 + n / 2),
          }
        )
      })
    let o = $q(a, p => p.value).value,
      s = Yq(a, p => p.value).value
    if (this.config.showDot) {
      const p = new Mn()
      p.setAttribute('position', new nn(i, 3))
      let g = new yB(p, this.config.pointsMaterial)
      g.rotateX(-Math.PI / 2), this.add(g)
    }
    let l = document.createElement('div')
    var u = Sj.create({
      container: l,
      radius: this.config.radius,
      width: e,
      height: n,
      alpha: !0,
    })
    u.setData({
      max: o,
      min: s,
      data: a,
    })
    let c = new Ti(e, n),
      h = new Yn(u._renderer.canvas)
    var f = new on({
      map: h,
      transparent: !0,
      depthWrite: !1,
      side: dr,
      fog: !1,
      wireframe: !1,
    })
    f.map.needsUpdate = !0
    let d = new De(c, f)
    ;(d.renderOrder = this.config.renderOrder),
      d.scale.set(1 / 100, 1 / 100, 1),
      d.position.set(0, this.config.z, 0),
      (d.rotation.x = Math.PI / 2),
      this.add(d)
  }
  destroy() {
    va(this)
  }
}
class bj {
  constructor(t, e) {
    ;(this.shader = null),
      (this.config = Object.assign(
        {
          uColor1: 2781042,
          uColor2: 860197,
          size: 15,
          dir: 'x',
        },
        e,
      )),
      this.init(t)
  }
  init(t) {
    let {uColor1: e, uColor2: n, dir: i, size: a} = this.config,
      o = {
        x: 1,
        y: 2,
        z: 3,
      }
    t.onBeforeCompile = s => {
      ;(this.shader = s),
        (s.uniforms = {
          ...s.uniforms,
          uColor1: {
            value: new qt(e),
          },
          uColor2: {
            value: new qt(n),
          },
          uDir: {
            value: o[i],
          },
          uSize: {
            value: a,
          },
        }),
        (s.vertexShader = s.vertexShader.replace(
          'void main() {',
          `
                attribute float alpha;
                varying vec3 vPosition;
                varying float vAlpha;
                void main() {
                  vAlpha = alpha;
                  vPosition = position;
              `,
        )),
        (s.fragmentShader = s.fragmentShader.replace(
          'void main() {',
          `
                varying vec3 vPosition;
                varying float vAlpha;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform float uDir;
                uniform float uSize;

                void main() {
              `,
        )),
        (s.fragmentShader = s.fragmentShader.replace(
          '#include <opaque_fragment>',
          `
              #ifdef OPAQUE
              diffuseColor.a = 1.0;
              #endif

              // https://github.com/mrdoob/three.js/pull/22425
              #ifdef USE_TRANSMISSION
              diffuseColor.a *= transmissionAlpha + 0.1;
              #endif
              // vec3 gradient = mix(uColor1, uColor2, vPosition.x / 15.0);
              vec3 gradient = vec3(0.0,0.0,0.0);
              if(uDir==1.0){
                gradient = mix(uColor1, uColor2, vPosition.x / uSize /2.0);
                // diffuseColor.a *= 1.0-vPosition.x/ uSize;
              }else if(uDir==2.0){
                gradient = mix(uColor1, uColor2, vPosition.z/ uSize/2.0);
                // diffuseColor.a *= 1.0-vPosition.z/ uSize;
              }else if(uDir==3.0){
                gradient = mix(uColor1, uColor2, vPosition.y/ uSize/2.0);
                // diffuseColor.a *= 1.0-vPosition.y/ uSize;
              }
              outgoingLight = outgoingLight * gradient;


              gl_FragColor = vec4( outgoingLight, diffuseColor.a  );
              `,
        ))
    }
  }
}
const wj = './assets/point-icon-47482592.svg',
  Mj = [
    {
      name: '杭州市',
      enName: 'hangzhou',
      value: 98,
      center: [120.153576, 30.287459],
      centroid: [119.476498, 29.898918],
    },
    {
      name: '宁波市',
      enName: 'ningbo',
      value: 57,
      center: [121.549792, 29.868388],
      centroid: [121.479174, 29.733017],
    },
    {
      name: '温州市',
      enName: 'wenzhou',
      value: 80,
      center: [120.672111, 28.000575],
      centroid: [120.463912, 27.894726],
    },
    {
      name: '嘉兴市',
      enName: 'jiaxing',
      value: 42,
      center: [120.750865, 30.762653],
      centroid: [120.783487, 30.620063],
    },
    {
      name: '湖州市',
      enName: 'huzhou',
      value: 37,
      center: [120.102398, 30.867198],
      centroid: [119.873663, 30.743058],
    },
    {
      name: '绍兴市',
      enName: 'shaoxing',
      value: 24,
      center: [120.582112, 29.997117],
      centroid: [120.640933, 29.732893],
    },
    {
      name: '金华市',
      enName: 'jinghua',
      value: 43,
      center: [119.649506, 29.089524],
      centroid: [119.957007, 29.115117],
    },
    {
      name: '衢州市',
      enName: 'hengzhou',
      value: 46,
      center: [118.87263, 28.941708],
      centroid: [118.679569, 28.932446],
    },
    {
      name: '舟山市',
      enName: 'zhousan',
      value: 37,
      center: [122.106863, 30.016028],
      centroid: [122.146805, 30.056563],
    },
    {
      name: '台州市',
      enName: 'taizhou',
      value: 36,
      center: [121.428599, 28.661378],
      centroid: [121.136679, 28.757098],
    },
    {
      name: '丽水市',
      enName: 'lishui',
      value: 48,
      center: [119.921786, 28.451993],
      centroid: [119.517145, 28.197644],
    },
  ],
  jF = [
    {
      name: '杭州市',
      enName: 'hangzhou',
      value: 45,
      center: [120.153576, 30.287459],
      centroid: [119.476498, 29.898918],
    },
    {
      name: '宁波市',
      enName: 'ningbo',
      value: 57,
      center: [121.549792, 29.868388],
      centroid: [121.479174, 29.733017],
    },
    {
      name: '温州市',
      enName: 'wenzhou',
      value: 80,
      center: [120.672111, 28.000575],
      centroid: [120.463912, 27.894726],
    },
    {
      name: '嘉兴市',
      enName: 'jiaxing',
      value: 42,
      center: [120.750865, 30.762653],
      centroid: [120.783487, 30.620063],
    },
    {
      name: '湖州市',
      enName: 'huzhou',
      value: 37,
      center: [120.102398, 30.867198],
      centroid: [119.873663, 30.743058],
    },
    {
      name: '绍兴市',
      enName: 'shaoxing',
      value: 24,
      center: [120.582112, 29.997117],
      centroid: [120.640933, 29.732893],
    },
    {
      name: '金华市',
      enName: 'jinghua',
      value: 99,
      center: [119.649506, 29.089524],
      centroid: [119.957007, 29.115117],
    },
    {
      name: '衢州市',
      enName: 'hengzhou',
      value: 46,
      center: [118.87263, 28.941708],
      centroid: [118.679569, 28.932446],
    },
    {
      name: '舟山市',
      enName: 'zhousan',
      value: 37,
      center: [122.106863, 30.016028],
      centroid: [122.146805, 30.056563],
    },
    {
      name: '台州市',
      enName: 'taizhou',
      value: 36,
      center: [121.428599, 28.661378],
      centroid: [121.136679, 28.757098],
    },
    {
      name: '丽水市',
      enName: 'lishui',
      value: 48,
      center: [119.921786, 28.451993],
      centroid: [119.517145, 28.197644],
    },
  ],
  Tj = [
    {
      value: 166,
      centroid: [119.24616103, 28.09020241],
    },
    {
      value: 120,
      centroid: [119.18042396, 28.70973428],
    },
    {
      value: 85,
      centroid: [119.18042396, 28.70973428],
    },
    {
      value: 110,
      centroid: [119.12407528, 29.84011268],
    },
    {
      value: 45,
      centroid: [119.73447116, 30.27089934],
    },
    {
      value: 88,
      centroid: [120.11010011, 30.5866928],
    },
    {
      value: 56,
      centroid: [120.87074922, 29.74231644],
    },
    {
      value: 24,
      centroid: [121.00221803, 28.92365701],
    },
    {
      value: 77,
      centroid: [120.70171529, 28.13161692],
    },
    {
      value: 33,
      centroid: [120.35426061, 27.5253857],
    },
    {
      value: 77,
      centroid: [119.55605201, 28.53663036],
    },
    {
      value: 23,
      centroid: [119.89411588, 29.30924506],
    },
    {
      value: 89,
      centroid: [120.58902752, 29.21913061],
    },
    {
      value: 145,
      centroid: [119.63117693, 28.75914002],
    },
  ]
var ST = {
  exports: {},
}
function AT() {}
AT.prototype = {
  on: function (r, t, e) {
    var n = this.e || (this.e = {})
    return (
      (n[r] || (n[r] = [])).push({
        fn: t,
        ctx: e,
      }),
      this
    )
  },
  once: function (r, t, e) {
    var n = this
    function i() {
      n.off(r, i), t.apply(e, arguments)
    }
    return (i._ = t), this.on(r, i, e)
  },
  emit: function (r) {
    var t = [].slice.call(arguments, 1),
      e = ((this.e || (this.e = {}))[r] || []).slice(),
      n = 0,
      i = e.length
    for (n; n < i; n++) e[n].fn.apply(e[n].ctx, t)
    return this
  },
  off: function (r, t) {
    var e = this.e || (this.e = {}),
      n = e[r],
      i = []
    if (n && t)
      for (var a = 0, o = n.length; a < o; a++)
        n[a].fn !== t && n[a].fn._ !== t && i.push(n[a])
    return i.length ? (e[r] = i) : delete e[r], this
  },
}
ST.exports = AT
ST.exports.TinyEmitter = AT
var Cj = ST.exports,
  Ej = Cj,
  Dj = new Ej()
const Cg = ZF(Dj),
  Ee = {
    $on: (...r) => Cg.on(...r),
    $once: (...r) => Cg.once(...r),
    $off: (...r) => Cg.off(...r),
    $emit: (...r) => Cg.emit(...r),
  }
function Lj(r) {
  return new Promise(t => setTimeout(t, r))
}
const Pj = d8()
function zx(r) {
  return r.sort((t, e) => e.value - t.value), r
}
class Rj extends PZ {
  constructor(t, e, n) {
    super(t),
      (this.debug = new GZ(n.debug)),
      (this.geoProjectionCenter = n.geoProjectionCenter || [
        120.109913, 29.181466,
      ]),
      (this.geoProjectionScale = n.geoProjectionScale || 90),
      (this.flyLineCenter = n.flyLineCenter || [120.20341805, 30.23969507]),
      (this.depth = n.depth),
      (this.scene.fog = new zM(0, 1, 50)),
      (this.scene.background = new qt(0)),
      this.camera.instance.position.set(
        -13.767695123014105,
        12.990152163077308,
        39.28228164159694,
      ),
      (this.camera.instance.near = 1),
      (this.camera.instance.far = 1e4),
      (this.camera.controls.enabled = !1),
      (this.interactionManager = new Wq(
        this.renderer.instance,
        this.camera.instance,
        this.canvas,
      )),
      (this.assets = e),
      this.initEnvironment(),
      this.init()
  }
  init() {
    ;(this.pointGroup = new un()),
      (this.pointGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.pointGroup),
      (this.trackGroup = new un()),
      (this.trackGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.trackGroup),
      (this.pathLabelGroup = new un()),
      (this.pathLabelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.pathLabelGroup),
      (this.labelGroup = new un()),
      (this.labelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.labelGroup),
      (this.barLabelGroup = new un()),
      (this.barLabelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.barLabelGroup),
      (this.hotmapGroup = new un()),
      this.scene.add(this.hotmapGroup),
      (this.label3d = new $Z(this)),
      (this.label2d = new KZ(this)),
      (this.flyLineFocusGroup = new un()),
      (this.flyLineFocusGroup.visible = !0),
      (this.flyLineFocusGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.flyLineFocusGroup),
      (this.eventElement = []),
      (this.defaultMaterial = null),
      (this.defaultLightMaterial = null)
    const t = new un()
    ;(this.barGroup = t),
      this.scene.add(t),
      (this.allBar = []),
      (this.allBarMaterial = []),
      (this.allBarLabel = []),
      (this.allGuangquan = []),
      (this.flylineTexture = this.assets.instance.getResource('mapFlyline')),
      this.createBottomBg(),
      this.createRotateBorder(),
      this.createLabel(),
      this.createMap(),
      this.createDiffuse(),
      this.createFocus(),
      this.createScatter(),
      this.createStorke(),
      this.createEvent()
    let e = Sn.timeline({
      onComplete: () => {},
    })
    e.pause(),
      (this.animateTl = e),
      e.addLabel('focusMap', 1.5),
      e.addLabel('focusMapOpacity', 2),
      e.addLabel('bar', 3),
      e.to(this.camera.instance.position, {
        duration: 2,
        x: 0.0580965177019102,
        y: 8.801522187331752,
        z: 10.106973982833994,
        ease: 'circ.out',
        onComplete: () => {
          Ee.$emit('mapPlayComplete'), this.limitCamera()
        },
      })
  }
  limitCamera() {
    ;(this.camera.controls.enabled = !0),
      (this.camera.controls.maxPolarAngle = Math.PI / 2.2),
      (this.camera.controls.minDistance = 1),
      (this.camera.controls.maxDistance = 15)
  }
  initEnvironment() {
    let t = new PB(16777215, 5)
    this.scene.add(t)
    let e = new Ay(16777215, 5)
    e.position.set(-30, 6, -8),
      (e.castShadow = !0),
      (e.shadow.radius = 20),
      (e.shadow.mapSize.width = 1024),
      (e.shadow.mapSize.height = 1024),
      this.scene.add(e)
  }
  createMap() {
    let t = new un(),
      e = new un()
    this.focusMapGroup = e
    let {map: n, mapTop: i, mapLine: a, mapLineBlack: o} = this.createProvince()
    n.setParent(e),
      i.setParent(e),
      a.setParent(e),
      (this.mapLine = a),
      e.add(o),
      t.add(e),
      (t.rotation.x = -Math.PI / 2),
      t.position.set(0, 0.2, 0),
      this.scene.add(t)
  }
  createProvince() {
    let t = this.assets.instance.getResource('mapJson'),
      e = this.assets.instance.getResource('face')
    if (
      ((e.colorSpace = cn),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(0.732, 0.732),
      e.offset.set(0.137, 1.081),
      this.debug.active)
    ) {
      const f = this.debug.instance.addFolder('face')
      let d = {
        scale: 0.732,
        x: 0.137,
        y: 1.081,
      }
      f.add(d, 'scale', 0, 1, 0.001).onChange(p => {
        let g = Number(p)
        e.repeat.set(g, g)
      }),
        f.add(e.offset, 'x', 0, 2, 0.001),
        f.add(e.offset, 'y', 0, 2, 0.001)
    }
    let [n, i] = this.createProvinceMaterial()
    ;(this.focusMapTopMaterial = n), (this.focusMapSideMaterial = i)
    let a = new tK(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, 0.11),
        data: t,
        depth: this.depth,
        topFaceMaterial: n,
        sideMaterial: i,
        renderOrder: 9,
      }),
      o = new on({
        color: 16777215,
        map: e,
        transparent: !0,
        opacity: 1,
        fog: !1,
      })
    ;(this.defaultMaterial = o),
      (this.defaultLightMaterial = this.defaultMaterial.clone()),
      (this.defaultLightMaterial.opacity = 0.95)
    let s = new QZ(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, this.depth + 0.22),
        data: t,
        material: o,
        renderOrder: 2,
      }),
      {boxSize: l, box3: u} = PD(s.mapGroup)
    s.mapGroup.children.map(f => {
      f.children.map(d => {
        this.eventElement.push(d),
          this.calcUv(d.geometry, l.x, l.y, u.min.x, u.min.y)
      })
    }),
      (this.mapLineMaterial = new dv({
        color: 16777215,
        opacity: 1,
        transparent: !0,
        fog: !1,
      }))
    let c = new Dx(this, {
      geoProjectionCenter: this.geoProjectionCenter,
      geoProjectionScale: this.geoProjectionScale,
      data: t,
      material: this.mapLineMaterial,
      type: 'Line3',
      tubeRadius: 0.02,
      renderOrder: 3,
    })
    c.lineGroup.position.z += this.depth + 0.23
    let h = c.lineGroup.clone()
    return (
      h.scale.set(1, 1, 0.1),
      (h.position.x += 0.01),
      (h.position.y -= -0.01),
      h.traverse(f => {
        f.isMesh &&
          ((f.material = f.material.clone()),
          (f.material.color = new qt(0)),
          (f.material.opacity = 1))
      }),
      {
        map: a,
        mapTop: s,
        mapLine: c,
        mapLineBlack: h,
      }
    )
  }
  calcUv(t, e, n, i, a) {
    const o = t.attributes.position,
      s = t.attributes.uv
    for (let l = 0; l < o.count; l++) {
      const u = o.getX(l),
        c = o.getY(l),
        h = (u - i) / e,
        f = (c - a) / n
      s.setXY(l, h, f)
    }
    ;(s.needsUpdate = !0), t.computeVertexNormals()
  }
  createProvinceMaterial() {
    let t = new CB({
        color: 16777215,
        transparent: !0,
        opacity: 1,
        fog: !1,
        side: dr,
      }),
      e = this.assets.instance.getResource('side')
    ;(e.flipY = !1),
      (e.colorSpace = cn),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(1, 1.8)
    let n = new Th({
      color: 16777215,
      map: e,
      fog: !1,
      opacity: 1,
      side: dr,
    })
    return [t, n]
  }
  createBar(t) {
    let e = this,
      n = zx(jF)
    t && (n = zx(t))
    const i = this.barGroup,
      a = 0.7,
      o = 3 * a,
      s = n[0].value
    n.map((u, c) => {
      let h = o * (u.value / s),
        f = new Th({
          color: 16777215,
          transparent: !0,
          opacity: 0,
          depthTest: !1,
          fog: !1,
        })
      new bj(f, {
        uColor1: c > 0 ? 5291006 : 16506760,
        uColor2: 16776948,
        size: h,
        dir: 'z',
      })
      let d = 0.08 * a
      const p = new $M(d, d, h)
      p.translate(0, h / 2, 0)
      const g = new De(p, f)
      ;(g.castShadow = !0),
        (g.rotation.x = Math.PI / 2),
        (g.renderOrder = 5),
        (g.name = u.name + '-bar')
      let v = g,
        [m, y] = this.geoProjection(u.centroid)
      v.position.set(m, -y, this.depth + 0.45), v.scale.set(1, 0, 1)
      let _ = new JZ(this, {
        size: 1.5,
        color: c > 0 ? 5291006 : 16506760,
      })
      ;(_.renderOrder = 8888),
        _.position.set(m, -y, this.depth + 0.45),
        _.traverse(A => {
          ;(A.renderOrder = 999999), (A.rotation.x = Math.PI / 2)
        }),
        this.barGroup.add(_),
        i.add(v),
        (i.rotation.x = -Math.PI / 2)
      let x = l(u, c, new U(m, -y, this.depth + 0.8 + h))
      this.allBar.push(v),
        this.allBarMaterial.push(f),
        this.allBarLabel.push(x),
        this.allGuangquan.push(_)
    })
    function l(u, c, h) {
      let f = e.label2d.create('', 'bar-label', !1)
      return (
        (f.name = u.name + '-barLabel'),
        f.init(
          `<div class="bar-label-wrap ${c === 0 ? 'cyan' : ''}" >
        <div class="bar-label-icon"><img src="${wj}"></div>
          <div class="bar-label-number">
            ${u.value}<span class="unit">次</span>
          </div>
        </div>`,
          h,
        ),
        f.setParent(e.labelGroup),
        f.element
          .querySelector('.bar-label-wrap')
          .addEventListener('click', d => {
            d.stopPropagation(), Ee.$emit('barLabelClick', u)
          }),
        f
      )
    }
    this.barAnimate()
  }
  clearBar() {
    this.allBarLabel.map(t => {
      t.parent.remove(t)
    }),
      va(this.barGroup),
      (this.allBar = []),
      (this.allBarMaterial = []),
      (this.allBarLabel = [])
  }
  async barAnimate() {
    await Lj(500),
      this.allBar.map((t, e) => {
        Sn.to(t.scale, {
          duration: 1,
          delay: 0.1 * e,
          x: 1,
          y: 1,
          z: 1,
          ease: 'circ.out',
        })
      }),
      this.allBarMaterial.map((t, e) => {
        Sn.to(t, {
          duration: 1,
          delay: 0.1 * e,
          opacity: 1,
          ease: 'circ.out',
        })
      }),
      this.allBarLabel.map((t, e) => {
        let n = t.element.querySelector('.bar-label-wrap')
        Sn.to(n, {
          duration: 1,
          delay: 0.2 * e,
          translateY: 0,
          opacity: 1,
          ease: 'circ.out',
        })
      })
  }
  createEvent() {
    let t = []
    const e = i => {
        i.traverse(a => {
          a.isMesh && (a.material = this.defaultMaterial)
        })
      },
      n = i => {
        i.traverse(a => {
          a.isMesh && (a.material = this.defaultLightMaterial)
        })
      }
    this.eventElement.map(i => {
      this.interactionManager.add(i),
        i.addEventListener('mousedown', a => {
          console.log(a.target.userData.name)
        }),
        i.addEventListener('mouseover', a => {
          t.includes(a.target.parent) || t.push(a.target.parent),
            (document.body.style.cursor = 'pointer'),
            n(a.target.parent)
        }),
        i.addEventListener('mouseout', a => {
          ;(t = t.filter(
            o => o.userData.name !== a.target.parent.userData.name,
          )),
            t.length > 0 && t[t.length - 1],
            e(a.target.parent),
            (document.body.style.cursor = 'default')
        })
    })
  }
  createDiffuse() {
    let t = this.assets.instance.getResource('diffuse')
    ;(t.colorSpace = cn), (t.wrapS = t.wrapT = Jn)
    let e = new Ti(15, 15),
      n = new on({
        color: 11584,
        map: t,
        transparent: !0,
        opacity: 1,
        fog: !0,
        blending: $r,
      }),
      i = new De(e, n)
    ;(i.renderOrder = 3),
      (i.rotation.x = -Math.PI / 2),
      i.scale.set(0, 0, 0),
      i.position.set(0, 0.21, 0),
      this.scene.add(i),
      (i._s = 0),
      this.time.on('tick', (a, o) => {
        ;(i._s += 0.01),
          i.scale.setScalar(i._s),
          i._s >= 1
            ? (i.material.opacity = 1 - (i._s - 1))
            : (i.material.opacity = 1),
          i._s >= 5 && (i._s = 0)
      })
  }
  createBottomBg() {
    let t = new Ti(15.3, 9.59)
    const e = this.assets.instance.getResource('bg')
    ;(e.colorSpace = cn),
      (e.anisotropy = 8),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(1, 1)
    let n = new on({
        map: e,
        opacity: 1,
        fog: !1,
      }),
      i = new De(t, n)
    if (
      ((i.rotation.x = -Math.PI / 2),
      i.position.set(0.51, -0.01, 0),
      i.scale.setScalar(1.46),
      this.scene.add(i),
      this.debug.active)
    ) {
      const a = this.debug.instance.addFolder('bg')
      a.add(i.position, 'x', -10, 10, 0.01),
        a.add(i.position, 'y', -10, 10, 0.01),
        a.add(i.position, 'z', -10, 10, 0.01)
      let o = {
        scale: 1,
      }
      a.add(o, 'scale', 1, 10, 0.01).onChange(s => {
        let l = Number(s)
        i.scale.setScalar(l)
      })
    }
  }
  createLabel() {
    let t = this,
      e = this.labelGroup,
      n = this.label2d
    Mj.map(a => {
      i(a, n, e)
    })
    function i(a, o, s) {
      let l = o.create('', 'province-label', !0)
      l.name = a.name + '-provinceLabel'
      const [u, c] = t.geoProjection(a.center)
      return (
        l.init(
          `<div class="name">${a.name}</div>`,
          new U(u, -c, t.depth * 2 + 0.1),
        ),
        l.setParent(s),
        l
      )
    }
  }
  createCircleQuan({
    width: t,
    speed: e,
    material: n,
    renderOrder: i,
    position: a = new U(0, -0.005, 0),
  }) {
    let o = new jZ(this, {
      width: t,
      needRotate: !0,
      rotateSpeed: e,
      material: n,
      position: a,
    })
    return (
      (o.instance.rotation.x = -Math.PI / 2),
      (o.instance.renderOrder = i),
      o.instance.scale.set(1, 1, 1),
      o.setParent(this.scene),
      o.instance
    )
  }
  createRotateBorder() {
    let t = this.assets.instance.getResource('quan1'),
      e = this.assets.instance.getResource('quan2'),
      n = this.assets.instance.getResource('quan3'),
      i = this.assets.instance.getResource('quan4')
    t.colorSpace = e.colorSpace = n.colorSpace = i.colorSpace = cn
    let a = new on({
        map: t,
        color: 54527,
        transparent: !0,
        opacity: 0.3,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      o = new on({
        map: e,
        transparent: !0,
        opacity: 0.8,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      s = new on({
        map: n,
        transparent: !0,
        depthWrite: !1,
        opacity: 0,
        fog: !1,
        blending: $r,
      }),
      l = new on({
        color: 5425407,
        map: i,
        transparent: !0,
        opacity: 0.02,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      u = this.createCircleQuan({
        width: 11,
        speed: -0.004,
        material: a,
        renderOrder: 2,
      }),
      c = this.createCircleQuan({
        width: 10,
        speed: 0.005,
        material: o,
        renderOrder: 2,
      })
    this.createCircleQuan({
      width: 7,
      speed: 0.005,
      material: s,
      renderOrder: 2,
    }),
      this.createCircleQuan({
        width: 9,
        speed: 0.005,
        material: l,
        renderOrder: 2,
      }),
      (this.rotateBorder1 = u),
      (this.rotateBorder2 = c)
  }
  createFlyLine(t, e) {
    ;(this.flyLineGroup = new un()), this.scene.add(this.flyLineGroup)
    const n = this.flylineTexture
    ;(n.wrapS = n.wrapT = Jn), (n.colorSpace = cn), n.repeat.set(0.5, 2)
    const i = 0.02,
      a = 32,
      o = 8,
      s = !1
    let [l, u] = this.geoProjection(t.centroid),
      c = new U(l, -u, 0)
    const h = new Th({
        map: n,
        transparent: !0,
        fog: !1,
        opacity: 1,
        depthTest: !1,
        emissiveIntensity: 2,
        blending: $r,
      }),
      f = new on({
        color: 63477,
        transparent: !0,
        fog: !1,
        opacity: 0.05,
        depthTest: !1,
        blending: $r,
      })
    e.map((d, p) => {
      let [g, v] = this.geoProjection(d.centroid),
        m = new U(g, -v, 0)
      const y = new U()
      y.addVectors(c, m).multiplyScalar(0.5), y.setZ(1.5)
      const _ = new YM(c, y, m),
        x = new bp(_, a, 0.08, 2, s),
        A = new bp(_, a, i, o, s),
        S = new De(x, h),
        b = new De(A, f)
      ;(S.name = 'flylineMesh1-' + p),
        (S.rotation.x = -Math.PI / 2),
        S.position.set(0, this.depth + 0.44, 0),
        (S.renderOrder = 21),
        (b.name = 'flylineMesh2-' + p),
        (b.rotation.x = -Math.PI / 2),
        b.position.set(0, this.depth + 0.44, 0),
        (b.renderOrder = 20),
        this.flyLineGroup.add(S, b)
    })
  }
  clearFlyLine() {
    va(this.flyLineGroup)
  }
  createFocus() {
    let t = new _j(this, {
        color1: 12451325,
        color2: 12451325,
      }),
      [e, n] = this.geoProjection(this.flyLineCenter)
    t.position.set(e, -n, this.depth + 0.44),
      t.scale.set(1, 1, 1),
      this.flyLineFocusGroup.add(t)
  }
  destroyFlyFocus() {
    va(this.flyLineGroup), va(this.flyLineFocusGroup)
  }
  createScatter() {
    ;(this.scatterGroup = new un()),
      (this.scatterGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.scatterGroup)
    const t = this.assets.instance.getResource('arrow'),
      e = new fB({
        map: t,
        color: 16776948,
        fog: !1,
        transparent: !0,
        depthTest: !1,
      })
    let n = zx(Tj),
      i = n[0].value
    n.map(a => {
      const o = new UY(e)
      o.renderOrder = 23
      let s = 0.1 + (a.value / i) * 0.2
      o.scale.set(s, s, s)
      let [l, u] = this.geoProjection(a.centroid)
      o.position.set(l, -u, this.depth + 0.45),
        (o.userData.position = [l, -u, this.depth + 0.45]),
        this.scatterGroup.add(o)
    })
  }
  createStorke() {
    const t = this.assets.instance.getResource('mapStroke'),
      e = this.assets.instance.getResource('pathLine3')
    ;(e.wrapS = e.wrapT = Jn), e.repeat.set(2, 1)
    let n = new Dx(this, {
      geoProjectionCenter: this.geoProjectionCenter,
      geoProjectionScale: this.geoProjectionScale,
      position: new U(0, 0, 0),
      data: t,
      material: new on({
        color: 2868444,
        map: e,
        alphaMap: e,
        fog: !1,
        transparent: !0,
        opacity: 1,
        blending: $r,
      }),
      type: 'Line3',
      renderOrder: 22,
      tubeRadius: 0.03,
    })
    this.focusMapGroup.add(n.lineGroup),
      this.time.on('tick', () => {
        e.offset.x += 0.005
      })
  }
  createPoint(t) {
    let e = this.label2d,
      n = this.pointGroup,
      i = this
    t.map(o => {
      let s = a(o)
      s.element.addEventListener('click', () => {
        Pj(s.userData.name)
      })
    })
    function a(o) {
      let s = e.create('', 'map-label-point')
      const [l, u] = i.geoProjection(o.centroid)
      return (
        s.init(
          `<div class="map-label-point-style ${o.level === '差' ? 'red' : ''}">
          <div class="map-label-point-style-name"> ${o.name} </div>
          <div class="map-label-point-style-icon"> </div>
          <div class="map-label-point-style-icon-arrow"> </div>
        </div>`,
          new U(l, -u, i.depth + 0.4),
        ),
        (s.userData = o),
        e.setLabelStyle(s, 'auto'),
        s.setParent(n),
        s
      )
    }
  }
  destroyPoint() {
    va(this.pointGroup)
  }
  createPath(t) {
    const e = this.assets.instance.getResource('pathLine').clone()
    ;(e.wrapS = e.wrapT = Jn), e.repeat.set(6, 1)
    let i = `{
      "features": [
        {
            "properties": { "_draw_type": "line" },
            "geometry": {
              "type": "LineString",
              "coordinates": ${JSON.stringify(t.coordinates)}
            }
        }
      ]
    }`,
      a = new Dx(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, this.depth * 2 + 0.1),
        data: i,
        material: new on({
          map: e,
          fog: !1,
          transparent: !0,
          opacity: 1,
          depthTest: !1,
          blending: $r,
        }),
        type: 'Line3',
        renderOrder: 99,
        tubeRadius: 0.03,
      })
    a.lineGroup.scale.set(1, 1, 1),
      this.trackGroup.add(a.lineGroup),
      this.time.on('tick', () => {
        e.offset.x -= 0.05
      }),
      this.createPathPointEvent(t.startPoint),
      this.createPathPointEvent(t.endPoint)
  }
  createPathPointEvent(t) {
    let [e, n] = this.geoProjection(t.position),
      i = this.label2d.create('', 'path-point-label'),
      a =
        t.type === 'start'
          ? 'path-point-label-icon-start'
          : 'path-point-label-icon-end'
    i.init(
      `
      <div class="path-point-label-wrap">
        <div class="path-point-label-icon ${a}"></div>
        <div class="path-point-label-info">
          <div class="name">${t.name}</div>
          <div class="thumb">
          <img src="../assets/huoche.jpg" />
          </div>
          <div class="info">
            <div class="info-item">载重：${t.weight} 吨</div>
            <div class="info-item">车厢：${t.trainCarriageNum} 节</div>
            <div class="info-item">人员：${t.staffNum}人</div>
            <div class="info-item">货物：${t.goods}</div>
            <div class="info-item">承运：${t.carrierCompany}</div>
          </div>
        </div>
      </div>
      `,
      new U(e, -n, this.depth * 2 + 0.2),
    ),
      i.setParent(this.pathLabelGroup),
      i.element
        .querySelector('.path-point-label-icon')
        .addEventListener('click', () => {
          i.element
            .querySelector('.path-point-label-info')
            .classList.toggle('show'),
            document.querySelectorAll('.path-point-label-info').forEach(o => {
              o !== i.element.querySelector('.path-point-label-info') &&
                o.classList.remove('show')
            })
        })
  }
  destroyPath() {
    va(this.trackGroup), va(this.pathLabelGroup)
  }
  createHeatmap() {
    const t = this.assets.instance.getResource('hotmapData')
    let e = JSON.parse(t)
    e = e.features.map(a => a.geometry.coordinates || [])
    let {boxSize: n} = PD(this.focusMapGroup),
      i = new Aj(this, {
        data: e,
        width: n.x,
        height: n.z,
        z: this.depth * 2 + 0.2,
      })
    this.hotmapGroup.add(i)
  }
  destroyHeatmap() {
    va(this.hotmapGroup)
  }
  geoProjection(t) {
    return V0()
      .center(this.geoProjectionCenter)
      .scale(this.geoProjectionScale)
      .translate([0, 0])(t)
  }
  update(t) {
    super.update(t),
      this.interactionManager && this.interactionManager.update(),
      this.allGuangquan.length &&
        this.allGuangquan.map(e => {
          e.update(t)
        }),
      this.flylineTexture && (this.flylineTexture.offset.x -= 0.006)
  }
  destroy() {
    super.destroy(), this.label3d && this.label3d.destroy()
  }
}
const Ij = [
  {
    name: '杭州市',
    enName: 'hangzhou',
    value: 45,
    center: [120.153576, 30.287459],
    centroid: [119.476498, 29.898918],
  },
  {
    name: '宁波市',
    enName: 'ningbo',
    value: 57,
    center: [121.549792, 29.868388],
    centroid: [121.479174, 29.733017],
  },
  {
    name: '温州市',
    enName: 'wenzhou',
    value: 80,
    center: [120.672111, 28.000575],
    centroid: [120.463912, 27.894726],
  },
  {
    name: '嘉兴市',
    enName: 'jiaxing',
    value: 42,
    center: [120.750865, 30.762653],
    centroid: [120.783487, 30.620063],
  },
  {
    name: '湖州市',
    enName: 'huzhou',
    value: 37,
    center: [120.102398, 30.867198],
    centroid: [119.873663, 30.743058],
  },
  {
    name: '绍兴市',
    enName: 'shaoxing',
    value: 24,
    center: [120.582112, 29.997117],
    centroid: [120.640933, 29.732893],
  },
  {
    name: '金华市',
    enName: 'jinghua',
    value: 99,
    center: [119.649506, 29.089524],
    centroid: [119.957007, 29.115117],
  },
  {
    name: '衢州市',
    enName: 'hengzhou',
    value: 46,
    center: [118.87263, 28.941708],
    centroid: [118.679569, 28.932446],
  },
  {
    name: '舟山市',
    enName: 'zhousan',
    value: 37,
    center: [122.106863, 30.016028],
    centroid: [122.146805, 30.056563],
  },
  {
    name: '台州市',
    enName: 'taizhou',
    value: 36,
    center: [121.428599, 28.661378],
    centroid: [121.136679, 28.757098],
  },
  {
    name: '丽水市',
    enName: 'lishui',
    value: 48,
    center: [119.921786, 28.451993],
    centroid: [119.517145, 28.197644],
  },
]
const Oj = {
    class: 'map',
  },
  Nj = {
    __name: 'map',
    setup(r, {expose: t}) {
      function e(y) {
        return y.sort((_, x) => x.value - _.value), y
      }
      const n = hh(null),
        i = [120.20341805, 30.23969507]
      Ea(() => {
        Ee.$on('loadMap', a),
          Ee.$on('mapPlayComplete', s),
          Ee.$on('createBar', l),
          Ee.$on('destroyBar', u),
          Ee.$on('createPoint', c),
          Ee.$on('destroyPoint', h),
          Ee.$on('createSituation', f),
          Ee.$on('destroySituation', d),
          Ee.$on('createPath', p),
          Ee.$on('destroyPath', g),
          Ee.$on('createHeatmap', v),
          Ee.$on('destroyHeatmap', m)
      }),
        Da(() => {
          n.value && n.value.destroy(),
            Ee.$off('loadMap', a),
            Ee.$off('createBar', l),
            Ee.$off('destroyBar', u),
            Ee.$off('createPoint', c),
            Ee.$off('destroyPoint', h),
            Ee.$off('createSituation', f),
            Ee.$off('destroySituation', d),
            Ee.$off('createPath', p),
            Ee.$off('destroyPath', g),
            Ee.$off('destroyHeatmap', m)
        })
      function a(y) {
        ;(n.value = new Rj(document.getElementById('canvasMap'), y, {
          geoProjectionCenter: [120.109913, 29.181466],
          geoProjectionScale: 90,
          flyLineCenter: i,
          depth: 0.3,
          debug: !1,
        })),
          n.value.time.pause()
      }
      async function o() {
        n.value &&
          (n.value.time.resume(),
          n.value.animateTl.timeScale(1),
          n.value.animateTl.play())
      }
      function s() {
        let y = e(Ij).filter((_, x) => x < 7)
        n.value.createBar(y),
          n.value.createFlyLine(
            {
              centroid: i,
            },
            y,
          )
      }
      function l(y) {
        n.value && n.value.createBar(y)
      }
      function u() {
        n.value && n.value.clearBar()
      }
      function c(y) {
        n.value && n.value.createPoint(y)
      }
      function h() {
        n.value && n.value.destroyPoint()
      }
      function f(y) {
        n.value && n.value.createSituation(y)
      }
      function d() {
        n.value && n.value.destroySituation()
      }
      function p(y) {
        n.value && n.value.createPath(y)
      }
      function g() {
        n.value && n.value.destroyPath()
      }
      function v() {
        n.value && n.value.createHeatmap()
      }
      function m() {
        n.value && n.value.destroyHeatmap()
      }
      return (
        t({
          loadMap: a,
          play: o,
          canvasMap: n,
        }),
        (y, _) => (
          en(),
          sn(
            'div',
            Oj,
            _[0] ||
              (_[0] = [
                wt(
                  'canvas',
                  {
                    id: 'canvasMap',
                  },
                  null,
                  -1,
                ),
              ]),
          )
        )
      )
    },
  }
const X0 = (r, t) => {
    const e = r.__vccOpts || r
    for (const [n, i] of t) e[n] = i
    return e
  },
  kj = {
    name: 'SvglineAnimation',
    props: {
      width: {
        type: Number,
        default: 135,
      },
      height: {
        type: Number,
        default: 150,
      },
      path: {
        type: String,
        default: 'M0 72.5H682L732 0.5H3082',
      },
      color: {
        type: String,
        default: '#0091FF',
      },
      duration: {
        type: Number,
        default: 3,
      },
      length: {
        type: Number,
        default: 100,
      },
      begin: {
        type: Number,
        default: 0,
      },
      dir: {
        type: Array,
        default: () => [0, 1],
      },
      strokeWidth: {
        type: Number,
        default: 4,
      },
    },
    data() {
      let r = 1
      return {
        maskId: 'svgline-' + r,
        radialGradientId: 'radialGradient-' + r,
      }
    },
    mounted() {
      let r = this._.uid
      ;(this.maskId = 'svgline-' + r),
        (this.radialGradientId = 'radialGradient-' + r)
    },
  },
  Bj = {
    class: 'svg-line-animation',
  },
  Fj = ['viewBox'],
  zj = ['id'],
  Uj = ['stop-opacity'],
  Vj = ['stop-opacity'],
  Gj = ['id'],
  Hj = ['r', 'fill'],
  Wj = ['begin', 'dur', 'path', 'keyPoints'],
  Xj = ['d', 'stroke', 'stroke-width', 'mask']
function Yj(r, t, e, n, i, a) {
  return (
    en(),
    sn('div', Bj, [
      (en(),
      sn(
        'svg',
        {
          width: '100%',
          height: '100%',
          viewBox: `0 0 ${e.width} ${e.height}`,
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        [
          wt('defs', null, [
            wt(
              'radialGradient',
              {
                id: i.radialGradientId,
                cx: '50%',
                cy: '50%',
                fx: '100%',
                fy: '50%',
                r: '50%',
              },
              [
                wt(
                  'stop',
                  {
                    offset: '0%',
                    'stop-color': '#fff',
                    'stop-opacity': e.dir[1],
                  },
                  null,
                  8,
                  Uj,
                ),
                wt(
                  'stop',
                  {
                    offset: '100%',
                    'stop-color': '#fff',
                    'stop-opacity': e.dir[0],
                  },
                  null,
                  8,
                  Vj,
                ),
              ],
              8,
              zj,
            ),
            wt(
              'mask',
              {
                id: i.maskId,
              },
              [
                wt(
                  'circle',
                  {
                    r: e.length,
                    cx: '0',
                    cy: '0',
                    fill: `url(#${i.radialGradientId})`,
                  },
                  [
                    wt(
                      'animateMotion',
                      {
                        begin: `${e.begin}s`,
                        dur: `${e.duration}s`,
                        path: e.path,
                        rotate: 'auto',
                        keyPoints: `${e.dir[0]};${e.dir[1]}`,
                        keyTimes: '0;1',
                        repeatCount: 'indefinite',
                      },
                      null,
                      8,
                      Wj,
                    ),
                  ],
                  8,
                  Hj,
                ),
              ],
              8,
              Gj,
            ),
          ]),
          wt(
            'path',
            {
              class: 'path-line',
              d: e.path,
              stroke: e.color,
              'stroke-width': e.strokeWidth,
              mask: `url(#${i.maskId})`,
            },
            null,
            8,
            Xj,
          ),
        ],
        8,
        Fj,
      )),
    ])
  )
}
const Oy = X0(kj, [['render', Yj]])
const $j = {
    class: 'm-header',
  },
  qj = {
    class: 'm-header-wrap',
  },
  Zj = {
    class: 'm-header-title',
  },
  Kj = {
    class: 'm-header-subtext',
  },
  jj = {
    class: 'm-header-left',
    style: {
      color: '#fff',
    },
  },
  Jj = {
    class: 'm-header-right',
  },
  Qj = {
    class: 'm-header-line',
  },
  tJ = {
    __name: 'index',
    props: {
      title: {
        type: String,
        default: '数据可视化大屏',
      },
      subText: {
        type: String,
        default: 'Visualization Platform',
      },
    },
    setup(r) {
      return (t, e) => (
        en(),
        sn('div', $j, [
          wt('div', qj, [
            wt('div', Zj, Si(r.title), 1),
            wt('div', Kj, Si(r.subText), 1),
          ]),
          wt('div', jj, [Bh(t.$slots, 'left')]),
          wt('div', Jj, [Bh(t.$slots, 'right')]),
          wt('div', Qj, [
            ye(Oy, {
              class: 'm-header-line-left',
              width: 961,
              height: 79,
              color: '#30DCFF',
              strokeWidth: 2,
              dir: [0, 1],
              length: 100,
              path: 'M1 1.52783L535 25.6808C552.73 26.5835 571.454 31.3851 588.834 39.2194C593.758 41.4385 598.692 43.7289 603.643 46.0273C633.567 59.9182 664.121 74.1016 696.754 74.6262C696.765 74.6264 696.775 74.6265 696.786 74.6267C821.602 76.5993 879.336 78 961 78',
            }),
            ye(Oy, {
              class: 'm-header-line-right',
              width: 961,
              height: 79,
              color: '#30DCFF',
              strokeWidth: 2,
              dir: [0, 1],
              length: 100,
              path: 'M1 1.52783L535 25.6808C552.73 26.5835 571.454 31.3851 588.834 39.2194C593.758 41.4385 598.692 43.7289 603.643 46.0273C633.567 59.9182 664.121 74.1016 696.754 74.6262C696.765 74.6264 696.775 74.6265 696.786 74.6267C821.602 76.5993 879.336 78 961 78',
            }),
          ]),
        ])
      )
    },
  }
let wL = 0
const ML = 'webkit moz ms o'.split(' ')
let Xa, Ya
const eJ = typeof window > 'u'
if (eJ) (Xa = function () {}), (Ya = function () {})
else {
  ;(Xa = window.requestAnimationFrame), (Ya = window.cancelAnimationFrame)
  let r
  for (let t = 0; t < ML.length && !(Xa && Ya); t++)
    (r = ML[t]),
      (Xa = Xa || window[r + 'RequestAnimationFrame']),
      (Ya =
        Ya ||
        window[r + 'CancelAnimationFrame'] ||
        window[r + 'CancelRequestAnimationFrame'])
  ;(!Xa || !Ya) &&
    ((Xa = function (t) {
      const e = new Date().getTime(),
        n = Math.max(0, 16 - (e - wL)),
        i = window.setTimeout(() => {
          t(e + n)
        }, n)
      return (wL = e + n), i
    }),
    (Ya = function (t) {
      window.clearTimeout(t)
    }))
}
const nJ = {
  props: {
    startVal: {
      type: Number,
      required: !1,
      default: 0,
    },
    endVal: {
      type: Number,
      required: !1,
      default: 2017,
    },
    duration: {
      type: Number,
      required: !1,
      default: 3e3,
    },
    autoplay: {
      type: Boolean,
      required: !1,
      default: !0,
    },
    decimals: {
      type: Number,
      required: !1,
      default: 0,
      validator(r) {
        return r >= 0
      },
    },
    decimal: {
      type: String,
      required: !1,
      default: '.',
    },
    separator: {
      type: String,
      required: !1,
      default: ',',
    },
    prefix: {
      type: String,
      required: !1,
      default: '',
    },
    suffix: {
      type: String,
      required: !1,
      default: '',
    },
    useEasing: {
      type: Boolean,
      required: !1,
      default: !0,
    },
    easingFn: {
      type: Function,
      default(r, t, e, n) {
        return (e * (-Math.pow(2, (-10 * r) / n) + 1) * 1024) / 1023 + t
      },
    },
  },
  data() {
    return {
      localStartVal: this.startVal,
      displayValue: this.formatNumber(this.startVal),
      printVal: null,
      paused: !1,
      localDuration: this.duration,
      startTime: null,
      timestamp: null,
      remaining: null,
      rAF: null,
    }
  },
  computed: {
    countDown() {
      return this.startVal > this.endVal
    },
  },
  watch: {
    startVal() {
      this.autoplay && this.start()
    },
    endVal() {
      this.autoplay && this.start()
    },
  },
  mounted() {
    this.autoplay && this.start(), this.$emit('mountedCallback')
  },
  methods: {
    start() {
      ;(this.localStartVal = this.startVal),
        (this.startTime = null),
        (this.localDuration = this.duration),
        (this.paused = !1),
        (this.rAF = Xa(this.count))
    },
    pauseResume() {
      this.paused
        ? (this.resume(), (this.paused = !1))
        : (this.pause(), (this.paused = !0))
    },
    pause() {
      Ya(this.rAF)
    },
    resume() {
      ;(this.startTime = null),
        (this.localDuration = +this.remaining),
        (this.localStartVal = +this.printVal),
        Xa(this.count)
    },
    reset() {
      ;(this.startTime = null),
        Ya(this.rAF),
        (this.displayValue = this.formatNumber(this.startVal))
    },
    count(r) {
      this.startTime || (this.startTime = r), (this.timestamp = r)
      const t = r - this.startTime
      ;(this.remaining = this.localDuration - t),
        this.useEasing
          ? this.countDown
            ? (this.printVal =
                this.localStartVal -
                this.easingFn(
                  t,
                  0,
                  this.localStartVal - this.endVal,
                  this.localDuration,
                ))
            : (this.printVal = this.easingFn(
                t,
                this.localStartVal,
                this.endVal - this.localStartVal,
                this.localDuration,
              ))
          : this.countDown
          ? (this.printVal =
              this.localStartVal -
              (this.localStartVal - this.endVal) * (t / this.localDuration))
          : (this.printVal =
              this.localStartVal +
              (this.endVal - this.localStartVal) * (t / this.localDuration)),
        this.countDown
          ? (this.printVal =
              this.printVal < this.endVal ? this.endVal : this.printVal)
          : (this.printVal =
              this.printVal > this.endVal ? this.endVal : this.printVal),
        (this.displayValue = this.formatNumber(this.printVal)),
        t < this.localDuration
          ? (this.rAF = Xa(this.count))
          : this.$emit('callback')
    },
    isNumber(r) {
      return !isNaN(parseFloat(r))
    },
    formatNumber(r) {
      ;(r = r.toFixed(this.decimals)), (r += '')
      const t = r.split('.')
      let e = t[0]
      const n = t.length > 1 ? this.decimal + t[1] : '',
        i = /(\d+)(\d{3})/
      if (this.separator && !this.isNumber(this.separator))
        for (; i.test(e); ) e = e.replace(i, '$1' + this.separator + '$2')
      return this.prefix + e + n + this.suffix
    },
  },
  destroyed() {
    Ya(this.rAF)
  },
}
function rJ(r, t, e, n, i, a) {
  return en(), sn('span', null, Si(i.displayValue), 1)
}
const bT = X0(nJ, [['render', rJ]])
typeof window < 'u' && window.Vue && window.Vue.component('count-to', bT)
const iJ = {
    class: 'count-card',
  },
  aJ = {
    class: 'count-card-left',
  },
  oJ = {
    class: 'count-card-title',
  },
  sJ = {
    class: 'title-zh',
  },
  lJ = {
    class: 'title-en',
  },
  uJ = {
    class: 'count-card-right',
  },
  cJ = {
    class: 'value',
  },
  hJ = {
    class: 'unit',
  },
  fJ = {
    __name: 'index',
    props: {
      info: {
        type: Object,
        default: () => ({
          icon: 'xiaoshoujine',
          zh: '2023年销售金额',
          en: 'Sales amount in 2023',
          value: 9500,
          unit: '万元',
          decimals: 0,
        }),
      },
    },
    setup(r) {
      function t(e) {
        return e.toUpperCase()
      }
      return (e, n) => (
        en(),
        sn('div', iJ, [
          wt('div', aJ, [
            wt(
              'div',
              {
                class: fh(['count-card-icon', 'icon-' + r.info.icon]),
              },
              null,
              2,
            ),
            wt('div', oJ, [
              wt('div', sJ, Si(r.info.zh), 1),
              wt('div', lJ, Si(t(r.info.en)), 1),
            ]),
          ]),
          wt('div', uJ, [
            wt('div', cJ, [
              ye(
                La(bT),
                {
                  startVal: 0,
                  endVal: r.info.value,
                  decimals: r.info.decimals,
                  duration: 2e3,
                  separator: '',
                  autoplay: !0,
                },
                null,
                8,
                ['endVal', 'decimals'],
              ),
            ]),
            wt('div', hJ, Si(r.info.unit), 1),
          ]),
        ])
      )
    },
  }
const dJ = {
    class: 'm-menu',
  },
  pJ = {
    __name: 'index',
    props: {
      defaultActive: {
        type: [String, Number],
        default: '',
      },
    },
    emits: ['select'],
    setup(r, {emit: t}) {
      const e = t,
        n = r,
        i = je(n.defaultActive)
      return (
        HE('updateActive', o => {
          ;(i.value = o), e('select', o)
        }),
        HE('activeIndex', i),
        Td(
          () => n.defaultActive,
          o => {
            o !== i.value && (i.value = o)
          },
        ),
        (o, s) => (en(), sn('div', dJ, [Bh(o.$slots, 'default')]))
      )
    },
  },
  vJ = './assets/radar-bg-9aa54028.png',
  gJ = './assets/saomiao-456ce626.png'
const mJ = {},
  yJ = {
    class: 'm-radar',
  }
function _J(r, t) {
  return (
    en(),
    sn(
      'div',
      yJ,
      t[0] ||
        (t[0] = [
          wt(
            'img',
            {
              class: 'm-radar-bg',
              src: vJ,
              alt: '',
            },
            null,
            -1,
          ),
          wt(
            'img',
            {
              class: 'm-radar-saomiao',
              src: gJ,
              alt: '',
            },
            null,
            -1,
          ),
        ]),
    )
  )
}
const xJ = X0(mJ, [['render', _J]]),
  Bc = {
    __name: 'index',
    props: {
      index: {
        type: [String, Number],
        required: !0,
      },
    },
    setup(r) {
      const t = r,
        e = dh('updateActive'),
        n = dh('activeIndex'),
        i = () => {
          e(t.index)
        }
      return (a, o) => (
        en(),
        sn(
          'div',
          {
            class: fh([
              'm-menu-item',
              {
                'is-active': r.index === La(n),
              },
            ]),
            onClick: i,
          },
          [Bh(a.$slots, 'default')],
          2,
        )
      )
    },
  }
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function tlt(r, t, e, n) {
  var i;
  if (e && e !== "none")
    if (
      ((i = Xn("rect", "bg", {
        width: r,
        height: t,
        x: "0",
        y: "0",
      })),
      bz(e))
    )
      vG(
        {
          fill: e,
        },
        i.attrs,
        "fill",
        n
      );
    else if (NT(e))
      gG(
        {
          style: {
            fill: e,
          },
          dirty: wn,
          getBoundingRect: function () {
            return {
              width: r,
              height: t,
            };
          },
        },
        i.attrs,
        "fill",
        n
      );
    else {
      var a = zp(e),
        o = a.color,
        s = a.opacity;
      (i.attrs.fill = o), s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
const elt = Qst;
function nlt(r) {
  r.registerPainter("svg", elt);
}
function TI(r, t, e) {
  var n = rl.createCanvas(),
    i = t.getWidth(),
    a = t.getHeight(),
    o = n.style;
  return (
    o &&
      ((o.position = "absolute"),
      (o.left = "0"),
      (o.top = "0"),
      (o.width = i + "px"),
      (o.height = a + "px"),
      n.setAttribute("data-zr-dom-id", r)),
    (n.width = i * e),
    (n.height = a * e),
    n
  );
}
var rlt = (function (r) {
  X(t, r);
  function t(e, n, i) {
    var a = r.call(this) || this;
    (a.motionBlur = !1),
      (a.lastFrameAlpha = 0.7),
      (a.dpr = 1),
      (a.virtual = !1),
      (a.config = {}),
      (a.incremental = !1),
      (a.zlevel = 0),
      (a.maxRepaintRectCount = 5),
      (a.__dirty = !0),
      (a.__firstTimePaint = !0),
      (a.__used = !1),
      (a.__drawIndex = 0),
      (a.__startIndex = 0),
      (a.__endIndex = 0),
      (a.__prevStartIndex = null),
      (a.__prevEndIndex = null);
    var o;
    (i = i || Gy),
      typeof e == "string" ? (o = TI(e, n, i)) : Ut(e) && ((o = e), (e = o.id)),
      (a.id = e),
      (a.dom = o);
    var s = o.style;
    return (
      s &&
        (iz(o),
        (o.onselectstart = function () {
          return !1;
        }),
        (s.padding = "0"),
        (s.margin = "0"),
        (s.borderWidth = "0")),
      (a.painter = n),
      (a.dpr = i),
      a
    );
  }
  return (
    (t.prototype.getElementCount = function () {
      return this.__endIndex - this.__startIndex;
    }),
    (t.prototype.afterBrush = function () {
      (this.__prevStartIndex = this.__startIndex),
        (this.__prevEndIndex = this.__endIndex);
    }),
    (t.prototype.initContext = function () {
      (this.ctx = this.dom.getContext("2d")), (this.ctx.dpr = this.dpr);
    }),
    (t.prototype.setUnpainted = function () {
      this.__firstTimePaint = !0;
    }),
    (t.prototype.createBackBuffer = function () {
      var e = this.dpr;
      (this.domBack = TI("back-" + this.id, this.painter, e)),
        (this.ctxBack = this.domBack.getContext("2d")),
        e !== 1 && this.ctxBack.scale(e, e);
    }),
    (t.prototype.createRepaintRects = function (e, n, i, a) {
      if (this.__firstTimePaint) return (this.__firstTimePaint = !1), null;
      var o = [],
        s = this.maxRepaintRectCount,
        l = !1,
        u = new ee(0, 0, 0, 0);
      function c(y) {
        if (!(!y.isFinite() || y.isZero()))
          if (o.length === 0) {
            var _ = new ee(0, 0, 0, 0);
            _.copy(y), o.push(_);
          } else {
            for (var x = !1, A = 1 / 0, S = 0, b = 0; b < o.length; ++b) {
              var T = o[b];
              if (T.intersect(y)) {
                var w = new ee(0, 0, 0, 0);
                w.copy(T), w.union(y), (o[b] = w), (x = !0);
                break;
              } else if (l) {
                u.copy(y), u.union(T);
                var M = y.width * y.height,
                  C = T.width * T.height,
                  E = u.width * u.height,
                  D = E - M - C;
                D < A && ((A = D), (S = b));
              }
            }
            if ((l && (o[S].union(y), (x = !0)), !x)) {
              var _ = new ee(0, 0, 0, 0);
              _.copy(y), o.push(_);
            }
            l || (l = o.length >= s);
          }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var f = e[h];
        if (f) {
          var d = f.shouldBePainted(i, a, !0, !0),
            p =
              f.__isRendered && (f.__dirty & yi || !d)
                ? f.getPrevPaintRect()
                : null;
          p && c(p);
          var g =
            d && (f.__dirty & yi || !f.__isRendered) ? f.getPaintRect() : null;
          g && c(g);
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var f = n[h],
          d = f && f.shouldBePainted(i, a, !0, !0);
        if (f && (!d || !f.__zr) && f.__isRendered) {
          var p = f.getPrevPaintRect();
          p && c(p);
        }
      }
      var v;
      do {
        v = !1;
        for (var h = 0; h < o.length; ) {
          if (o[h].isZero()) {
            o.splice(h, 1);
            continue;
          }
          for (var m = h + 1; m < o.length; )
            o[h].intersect(o[m])
              ? ((v = !0), o[h].union(o[m]), o.splice(m, 1))
              : m++;
          h++;
        }
      } while (v);
      return (this._paintRects = o), o;
    }),
    (t.prototype.debugGetPaintRects = function () {
      return (this._paintRects || []).slice();
    }),
    (t.prototype.resize = function (e, n) {
      var i = this.dpr,
        a = this.dom,
        o = a.style,
        s = this.domBack;
      o && ((o.width = e + "px"), (o.height = n + "px")),
        (a.width = e * i),
        (a.height = n * i),
        s &&
          ((s.width = e * i),
          (s.height = n * i),
          i !== 1 && this.ctxBack.scale(i, i));
    }),
    (t.prototype.clear = function (e, n, i) {
      var a = this.dom,
        o = this.ctx,
        s = a.width,
        l = a.height;
      n = n || this.clearColor;
      var u = this.motionBlur && !e,
        c = this.lastFrameAlpha,
        h = this.dpr,
        f = this;
      u &&
        (this.domBack || this.createBackBuffer(),
        (this.ctxBack.globalCompositeOperation = "copy"),
        this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
      var d = this.domBack;
      function p(g, v, m, y) {
        if ((o.clearRect(g, v, m, y), n && n !== "transparent")) {
          var _ = void 0;
          if ($0(n)) {
            var x = n.global || (n.__width === m && n.__height === y);
            (_ =
              (x && n.__canvasGradient) ||
              _w(o, n, {
                x: 0,
                y: 0,
                width: m,
                height: y,
              })),
              (n.__canvasGradient = _),
              (n.__width = m),
              (n.__height = y);
          } else
            kJ(n) &&
              ((n.scaleX = n.scaleX || h),
              (n.scaleY = n.scaleY || h),
              (_ = xw(o, n, {
                dirty: function () {
                  f.setUnpainted(), f.painter.refresh();
                },
              })));
          o.save(), (o.fillStyle = _ || n), o.fillRect(g, v, m, y), o.restore();
        }
        u &&
          (o.save(),
          (o.globalAlpha = c),
          o.drawImage(d, g, v, m, y),
          o.restore());
      }
      !i || u
        ? p(0, 0, s, l)
        : i.length &&
          R(i, function (g) {
            p(g.x * h, g.y * h, g.width * h, g.height * h);
          });
    }),
    t
  );
})(ra);
const tS = rlt;
var CI = 1e5,
  jl = 314159,
  um = 0.01,
  ilt = 0.001;
function alt(r) {
  return r
    ? r.__builtin__
      ? !0
      : !(typeof r.resize != "function" || typeof r.refresh != "function")
    : !1;
}
function olt(r, t) {
  var e = document.createElement("div");
  return (
    (e.style.cssText =
      [
        "position:relative",
        "width:" + r + "px",
        "height:" + t + "px",
        "padding:0",
        "margin:0",
        "border-width:0",
      ].join(";") + ";"),
    e
  );
}
var slt = (function () {
  function r(t, e, n, i) {
    (this.type = "canvas"),
      (this._zlevelList = []),
      (this._prevDisplayList = []),
      (this._layers = {}),
      (this._layerConfig = {}),
      (this._needsManuallyCompositing = !1),
      (this.type = "canvas");
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    (this._opts = n = Q({}, n || {})),
      (this.dpr = n.devicePixelRatio || Gy),
      (this._singleCanvas = a),
      (this.root = t);
    var o = t.style;
    o && (iz(t), (t.innerHTML = "")), (this.storage = e);
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t,
        h = c.width,
        f = c.height;
      n.width != null && (h = n.width),
        n.height != null && (f = n.height),
        (this.dpr = n.devicePixelRatio || 1),
        (c.width = h * this.dpr),
        (c.height = f * this.dpr),
        (this._width = h),
        (this._height = f);
      var d = new tS(c, this, this.dpr);
      (d.__builtin__ = !0),
        d.initContext(),
        (l[jl] = d),
        (d.zlevel = jl),
        s.push(jl),
        (this._domRoot = t);
    } else {
      (this._width = xh(t, 0, n)), (this._height = xh(t, 1, n));
      var u = (this._domRoot = olt(this._width, this._height));
      t.appendChild(u);
    }
  }
  return (
    (r.prototype.getType = function () {
      return "canvas";
    }),
    (r.prototype.isSingleCanvas = function () {
      return this._singleCanvas;
    }),
    (r.prototype.getViewportRoot = function () {
      return this._domRoot;
    }),
    (r.prototype.getViewportRootOffset = function () {
      var t = this.getViewportRoot();
      if (t)
        return {
          offsetLeft: t.offsetLeft || 0,
          offsetTop: t.offsetTop || 0,
        };
    }),
    (r.prototype.refresh = function (t) {
      var e = this.storage.getDisplayList(!0),
        n = this._prevDisplayList,
        i = this._zlevelList;
      (this._redrawId = Math.random()),
        this._paintList(e, n, t, this._redrawId);
      for (var a = 0; a < i.length; a++) {
        var o = i[a],
          s = this._layers[o];
        if (!s.__builtin__ && s.refresh) {
          var l = a === 0 ? this._backgroundColor : null;
          s.refresh(l);
        }
      }
      return (
        this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this
      );
    }),
    (r.prototype.refreshHover = function () {
      this._paintHoverList(this.storage.getDisplayList(!1));
    }),
    (r.prototype._paintHoverList = function (t) {
      var e = t.length,
        n = this._hoverlayer;
      if ((n && n.clear(), !!e)) {
        for (
          var i = {
              inHover: !0,
              viewWidth: this._width,
              viewHeight: this._height,
            },
            a,
            o = 0;
          o < e;
          o++
        ) {
          var s = t[o];
          s.__inHover &&
            (n || (n = this._hoverlayer = this.getLayer(CI)),
            a || ((a = n.ctx), a.save()),
            Au(a, s, i, o === e - 1));
        }
        a && a.restore();
      }
    }),
    (r.prototype.getHoverLayer = function () {
      return this.getLayer(CI);
    }),
    (r.prototype.paintOne = function (t, e) {
      Q5(t, e);
    }),
    (r.prototype._paintList = function (t, e, n, i) {
      if (this._redrawId === i) {
        (n = n || !1), this._updateLayerStatus(t);
        var a = this._doPaintList(t, e, n),
          o = a.finished,
          s = a.needsRefreshHover;
        if (
          (this._needsManuallyCompositing && this._compositeManually(),
          s && this._paintHoverList(t),
          o)
        )
          this.eachLayer(function (u) {
            u.afterBrush && u.afterBrush();
          });
        else {
          var l = this;
          Nb(function () {
            l._paintList(t, e, n, i);
          });
        }
      }
    }),
    (r.prototype._compositeManually = function () {
      var t = this.getLayer(jl).ctx,
        e = this._domRoot.width,
        n = this._domRoot.height;
      t.clearRect(0, 0, e, n),
        this.eachBuiltinLayer(function (i) {
          i.virtual && t.drawImage(i.dom, 0, 0, e, n);
        });
    }),
    (r.prototype._doPaintList = function (t, e, n) {
      for (
        var i = this, a = [], o = this._opts.useDirtyRect, s = 0;
        s < this._zlevelList.length;
        s++
      ) {
        var l = this._zlevelList[s],
          u = this._layers[l];
        u.__builtin__ &&
          u !== this._hoverlayer &&
          (u.__dirty || n) &&
          a.push(u);
      }
      for (
        var c = !0,
          h = !1,
          f = function (g) {
            var v = a[g],
              m = v.ctx,
              y = o && v.createRepaintRects(t, e, d._width, d._height),
              _ = n ? v.__startIndex : v.__drawIndex,
              x = !n && v.incremental && Date.now,
              A = x && Date.now(),
              S = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
            if (v.__startIndex === v.__endIndex) v.clear(!1, S, y);
            else if (_ === v.__startIndex) {
              var b = t[_];
              (!b.incremental || !b.notClear || n) && v.clear(!1, S, y);
            }
            _ === -1 &&
              (console.error("For some unknown reason. drawIndex is -1"),
              (_ = v.__startIndex));
            var T,
              w = function (D) {
                var P = {
                  inHover: !1,
                  allClipped: !1,
                  prevEl: null,
                  viewWidth: i._width,
                  viewHeight: i._height,
                };
                for (T = _; T < v.__endIndex; T++) {
                  var L = t[T];
                  if (
                    (L.__inHover && (h = !0),
                    i._doPaintEl(L, v, o, D, P, T === v.__endIndex - 1),
                    x)
                  ) {
                    var I = Date.now() - A;
                    if (I > 15) break;
                  }
                }
                P.prevElClipPaths && m.restore();
              };
            if (y)
              if (y.length === 0) T = v.__endIndex;
              else
                for (var M = d.dpr, C = 0; C < y.length; ++C) {
                  var E = y[C];
                  m.save(),
                    m.beginPath(),
                    m.rect(E.x * M, E.y * M, E.width * M, E.height * M),
                    m.clip(),
                    w(E),
                    m.restore();
                }
            else m.save(), w(), m.restore();
            (v.__drawIndex = T), v.__drawIndex < v.__endIndex && (c = !1);
          },
          d = this,
          p = 0;
        p < a.length;
        p++
      )
        f(p);
      return (
        Se.wxa &&
          R(this._layers, function (g) {
            g && g.ctx && g.ctx.draw && g.ctx.draw();
          }),
        {
          finished: c,
          needsRefreshHover: h,
        }
      );
    }),
    (r.prototype._doPaintEl = function (t, e, n, i, a, o) {
      var s = e.ctx;
      if (n) {
        var l = t.getPaintRect();
        (!i || (l && l.intersect(i))) &&
          (Au(s, t, a, o), t.setPrevPaintRect(l));
      } else Au(s, t, a, o);
    }),
    (r.prototype.getLayer = function (t, e) {
      this._singleCanvas && !this._needsManuallyCompositing && (t = jl);
      var n = this._layers[t];
      return (
        n ||
          ((n = new tS("zr_" + t, this, this.dpr)),
          (n.zlevel = t),
          (n.__builtin__ = !0),
          this._layerConfig[t]
            ? te(n, this._layerConfig[t], !0)
            : this._layerConfig[t - um] && te(n, this._layerConfig[t - um], !0),
          e && (n.virtual = e),
          this.insertLayer(t, n),
          n.initContext()),
        n
      );
    }),
    (r.prototype.insertLayer = function (t, e) {
      var n = this._layers,
        i = this._zlevelList,
        a = i.length,
        o = this._domRoot,
        s = null,
        l = -1;
      if (!n[t] && alt(e)) {
        if (a > 0 && t > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < t && i[l + 1] > t); l++);
          s = n[i[l]];
        }
        if ((i.splice(l + 1, 0, t), (n[t] = e), !e.virtual))
          if (s) {
            var u = s.dom;
            u.nextSibling
              ? o.insertBefore(e.dom, u.nextSibling)
              : o.appendChild(e.dom);
          } else
            o.firstChild
              ? o.insertBefore(e.dom, o.firstChild)
              : o.appendChild(e.dom);
        e.painter || (e.painter = this);
      }
    }),
    (r.prototype.eachLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i];
        t.call(e, this._layers[a], a);
      }
    }),
    (r.prototype.eachBuiltinLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i],
          o = this._layers[a];
        o.__builtin__ && t.call(e, o, a);
      }
    }),
    (r.prototype.eachOtherLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i],
          o = this._layers[a];
        o.__builtin__ || t.call(e, o, a);
      }
    }),
    (r.prototype.getLayers = function () {
      return this._layers;
    }),
    (r.prototype._updateLayerStatus = function (t) {
      this.eachBuiltinLayer(function (h, f) {
        h.__dirty = h.__used = !1;
      });
      function e(h) {
        a && (a.__endIndex !== h && (a.__dirty = !0), (a.__endIndex = h));
      }
      if (this._singleCanvas)
        for (var n = 1; n < t.length; n++) {
          var i = t[n];
          if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
            this._needsManuallyCompositing = !0;
            break;
          }
        }
      var a = null,
        o = 0,
        s,
        l;
      for (l = 0; l < t.length; l++) {
        var i = t[l],
          u = i.zlevel,
          c = void 0;
        s !== u && ((s = u), (o = 0)),
          i.incremental
            ? ((c = this.getLayer(u + ilt, this._needsManuallyCompositing)),
              (c.incremental = !0),
              (o = 1))
            : (c = this.getLayer(
                u + (o > 0 ? um : 0),
                this._needsManuallyCompositing
              )),
          c.__builtin__ ||
            CT("ZLevel " + u + " has been used by unkown layer " + c.id),
          c !== a &&
            ((c.__used = !0),
            c.__startIndex !== l && (c.__dirty = !0),
            (c.__startIndex = l),
            c.incremental ? (c.__drawIndex = -1) : (c.__drawIndex = l),
            e(l),
            (a = c)),
          i.__dirty & yi &&
            !i.__inHover &&
            ((c.__dirty = !0),
            c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
      }
      e(l),
        this.eachBuiltinLayer(function (h, f) {
          !h.__used &&
            h.getElementCount() > 0 &&
            ((h.__dirty = !0),
            (h.__startIndex = h.__endIndex = h.__drawIndex = 0)),
            h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
        });
    }),
    (r.prototype.clear = function () {
      return this.eachBuiltinLayer(this._clearLayer), this;
    }),
    (r.prototype._clearLayer = function (t) {
      t.clear();
    }),
    (r.prototype.setBackgroundColor = function (t) {
      (this._backgroundColor = t),
        R(this._layers, function (e) {
          e.setUnpainted();
        });
    }),
    (r.prototype.configLayer = function (t, e) {
      if (e) {
        var n = this._layerConfig;
        n[t] ? te(n[t], e, !0) : (n[t] = e);
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i];
          if (a === t || a === t + um) {
            var o = this._layers[a];
            te(o, n[t], !0);
          }
        }
      }
    }),
    (r.prototype.delLayer = function (t) {
      var e = this._layers,
        n = this._zlevelList,
        i = e[t];
      i &&
        (i.dom.parentNode.removeChild(i.dom),
        delete e[t],
        n.splice(re(n, t), 1));
    }),
    (r.prototype.resize = function (t, e) {
      if (this._domRoot.style) {
        var n = this._domRoot;
        n.style.display = "none";
        var i = this._opts,
          a = this.root;
        if (
          (t != null && (i.width = t),
          e != null && (i.height = e),
          (t = xh(a, 0, i)),
          (e = xh(a, 1, i)),
          (n.style.display = ""),
          this._width !== t || e !== this._height)
        ) {
          (n.style.width = t + "px"), (n.style.height = e + "px");
          for (var o in this._layers)
            this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
          this.refresh(!0);
        }
        (this._width = t), (this._height = e);
      } else {
        if (t == null || e == null) return;
        (this._width = t), (this._height = e), this.getLayer(jl).resize(t, e);
      }
      return this;
    }),
    (r.prototype.clearLayer = function (t) {
      var e = this._layers[t];
      e && e.clear();
    }),
    (r.prototype.dispose = function () {
      (this.root.innerHTML = ""),
        (this.root = this.storage = this._domRoot = this._layers = null);
    }),
    (r.prototype.getRenderedCanvas = function (t) {
      if (((t = t || {}), this._singleCanvas && !this._compositeManually))
        return this._layers[jl].dom;
      var e = new tS("image", this, t.pixelRatio || this.dpr);
      e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor);
      var n = e.ctx;
      if (t.pixelRatio <= this.dpr) {
        this.refresh();
        var i = e.dom.width,
          a = e.dom.height;
        this.eachLayer(function (h) {
          h.__builtin__
            ? n.drawImage(h.dom, 0, 0, i, a)
            : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
        });
      } else
        for (
          var o = {
              inHover: !1,
              viewWidth: this._width,
              viewHeight: this._height,
            },
            s = this.storage.getDisplayList(!0),
            l = 0,
            u = s.length;
          l < u;
          l++
        ) {
          var c = s[l];
          Au(n, c, o, l === u - 1);
        }
      return e.dom;
    }),
    (r.prototype.getWidth = function () {
      return this._width;
    }),
    (r.prototype.getHeight = function () {
      return this._height;
    }),
    r
  );
})();
const llt = slt
function ult(r) {
  r.registerPainter('canvas', llt)
}
var clt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getLegendIcon = function (e) {
      var n = new Ht(),
        i = Rn(
          'line',
          0,
          e.itemHeight / 2,
          e.itemWidth,
          0,
          e.lineStyle.stroke,
          !1,
        )
      n.add(i), i.setStyle(e.lineStyle)
      var a = this.getData().getVisual('symbol'),
        o = this.getData().getVisual('symbolRotate'),
        s = a === 'none' ? 'circle' : a,
        l = e.itemHeight * 0.8,
        u = Rn(
          s,
          (e.itemWidth - l) / 2,
          (e.itemHeight - l) / 2,
          l,
          l,
          e.itemStyle.fill,
        )
      n.add(u), u.setStyle(e.itemStyle)
      var c = e.iconRotate === 'inherit' ? o : e.iconRotate || 0
      return (
        (u.rotation = (c * Math.PI) / 180),
        u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]),
        s.indexOf('empty') > -1 &&
          ((u.style.stroke = u.style.fill),
          (u.style.fill = '#fff'),
          (u.style.lineWidth = 2)),
        n
      )
    }),
    (t.type = 'series.line'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = {
      z: 3,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: 'top',
      },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8,
      },
      lineStyle: {
        width: 2,
        type: 'solid',
      },
      emphasis: {
        scale: !0,
      },
      step: !1,
      smooth: !1,
      smoothMonotone: null,
      symbol: 'emptyCircle',
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      showAllSymbol: 'auto',
      connectNulls: !1,
      sampling: 'none',
      animationEasing: 'linear',
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: 'clone',
      },
      triggerLineEvent: !1,
    }),
    t
  )
})(rn)
const hlt = clt
function of(r, t) {
  var e = r.mapDimensionsAll('defaultedLabel'),
    n = e.length
  if (n === 1) {
    var i = nf(r, t, e[0])
    return i != null ? i + '' : null
  } else if (n) {
    for (var a = [], o = 0; o < e.length; o++) a.push(nf(r, t, e[o]))
    return a.join(' ')
  }
}
function xG(r, t) {
  var e = r.mapDimensionsAll('defaultedLabel')
  if (!at(t)) return t + ''
  for (var n = [], i = 0; i < e.length; i++) {
    var a = r.getDimensionIndex(e[i])
    a >= 0 && n.push(t[a])
  }
  return n.join(' ')
}
var flt = (function (r) {
  X(t, r)
  function t(e, n, i, a) {
    var o = r.call(this) || this
    return o.updateData(e, n, i, a), o
  }
  return (
    (t.prototype._createSymbol = function (e, n, i, a, o) {
      this.removeAll()
      var s = Rn(e, -1, -1, 2, 2, null, o)
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2,
      }),
        (s.drift = dlt),
        (this._symbolType = e),
        this.add(s)
    }),
    (t.prototype.stopSymbolAnimation = function (e) {
      this.childAt(0).stopAnimation(null, e)
    }),
    (t.prototype.getSymbolType = function () {
      return this._symbolType
    }),
    (t.prototype.getSymbolPath = function () {
      return this.childAt(0)
    }),
    (t.prototype.highlight = function () {
      Qo(this.childAt(0))
    }),
    (t.prototype.downplay = function () {
      ts(this.childAt(0))
    }),
    (t.prototype.setZ = function (e, n) {
      var i = this.childAt(0)
      ;(i.zlevel = e), (i.z = n)
    }),
    (t.prototype.setDraggable = function (e, n) {
      var i = this.childAt(0)
      ;(i.draggable = e), (i.cursor = !n && e ? 'move' : i.cursor)
    }),
    (t.prototype.updateData = function (e, n, i, a) {
      this.silent = !1
      var o = e.getItemVisual(n, 'symbol') || 'circle',
        s = e.hostModel,
        l = t.getSymbolSize(e, n),
        u = o !== this._symbolType,
        c = a && a.disableAnimation
      if (u) {
        var h = e.getItemVisual(n, 'symbolKeepAspect')
        this._createSymbol(o, e, n, l, h)
      } else {
        var f = this.childAt(0)
        f.silent = !1
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2,
        }
        c ? f.attr(d) : we(f, d, s, n), Ca(f)
      }
      if ((this._updateCommon(e, n, l, i, a), u)) {
        var f = this.childAt(0)
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: f.style.opacity,
            },
          }
          ;(f.scaleX = f.scaleY = 0), (f.style.opacity = 0), Je(f, d, s, n)
        }
      }
      c && this.childAt(0).stopAnimation('leave')
    }),
    (t.prototype._updateCommon = function (e, n, i, a, o) {
      var s = this.childAt(0),
        l = e.hostModel,
        u,
        c,
        h,
        f,
        d,
        p,
        g,
        v,
        m
      if (
        (a &&
          ((u = a.emphasisItemStyle),
          (c = a.blurItemStyle),
          (h = a.selectItemStyle),
          (f = a.focus),
          (d = a.blurScope),
          (g = a.labelStatesModels),
          (v = a.hoverScale),
          (m = a.cursorStyle),
          (p = a.emphasisDisabled)),
        !a || e.hasItemOption)
      ) {
        var y = a && a.itemModel ? a.itemModel : e.getItemModel(n),
          _ = y.getModel('emphasis')
        ;(u = _.getModel('itemStyle').getItemStyle()),
          (h = y.getModel(['select', 'itemStyle']).getItemStyle()),
          (c = y.getModel(['blur', 'itemStyle']).getItemStyle()),
          (f = _.get('focus')),
          (d = _.get('blurScope')),
          (p = _.get('disabled')),
          (g = Zn(y)),
          (v = _.getShallow('scale')),
          (m = y.getShallow('cursor'))
      }
      var x = e.getItemVisual(n, 'symbolRotate')
      s.attr('rotation', ((x || 0) * Math.PI) / 180 || 0)
      var A = ic(e.getItemVisual(n, 'symbolOffset'), i)
      A && ((s.x = A[0]), (s.y = A[1])), m && s.attr('cursor', m)
      var S = e.getItemVisual(n, 'style'),
        b = S.fill
      if (s instanceof yr) {
        var T = s.style
        s.useStyle(
          Q(
            {
              image: T.image,
              x: T.x,
              y: T.y,
              width: T.width,
              height: T.height,
            },
            S,
          ),
        )
      } else
        s.__isEmptyBrush ? s.useStyle(Q({}, S)) : s.useStyle(S),
          (s.style.decal = null),
          s.setColor(b, o && o.symbolInnerColor),
          (s.style.strokeNoScale = !0)
      var w = e.getItemVisual(n, 'liftZ'),
        M = this._z2
      w != null
        ? M == null && ((this._z2 = s.z2), (s.z2 += w))
        : M != null && ((s.z2 = M), (this._z2 = null))
      var C = o && o.useNameLabel
      mr(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: E,
        inheritColor: b,
        defaultOpacity: S.opacity,
      })
      function E(L) {
        return C ? e.getName(L) : of(e, L)
      }
      ;(this._sizeX = i[0] / 2), (this._sizeY = i[1] / 2)
      var D = s.ensureState('emphasis')
      ;(D.style = u),
        (s.ensureState('select').style = h),
        (s.ensureState('blur').style = c)
      var P =
        v == null || v === !0
          ? Math.max(1.1, 3 / this._sizeY)
          : isFinite(v) && v > 0
          ? +v
          : 1
      ;(D.scaleX = this._sizeX * P),
        (D.scaleY = this._sizeY * P),
        this.setSymbolScale(1),
        fn(this, f, d, p)
    }),
    (t.prototype.setSymbolScale = function (e) {
      this.scaleX = this.scaleY = e
    }),
    (t.prototype.fadeOut = function (e, n, i) {
      var a = this.childAt(0),
        o = Wt(this).dataIndex,
        s = i && i.animation
      if (((this.silent = a.silent = !0), i && i.fadeLabel)) {
        var l = a.getTextContent()
        l &&
          al(
            l,
            {
              style: {
                opacity: 0,
              },
            },
            n,
            {
              dataIndex: o,
              removeOpt: s,
              cb: function () {
                a.removeTextContent()
              },
            },
          )
      } else a.removeTextContent()
      al(
        a,
        {
          style: {
            opacity: 0,
          },
          scaleX: 0,
          scaleY: 0,
        },
        n,
        {
          dataIndex: o,
          cb: e,
          removeOpt: s,
        },
      )
    }),
    (t.getSymbolSize = function (e, n) {
      return Lf(e.getItemVisual(n, 'symbolSize'))
    }),
    t
  )
})(Ht)
function dlt(r, t) {
  this.parent.drift(r, t)
}
const Tv = flt
function eS(r, t, e, n) {
  return (
    t &&
    !isNaN(t[0]) &&
    !isNaN(t[1]) &&
    !(n.isIgnore && n.isIgnore(e)) &&
    !(n.clipShape && !n.clipShape.contain(t[0], t[1])) &&
    r.getItemVisual(e, 'symbol') !== 'none'
  )
}
function EI(r) {
  return (
    r != null &&
      !Ut(r) &&
      (r = {
        isIgnore: r,
      }),
    r || {}
  )
}
function DI(r) {
  var t = r.hostModel,
    e = t.getModel('emphasis')
  return {
    emphasisItemStyle: e.getModel('itemStyle').getItemStyle(),
    blurItemStyle: t.getModel(['blur', 'itemStyle']).getItemStyle(),
    selectItemStyle: t.getModel(['select', 'itemStyle']).getItemStyle(),
    focus: e.get('focus'),
    blurScope: e.get('blurScope'),
    emphasisDisabled: e.get('disabled'),
    hoverScale: e.get('scale'),
    labelStatesModels: Zn(t),
    cursorStyle: t.get('cursor'),
  }
}
var plt = (function () {
  function r(t) {
    ;(this.group = new Ht()), (this._SymbolCtor = t || Tv)
  }
  return (
    (r.prototype.updateData = function (t, e) {
      ;(this._progressiveEls = null), (e = EI(e))
      var n = this.group,
        i = t.hostModel,
        a = this._data,
        o = this._SymbolCtor,
        s = e.disableAnimation,
        l = DI(t),
        u = {
          disableAnimation: s,
        },
        c =
          e.getSymbolPoint ||
          function (h) {
            return t.getItemLayout(h)
          }
      a || n.removeAll(),
        t
          .diff(a)
          .add(function (h) {
            var f = c(h)
            if (eS(t, f, h, e)) {
              var d = new o(t, h, l, u)
              d.setPosition(f), t.setItemGraphicEl(h, d), n.add(d)
            }
          })
          .update(function (h, f) {
            var d = a.getItemGraphicEl(f),
              p = c(h)
            if (!eS(t, p, h, e)) {
              n.remove(d)
              return
            }
            var g = t.getItemVisual(h, 'symbol') || 'circle',
              v = d && d.getSymbolType && d.getSymbolType()
            if (!d || (v && v !== g))
              n.remove(d), (d = new o(t, h, l, u)), d.setPosition(p)
            else {
              d.updateData(t, h, l, u)
              var m = {
                x: p[0],
                y: p[1],
              }
              s ? d.attr(m) : we(d, m, i)
            }
            n.add(d), t.setItemGraphicEl(h, d)
          })
          .remove(function (h) {
            var f = a.getItemGraphicEl(h)
            f &&
              f.fadeOut(function () {
                n.remove(f)
              }, i)
          })
          .execute(),
        (this._getSymbolPoint = c),
        (this._data = t)
    }),
    (r.prototype.updateLayout = function () {
      var t = this,
        e = this._data
      e &&
        e.eachItemGraphicEl(function (n, i) {
          var a = t._getSymbolPoint(i)
          n.setPosition(a), n.markRedraw()
        })
    }),
    (r.prototype.incrementalPrepareUpdate = function (t) {
      ;(this._seriesScope = DI(t)), (this._data = null), this.group.removeAll()
    }),
    (r.prototype.incrementalUpdate = function (t, e, n) {
      ;(this._progressiveEls = []), (n = EI(n))
      function i(l) {
        l.isGroup ||
          ((l.incremental = !0), (l.ensureState('emphasis').hoverLayer = !0))
      }
      for (var a = t.start; a < t.end; a++) {
        var o = e.getItemLayout(a)
        if (eS(e, o, a, n)) {
          var s = new this._SymbolCtor(e, a, this._seriesScope)
          s.traverse(i),
            s.setPosition(o),
            this.group.add(s),
            e.setItemGraphicEl(a, s),
            this._progressiveEls.push(s)
        }
      }
    }),
    (r.prototype.eachRendered = function (t) {
      vl(this._progressiveEls || this.group, t)
    }),
    (r.prototype.remove = function (t) {
      var e = this.group,
        n = this._data
      n && t
        ? n.eachItemGraphicEl(function (i) {
            i.fadeOut(function () {
              e.remove(i)
            }, n.hostModel)
          })
        : e.removeAll()
    }),
    r
  )
})()
const Cv = plt
function SG(r, t, e) {
  var n = r.getBaseAxis(),
    i = r.getOtherAxis(n),
    a = vlt(i, e),
    o = n.dim,
    s = i.dim,
    l = t.mapDimension(s),
    u = t.mapDimension(o),
    c = s === 'x' || s === 'radius' ? 1 : 0,
    h = st(r.dimensions, function (p) {
      return t.mapDimension(p)
    }),
    f = !1,
    d = t.getCalculationInfo('stackResultDimension')
  return (
    sl(t, h[0]) && ((f = !0), (h[0] = d)),
    sl(t, h[1]) && ((f = !0), (h[1] = d)),
    {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: s,
      baseAxisDim: o,
      stacked: !!f,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: t.getCalculationInfo('stackedOverDimension'),
    }
  )
}
function vlt(r, t) {
  var e = 0,
    n = r.scale.getExtent()
  return (
    t === 'start'
      ? (e = n[0])
      : t === 'end'
      ? (e = n[1])
      : be(t) && !isNaN(t)
      ? (e = t)
      : n[0] > 0
      ? (e = n[0])
      : n[1] < 0 && (e = n[1]),
    e
  )
}
function AG(r, t, e, n) {
  var i = NaN
  r.stacked && (i = e.get(e.getCalculationInfo('stackedOverDimension'), n)),
    isNaN(i) && (i = r.valueStart)
  var a = r.baseDataOffset,
    o = []
  return (o[a] = e.get(r.baseDim, n)), (o[1 - a] = i), t.dataToPoint(o)
}
function glt(r, t) {
  var e = []
  return (
    t
      .diff(r)
      .add(function (n) {
        e.push({
          cmd: '+',
          idx: n,
        })
      })
      .update(function (n, i) {
        e.push({
          cmd: '=',
          idx: i,
          idx1: n,
        })
      })
      .remove(function (n) {
        e.push({
          cmd: '-',
          idx: n,
        })
      })
      .execute(),
    e
  )
}
function mlt(r, t, e, n, i, a, o, s) {
  for (
    var l = glt(r, t),
      u = [],
      c = [],
      h = [],
      f = [],
      d = [],
      p = [],
      g = [],
      v = SG(i, t, o),
      m = r.getLayout('points') || [],
      y = t.getLayout('points') || [],
      _ = 0;
    _ < l.length;
    _++
  ) {
    var x = l[_],
      A = !0,
      S = void 0,
      b = void 0
    switch (x.cmd) {
      case '=':
        ;(S = x.idx * 2), (b = x.idx1 * 2)
        var T = m[S],
          w = m[S + 1],
          M = y[b],
          C = y[b + 1]
        ;(isNaN(T) || isNaN(w)) && ((T = M), (w = C)),
          u.push(T, w),
          c.push(M, C),
          h.push(e[S], e[S + 1]),
          f.push(n[b], n[b + 1]),
          g.push(t.getRawIndex(x.idx1))
        break
      case '+':
        var E = x.idx,
          D = v.dataDimsForPoint,
          P = i.dataToPoint([t.get(D[0], E), t.get(D[1], E)])
        ;(b = E * 2), u.push(P[0], P[1]), c.push(y[b], y[b + 1])
        var L = AG(v, i, t, E)
        h.push(L[0], L[1]), f.push(n[b], n[b + 1]), g.push(t.getRawIndex(E))
        break
      case '-':
        A = !1
    }
    A && (d.push(x), p.push(p.length))
  }
  p.sort(function (Z, ft) {
    return g[Z] - g[ft]
  })
  for (
    var I = u.length, F = eo(I), k = eo(I), V = eo(I), H = eo(I), Y = [], _ = 0;
    _ < p.length;
    _++
  ) {
    var K = p[_],
      ut = _ * 2,
      W = K * 2
    ;(F[ut] = u[W]),
      (F[ut + 1] = u[W + 1]),
      (k[ut] = c[W]),
      (k[ut + 1] = c[W + 1]),
      (V[ut] = h[W]),
      (V[ut + 1] = h[W + 1]),
      (H[ut] = f[W]),
      (H[ut + 1] = f[W + 1]),
      (Y[_] = d[K])
  }
  return {
    current: F,
    next: k,
    stackedOnCurrent: V,
    stackedOnNext: H,
    status: Y,
  }
}
var As = Math.min,
  bs = Math.max
function Bu(r, t) {
  return isNaN(r) || isNaN(t)
}
function Lw(r, t, e, n, i, a, o, s, l) {
  for (var u, c, h, f, d, p, g = e, v = 0; v < n; v++) {
    var m = t[g * 2],
      y = t[g * 2 + 1]
    if (g >= i || g < 0) break
    if (Bu(m, y)) {
      if (l) {
        g += a
        continue
      }
      break
    }
    if (g === e) r[a > 0 ? 'moveTo' : 'lineTo'](m, y), (h = m), (f = y)
    else {
      var _ = m - u,
        x = y - c
      if (_ * _ + x * x < 0.5) {
        g += a
        continue
      }
      if (o > 0) {
        for (
          var A = g + a, S = t[A * 2], b = t[A * 2 + 1];
          S === m && b === y && v < n;

        )
          v++,
            (A += a),
            (g += a),
            (S = t[A * 2]),
            (b = t[A * 2 + 1]),
            (m = t[g * 2]),
            (y = t[g * 2 + 1]),
            (_ = m - u),
            (x = y - c)
        var T = v + 1
        if (l)
          for (; Bu(S, b) && T < n; )
            T++, (A += a), (S = t[A * 2]), (b = t[A * 2 + 1])
        var w = 0.5,
          M = 0,
          C = 0,
          E = void 0,
          D = void 0
        if (T >= n || Bu(S, b)) (d = m), (p = y)
        else {
          ;(M = S - u), (C = b - c)
          var P = m - u,
            L = S - m,
            I = y - c,
            F = b - y,
            k = void 0,
            V = void 0
          if (s === 'x') {
            ;(k = Math.abs(P)), (V = Math.abs(L))
            var H = M > 0 ? 1 : -1
            ;(d = m - H * k * o), (p = y), (E = m + H * V * o), (D = y)
          } else if (s === 'y') {
            ;(k = Math.abs(I)), (V = Math.abs(F))
            var Y = C > 0 ? 1 : -1
            ;(d = m), (p = y - Y * k * o), (E = m), (D = y + Y * V * o)
          } else
            (k = Math.sqrt(P * P + I * I)),
              (V = Math.sqrt(L * L + F * F)),
              (w = V / (V + k)),
              (d = m - M * o * (1 - w)),
              (p = y - C * o * (1 - w)),
              (E = m + M * o * w),
              (D = y + C * o * w),
              (E = As(E, bs(S, m))),
              (D = As(D, bs(b, y))),
              (E = bs(E, As(S, m))),
              (D = bs(D, As(b, y))),
              (M = E - m),
              (C = D - y),
              (d = m - (M * k) / V),
              (p = y - (C * k) / V),
              (d = As(d, bs(u, m))),
              (p = As(p, bs(c, y))),
              (d = bs(d, As(u, m))),
              (p = bs(p, As(c, y))),
              (M = m - d),
              (C = y - p),
              (E = m + (M * V) / k),
              (D = y + (C * V) / k)
        }
        r.bezierCurveTo(h, f, d, p, m, y), (h = E), (f = D)
      } else r.lineTo(m, y)
    }
    ;(u = m), (c = y), (g += a)
  }
  return v
}
var bG = (function () {
    function r() {
      ;(this.smooth = 0), (this.smoothConstraint = !0)
    }
    return r
  })(),
  ylt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'ec-polyline'), n
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new bG()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = 0,
          o = i.length / 2
        if (n.connectNulls) {
          for (; o > 0 && Bu(i[o * 2 - 2], i[o * 2 - 1]); o--);
          for (; a < o && Bu(i[a * 2], i[a * 2 + 1]); a++);
        }
        for (; a < o; )
          a +=
            Lw(e, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1
      }),
      (t.prototype.getPointOn = function (e, n) {
        this.path ||
          (this.createPathProxy(), this.buildPath(this.path, this.shape))
        for (
          var i = this.path,
            a = i.data,
            o = vo.CMD,
            s,
            l,
            u = n === 'x',
            c = [],
            h = 0;
          h < a.length;

        ) {
          var f = a[h++],
            d = void 0,
            p = void 0,
            g = void 0,
            v = void 0,
            m = void 0,
            y = void 0,
            _ = void 0
          switch (f) {
            case o.M:
              ;(s = a[h++]), (l = a[h++])
              break
            case o.L:
              if (
                ((d = a[h++]),
                (p = a[h++]),
                (_ = u ? (e - s) / (d - s) : (e - l) / (p - l)),
                _ <= 1 && _ >= 0)
              ) {
                var x = u ? (p - l) * _ + l : (d - s) * _ + s
                return u ? [e, x] : [x, e]
              }
              ;(s = d), (l = p)
              break
            case o.C:
              ;(d = a[h++]),
                (p = a[h++]),
                (g = a[h++]),
                (v = a[h++]),
                (m = a[h++]),
                (y = a[h++])
              var A = u ? Fy(s, d, g, m, e, c) : Fy(l, p, v, y, e, c)
              if (A > 0)
                for (var S = 0; S < A; S++) {
                  var b = c[S]
                  if (b <= 1 && b >= 0) {
                    var x = u ? Wn(l, p, v, y, b) : Wn(s, d, g, m, b)
                    return u ? [e, x] : [x, e]
                  }
                }
              ;(s = m), (l = y)
              break
          }
        }
      }),
      t
    )
  })(oe),
  _lt = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return t
  })(bG),
  wG = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'ec-polygon'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new _lt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = n.stackedOnPoints,
          o = 0,
          s = i.length / 2,
          l = n.smoothMonotone
        if (n.connectNulls) {
          for (; s > 0 && Bu(i[s * 2 - 2], i[s * 2 - 1]); s--);
          for (; o < s && Bu(i[o * 2], i[o * 2 + 1]); o++);
        }
        for (; o < s; ) {
          var u = Lw(e, i, o, s, s, 1, n.smooth, l, n.connectNulls)
          Lw(e, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls),
            (o += u + 1),
            e.closePath()
        }
      }),
      t
    )
  })(oe)
function MG(r, t, e, n, i) {
  var a = r.getArea(),
    o = a.x,
    s = a.y,
    l = a.width,
    u = a.height,
    c = e.get(['lineStyle', 'width']) || 2
  ;(o -= c / 2),
    (s -= c / 2),
    (l += c),
    (u += c),
    (l = Math.ceil(l)),
    o !== Math.floor(o) && ((o = Math.floor(o)), l++)
  var h = new ge({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u,
    },
  })
  if (t) {
    var f = r.getBaseAxis(),
      d = f.isHorizontal(),
      p = f.inverse
    d
      ? (p && (h.shape.x += l), (h.shape.width = 0))
      : (p || (h.shape.y += u), (h.shape.height = 0))
    var g = Nt(i)
      ? function (v) {
          i(v, h)
        }
      : null
    Je(
      h,
      {
        shape: {
          width: l,
          height: u,
          x: o,
          y: s,
        },
      },
      e,
      null,
      n,
      g,
    )
  }
  return h
}
function TG(r, t, e) {
  var n = r.getArea(),
    i = mn(n.r0, 1),
    a = mn(n.r, 1),
    o = new oi({
      shape: {
        cx: mn(r.cx, 1),
        cy: mn(r.cy, 1),
        r0: i,
        r: a,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise,
      },
    })
  if (t) {
    var s = r.getBaseAxis().dim === 'angle'
    s ? (o.shape.endAngle = n.startAngle) : (o.shape.r = i),
      Je(
        o,
        {
          shape: {
            endAngle: n.endAngle,
            r: a,
          },
        },
        e,
      )
  }
  return o
}
function Ev(r, t, e, n, i) {
  if (r) {
    if (r.type === 'polar') return TG(r, t, e)
    if (r.type === 'cartesian2d') return MG(r, t, e, n, i)
  } else return null
  return null
}
function oc(r, t) {
  return r.type === t
}
function LI(r, t) {
  if (r.length === t.length) {
    for (var e = 0; e < r.length; e++) if (r[e] !== t[e]) return
    return !0
  }
}
function PI(r) {
  for (
    var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0;
    a < r.length;

  ) {
    var o = r[a++],
      s = r[a++]
    isNaN(o) || ((t = Math.min(o, t)), (n = Math.max(o, n))),
      isNaN(s) || ((e = Math.min(s, e)), (i = Math.max(s, i)))
  }
  return [
    [t, e],
    [n, i],
  ]
}
function RI(r, t) {
  var e = PI(r),
    n = e[0],
    i = e[1],
    a = PI(t),
    o = a[0],
    s = a[1]
  return Math.max(
    Math.abs(n[0] - o[0]),
    Math.abs(n[1] - o[1]),
    Math.abs(i[0] - s[0]),
    Math.abs(i[1] - s[1]),
  )
}
function II(r) {
  return be(r) ? r : r ? 0.5 : 0
}
function xlt(r, t, e) {
  if (!e.valueDim) return []
  for (var n = t.count(), i = eo(n * 2), a = 0; a < n; a++) {
    var o = AG(e, r, t, a)
    ;(i[a * 2] = o[0]), (i[a * 2 + 1] = o[1])
  }
  return i
}
function ws(r, t, e, n) {
  var i = t.getBaseAxis(),
    a = i.dim === 'x' || i.dim === 'radius' ? 0 : 1,
    o = [],
    s = 0,
    l = [],
    u = [],
    c = [],
    h = []
  if (n) {
    for (s = 0; s < r.length; s += 2)
      !isNaN(r[s]) && !isNaN(r[s + 1]) && h.push(r[s], r[s + 1])
    r = h
  }
  for (s = 0; s < r.length - 2; s += 2)
    switch (
      ((c[0] = r[s + 2]),
      (c[1] = r[s + 3]),
      (u[0] = r[s]),
      (u[1] = r[s + 1]),
      o.push(u[0], u[1]),
      e)
    ) {
      case 'end':
        ;(l[a] = c[a]), (l[1 - a] = u[1 - a]), o.push(l[0], l[1])
        break
      case 'middle':
        var f = (u[a] + c[a]) / 2,
          d = []
        ;(l[a] = d[a] = f),
          (l[1 - a] = u[1 - a]),
          (d[1 - a] = c[1 - a]),
          o.push(l[0], l[1]),
          o.push(d[0], d[1])
        break
      default:
        ;(l[a] = u[a]), (l[1 - a] = c[1 - a]), o.push(l[0], l[1])
    }
  return o.push(r[s++], r[s++]), o
}
function Slt(r, t) {
  var e = [],
    n = r.length,
    i,
    a
  function o(c, h, f) {
    var d = c.coord,
      p = (f - d) / (h.coord - d),
      g = DQ(p, [c.color, h.color])
    return {
      coord: f,
      color: g,
    }
  }
  for (var s = 0; s < n; s++) {
    var l = r[s],
      u = l.coord
    if (u < 0) i = l
    else if (u > t) {
      a ? e.push(o(a, l, t)) : i && e.push(o(i, l, 0), o(i, l, t))
      break
    } else i && (e.push(o(i, l, 0)), (i = null)), e.push(l), (a = l)
  }
  return e
}
function Alt(r, t, e) {
  var n = r.getVisual('visualMeta')
  if (!(!n || !n.length || !r.count()) && t.type === 'cartesian2d') {
    for (var i, a, o = n.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(n[o].dimension)
      if (((i = s && s.coordDim), i === 'x' || i === 'y')) {
        a = n[o]
        break
      }
    }
    if (a) {
      var l = t.getAxis(i),
        u = st(a.stops, function (_) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(_.value)),
            color: _.color,
          }
        }),
        c = u.length,
        h = a.outerColors.slice()
      c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse())
      var f = Slt(u, i === 'x' ? e.getWidth() : e.getHeight()),
        d = f.length
      if (!d && c)
        return u[0].coord < 0
          ? h[1]
            ? h[1]
            : u[c - 1].color
          : h[0]
          ? h[0]
          : u[0].color
      var p = 10,
        g = f[0].coord - p,
        v = f[d - 1].coord + p,
        m = v - g
      if (m < 0.001) return 'transparent'
      R(f, function (_) {
        _.offset = (_.coord - g) / m
      }),
        f.push({
          offset: d ? f[d - 1].offset : 0.5,
          color: h[1] || 'transparent',
        }),
        f.unshift({
          offset: d ? f[0].offset : 0.5,
          color: h[0] || 'transparent',
        })
      var y = new He(0, 0, 0, 0, f, !0)
      return (y[i] = g), (y[i + '2'] = v), y
    }
  }
}
function blt(r, t, e) {
  var n = r.get('showAllSymbol'),
    i = n === 'auto'
  if (!(n && !i)) {
    var a = e.getAxesByScale('ordinal')[0]
    if (a && !(i && wlt(a, t))) {
      var o = t.mapDimension(a.dim),
        s = {}
      return (
        R(a.getViewLabels(), function (l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue)
          s[u] = 1
        }),
        function (l) {
          return !s.hasOwnProperty(t.get(o, l))
        }
      )
    }
  }
}
function wlt(r, t) {
  var e = r.getExtent(),
    n = Math.abs(e[1] - e[0]) / r.scale.count()
  isNaN(n) && (n = 0)
  for (
    var i = t.count(), a = Math.max(1, Math.round(i / 5)), o = 0;
    o < i;
    o += a
  )
    if (Tv.getSymbolSize(t, o)[r.isHorizontal() ? 1 : 0] * 1.5 > n) return !1
  return !0
}
function Mlt(r, t) {
  return isNaN(r) || isNaN(t)
}
function Tlt(r) {
  for (var t = r.length / 2; t > 0 && Mlt(r[t * 2 - 2], r[t * 2 - 1]); t--);
  return t - 1
}
function OI(r, t) {
  return [r[t * 2], r[t * 2 + 1]]
}
function Clt(r, t, e) {
  for (
    var n = r.length / 2, i = e === 'x' ? 0 : 1, a, o, s = 0, l = -1, u = 0;
    u < n;
    u++
  )
    if (((o = r[u * 2 + i]), !(isNaN(o) || isNaN(r[u * 2 + 1 - i])))) {
      if (u === 0) {
        a = o
        continue
      }
      if ((a <= t && o >= t) || (a >= t && o <= t)) {
        l = u
        break
      }
      ;(s = u), (a = o)
    }
  return {
    range: [s, l],
    t: (t - a) / (o - a),
  }
}
function CG(r) {
  if (r.get(['endLabel', 'show'])) return !0
  for (var t = 0; t < Hr.length; t++)
    if (r.get([Hr[t], 'endLabel', 'show'])) return !0
  return !1
}
function nS(r, t, e, n) {
  if (oc(t, 'cartesian2d')) {
    var i = n.getModel('endLabel'),
      a = i.get('valueAnimation'),
      o = n.getData(),
      s = {
        lastFrameIndex: 0,
      },
      l = CG(n)
        ? function (d, p) {
            r._endLabelOnDuring(d, p, o, s, a, i, t)
          }
        : null,
      u = t.getBaseAxis().isHorizontal(),
      c = MG(
        t,
        e,
        n,
        function () {
          var d = r._endLabel
          d &&
            e &&
            s.originalX != null &&
            d.attr({
              x: s.originalX,
              y: s.originalY,
            })
        },
        l,
      )
    if (!n.get('clip', !0)) {
      var h = c.shape,
        f = Math.max(h.width, h.height)
      u ? ((h.y -= f), (h.height += f * 2)) : ((h.x -= f), (h.width += f * 2))
    }
    return l && l(1, c), c
  } else return TG(t, e, n)
}
function Elt(r, t) {
  var e = t.getBaseAxis(),
    n = e.isHorizontal(),
    i = e.inverse,
    a = n ? (i ? 'right' : 'left') : 'center',
    o = n ? 'middle' : i ? 'top' : 'bottom'
  return {
    normal: {
      align: r.get('align') || a,
      verticalAlign: r.get('verticalAlign') || o,
    },
  }
}
var Dlt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.init = function () {
      var e = new Ht(),
        n = new Cv()
      this.group.add(n.group), (this._symbolDraw = n), (this._lineGroup = e)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = this,
        o = e.coordinateSystem,
        s = this.group,
        l = e.getData(),
        u = e.getModel('lineStyle'),
        c = e.getModel('areaStyle'),
        h = l.getLayout('points') || [],
        f = o.type === 'polar',
        d = this._coordSys,
        p = this._symbolDraw,
        g = this._polyline,
        v = this._polygon,
        m = this._lineGroup,
        y = !n.ssr && e.get('animation'),
        _ = !c.isEmpty(),
        x = c.get('origin'),
        A = SG(o, l, x),
        S = _ && xlt(o, l, A),
        b = e.get('showSymbol'),
        T = e.get('connectNulls'),
        w = b && !f && blt(e, l, o),
        M = this._data
      M &&
        M.eachItemGraphicEl(function (ft, lt) {
          ft.__temp && (s.remove(ft), M.setItemGraphicEl(lt, null))
        }),
        b || p.remove(),
        s.add(m)
      var C = f ? !1 : e.get('step'),
        E
      o &&
        o.getArea &&
        e.get('clip', !0) &&
        ((E = o.getArea()),
        E.width != null
          ? ((E.x -= 0.1), (E.y -= 0.1), (E.width += 0.2), (E.height += 0.2))
          : E.r0 && ((E.r0 -= 0.5), (E.r += 0.5))),
        (this._clipShapeForSymbol = E)
      var D = Alt(l, o, i) || l.getVisual('style')[l.getVisual('drawType')]
      if (!(g && d.type === o.type && C === this._step))
        b &&
          p.updateData(l, {
            isIgnore: w,
            clipShape: E,
            disableAnimation: !0,
            getSymbolPoint: function (ft) {
              return [h[ft * 2], h[ft * 2 + 1]]
            },
          }),
          y && this._initSymbolLabelAnimation(l, o, E),
          C && ((h = ws(h, o, C, T)), S && (S = ws(S, o, C, T))),
          (g = this._newPolyline(h)),
          _
            ? (v = this._newPolygon(h, S))
            : v && (m.remove(v), (v = this._polygon = null)),
          f || this._initOrUpdateEndLabel(e, o, Zu(D)),
          m.setClipPath(nS(this, o, !0, e))
      else {
        _ && !v
          ? (v = this._newPolygon(h, S))
          : v && !_ && (m.remove(v), (v = this._polygon = null)),
          f || this._initOrUpdateEndLabel(e, o, Zu(D))
        var P = m.getClipPath()
        if (P) {
          var L = nS(this, o, !1, e)
          Je(
            P,
            {
              shape: L.shape,
            },
            e,
          )
        } else m.setClipPath(nS(this, o, !0, e))
        b &&
          p.updateData(l, {
            isIgnore: w,
            clipShape: E,
            disableAnimation: !0,
            getSymbolPoint: function (ft) {
              return [h[ft * 2], h[ft * 2 + 1]]
            },
          }),
          (!LI(this._stackedOnPoints, S) || !LI(this._points, h)) &&
            (y
              ? this._doUpdateAnimation(l, S, o, i, C, x, T)
              : (C && ((h = ws(h, o, C, T)), S && (S = ws(S, o, C, T))),
                g.setShape({
                  points: h,
                }),
                v &&
                  v.setShape({
                    points: h,
                    stackedOnPoints: S,
                  })))
      }
      var I = e.getModel('emphasis'),
        F = I.get('focus'),
        k = I.get('blurScope'),
        V = I.get('disabled')
      if (
        (g.useStyle(
          zt(u.getLineStyle(), {
            fill: 'none',
            stroke: D,
            lineJoin: 'bevel',
          }),
        ),
        gr(g, e, 'lineStyle'),
        g.style.lineWidth > 0 &&
          e.get(['emphasis', 'lineStyle', 'width']) === 'bolder')
      ) {
        var H = g.getState('emphasis').style
        H.lineWidth = +g.style.lineWidth + 1
      }
      ;(Wt(g).seriesIndex = e.seriesIndex), fn(g, F, k, V)
      var Y = II(e.get('smooth')),
        K = e.get('smoothMonotone')
      if (
        (g.setShape({
          smooth: Y,
          smoothMonotone: K,
          connectNulls: T,
        }),
        v)
      ) {
        var ut = l.getCalculationInfo('stackedOnSeries'),
          W = 0
        v.useStyle(
          zt(c.getAreaStyle(), {
            fill: D,
            opacity: 0.7,
            lineJoin: 'bevel',
            decal: l.getVisual('style').decal,
          }),
        ),
          ut && (W = II(ut.get('smooth'))),
          v.setShape({
            smooth: Y,
            stackedOnSmooth: W,
            smoothMonotone: K,
            connectNulls: T,
          }),
          gr(v, e, 'areaStyle'),
          (Wt(v).seriesIndex = e.seriesIndex),
          fn(v, F, k, V)
      }
      var Z = function (ft) {
        a._changePolyState(ft)
      }
      l.eachItemGraphicEl(function (ft) {
        ft && (ft.onHoverStateChange = Z)
      }),
        (this._polyline.onHoverStateChange = Z),
        (this._data = l),
        (this._coordSys = o),
        (this._stackedOnPoints = S),
        (this._points = h),
        (this._step = C),
        (this._valueOrigin = x),
        e.get('triggerLineEvent') &&
          (this.packEventData(e, g), v && this.packEventData(e, v))
    }),
    (t.prototype.packEventData = function (e, n) {
      Wt(n).eventData = {
        componentType: 'series',
        componentSubType: 'line',
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: 'line',
      }
    }),
    (t.prototype.highlight = function (e, n, i, a) {
      var o = e.getData(),
        s = Yu(o, a)
      if (
        (this._changePolyState('emphasis'),
        !(s instanceof Array) && s != null && s >= 0)
      ) {
        var l = o.getLayout('points'),
          u = o.getItemGraphicEl(s)
        if (!u) {
          var c = l[s * 2],
            h = l[s * 2 + 1]
          if (
            isNaN(c) ||
            isNaN(h) ||
            (this._clipShapeForSymbol &&
              !this._clipShapeForSymbol.contain(c, h))
          )
            return
          var f = e.get('zlevel') || 0,
            d = e.get('z') || 0
          ;(u = new Tv(o, s)), (u.x = c), (u.y = h), u.setZ(f, d)
          var p = u.getSymbolPath().getTextContent()
          p && ((p.zlevel = f), (p.z = d), (p.z2 = this._polyline.z2 + 1)),
            (u.__temp = !0),
            o.setItemGraphicEl(s, u),
            u.stopSymbolAnimation(!0),
            this.group.add(u)
        }
        u.highlight()
      } else Ze.prototype.highlight.call(this, e, n, i, a)
    }),
    (t.prototype.downplay = function (e, n, i, a) {
      var o = e.getData(),
        s = Yu(o, a)
      if ((this._changePolyState('normal'), s != null && s >= 0)) {
        var l = o.getItemGraphicEl(s)
        l &&
          (l.__temp
            ? (o.setItemGraphicEl(s, null), this.group.remove(l))
            : l.downplay())
      } else Ze.prototype.downplay.call(this, e, n, i, a)
    }),
    (t.prototype._changePolyState = function (e) {
      var n = this._polygon
      Xy(this._polyline, e), n && Xy(n, e)
    }),
    (t.prototype._newPolyline = function (e) {
      var n = this._polyline
      return (
        n && this._lineGroup.remove(n),
        (n = new ylt({
          shape: {
            points: e,
          },
          segmentIgnoreThreshold: 2,
          z2: 10,
        })),
        this._lineGroup.add(n),
        (this._polyline = n),
        n
      )
    }),
    (t.prototype._newPolygon = function (e, n) {
      var i = this._polygon
      return (
        i && this._lineGroup.remove(i),
        (i = new wG({
          shape: {
            points: e,
            stackedOnPoints: n,
          },
          segmentIgnoreThreshold: 2,
        })),
        this._lineGroup.add(i),
        (this._polygon = i),
        i
      )
    }),
    (t.prototype._initSymbolLabelAnimation = function (e, n, i) {
      var a,
        o,
        s = n.getBaseAxis(),
        l = s.inverse
      n.type === 'cartesian2d'
        ? ((a = s.isHorizontal()), (o = !1))
        : n.type === 'polar' && ((a = s.dim === 'angle'), (o = !0))
      var u = e.hostModel,
        c = u.get('animationDuration')
      Nt(c) && (c = c(null))
      var h = u.get('animationDelay') || 0,
        f = Nt(h) ? h(null) : h
      e.eachItemGraphicEl(function (d, p) {
        var g = d
        if (g) {
          var v = [d.x, d.y],
            m = void 0,
            y = void 0,
            _ = void 0
          if (i)
            if (o) {
              var x = i,
                A = n.pointToCoord(v)
              a
                ? ((m = x.startAngle),
                  (y = x.endAngle),
                  (_ = (-A[1] / 180) * Math.PI))
                : ((m = x.r0), (y = x.r), (_ = A[0]))
            } else {
              var S = i
              a
                ? ((m = S.x), (y = S.x + S.width), (_ = d.x))
                : ((m = S.y + S.height), (y = S.y), (_ = d.y))
            }
          var b = y === m ? 0 : (_ - m) / (y - m)
          l && (b = 1 - b)
          var T = Nt(h) ? h(p) : c * b + f,
            w = g.getSymbolPath(),
            M = w.getTextContent()
          g.attr({
            scaleX: 0,
            scaleY: 0,
          }),
            g.animateTo(
              {
                scaleX: 1,
                scaleY: 1,
              },
              {
                duration: 200,
                setToFinal: !0,
                delay: T,
              },
            ),
            M &&
              M.animateFrom(
                {
                  style: {
                    opacity: 0,
                  },
                },
                {
                  duration: 300,
                  delay: T,
                },
              ),
            (w.disableLabelAnimation = !0)
        }
      })
    }),
    (t.prototype._initOrUpdateEndLabel = function (e, n, i) {
      var a = e.getModel('endLabel')
      if (CG(e)) {
        var o = e.getData(),
          s = this._polyline,
          l = o.getLayout('points')
        if (!l) {
          s.removeTextContent(), (this._endLabel = null)
          return
        }
        var u = this._endLabel
        u ||
          ((u = this._endLabel =
            new Ae({
              z2: 200,
            })),
          (u.ignoreClip = !0),
          s.setTextContent(this._endLabel),
          (s.disableLabelAnimation = !0))
        var c = Tlt(l)
        c >= 0 &&
          (mr(
            s,
            Zn(e, 'endLabel'),
            {
              inheritColor: i,
              labelFetcher: e,
              labelDataIndex: c,
              defaultText: function (h, f, d) {
                return d != null ? xG(o, d) : of(o, h)
              },
              enableTextSetter: !0,
            },
            Elt(a, n),
          ),
          (s.textConfig.position = null))
      } else
        this._endLabel &&
          (this._polyline.removeTextContent(), (this._endLabel = null))
    }),
    (t.prototype._endLabelOnDuring = function (e, n, i, a, o, s, l) {
      var u = this._endLabel,
        c = this._polyline
      if (u) {
        e < 1 &&
          a.originalX == null &&
          ((a.originalX = u.x), (a.originalY = u.y))
        var h = i.getLayout('points'),
          f = i.hostModel,
          d = f.get('connectNulls'),
          p = s.get('precision'),
          g = s.get('distance') || 0,
          v = l.getBaseAxis(),
          m = v.isHorizontal(),
          y = v.inverse,
          _ = n.shape,
          x = y ? (m ? _.x : _.y + _.height) : m ? _.x + _.width : _.y,
          A = (m ? g : 0) * (y ? -1 : 1),
          S = (m ? 0 : -g) * (y ? -1 : 1),
          b = m ? 'x' : 'y',
          T = Clt(h, x, b),
          w = T.range,
          M = w[1] - w[0],
          C = void 0
        if (M >= 1) {
          if (M > 1 && !d) {
            var E = OI(h, w[0])
            u.attr({
              x: E[0] + A,
              y: E[1] + S,
            }),
              o && (C = f.getRawValue(w[0]))
          } else {
            var E = c.getPointOn(x, b)
            E &&
              u.attr({
                x: E[0] + A,
                y: E[1] + S,
              })
            var D = f.getRawValue(w[0]),
              P = f.getRawValue(w[1])
            o && (C = Yz(i, p, D, P, T.t))
          }
          a.lastFrameIndex = w[0]
        } else {
          var L = e === 1 || a.lastFrameIndex > 0 ? w[0] : 0,
            E = OI(h, L)
          o && (C = f.getRawValue(L)),
            u.attr({
              x: E[0] + A,
              y: E[1] + S,
            })
        }
        if (o) {
          var I = Af(u)
          typeof I.setLabelText == 'function' && I.setLabelText(C)
        }
      }
    }),
    (t.prototype._doUpdateAnimation = function (e, n, i, a, o, s, l) {
      var u = this._polyline,
        c = this._polygon,
        h = e.hostModel,
        f = mlt(
          this._data,
          e,
          this._stackedOnPoints,
          n,
          this._coordSys,
          i,
          this._valueOrigin,
        ),
        d = f.current,
        p = f.stackedOnCurrent,
        g = f.next,
        v = f.stackedOnNext
      if (
        (o &&
          ((d = ws(f.current, i, o, l)),
          (p = ws(f.stackedOnCurrent, i, o, l)),
          (g = ws(f.next, i, o, l)),
          (v = ws(f.stackedOnNext, i, o, l))),
        RI(d, g) > 3e3 || (c && RI(p, v) > 3e3))
      ) {
        u.stopAnimation(),
          u.setShape({
            points: g,
          }),
          c &&
            (c.stopAnimation(),
            c.setShape({
              points: g,
              stackedOnPoints: v,
            }))
        return
      }
      ;(u.shape.__points = f.current), (u.shape.points = d)
      var m = {
        shape: {
          points: g,
        },
      }
      f.current !== d && (m.shape.__points = f.next),
        u.stopAnimation(),
        we(u, m, h),
        c &&
          (c.setShape({
            points: d,
            stackedOnPoints: p,
          }),
          c.stopAnimation(),
          we(
            c,
            {
              shape: {
                stackedOnPoints: v,
              },
            },
            h,
          ),
          u.shape.points !== c.shape.points &&
            (c.shape.points = u.shape.points))
      for (var y = [], _ = f.status, x = 0; x < _.length; x++) {
        var A = _[x].cmd
        if (A === '=') {
          var S = e.getItemGraphicEl(_[x].idx1)
          S &&
            y.push({
              el: S,
              ptIdx: x,
            })
        }
      }
      u.animators &&
        u.animators.length &&
        u.animators[0].during(function () {
          c && c.dirtyShape()
          for (var b = u.shape.__points, T = 0; T < y.length; T++) {
            var w = y[T].el,
              M = y[T].ptIdx * 2
            ;(w.x = b[M]), (w.y = b[M + 1]), w.markRedraw()
          }
        })
    }),
    (t.prototype.remove = function (e) {
      var n = this.group,
        i = this._data
      this._lineGroup.removeAll(),
        this._symbolDraw.remove(!0),
        i &&
          i.eachItemGraphicEl(function (a, o) {
            a.__temp && (n.remove(a), i.setItemGraphicEl(o, null))
          }),
        (this._polyline =
          this._polygon =
          this._coordSys =
          this._points =
          this._stackedOnPoints =
          this._endLabel =
          this._data =
            null)
    }),
    (t.type = 'line'),
    t
  )
})(Ze)
const Llt = Dlt
function Dv(r, t) {
  return {
    seriesType: r,
    plan: Ef(),
    reset: function (e) {
      var n = e.getData(),
        i = e.coordinateSystem,
        a = e.pipelineContext,
        o = t || a.large
      if (i) {
        var s = st(i.dimensions, function (d) {
            return n.mapDimension(d)
          }).slice(0, 2),
          l = s.length,
          u = n.getCalculationInfo('stackResultDimension')
        sl(n, s[0]) && (s[0] = u), sl(n, s[1]) && (s[1] = u)
        var c = n.getStore(),
          h = n.getDimensionIndex(s[0]),
          f = n.getDimensionIndex(s[1])
        return (
          l && {
            progress: function (d, p) {
              for (
                var g = d.end - d.start,
                  v = o && eo(g * l),
                  m = [],
                  y = [],
                  _ = d.start,
                  x = 0;
                _ < d.end;
                _++
              ) {
                var A = void 0
                if (l === 1) {
                  var S = c.get(h, _)
                  A = i.dataToPoint(S, null, y)
                } else
                  (m[0] = c.get(h, _)),
                    (m[1] = c.get(f, _)),
                    (A = i.dataToPoint(m, null, y))
                o
                  ? ((v[x++] = A[0]), (v[x++] = A[1]))
                  : p.setItemLayout(_, A.slice())
              }
              o && p.setLayout('points', v)
            },
          }
        )
      }
    },
  }
}
var Plt = {
    average: function (r) {
      for (var t = 0, e = 0, n = 0; n < r.length; n++)
        isNaN(r[n]) || ((t += r[n]), e++)
      return e === 0 ? NaN : t / e
    },
    sum: function (r) {
      for (var t = 0, e = 0; e < r.length; e++) t += r[e] || 0
      return t
    },
    max: function (r) {
      for (var t = -1 / 0, e = 0; e < r.length; e++) r[e] > t && (t = r[e])
      return isFinite(t) ? t : NaN
    },
    min: function (r) {
      for (var t = 1 / 0, e = 0; e < r.length; e++) r[e] < t && (t = r[e])
      return isFinite(t) ? t : NaN
    },
    minmax: function (r) {
      for (var t = -1 / 0, e = -1 / 0, n = 0; n < r.length; n++) {
        var i = r[n],
          a = Math.abs(i)
        a > t && ((t = a), (e = i))
      }
      return isFinite(e) ? e : NaN
    },
    nearest: function (r) {
      return r[0]
    },
  },
  Rlt = function (r) {
    return Math.round(r.length / 2)
  }
function EG(r) {
  return {
    seriesType: r,
    reset: function (t, e, n) {
      var i = t.getData(),
        a = t.get('sampling'),
        o = t.coordinateSystem,
        s = i.count()
      if (s > 10 && o.type === 'cartesian2d' && a) {
        var l = o.getBaseAxis(),
          u = o.getOtherAxis(l),
          c = l.getExtent(),
          h = n.getDevicePixelRatio(),
          f = Math.abs(c[1] - c[0]) * (h || 1),
          d = Math.round(s / f)
        if (isFinite(d) && d > 1) {
          a === 'lttb' &&
            t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d))
          var p = void 0
          bt(a) ? (p = Plt[a]) : Nt(a) && (p = a),
            p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, Rlt))
        }
      }
    },
  }
}
function Ilt(r) {
  r.registerChartView(Llt),
    r.registerSeriesModel(hlt),
    r.registerLayout(Dv('line', !0)),
    r.registerVisual({
      seriesType: 'line',
      reset: function (t) {
        var e = t.getData(),
          n = t.getModel('lineStyle').getLineStyle()
        n && !n.stroke && (n.stroke = e.getVisual('style').fill),
          e.setVisual('legendLineStyle', n)
      },
    }),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, EG('line'))
}
var DG = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getMarkerPosition = function (e, n, i) {
      var a = this.coordinateSystem
      if (a && a.clampData) {
        var o = a.clampData(e),
          s = a.dataToPoint(o)
        if (i)
          R(a.getAxes(), function (f, d) {
            if (f.type === 'category' && n != null) {
              var p = f.getTicksCoords(),
                g = f.getTickModel().get('alignWithLabel'),
                v = o[d],
                m = n[d] === 'x1' || n[d] === 'y1'
              if ((m && !g && (v += 1), p.length < 2)) return
              if (p.length === 2) {
                s[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0])
                return
              }
              for (
                var y = void 0, _ = void 0, x = 1, A = 0;
                A < p.length;
                A++
              ) {
                var S = p[A].coord,
                  b =
                    A === p.length - 1 ? p[A - 1].tickValue + x : p[A].tickValue
                if (b === v) {
                  _ = S
                  break
                } else if (b < v) y = S
                else if (y != null && b > v) {
                  _ = (S + y) / 2
                  break
                }
                A === 1 && (x = b - p[0].tickValue)
              }
              _ == null &&
                (y ? y && (_ = p[p.length - 1].coord) : (_ = p[0].coord)),
                (s[d] = f.toGlobalCoord(_))
            }
          })
        else {
          var l = this.getData(),
            u = l.getLayout('offset'),
            c = l.getLayout('size'),
            h = a.getBaseAxis().isHorizontal() ? 0 : 1
          s[h] += u + c / 2
        }
        return s
      }
      return [NaN, NaN]
    }),
    (t.type = 'series.__base_bar__'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      barMinHeight: 0,
      barMinAngle: 0,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: 'mod',
    }),
    t
  )
})(rn)
rn.registerClass(DG)
const c0 = DG
var Olt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function () {
      return as(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get('realtimeSort', !0) || null,
      })
    }),
    (t.prototype.getProgressive = function () {
      return this.get('large') ? this.get('progressive') : !1
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.get('progressiveThreshold'),
        n = this.get('largeThreshold')
      return n > e && (e = n), e
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.rect(n.getItemLayout(e))
    }),
    (t.type = 'series.bar'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = gl(c0.defaultOption, {
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: 'rgba(180, 180, 180, 0.2)',
        borderColor: null,
        borderWidth: 0,
        borderType: 'solid',
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1,
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      realtimeSort: !1,
    })),
    t
  )
})(c0)
const Nlt = Olt
var klt = (function () {
    function r() {
      ;(this.cx = 0),
        (this.cy = 0),
        (this.r0 = 0),
        (this.r = 0),
        (this.startAngle = 0),
        (this.endAngle = Math.PI * 2),
        (this.clockwise = !0)
    }
    return r
  })(),
  Blt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'sausage'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new klt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.cx,
          a = n.cy,
          o = Math.max(n.r0 || 0, 0),
          s = Math.max(n.r, 0),
          l = (s - o) * 0.5,
          u = o + l,
          c = n.startAngle,
          h = n.endAngle,
          f = n.clockwise,
          d = Math.PI * 2,
          p = f ? h - c < d : c - h < d
        p || (c = h - (f ? d : -d))
        var g = Math.cos(c),
          v = Math.sin(c),
          m = Math.cos(h),
          y = Math.sin(h)
        p
          ? (e.moveTo(g * o + i, v * o + a),
            e.arc(g * u + i, v * u + a, l, -Math.PI + c, c, !f))
          : e.moveTo(g * s + i, v * s + a),
          e.arc(i, a, s, c, h, !f),
          e.arc(m * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !f),
          o !== 0 && e.arc(i, a, o, h, c, f)
      }),
      t
    )
  })(oe)
const h0 = Blt
function Flt(r, t) {
  t = t || {}
  var e = t.isRoundCap
  return function (n, i, a) {
    var o = i.position
    if (!o || o instanceof Array) return Hy(n, i, a)
    var s = r(o),
      l = i.distance != null ? i.distance : 5,
      u = this.shape,
      c = u.cx,
      h = u.cy,
      f = u.r,
      d = u.r0,
      p = (f + d) / 2,
      g = u.startAngle,
      v = u.endAngle,
      m = (g + v) / 2,
      y = e ? Math.abs(f - d) / 2 : 0,
      _ = Math.cos,
      x = Math.sin,
      A = c + f * _(g),
      S = h + f * x(g),
      b = 'left',
      T = 'top'
    switch (s) {
      case 'startArc':
        ;(A = c + (d - l) * _(m)),
          (S = h + (d - l) * x(m)),
          (b = 'center'),
          (T = 'top')
        break
      case 'insideStartArc':
        ;(A = c + (d + l) * _(m)),
          (S = h + (d + l) * x(m)),
          (b = 'center'),
          (T = 'bottom')
        break
      case 'startAngle':
        ;(A = c + p * _(g) + cm(g, l + y, !1)),
          (S = h + p * x(g) + hm(g, l + y, !1)),
          (b = 'right'),
          (T = 'middle')
        break
      case 'insideStartAngle':
        ;(A = c + p * _(g) + cm(g, -l + y, !1)),
          (S = h + p * x(g) + hm(g, -l + y, !1)),
          (b = 'left'),
          (T = 'middle')
        break
      case 'middle':
        ;(A = c + p * _(m)), (S = h + p * x(m)), (b = 'center'), (T = 'middle')
        break
      case 'endArc':
        ;(A = c + (f + l) * _(m)),
          (S = h + (f + l) * x(m)),
          (b = 'center'),
          (T = 'bottom')
        break
      case 'insideEndArc':
        ;(A = c + (f - l) * _(m)),
          (S = h + (f - l) * x(m)),
          (b = 'center'),
          (T = 'top')
        break
      case 'endAngle':
        ;(A = c + p * _(v) + cm(v, l + y, !0)),
          (S = h + p * x(v) + hm(v, l + y, !0)),
          (b = 'left'),
          (T = 'middle')
        break
      case 'insideEndAngle':
        ;(A = c + p * _(v) + cm(v, -l + y, !0)),
          (S = h + p * x(v) + hm(v, -l + y, !0)),
          (b = 'right'),
          (T = 'middle')
        break
      default:
        return Hy(n, i, a)
    }
    return (
      (n = n || {}),
      (n.x = A),
      (n.y = S),
      (n.align = b),
      (n.verticalAlign = T),
      n
    )
  }
}
function zlt(r, t, e, n) {
  if (be(n)) {
    r.setTextConfig({
      rotation: n,
    })
    return
  } else if (at(t)) {
    r.setTextConfig({
      rotation: 0,
    })
    return
  }
  var i = r.shape,
    a = i.clockwise ? i.startAngle : i.endAngle,
    o = i.clockwise ? i.endAngle : i.startAngle,
    s = (a + o) / 2,
    l,
    u = e(t)
  switch (u) {
    case 'startArc':
    case 'insideStartArc':
    case 'middle':
    case 'insideEndArc':
    case 'endArc':
      l = s
      break
    case 'startAngle':
    case 'insideStartAngle':
      l = a
      break
    case 'endAngle':
    case 'insideEndAngle':
      l = o
      break
    default:
      r.setTextConfig({
        rotation: 0,
      })
      return
  }
  var c = Math.PI * 1.5 - l
  u === 'middle' && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI),
    r.setTextConfig({
      rotation: c,
    })
}
function cm(r, t, e) {
  return t * Math.sin(r) * (e ? -1 : 1)
}
function hm(r, t, e) {
  return t * Math.cos(r) * (e ? 1 : -1)
}
function bu(r, t, e) {
  var n = r.get('borderRadius')
  if (n == null)
    return e
      ? {
          cornerRadius: 0,
        }
      : null
  at(n) || (n = [n, n, n, n])
  var i = Math.abs(t.r || 0 - t.r0 || 0)
  return {
    cornerRadius: st(n, function (a) {
      return Ta(a, i)
    }),
  }
}
var rS = Math.max,
  iS = Math.min
function Ult(r, t) {
  var e = r.getArea && r.getArea()
  if (oc(r, 'cartesian2d')) {
    var n = r.getBaseAxis()
    if (n.type !== 'category' || !n.onBand) {
      var i = t.getLayout('bandWidth')
      n.isHorizontal()
        ? ((e.x -= i), (e.width += i * 2))
        : ((e.y -= i), (e.height += i * 2))
    }
  }
  return e
}
var Vlt = (function (r) {
    X(t, r)
    function t() {
      var e = r.call(this) || this
      return (e.type = t.type), (e._isFirstFrame = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        ;(this._model = e),
          this._removeOnRenderedListener(i),
          this._updateDrawMode(e)
        var o = e.get('coordinateSystem')
        ;(o === 'cartesian2d' || o === 'polar') &&
          ((this._progressiveEls = null),
          this._isLargeDraw
            ? this._renderLarge(e, n, i)
            : this._renderNormal(e, n, i, a))
      }),
      (t.prototype.incrementalPrepareRender = function (e) {
        this._clear(), this._updateDrawMode(e), this._updateLargeClip(e)
      }),
      (t.prototype.incrementalRender = function (e, n) {
        ;(this._progressiveEls = []), this._incrementalRenderLarge(e, n)
      }),
      (t.prototype.eachRendered = function (e) {
        vl(this._progressiveEls || this.group, e)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var n = e.pipelineContext.large
        ;(this._isLargeDraw == null || n !== this._isLargeDraw) &&
          ((this._isLargeDraw = n), this._clear())
      }),
      (t.prototype._renderNormal = function (e, n, i, a) {
        var o = this.group,
          s = e.getData(),
          l = this._data,
          u = e.coordinateSystem,
          c = u.getBaseAxis(),
          h
        u.type === 'cartesian2d'
          ? (h = c.isHorizontal())
          : u.type === 'polar' && (h = c.dim === 'angle')
        var f = e.isAnimationEnabled() ? e : null,
          d = Glt(e, u)
        d && this._enableRealtimeSort(d, s, i)
        var p = e.get('clip', !0) || d,
          g = Ult(u, s)
        o.removeClipPath()
        var v = e.get('roundCap', !0),
          m = e.get('showBackground', !0),
          y = e.getModel('backgroundStyle'),
          _ = y.get('borderRadius') || 0,
          x = [],
          A = this._backgroundEls,
          S = a && a.isInitSort,
          b = a && a.type === 'changeAxisOrder'
        function T(C) {
          var E = fm[u.type](s, C),
            D = Zlt(u, h, E)
          return (
            D.useStyle(y.getItemStyle()),
            u.type === 'cartesian2d'
              ? D.setShape('r', _)
              : D.setShape('cornerRadius', _),
            (x[C] = D),
            D
          )
        }
        s.diff(l)
          .add(function (C) {
            var E = s.getItemModel(C),
              D = fm[u.type](s, C, E)
            if ((m && T(C), !(!s.hasValue(C) || !zI[u.type](D)))) {
              var P = !1
              p && (P = NI[u.type](g, D))
              var L = kI[u.type](e, s, C, D, h, f, c.model, !1, v)
              d && (L.forceLabelAnimation = !0),
                UI(L, s, C, E, D, e, h, u.type === 'polar'),
                S
                  ? L.attr({
                      shape: D,
                    })
                  : d
                  ? BI(d, f, L, D, C, h, !1, !1)
                  : Je(
                      L,
                      {
                        shape: D,
                      },
                      e,
                      C,
                    ),
                s.setItemGraphicEl(C, L),
                o.add(L),
                (L.ignore = P)
            }
          })
          .update(function (C, E) {
            var D = s.getItemModel(C),
              P = fm[u.type](s, C, D)
            if (m) {
              var L = void 0
              A.length === 0
                ? (L = T(E))
                : ((L = A[E]),
                  L.useStyle(y.getItemStyle()),
                  u.type === 'cartesian2d'
                    ? L.setShape('r', _)
                    : L.setShape('cornerRadius', _),
                  (x[C] = L))
              var I = fm[u.type](s, C),
                F = PG(h, I, u)
              we(
                L,
                {
                  shape: F,
                },
                f,
                C,
              )
            }
            var k = l.getItemGraphicEl(E)
            if (!s.hasValue(C) || !zI[u.type](P)) {
              o.remove(k)
              return
            }
            var V = !1
            if (
              (p && ((V = NI[u.type](g, P)), V && o.remove(k)),
              k ? Ca(k) : (k = kI[u.type](e, s, C, P, h, f, c.model, !!k, v)),
              d && (k.forceLabelAnimation = !0),
              b)
            ) {
              var H = k.getTextContent()
              if (H) {
                var Y = Af(H)
                Y.prevValue != null && (Y.prevValue = Y.value)
              }
            } else UI(k, s, C, D, P, e, h, u.type === 'polar')
            S
              ? k.attr({
                  shape: P,
                })
              : d
              ? BI(d, f, k, P, C, h, !0, b)
              : we(
                  k,
                  {
                    shape: P,
                  },
                  e,
                  C,
                  null,
                ),
              s.setItemGraphicEl(C, k),
              (k.ignore = V),
              o.add(k)
          })
          .remove(function (C) {
            var E = l.getItemGraphicEl(C)
            E && Xp(E, e, C)
          })
          .execute()
        var w = this._backgroundGroup || (this._backgroundGroup = new Ht())
        w.removeAll()
        for (var M = 0; M < x.length; ++M) w.add(x[M])
        o.add(w), (this._backgroundEls = x), (this._data = s)
      }),
      (t.prototype._renderLarge = function (e, n, i) {
        this._clear(), GI(e, this.group), this._updateLargeClip(e)
      }),
      (t.prototype._incrementalRenderLarge = function (e, n) {
        this._removeBackground(), GI(n, this.group, this._progressiveEls, !0)
      }),
      (t.prototype._updateLargeClip = function (e) {
        var n = e.get('clip', !0) && Ev(e.coordinateSystem, !1, e),
          i = this.group
        n ? i.setClipPath(n) : i.removeClipPath()
      }),
      (t.prototype._enableRealtimeSort = function (e, n, i) {
        var a = this
        if (n.count()) {
          var o = e.baseAxis
          if (this._isFirstFrame)
            this._dispatchInitSort(n, e, i), (this._isFirstFrame = !1)
          else {
            var s = function (l) {
              var u = n.getItemGraphicEl(l),
                c = u && u.shape
              return (c && Math.abs(o.isHorizontal() ? c.height : c.width)) || 0
            }
            ;(this._onRendered = function () {
              a._updateSortWithinSameData(n, s, o, i)
            }),
              i.getZr().on('rendered', this._onRendered)
          }
        }
      }),
      (t.prototype._dataSort = function (e, n, i) {
        var a = []
        return (
          e.each(e.mapDimension(n.dim), function (o, s) {
            var l = i(s)
            ;(l = l ?? NaN),
              a.push({
                dataIndex: s,
                mappedValue: l,
                ordinalNumber: o,
              })
          }),
          a.sort(function (o, s) {
            return s.mappedValue - o.mappedValue
          }),
          {
            ordinalNumbers: st(a, function (o) {
              return o.ordinalNumber
            }),
          }
        )
      }),
      (t.prototype._isOrderChangedWithinSameData = function (e, n, i) {
        for (
          var a = i.scale,
            o = e.mapDimension(i.dim),
            s = Number.MAX_VALUE,
            l = 0,
            u = a.getOrdinalMeta().categories.length;
          l < u;
          ++l
        ) {
          var c = e.rawIndexOf(o, a.getRawOrdinalNumber(l)),
            h = c < 0 ? Number.MIN_VALUE : n(e.indexOfRawIndex(c))
          if (h > s) return !0
          s = h
        }
        return !1
      }),
      (t.prototype._isOrderDifferentInView = function (e, n) {
        for (
          var i = n.scale,
            a = i.getExtent(),
            o = Math.max(0, a[0]),
            s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1);
          o <= s;
          ++o
        )
          if (e.ordinalNumbers[o] !== i.getRawOrdinalNumber(o)) return !0
      }),
      (t.prototype._updateSortWithinSameData = function (e, n, i, a) {
        if (this._isOrderChangedWithinSameData(e, n, i)) {
          var o = this._dataSort(e, i, n)
          this._isOrderDifferentInView(o, i) &&
            (this._removeOnRenderedListener(a),
            a.dispatchAction({
              type: 'changeAxisOrder',
              componentType: i.dim + 'Axis',
              axisId: i.index,
              sortInfo: o,
            }))
        }
      }),
      (t.prototype._dispatchInitSort = function (e, n, i) {
        var a = n.baseAxis,
          o = this._dataSort(e, a, function (s) {
            return e.get(e.mapDimension(n.otherAxis.dim), s)
          })
        i.dispatchAction({
          type: 'changeAxisOrder',
          componentType: a.dim + 'Axis',
          isInitSort: !0,
          axisId: a.index,
          sortInfo: o,
        })
      }),
      (t.prototype.remove = function (e, n) {
        this._clear(this._model), this._removeOnRenderedListener(n)
      }),
      (t.prototype.dispose = function (e, n) {
        this._removeOnRenderedListener(n)
      }),
      (t.prototype._removeOnRenderedListener = function (e) {
        this._onRendered &&
          (e.getZr().off('rendered', this._onRendered),
          (this._onRendered = null))
      }),
      (t.prototype._clear = function (e) {
        var n = this.group,
          i = this._data
        e && e.isAnimationEnabled() && i && !this._isLargeDraw
          ? (this._removeBackground(),
            (this._backgroundEls = []),
            i.eachItemGraphicEl(function (a) {
              Xp(a, e, Wt(a).dataIndex)
            }))
          : n.removeAll(),
          (this._data = null),
          (this._isFirstFrame = !0)
      }),
      (t.prototype._removeBackground = function () {
        this.group.remove(this._backgroundGroup), (this._backgroundGroup = null)
      }),
      (t.type = 'bar'),
      t
    )
  })(Ze),
  NI = {
    cartesian2d: function (r, t) {
      var e = t.width < 0 ? -1 : 1,
        n = t.height < 0 ? -1 : 1
      e < 0 && ((t.x += t.width), (t.width = -t.width)),
        n < 0 && ((t.y += t.height), (t.height = -t.height))
      var i = r.x + r.width,
        a = r.y + r.height,
        o = rS(t.x, r.x),
        s = iS(t.x + t.width, i),
        l = rS(t.y, r.y),
        u = iS(t.y + t.height, a),
        c = s < o,
        h = u < l
      return (
        (t.x = c && o > i ? s : o),
        (t.y = h && l > a ? u : l),
        (t.width = c ? 0 : s - o),
        (t.height = h ? 0 : u - l),
        e < 0 && ((t.x += t.width), (t.width = -t.width)),
        n < 0 && ((t.y += t.height), (t.height = -t.height)),
        c || h
      )
    },
    polar: function (r, t) {
      var e = t.r0 <= t.r ? 1 : -1
      if (e < 0) {
        var n = t.r
        ;(t.r = t.r0), (t.r0 = n)
      }
      var i = iS(t.r, r.r),
        a = rS(t.r0, r.r0)
      ;(t.r = i), (t.r0 = a)
      var o = i - a < 0
      if (e < 0) {
        var n = t.r
        ;(t.r = t.r0), (t.r0 = n)
      }
      return o
    },
  },
  kI = {
    cartesian2d: function (r, t, e, n, i, a, o, s, l) {
      var u = new ge({
        shape: Q({}, n),
        z2: 1,
      })
      if (((u.__dataIndex = e), (u.name = 'item'), a)) {
        var c = u.shape,
          h = i ? 'height' : 'width'
        c[h] = 0
      }
      return u
    },
    polar: function (r, t, e, n, i, a, o, s, l) {
      var u = !i && l ? h0 : oi,
        c = new u({
          shape: n,
          z2: 1,
        })
      c.name = 'item'
      var h = LG(i)
      if (
        ((c.calculateTextPosition = Flt(h, {
          isRoundCap: u === h0,
        })),
        a)
      ) {
        var f = c.shape,
          d = i ? 'r' : 'endAngle',
          p = {}
        ;(f[d] = i ? n.r0 : n.startAngle),
          (p[d] = n[d]),
          (s ? we : Je)(
            c,
            {
              shape: p,
            },
            a,
          )
      }
      return c
    },
  }
function Glt(r, t) {
  var e = r.get('realtimeSort', !0),
    n = t.getBaseAxis()
  if (e && n.type === 'category' && t.type === 'cartesian2d')
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n),
    }
}
function BI(r, t, e, n, i, a, o, s) {
  var l, u
  a
    ? ((u = {
        x: n.x,
        width: n.width,
      }),
      (l = {
        y: n.y,
        height: n.height,
      }))
    : ((u = {
        y: n.y,
        height: n.height,
      }),
      (l = {
        x: n.x,
        width: n.width,
      })),
    s ||
      (o ? we : Je)(
        e,
        {
          shape: l,
        },
        t,
        i,
        null,
      )
  var c = t ? r.baseAxis.model : null
  ;(o ? we : Je)(
    e,
    {
      shape: u,
    },
    c,
    i,
  )
}
function FI(r, t) {
  for (var e = 0; e < t.length; e++) if (!isFinite(r[t[e]])) return !0
  return !1
}
var Hlt = ['x', 'y', 'width', 'height'],
  Wlt = ['cx', 'cy', 'r', 'startAngle', 'endAngle'],
  zI = {
    cartesian2d: function (r) {
      return !FI(r, Hlt)
    },
    polar: function (r) {
      return !FI(r, Wlt)
    },
  },
  fm = {
    cartesian2d: function (r, t, e) {
      var n = r.getItemLayout(t),
        i = e ? Ylt(e, n) : 0,
        a = n.width > 0 ? 1 : -1,
        o = n.height > 0 ? 1 : -1
      return {
        x: n.x + (a * i) / 2,
        y: n.y + (o * i) / 2,
        width: n.width - a * i,
        height: n.height - o * i,
      }
    },
    polar: function (r, t, e) {
      var n = r.getItemLayout(t)
      return {
        cx: n.cx,
        cy: n.cy,
        r0: n.r0,
        r: n.r,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise,
      }
    },
  }
function Xlt(r) {
  return (
    r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle
  )
}
function LG(r) {
  return (function (t) {
    var e = t ? 'Arc' : 'Angle'
    return function (n) {
      switch (n) {
        case 'start':
        case 'insideStart':
        case 'end':
        case 'insideEnd':
          return n + e
        default:
          return n
      }
    }
  })(r)
}
function UI(r, t, e, n, i, a, o, s) {
  var l = t.getItemVisual(e, 'style')
  if (s) {
    if (!a.get('roundCap')) {
      var c = r.shape,
        h = bu(n.getModel('itemStyle'), c, !0)
      Q(c, h), r.setShape(c)
    }
  } else {
    var u = n.get(['itemStyle', 'borderRadius']) || 0
    r.setShape('r', u)
  }
  r.useStyle(l)
  var f = n.getShallow('cursor')
  f && r.attr('cursor', f)
  var d = s
      ? o
        ? i.r >= i.r0
          ? 'endArc'
          : 'startArc'
        : i.endAngle >= i.startAngle
        ? 'endAngle'
        : 'startAngle'
      : o
      ? i.height >= 0
        ? 'bottom'
        : 'top'
      : i.width >= 0
      ? 'right'
      : 'left',
    p = Zn(n)
  mr(r, p, {
    labelFetcher: a,
    labelDataIndex: e,
    defaultText: of(a.getData(), e),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d,
  })
  var g = r.getTextContent()
  if (s && g) {
    var v = n.get(['label', 'position'])
    ;(r.textConfig.inside = v === 'middle' ? !0 : null),
      zlt(r, v === 'outside' ? d : v, LG(o), n.get(['label', 'rotate']))
  }
  GU(g, p, a.getRawValue(e), function (y) {
    return xG(t, y)
  })
  var m = n.getModel(['emphasis'])
  fn(r, m.get('focus'), m.get('blurScope'), m.get('disabled')),
    gr(r, n),
    Xlt(i) &&
      ((r.style.fill = 'none'),
      (r.style.stroke = 'none'),
      R(r.states, function (y) {
        y.style && (y.style.fill = y.style.stroke = 'none')
      }))
}
function Ylt(r, t) {
  var e = r.get(['itemStyle', 'borderColor'])
  if (!e || e === 'none') return 0
  var n = r.get(['itemStyle', 'borderWidth']) || 0,
    i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width),
    a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height)
  return Math.min(n, i, a)
}
var $lt = (function () {
    function r() {}
    return r
  })(),
  VI = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'largeBar'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new $lt()
      }),
      (t.prototype.buildPath = function (e, n) {
        for (
          var i = n.points,
            a = this.baseDimIdx,
            o = 1 - this.baseDimIdx,
            s = [],
            l = [],
            u = this.barWidth,
            c = 0;
          c < i.length;
          c += 3
        )
          (l[a] = u),
            (l[o] = i[c + 2]),
            (s[a] = i[c + a]),
            (s[o] = i[c + o]),
            e.rect(s[0], s[1], l[0], l[1])
      }),
      t
    )
  })(oe)
function GI(r, t, e, n) {
  var i = r.getData(),
    a = i.getLayout('valueAxisHorizontal') ? 1 : 0,
    o = i.getLayout('largeDataIndices'),
    s = i.getLayout('size'),
    l = r.getModel('backgroundStyle'),
    u = i.getLayout('largeBackgroundPoints')
  if (u) {
    var c = new VI({
      shape: {
        points: u,
      },
      incremental: !!n,
      silent: !0,
      z2: 0,
    })
    ;(c.baseDimIdx = a),
      (c.largeDataIndices = o),
      (c.barWidth = s),
      c.useStyle(l.getItemStyle()),
      t.add(c),
      e && e.push(c)
  }
  var h = new VI({
    shape: {
      points: i.getLayout('largePoints'),
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1,
  })
  ;(h.baseDimIdx = a),
    (h.largeDataIndices = o),
    (h.barWidth = s),
    t.add(h),
    h.useStyle(i.getVisual('style')),
    (Wt(h).seriesIndex = r.seriesIndex),
    r.get('silent') || (h.on('mousedown', HI), h.on('mousemove', HI)),
    e && e.push(h)
}
var HI = __(
  function (r) {
    var t = this,
      e = qlt(t, r.offsetX, r.offsetY)
    Wt(t).dataIndex = e >= 0 ? e : null
  },
  30,
  !1,
)
function qlt(r, t, e) {
  for (
    var n = r.baseDimIdx,
      i = 1 - n,
      a = r.shape.points,
      o = r.largeDataIndices,
      s = [],
      l = [],
      u = r.barWidth,
      c = 0,
      h = a.length / 3;
    c < h;
    c++
  ) {
    var f = c * 3
    if (
      ((l[n] = u),
      (l[i] = a[f + 2]),
      (s[n] = a[f + n]),
      (s[i] = a[f + i]),
      l[i] < 0 && ((s[i] += l[i]), (l[i] = -l[i])),
      t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1])
    )
      return o[c]
  }
  return -1
}
function PG(r, t, e) {
  if (oc(e, 'cartesian2d')) {
    var n = t,
      i = e.getArea()
    return {
      x: r ? n.x : i.x,
      y: r ? i.y : n.y,
      width: r ? n.width : i.width,
      height: r ? i.height : n.height,
    }
  } else {
    var i = e.getArea(),
      a = t
    return {
      cx: i.cx,
      cy: i.cy,
      r0: r ? i.r0 : a.r0,
      r: r ? i.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2,
    }
  }
}
function Zlt(r, t, e) {
  var n = r.type === 'polar' ? oi : ge
  return new n({
    shape: PG(t, e, r),
    silent: !0,
    z2: 0,
  })
}
const Klt = Vlt
function jlt(r) {
  r.registerChartView(Klt),
    r.registerSeriesModel(Nlt),
    r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Zt(IV, 'bar')),
    r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OV('bar')),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, EG('bar')),
    r.registerAction(
      {
        type: 'changeAxisOrder',
        event: 'changeAxisOrder',
        update: 'update',
      },
      function (t, e) {
        var n = t.componentType || 'series'
        e.eachComponent(
          {
            mainType: n,
            query: t,
          },
          function (i) {
            t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo)
          },
        )
      },
    )
}
var WI = Math.PI * 2,
  dm = Math.PI / 180
function RG(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function IG(r, t) {
  var e = RG(r, t),
    n = r.get('center'),
    i = r.get('radius')
  at(i) || (i = [0, i])
  var a = _t(e.width, t.getWidth()),
    o = _t(e.height, t.getHeight()),
    s = Math.min(a, o),
    l = _t(i[0], s / 2),
    u = _t(i[1], s / 2),
    c,
    h,
    f = r.coordinateSystem
  if (f) {
    var d = f.dataToPoint(n)
    ;(c = d[0] || 0), (h = d[1] || 0)
  } else at(n) || (n = [n, n]), (c = _t(n[0], a) + e.x), (h = _t(n[1], o) + e.y)
  return {
    cx: c,
    cy: h,
    r0: l,
    r: u,
  }
}
function Jlt(r, t, e) {
  t.eachSeriesByType(r, function (n) {
    var i = n.getData(),
      a = i.mapDimension('value'),
      o = RG(n, e),
      s = IG(n, e),
      l = s.cx,
      u = s.cy,
      c = s.r,
      h = s.r0,
      f = -n.get('startAngle') * dm,
      d = n.get('endAngle'),
      p = n.get('padAngle') * dm
    d = d === 'auto' ? f - WI : -d * dm
    var g = n.get('minAngle') * dm,
      v = g + p,
      m = 0
    i.each(a, function (F) {
      !isNaN(F) && m++
    })
    var y = i.getSum(a),
      _ = (Math.PI / (y || m)) * 2,
      x = n.get('clockwise'),
      A = n.get('roseType'),
      S = n.get('stillShowZeroSum'),
      b = i.getDataExtent(a)
    b[0] = 0
    var T = x ? 1 : -1,
      w = [f, d],
      M = (T * p) / 2
    HT(w, !x), (f = w[0]), (d = w[1])
    var C = OG(n)
    ;(C.startAngle = f), (C.endAngle = d), (C.clockwise = x)
    var E = Math.abs(d - f),
      D = E,
      P = 0,
      L = f
    if (
      (i.setLayout({
        viewRect: o,
        r: c,
      }),
      i.each(a, function (F, k) {
        var V
        if (isNaN(F)) {
          i.setItemLayout(k, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: x,
            cx: l,
            cy: u,
            r0: h,
            r: A ? NaN : c,
          })
          return
        }
        A !== 'area' ? (V = y === 0 && S ? _ : F * _) : (V = E / m),
          V < v ? ((V = v), (D -= v)) : (P += F)
        var H = L + T * V,
          Y = 0,
          K = 0
        p > V ? ((Y = L + (T * V) / 2), (K = Y)) : ((Y = L + M), (K = H - M)),
          i.setItemLayout(k, {
            angle: V,
            startAngle: Y,
            endAngle: K,
            clockwise: x,
            cx: l,
            cy: u,
            r0: h,
            r: A ? Re(F, b, [h, c]) : c,
          }),
          (L = H)
      }),
      D < WI && m)
    )
      if (D <= 0.001) {
        var I = E / m
        i.each(a, function (F, k) {
          if (!isNaN(F)) {
            var V = i.getItemLayout(k)
            V.angle = I
            var H = 0,
              Y = 0
            I < p
              ? ((H = f + T * (k + 1 / 2) * I), (Y = H))
              : ((H = f + T * k * I + M), (Y = f + T * (k + 1) * I - M)),
              (V.startAngle = H),
              (V.endAngle = Y)
          }
        })
      } else
        (_ = D / P),
          (L = f),
          i.each(a, function (F, k) {
            if (!isNaN(F)) {
              var V = i.getItemLayout(k),
                H = V.angle === v ? v : F * _,
                Y = 0,
                K = 0
              H < p
                ? ((Y = L + (T * H) / 2), (K = Y))
                : ((Y = L + M), (K = L + T * H - M)),
                (V.startAngle = Y),
                (V.endAngle = K),
                (L += T * H)
            }
          })
  })
}
var OG = ve()
function Lv(r) {
  return {
    seriesType: r,
    reset: function (t, e) {
      var n = e.findComponents({
        mainType: 'legend',
      })
      if (!(!n || !n.length)) {
        var i = t.getData()
        i.filterSelf(function (a) {
          for (var o = i.getName(a), s = 0; s < n.length; s++)
            if (!n[s].isSelected(o)) return !1
          return !0
        })
      }
    },
  }
}
var Qlt = Math.PI / 180
function XI(r, t, e, n, i, a, o, s, l, u) {
  if (r.length < 2) return
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var _ = g.list[y],
        x = Math.abs(_.label.y - e),
        A = n + _.len,
        S = A * A,
        b = Math.sqrt((1 - Math.abs((x * x) / m)) * S),
        T = t + (b + _.len2) * i,
        w = T - _.label.x,
        M = _.targetTextWidth - w * i
      NG(_, M, !0), (_.label.x = T)
    }
  }
  function h(g) {
    for (
      var v = {
          list: [],
          maxY: 0,
        },
        m = {
          list: [],
          maxY: 0,
        },
        y = 0;
      y < g.length;
      y++
    )
      if (g[y].labelAlignTo === 'none') {
        var _ = g[y],
          x = _.label.y > e ? m : v,
          A = Math.abs(_.label.y - e)
        if (A >= x.maxY) {
          var S = _.label.x - t - _.len2 * i,
            b = n + _.len,
            T = Math.abs(S) < b ? Math.sqrt((A * A) / (1 - (S * S) / b / b)) : b
          ;(x.rB = T), (x.maxY = A)
        }
        x.list.push(_)
      }
    c(v), c(m)
  }
  for (var f = r.length, d = 0; d < f; d++)
    if (r[d].position === 'outer' && r[d].labelAlignTo === 'labelLine') {
      var p = r[d].label.x - u
      ;(r[d].linePoints[1][0] += p), (r[d].label.x = u)
    }
  rG(r, l, l + o) && h(r)
}
function tut(r, t, e, n, i, a, o, s) {
  for (
    var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0;
    f < r.length;
    f++
  ) {
    var d = r[f].label
    aS(r[f]) ||
      (d.x < t
        ? ((c = Math.min(c, d.x)), l.push(r[f]))
        : ((h = Math.max(h, d.x)), u.push(r[f])))
  }
  for (var f = 0; f < r.length; f++) {
    var p = r[f]
    if (!aS(p) && p.linePoints) {
      if (p.labelStyleWidth != null) continue
      var d = p.label,
        g = p.linePoints,
        v = void 0
      p.labelAlignTo === 'edge'
        ? d.x < t
          ? (v = g[2][0] - p.labelDistance - o - p.edgeDistance)
          : (v = o + i - p.edgeDistance - g[2][0] - p.labelDistance)
        : p.labelAlignTo === 'labelLine'
        ? d.x < t
          ? (v = c - o - p.bleedMargin)
          : (v = o + i - h - p.bleedMargin)
        : d.x < t
        ? (v = d.x - o - p.bleedMargin)
        : (v = o + i - d.x - p.bleedMargin),
        (p.targetTextWidth = v),
        NG(p, v)
    }
  }
  XI(u, t, e, n, 1, i, a, o, s, h), XI(l, t, e, n, -1, i, a, o, s, c)
  for (var f = 0; f < r.length; f++) {
    var p = r[f]
    if (!aS(p) && p.linePoints) {
      var d = p.label,
        g = p.linePoints,
        m = p.labelAlignTo === 'edge',
        y = d.style.padding,
        _ = y ? y[1] + y[3] : 0,
        x = d.style.backgroundColor ? 0 : _,
        A = p.rect.width + x,
        S = g[1][0] - g[2][0]
      m
        ? d.x < t
          ? (g[2][0] = o + p.edgeDistance + A + p.labelDistance)
          : (g[2][0] = o + i - p.edgeDistance - A - p.labelDistance)
        : (d.x < t
            ? (g[2][0] = d.x + p.labelDistance)
            : (g[2][0] = d.x - p.labelDistance),
          (g[1][0] = g[2][0] + S)),
        (g[1][1] = g[2][1] = d.y)
    }
  }
}
function NG(r, t, e) {
  if ((e === void 0 && (e = !1), r.labelStyleWidth == null)) {
    var n = r.label,
      i = n.style,
      a = r.rect,
      o = i.backgroundColor,
      s = i.padding,
      l = s ? s[1] + s[3] : 0,
      u = i.overflow,
      c = a.width + (o ? 0 : l)
    if (t < c || e) {
      var h = a.height
      if (u && u.match('break')) {
        n.setStyle('backgroundColor', null), n.setStyle('width', t - l)
        var f = n.getBoundingRect()
        n.setStyle('width', Math.ceil(f.width)),
          n.setStyle('backgroundColor', o)
      } else {
        var d = t - l,
          p = t < c ? d : e ? (d > r.unconstrainedWidth ? null : d) : null
        n.setStyle('width', p)
      }
      var g = n.getBoundingRect()
      a.width = g.width
      var v = (n.style.margin || 0) + 2.1
      ;(a.height = g.height + v), (a.y -= (a.height - h) / 2)
    }
  }
}
function aS(r) {
  return r.position === 'center'
}
function eut(r) {
  var t = r.getData(),
    e = [],
    n,
    i,
    a = !1,
    o = (r.get('minShowLabelAngle') || 0) * Qlt,
    s = t.getLayout('viewRect'),
    l = t.getLayout('r'),
    u = s.width,
    c = s.x,
    h = s.y,
    f = s.height
  function d(S) {
    S.ignore = !0
  }
  function p(S) {
    if (!S.ignore) return !0
    for (var b in S.states) if (S.states[b].ignore === !1) return !0
    return !1
  }
  t.each(function (S) {
    var b = t.getItemGraphicEl(S),
      T = b.shape,
      w = b.getTextContent(),
      M = b.getTextGuideLine(),
      C = t.getItemModel(S),
      E = C.getModel('label'),
      D = E.get('position') || C.get(['emphasis', 'label', 'position']),
      P = E.get('distanceToLabelLine'),
      L = E.get('alignTo'),
      I = _t(E.get('edgeDistance'), u),
      F = E.get('bleedMargin'),
      k = C.getModel('labelLine'),
      V = k.get('length')
    V = _t(V, u)
    var H = k.get('length2')
    if (((H = _t(H, u)), Math.abs(T.endAngle - T.startAngle) < o)) {
      R(w.states, d), (w.ignore = !0), M && (R(M.states, d), (M.ignore = !0))
      return
    }
    if (p(w)) {
      var Y = (T.startAngle + T.endAngle) / 2,
        K = Math.cos(Y),
        ut = Math.sin(Y),
        W,
        Z,
        ft,
        lt
      ;(n = T.cx), (i = T.cy)
      var ct = D === 'inside' || D === 'inner'
      if (D === 'center') (W = T.cx), (Z = T.cy), (lt = 'center')
      else {
        var At = (ct ? ((T.r + T.r0) / 2) * K : T.r * K) + n,
          gt = (ct ? ((T.r + T.r0) / 2) * ut : T.r * ut) + i
        if (((W = At + K * 3), (Z = gt + ut * 3), !ct)) {
          var dt = At + K * (V + l - T.r),
            B = gt + ut * (V + l - T.r),
            ht = dt + (K < 0 ? -1 : 1) * H,
            it = B
          L === 'edge'
            ? (W = K < 0 ? c + I : c + u - I)
            : (W = ht + (K < 0 ? -P : P)),
            (Z = it),
            (ft = [
              [At, gt],
              [dt, B],
              [ht, it],
            ])
        }
        lt = ct
          ? 'center'
          : L === 'edge'
          ? K > 0
            ? 'right'
            : 'left'
          : K > 0
          ? 'left'
          : 'right'
      }
      var xt = Math.PI,
        rt = 0,
        kt = E.get('rotate')
      if (be(kt)) rt = kt * (xt / 180)
      else if (D === 'center') rt = 0
      else if (kt === 'radial' || kt === !0) {
        var Ct = K < 0 ? -Y + xt : -Y
        rt = Ct
      } else if (kt === 'tangential' && D !== 'outside' && D !== 'outer') {
        var Lt = Math.atan2(K, ut)
        Lt < 0 && (Lt = xt * 2 + Lt)
        var G = ut > 0
        G && (Lt = xt + Lt), (rt = Lt - xt)
      }
      if (
        ((a = !!rt),
        (w.x = W),
        (w.y = Z),
        (w.rotation = rt),
        w.setStyle({
          verticalAlign: 'middle',
        }),
        ct)
      ) {
        w.setStyle({
          align: lt,
        })
        var vt = w.states.select
        vt && ((vt.x += w.x), (vt.y += w.y))
      } else {
        var N = w.getBoundingRect().clone()
        N.applyTransform(w.getComputedTransform())
        var J = (w.style.margin || 0) + 2.1
        ;(N.y -= J / 2),
          (N.height += J),
          e.push({
            label: w,
            labelLine: M,
            position: D,
            len: V,
            len2: H,
            minTurnAngle: k.get('minTurnAngle'),
            maxSurfaceAngle: k.get('maxSurfaceAngle'),
            surfaceNormal: new Qt(K, ut),
            linePoints: ft,
            textAlign: lt,
            labelDistance: P,
            labelAlignTo: L,
            edgeDistance: I,
            bleedMargin: F,
            rect: N,
            unconstrainedWidth: N.width,
            labelStyleWidth: w.style.width,
          })
      }
      b.setTextConfig({
        inside: ct,
      })
    }
  }),
    !a && r.get('avoidLabelOverlap') && tut(e, n, i, l, u, f, c, h)
  for (var g = 0; g < e.length; g++) {
    var v = e[g],
      m = v.label,
      y = v.labelLine,
      _ = isNaN(m.x) || isNaN(m.y)
    if (m) {
      m.setStyle({
        align: v.textAlign,
      }),
        _ && (R(m.states, d), (m.ignore = !0))
      var x = m.states.select
      x && ((x.x += m.x), (x.y += m.y))
    }
    if (y) {
      var A = v.linePoints
      _ || !A
        ? (R(y.states, d), (y.ignore = !0))
        : (tG(A, v.minTurnAngle),
          fst(A, v.surfaceNormal, v.maxSurfaceAngle),
          y.setShape({
            points: A,
          }),
          (m.__hostTarget.textGuideLineConfig = {
            anchor: new Qt(A[0][0], A[0][1]),
          }))
    }
  }
}
var nut = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this) || this
      a.z2 = 2
      var o = new Ae()
      return a.setTextContent(o), a.updateData(e, n, i, !0), a
    }
    return (
      (t.prototype.updateData = function (e, n, i, a) {
        var o = this,
          s = e.hostModel,
          l = e.getItemModel(n),
          u = l.getModel('emphasis'),
          c = e.getItemLayout(n),
          h = Q(bu(l.getModel('itemStyle'), c, !0), c)
        if (isNaN(h.startAngle)) {
          o.setShape(h)
          return
        }
        if (a) {
          o.setShape(h)
          var f = s.getShallow('animationType')
          s.ecModel.ssr
            ? (Je(
                o,
                {
                  scaleX: 0,
                  scaleY: 0,
                },
                s,
                {
                  dataIndex: n,
                  isFrom: !0,
                },
              ),
              (o.originX = h.cx),
              (o.originY = h.cy))
            : f === 'scale'
            ? ((o.shape.r = c.r0),
              Je(
                o,
                {
                  shape: {
                    r: c.r,
                  },
                },
                s,
                n,
              ))
            : i != null
            ? (o.setShape({
                startAngle: i,
                endAngle: i,
              }),
              Je(
                o,
                {
                  shape: {
                    startAngle: c.startAngle,
                    endAngle: c.endAngle,
                  },
                },
                s,
                n,
              ))
            : ((o.shape.endAngle = c.startAngle),
              we(
                o,
                {
                  shape: {
                    endAngle: c.endAngle,
                  },
                },
                s,
                n,
              ))
        } else
          Ca(o),
            we(
              o,
              {
                shape: h,
              },
              s,
              n,
            )
        o.useStyle(e.getItemVisual(n, 'style')), gr(o, l)
        var d = (c.startAngle + c.endAngle) / 2,
          p = s.get('selectedOffset'),
          g = Math.cos(d) * p,
          v = Math.sin(d) * p,
          m = l.getShallow('cursor')
        m && o.attr('cursor', m),
          this._updateLabel(s, e, n),
          (o.ensureState('emphasis').shape = Q(
            {
              r: c.r + ((u.get('scale') && u.get('scaleSize')) || 0),
            },
            bu(u.getModel('itemStyle'), c),
          )),
          Q(o.ensureState('select'), {
            x: g,
            y: v,
            shape: bu(l.getModel(['select', 'itemStyle']), c),
          }),
          Q(o.ensureState('blur'), {
            shape: bu(l.getModel(['blur', 'itemStyle']), c),
          })
        var y = o.getTextGuideLine(),
          _ = o.getTextContent()
        y &&
          Q(y.ensureState('select'), {
            x: g,
            y: v,
          }),
          Q(_.ensureState('select'), {
            x: g,
            y: v,
          }),
          fn(this, u.get('focus'), u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e, n, i) {
        var a = this,
          o = n.getItemModel(i),
          s = o.getModel('labelLine'),
          l = n.getItemVisual(i, 'style'),
          u = l && l.fill,
          c = l && l.opacity
        mr(a, Zn(o), {
          labelFetcher: n.hostModel,
          labelDataIndex: i,
          inheritColor: u,
          defaultOpacity: c,
          defaultText: e.getFormattedLabel(i, 'normal') || n.getName(i),
        })
        var h = a.getTextContent()
        a.setTextConfig({
          position: null,
          rotation: null,
        }),
          h.attr({
            z2: 10,
          })
        var f = e.get(['label', 'position'])
        if (f !== 'outside' && f !== 'outer') a.removeTextGuideLine()
        else {
          var d = this.getTextGuideLine()
          d || ((d = new li()), this.setTextGuideLine(d)),
            LC(this, PC(o), {
              stroke: u,
              opacity: ao(s.get(['lineStyle', 'opacity']), c, 1),
            })
        }
      }),
      t
    )
  })(oi),
  rut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.ignoreLabelLineUpdate = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = e.getData(),
          s = this._data,
          l = this.group,
          u
        if (!s && o.count() > 0) {
          for (
            var c = o.getItemLayout(0), h = 1;
            isNaN(c && c.startAngle) && h < o.count();
            ++h
          )
            c = o.getItemLayout(h)
          c && (u = c.startAngle)
        }
        if (
          (this._emptyCircleSector && l.remove(this._emptyCircleSector),
          o.count() === 0 && e.get('showEmptyCircle'))
        ) {
          var f = OG(e),
            d = new oi({
              shape: Q(IG(e, i), f),
            })
          d.useStyle(e.getModel('emptyCircleStyle').getItemStyle()),
            (this._emptyCircleSector = d),
            l.add(d)
        }
        o
          .diff(s)
          .add(function (p) {
            var g = new nut(o, p, u)
            o.setItemGraphicEl(p, g), l.add(g)
          })
          .update(function (p, g) {
            var v = s.getItemGraphicEl(g)
            v.updateData(o, p, u),
              v.off('click'),
              l.add(v),
              o.setItemGraphicEl(p, v)
          })
          .remove(function (p) {
            var g = s.getItemGraphicEl(p)
            Xp(g, e, p)
          })
          .execute(),
          eut(e),
          e.get('animationTypeUpdate') !== 'expansion' && (this._data = o)
      }),
      (t.prototype.dispose = function () {}),
      (t.prototype.containPoint = function (e, n) {
        var i = n.getData(),
          a = i.getItemLayout(0)
        if (a) {
          var o = e[0] - a.cx,
            s = e[1] - a.cy,
            l = Math.sqrt(o * o + s * s)
          return l <= a.r && l >= a.r0
        }
      }),
      (t.type = 'pie'),
      t
    )
  })(Ze)
const iut = rut
function Rf(r, t, e) {
  t =
    (at(t) && {
      coordDimensions: t,
    }) ||
    Q(
      {
        encodeDefine: r.getEncode(),
      },
      t,
    )
  var n = r.getSource(),
    i = wv(n, t).dimensions,
    a = new Vr(i, r)
  return a.initData(n, e), a
}
var aut = (function () {
  function r(t, e) {
    ;(this._getDataWithEncodedVisual = t), (this._getRawData = e)
  }
  return (
    (r.prototype.getAllNames = function () {
      var t = this._getRawData()
      return t.mapArray(t.getName)
    }),
    (r.prototype.containName = function (t) {
      var e = this._getRawData()
      return e.indexOfName(t) >= 0
    }),
    (r.prototype.indexOfName = function (t) {
      var e = this._getDataWithEncodedVisual()
      return e.indexOfName(t)
    }),
    (r.prototype.getItemVisual = function (t, e) {
      var n = this._getDataWithEncodedVisual()
      return n.getItemVisual(t, e)
    }),
    r
  )
})()
const Pv = aut
var out = ve(),
  sut = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.init = function (e) {
        r.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new Pv(
            Tt(this.getData, this),
            Tt(this.getRawData, this),
          )),
          this._defaultLabelLine(e)
      }),
      (t.prototype.mergeOption = function () {
        r.prototype.mergeOption.apply(this, arguments)
      }),
      (t.prototype.getInitialData = function () {
        return Rf(this, {
          coordDimensions: ['value'],
          encodeDefaulter: Zt(lC, this),
        })
      }),
      (t.prototype.getDataParams = function (e) {
        var n = this.getData(),
          i = out(n),
          a = i.seats
        if (!a) {
          var o = []
          n.each(n.mapDimension('value'), function (l) {
            o.push(l)
          }),
            (a = i.seats = ptt(o, n.hostModel.get('percentPrecision')))
        }
        var s = r.prototype.getDataParams.call(this, e)
        return (s.percent = a[e] || 0), s.$vars.push('percent'), s
      }),
      (t.prototype._defaultLabelLine = function (e) {
        Xu(e, 'labelLine', ['show'])
        var n = e.labelLine,
          i = e.emphasis.labelLine
        ;(n.show = n.show && e.label.show),
          (i.show = i.show && e.emphasis.label.show)
      }),
      (t.type = 'series.pie'),
      (t.defaultOption = {
        z: 2,
        legendHoverLink: !0,
        colorBy: 'data',
        center: ['50%', '50%'],
        radius: [0, '75%'],
        clockwise: !0,
        startAngle: 90,
        endAngle: 'auto',
        padAngle: 0,
        minAngle: 0,
        minShowLabelAngle: 0,
        selectedOffset: 10,
        percentPrecision: 2,
        stillShowZeroSum: !0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          rotate: 0,
          show: !0,
          overflow: 'truncate',
          position: 'outer',
          alignTo: 'none',
          edgeDistance: '25%',
          bleedMargin: 10,
          distanceToLabelLine: 5,
        },
        labelLine: {
          show: !0,
          length: 15,
          length2: 15,
          smooth: !1,
          minTurnAngle: 90,
          maxSurfaceAngle: 90,
          lineStyle: {
            width: 1,
            type: 'solid',
          },
        },
        itemStyle: {
          borderWidth: 1,
          borderJoin: 'round',
        },
        showEmptyCircle: !0,
        emptyCircleStyle: {
          color: 'lightgray',
          opacity: 1,
        },
        labelLayout: {
          hideOverlap: !0,
        },
        emphasis: {
          scale: !0,
          scaleSize: 5,
        },
        avoidLabelOverlap: !0,
        animationType: 'expansion',
        animationDuration: 1e3,
        animationTypeUpdate: 'transition',
        animationEasingUpdate: 'cubicInOut',
        animationDurationUpdate: 500,
        animationEasing: 'cubicInOut',
      }),
      t
    )
  })(rn)
const lut = sut
function uut(r) {
  return {
    seriesType: r,
    reset: function (t, e) {
      var n = t.getData()
      n.filterSelf(function (i) {
        var a = n.mapDimension('value'),
          o = n.get(a, i)
        return !(be(o) && !isNaN(o) && o < 0)
      })
    },
  }
}
function cut(r) {
  r.registerChartView(iut),
    r.registerSeriesModel(lut),
    K5('pie', r.registerAction),
    r.registerLayout(Zt(Jlt, 'pie')),
    r.registerProcessor(Lv('pie')),
    r.registerProcessor(uut('pie'))
}
var hut = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getProgressive = function () {
      var e = this.option.progressive
      return e ?? (this.option.large ? 5e3 : this.get('progressive'))
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.option.progressiveThreshold
      return e ?? (this.option.large ? 1e4 : this.get('progressiveThreshold'))
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.point(n.getItemLayout(e))
    }),
    (t.prototype.getZLevelKey = function () {
      return this.getData().count() > this.getProgressiveThreshold()
        ? this.id
        : ''
    }),
    (t.type = 'series.scatter'),
    (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      large: !1,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8,
      },
      emphasis: {
        scale: !0,
      },
      clip: !0,
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      universalTransition: {
        divideShape: 'clone',
      },
    }),
    t
  )
})(rn)
const fut = hut
var kG = 4,
  dut = (function () {
    function r() {}
    return r
  })(),
  put = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n._off = 0), (n.hoverDataIdx = -1), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new dut()
      }),
      (t.prototype.reset = function () {
        ;(this.notClear = !1), (this._off = 0)
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = n.size,
          o = this.symbolProxy,
          s = o.shape,
          l = e.getContext ? e.getContext() : e,
          u = l && a[0] < kG,
          c = this.softClipShape,
          h
        if (u) {
          this._ctx = l
          return
        }
        for (this._ctx = null, h = this._off; h < i.length; ) {
          var f = i[h++],
            d = i[h++]
          isNaN(f) ||
            isNaN(d) ||
            (c && !c.contain(f, d)) ||
            ((s.x = f - a[0] / 2),
            (s.y = d - a[1] / 2),
            (s.width = a[0]),
            (s.height = a[1]),
            o.buildPath(e, s, !0))
        }
        this.incremental && ((this._off = h), (this.notClear = !0))
      }),
      (t.prototype.afterBrush = function () {
        var e = this.shape,
          n = e.points,
          i = e.size,
          a = this._ctx,
          o = this.softClipShape,
          s
        if (a) {
          for (s = this._off; s < n.length; ) {
            var l = n[s++],
              u = n[s++]
            isNaN(l) ||
              isNaN(u) ||
              (o && !o.contain(l, u)) ||
              a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1])
          }
          this.incremental && ((this._off = s), (this.notClear = !0))
        }
      }),
      (t.prototype.findDataIndex = function (e, n) {
        for (
          var i = this.shape,
            a = i.points,
            o = i.size,
            s = Math.max(o[0], 4),
            l = Math.max(o[1], 4),
            u = a.length / 2 - 1;
          u >= 0;
          u--
        ) {
          var c = u * 2,
            h = a[c] - s / 2,
            f = a[c + 1] - l / 2
          if (e >= h && n >= f && e <= h + s && n <= f + l) return u
        }
        return -1
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        if (((e = i[0]), (n = i[1]), a.contain(e, n))) {
          var o = (this.hoverDataIdx = this.findDataIndex(e, n))
          return o >= 0
        }
        return (this.hoverDataIdx = -1), !1
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect
        if (!e) {
          for (
            var n = this.shape,
              i = n.points,
              a = n.size,
              o = a[0],
              s = a[1],
              l = 1 / 0,
              u = 1 / 0,
              c = -1 / 0,
              h = -1 / 0,
              f = 0;
            f < i.length;

          ) {
            var d = i[f++],
              p = i[f++]
            ;(l = Math.min(d, l)),
              (c = Math.max(d, c)),
              (u = Math.min(p, u)),
              (h = Math.max(p, h))
          }
          e = this._rect = new ee(l - o / 2, u - s / 2, c - l + o, h - u + s)
        }
        return e
      }),
      t
    )
  })(oe),
  vut = (function () {
    function r() {
      this.group = new Ht()
    }
    return (
      (r.prototype.updateData = function (t, e) {
        this._clear()
        var n = this._create()
        n.setShape({
          points: t.getLayout('points'),
        }),
          this._setCommon(n, t, e)
      }),
      (r.prototype.updateLayout = function (t) {
        var e = t.getLayout('points')
        this.group.eachChild(function (n) {
          if (n.startIndex != null) {
            var i = (n.endIndex - n.startIndex) * 2,
              a = n.startIndex * 4 * 2
            e = new Float32Array(e.buffer, a, i)
          }
          n.setShape('points', e), n.reset()
        })
      }),
      (r.prototype.incrementalPrepareUpdate = function (t) {
        this._clear()
      }),
      (r.prototype.incrementalUpdate = function (t, e, n) {
        var i = this._newAdded[0],
          a = e.getLayout('points'),
          o = i && i.shape.points
        if (o && o.length < 2e4) {
          var s = o.length,
            l = new Float32Array(s + a.length)
          l.set(o),
            l.set(a, s),
            (i.endIndex = t.end),
            i.setShape({
              points: l,
            })
        } else {
          this._newAdded = []
          var u = this._create()
          ;(u.startIndex = t.start),
            (u.endIndex = t.end),
            (u.incremental = !0),
            u.setShape({
              points: a,
            }),
            this._setCommon(u, e, n)
        }
      }),
      (r.prototype.eachRendered = function (t) {
        this._newAdded[0] && t(this._newAdded[0])
      }),
      (r.prototype._create = function () {
        var t = new put({
          cursor: 'default',
        })
        return (
          (t.ignoreCoarsePointer = !0),
          this.group.add(t),
          this._newAdded.push(t),
          t
        )
      }),
      (r.prototype._setCommon = function (t, e, n) {
        var i = e.hostModel
        n = n || {}
        var a = e.getVisual('symbolSize')
        t.setShape('size', a instanceof Array ? a : [a, a]),
          (t.softClipShape = n.clipShape || null),
          (t.symbolProxy = Rn(e.getVisual('symbol'), 0, 0, 0, 0)),
          (t.setColor = t.symbolProxy.setColor)
        var o = t.shape.size[0] < kG
        t.useStyle(
          i
            .getModel('itemStyle')
            .getItemStyle(
              o ? ['color', 'shadowBlur', 'shadowColor'] : ['color'],
            ),
        )
        var s = e.getVisual('style'),
          l = s && s.fill
        l && t.setColor(l)
        var u = Wt(t)
        ;(u.seriesIndex = i.seriesIndex),
          t.on('mousemove', function (c) {
            u.dataIndex = null
            var h = t.hoverDataIdx
            h >= 0 && (u.dataIndex = h + (t.startIndex || 0))
          })
      }),
      (r.prototype.remove = function () {
        this._clear()
      }),
      (r.prototype._clear = function () {
        ;(this._newAdded = []), this.group.removeAll()
      }),
      r
    )
  })()
const gut = vut
var mut = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._updateSymbolDraw(a, e)
      o.updateData(a, {
        clipShape: this._getClipShape(e),
      }),
        (this._finished = !0)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      var a = e.getData(),
        o = this._updateSymbolDraw(a, e)
      o.incrementalPrepareUpdate(a), (this._finished = !1)
    }),
    (t.prototype.incrementalRender = function (e, n, i) {
      this._symbolDraw.incrementalUpdate(e, n.getData(), {
        clipShape: this._getClipShape(n),
      }),
        (this._finished = e.end === n.getData().count())
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData()
      if ((this.group.dirty(), !this._finished || a.count() > 1e4))
        return {
          update: !0,
        }
      var o = Dv('').reset(e, n, i)
      o.progress &&
        o.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._symbolDraw.updateLayout(a)
    }),
    (t.prototype.eachRendered = function (e) {
      this._symbolDraw && this._symbolDraw.eachRendered(e)
    }),
    (t.prototype._getClipShape = function (e) {
      if (e.get('clip', !0)) {
        var n = e.coordinateSystem
        return n && n.getArea && n.getArea(0.1)
      }
    }),
    (t.prototype._updateSymbolDraw = function (e, n) {
      var i = this._symbolDraw,
        a = n.pipelineContext,
        o = a.large
      return (
        (!i || o !== this._isLargeDraw) &&
          (i && i.remove(),
          (i = this._symbolDraw = o ? new gut() : new Cv()),
          (this._isLargeDraw = o),
          this.group.removeAll()),
        this.group.add(i.group),
        i
      )
    }),
    (t.prototype.remove = function (e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), (this._symbolDraw = null)
    }),
    (t.prototype.dispose = function () {}),
    (t.type = 'scatter'),
    t
  )
})(Ze)
const yut = mut
var _ut = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.type = 'grid'),
    (t.dependencies = ['xAxis', 'yAxis']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      show: !1,
      z: 0,
      left: '10%',
      top: 60,
      right: '10%',
      bottom: 70,
      containLabel: !1,
      backgroundColor: 'rgba(0,0,0,0)',
      borderWidth: 1,
      borderColor: '#ccc',
    }),
    t
  )
})(xe)
const xut = _ut
var Pw = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this.getReferringComponents('grid', Pn).models[0]
    }),
    (t.type = 'cartesian2dAxis'),
    t
  )
})(xe)
In(Pw, Mv)
var BG = {
    show: !0,
    z: 0,
    inverse: !1,
    name: '',
    nameLocation: 'end',
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: '...',
      placeholder: '.',
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: !1,
    triggerEvent: !1,
    tooltip: {
      show: !1,
    },
    axisPointer: {},
    axisLine: {
      show: !0,
      onZero: !0,
      onZeroAxisIndex: null,
      lineStyle: {
        color: '#6E7079',
        width: 1,
        type: 'solid',
      },
      symbol: ['none', 'none'],
      symbolSize: [10, 15],
    },
    axisTick: {
      show: !0,
      inside: !1,
      length: 5,
      lineStyle: {
        width: 1,
      },
    },
    axisLabel: {
      show: !0,
      inside: !1,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12,
    },
    splitLine: {
      show: !0,
      lineStyle: {
        color: ['#E0E6F1'],
        width: 1,
        type: 'solid',
      },
    },
    splitArea: {
      show: !1,
      areaStyle: {
        color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)'],
      },
    },
  },
  Sut = te(
    {
      boundaryGap: !0,
      deduplication: null,
      splitLine: {
        show: !1,
      },
      axisTick: {
        alignWithLabel: !1,
        interval: 'auto',
      },
      axisLabel: {
        interval: 'auto',
      },
    },
    BG,
  ),
  BC = te(
    {
      boundaryGap: [0, 0],
      axisLine: {
        show: 'auto',
      },
      axisTick: {
        show: 'auto',
      },
      splitNumber: 5,
      minorTick: {
        show: !1,
        splitNumber: 5,
        length: 3,
        lineStyle: {},
      },
      minorSplitLine: {
        show: !1,
        lineStyle: {
          color: '#F4F7FD',
          width: 1,
        },
      },
    },
    BG,
  ),
  Aut = te(
    {
      splitNumber: 6,
      axisLabel: {
        showMinLabel: !1,
        showMaxLabel: !1,
        rich: {
          primary: {
            fontWeight: 'bold',
          },
        },
      },
      splitLine: {
        show: !1,
      },
    },
    BC,
  ),
  but = zt(
    {
      logBase: 10,
    },
    BC,
  )
const FG = {
  category: Sut,
  value: BC,
  time: Aut,
  log: but,
}
var wut = {
  value: 1,
  category: 1,
  time: 1,
  log: 1,
}
function sf(r, t, e, n) {
  R(wut, function (i, a) {
    var o = te(te({}, FG[a], !0), n, !0),
      s = (function (l) {
        X(u, l)
        function u() {
          var c = (l !== null && l.apply(this, arguments)) || this
          return (c.type = t + 'Axis.' + a), c
        }
        return (
          (u.prototype.mergeDefaultAndTheme = function (c, h) {
            var f = $p(this),
              d = f ? Mf(c) : {},
              p = h.getTheme()
            te(c, p.get(a + 'Axis')),
              te(c, this.getDefaultOption()),
              (c.type = YI(c)),
              f && ol(c, d, f)
          }),
          (u.prototype.optionUpdated = function () {
            var c = this.option
            c.type === 'category' &&
              (this.__ordinalMeta = ww.createByAxisModel(this))
          }),
          (u.prototype.getCategories = function (c) {
            var h = this.option
            if (h.type === 'category')
              return c ? h.data : this.__ordinalMeta.categories
          }),
          (u.prototype.getOrdinalMeta = function () {
            return this.__ordinalMeta
          }),
          (u.type = t + 'Axis.' + a),
          (u.defaultOption = o),
          u
        )
      })(e)
    r.registerComponentModel(s)
  }),
    r.registerSubTypeDefaulter(t + 'Axis', YI)
}
function YI(r) {
  return r.type || (r.data ? 'category' : 'value')
}
var Mut = (function () {
  function r(t) {
    ;(this.type = 'cartesian'),
      (this._dimList = []),
      (this._axes = {}),
      (this.name = t || '')
  }
  return (
    (r.prototype.getAxis = function (t) {
      return this._axes[t]
    }),
    (r.prototype.getAxes = function () {
      return st(
        this._dimList,
        function (t) {
          return this._axes[t]
        },
        this,
      )
    }),
    (r.prototype.getAxesByScale = function (t) {
      return (
        (t = t.toLowerCase()),
        Ne(this.getAxes(), function (e) {
          return e.scale.type === t
        })
      )
    }),
    (r.prototype.addAxis = function (t) {
      var e = t.dim
      ;(this._axes[e] = t), this._dimList.push(e)
    }),
    r
  )
})()
const Tut = Mut
var Rw = ['x', 'y']
function $I(r) {
  return r.type === 'interval' || r.type === 'time'
}
var Cut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'cartesian2d'), (e.dimensions = Rw), e
    }
    return (
      (t.prototype.calcAffineTransform = function () {
        this._transform = this._invTransform = null
        var e = this.getAxis('x').scale,
          n = this.getAxis('y').scale
        if (!(!$I(e) || !$I(n))) {
          var i = e.getExtent(),
            a = n.getExtent(),
            o = this.dataToPoint([i[0], a[0]]),
            s = this.dataToPoint([i[1], a[1]]),
            l = i[1] - i[0],
            u = a[1] - a[0]
          if (!(!l || !u)) {
            var c = (s[0] - o[0]) / l,
              h = (s[1] - o[1]) / u,
              f = o[0] - i[0] * c,
              d = o[1] - a[0] * h,
              p = (this._transform = [c, 0, 0, h, f, d])
            this._invTransform = mf([], p)
          }
        }
      }),
      (t.prototype.getBaseAxis = function () {
        return (
          this.getAxesByScale('ordinal')[0] ||
          this.getAxesByScale('time')[0] ||
          this.getAxis('x')
        )
      }),
      (t.prototype.containPoint = function (e) {
        var n = this.getAxis('x'),
          i = this.getAxis('y')
        return (
          n.contain(n.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]))
        )
      }),
      (t.prototype.containData = function (e) {
        return (
          this.getAxis('x').containData(e[0]) &&
          this.getAxis('y').containData(e[1])
        )
      }),
      (t.prototype.containZone = function (e, n) {
        var i = this.dataToPoint(e),
          a = this.dataToPoint(n),
          o = this.getArea(),
          s = new ee(i[0], i[1], a[0] - i[0], a[1] - i[1])
        return o.intersect(s)
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        i = i || []
        var a = e[0],
          o = e[1]
        if (
          this._transform &&
          a != null &&
          isFinite(a) &&
          o != null &&
          isFinite(o)
        )
          return pr(i, e, this._transform)
        var s = this.getAxis('x'),
          l = this.getAxis('y')
        return (
          (i[0] = s.toGlobalCoord(s.dataToCoord(a, n))),
          (i[1] = l.toGlobalCoord(l.dataToCoord(o, n))),
          i
        )
      }),
      (t.prototype.clampData = function (e, n) {
        var i = this.getAxis('x').scale,
          a = this.getAxis('y').scale,
          o = i.getExtent(),
          s = a.getExtent(),
          l = i.parse(e[0]),
          u = a.parse(e[1])
        return (
          (n = n || []),
          (n[0] = Math.min(
            Math.max(Math.min(o[0], o[1]), l),
            Math.max(o[0], o[1]),
          )),
          (n[1] = Math.min(
            Math.max(Math.min(s[0], s[1]), u),
            Math.max(s[0], s[1]),
          )),
          n
        )
      }),
      (t.prototype.pointToData = function (e, n) {
        var i = []
        if (this._invTransform) return pr(i, e, this._invTransform)
        var a = this.getAxis('x'),
          o = this.getAxis('y')
        return (
          (i[0] = a.coordToData(a.toLocalCoord(e[0]), n)),
          (i[1] = o.coordToData(o.toLocalCoord(e[1]), n)),
          i
        )
      }),
      (t.prototype.getOtherAxis = function (e) {
        return this.getAxis(e.dim === 'x' ? 'y' : 'x')
      }),
      (t.prototype.getArea = function (e) {
        e = e || 0
        var n = this.getAxis('x').getGlobalExtent(),
          i = this.getAxis('y').getGlobalExtent(),
          a = Math.min(n[0], n[1]) - e,
          o = Math.min(i[0], i[1]) - e,
          s = Math.max(n[0], n[1]) - a + e,
          l = Math.max(i[0], i[1]) - o + e
        return new ee(a, o, s, l)
      }),
      t
    )
  })(Tut),
  Eut = (function (r) {
    X(t, r)
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this
      return (
        (s.index = 0), (s.type = a || 'value'), (s.position = o || 'bottom'), s
      )
    }
    return (
      (t.prototype.isHorizontal = function () {
        var e = this.position
        return e === 'top' || e === 'bottom'
      }),
      (t.prototype.getGlobalExtent = function (e) {
        var n = this.getExtent()
        return (
          (n[0] = this.toGlobalCoord(n[0])),
          (n[1] = this.toGlobalCoord(n[1])),
          e && n[0] > n[1] && n.reverse(),
          n
        )
      }),
      (t.prototype.pointToData = function (e, n) {
        return this.coordToData(
          this.toLocalCoord(e[this.dim === 'x' ? 0 : 1]),
          n,
        )
      }),
      (t.prototype.setCategorySortInfo = function (e) {
        if (this.type !== 'category') return !1
        ;(this.model.option.categorySortInfo = e), this.scale.setSortInfo(e)
      }),
      t
    )
  })(Ra)
const Dut = Eut
function Iw(r, t, e) {
  e = e || {}
  var n = r.coordinateSystem,
    i = t.axis,
    a = {},
    o = i.getAxesOnZeroOf()[0],
    s = i.position,
    l = o ? 'onZero' : s,
    u = i.dim,
    c = n.getRect(),
    h = [c.x, c.x + c.width, c.y, c.y + c.height],
    f = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2,
    },
    d = t.get('offset') || 0,
    p = u === 'x' ? [h[2] - d, h[3] + d] : [h[0] - d, h[1] + d]
  if (o) {
    var g = o.toGlobalCoord(o.dataToCoord(0))
    p[f.onZero] = Math.max(Math.min(g, p[1]), p[0])
  }
  ;(a.position = [u === 'y' ? p[f[l]] : h[0], u === 'x' ? p[f[l]] : h[3]]),
    (a.rotation = (Math.PI / 2) * (u === 'x' ? 0 : 1))
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1,
  }
  ;(a.labelDirection = a.tickDirection = a.nameDirection = v[s]),
    (a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0),
    t.get(['axisTick', 'inside']) && (a.tickDirection = -a.tickDirection),
    nr(e.labelInside, t.get(['axisLabel', 'inside'])) &&
      (a.labelDirection = -a.labelDirection)
  var m = t.get(['axisLabel', 'rotate'])
  return (a.labelRotate = l === 'top' ? -m : m), (a.z2 = 1), a
}
function qI(r) {
  return r.get('coordinateSystem') === 'cartesian2d'
}
function ZI(r) {
  var t = {
    xAxisModel: null,
    yAxisModel: null,
  }
  return (
    R(t, function (e, n) {
      var i = n.replace(/Model$/, ''),
        a = r.getReferringComponents(i, Pn).models[0]
      t[n] = a
    }),
    t
  )
}
var oS = Math.log
function zG(r, t, e) {
  var n = ll.prototype,
    i = n.getTicks.call(e),
    a = n.getTicks.call(e, !0),
    o = i.length - 1,
    s = n.getInterval.call(e),
    l = VV(r, t),
    u = l.extent,
    c = l.fixMin,
    h = l.fixMax
  if (r.type === 'log') {
    var f = oS(r.base)
    u = [oS(u[0]) / f, oS(u[1]) / f]
  }
  r.setExtent(u[0], u[1]),
    r.calcNiceExtent({
      splitNumber: o,
      fixMin: c,
      fixMax: h,
    })
  var d = n.getExtent.call(r)
  c && (u[0] = d[0]), h && (u[1] = d[1])
  var p = n.getInterval.call(r),
    g = u[0],
    v = u[1]
  if (c && h) p = (v - g) / o
  else if (c)
    for (v = u[0] + p * o; v < u[1] && isFinite(v) && isFinite(u[1]); )
      (p = X1(p)), (v = u[0] + p * o)
  else if (h)
    for (g = u[1] - p * o; g > u[0] && isFinite(g) && isFinite(u[0]); )
      (p = X1(p)), (g = u[1] - p * o)
  else {
    var m = r.getTicks().length - 1
    m > o && (p = X1(p))
    var y = p * o
    ;(v = Math.ceil(u[1] / p) * p),
      (g = mn(v - y)),
      g < 0 && u[0] >= 0
        ? ((g = 0), (v = mn(y)))
        : v > 0 && u[1] <= 0 && ((v = 0), (g = -mn(y)))
  }
  var _ = (i[0].value - a[0].value) / s,
    x = (i[o].value - a[o].value) / s
  n.setExtent.call(r, g + p * _, v + p * x),
    n.setInterval.call(r, p),
    (_ || x) && n.setNiceExtent.call(r, g + p, v - p)
}
var Lut = (function () {
  function r(t, e, n) {
    ;(this.type = 'grid'),
      (this._coordsMap = {}),
      (this._coordsList = []),
      (this._axesMap = {}),
      (this._axesList = []),
      (this.axisPointerEnabled = !0),
      (this.dimensions = Rw),
      this._initCartesian(t, e, n),
      (this.model = t)
  }
  return (
    (r.prototype.getRect = function () {
      return this._rect
    }),
    (r.prototype.update = function (t, e) {
      var n = this._axesMap
      this._updateScale(t, this.model)
      function i(o) {
        var s,
          l = pe(o),
          u = l.length
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h],
              d = o[f],
              p = d.model,
              g = d.scale
            Mw(g) && p.get('alignTicks') && p.get('interval') == null
              ? c.push(d)
              : (af(g, p), Mw(g) && (s = d))
          }
          c.length &&
            (s || ((s = c.pop()), af(s.scale, s.model)),
            R(c, function (v) {
              zG(v.scale, v.model, s.scale)
            }))
        }
      }
      i(n.x), i(n.y)
      var a = {}
      R(n.x, function (o) {
        KI(n, 'y', o, a)
      }),
        R(n.y, function (o) {
          KI(n, 'x', o, a)
        }),
        this.resize(this.model, e)
    }),
    (r.prototype.resize = function (t, e, n) {
      var i = t.getBoxLayoutParams(),
        a = !n && t.get('containLabel'),
        o = Vn(i, {
          width: e.getWidth(),
          height: e.getHeight(),
        })
      this._rect = o
      var s = this._axesList
      l(),
        a &&
          (R(s, function (u) {
            if (!u.model.get(['axisLabel', 'inside'])) {
              var c = Got(u)
              if (c) {
                var h = u.isHorizontal() ? 'height' : 'width',
                  f = u.model.get(['axisLabel', 'margin'])
                ;(o[h] -= c[h] + f),
                  u.position === 'top'
                    ? (o.y += c.height + f)
                    : u.position === 'left' && (o.x += c.width + f)
              }
            }
          }),
          l()),
        R(this._coordsList, function (u) {
          u.calcAffineTransform()
        })
      function l() {
        R(s, function (u) {
          var c = u.isHorizontal(),
            h = c ? [0, o.width] : [0, o.height],
            f = u.inverse ? 1 : 0
          u.setExtent(h[f], h[1 - f]), Put(u, c ? o.x : o.y)
        })
      }
    }),
    (r.prototype.getAxis = function (t, e) {
      var n = this._axesMap[t]
      if (n != null) return n[e || 0]
    }),
    (r.prototype.getAxes = function () {
      return this._axesList.slice()
    }),
    (r.prototype.getCartesian = function (t, e) {
      if (t != null && e != null) {
        var n = 'x' + t + 'y' + e
        return this._coordsMap[n]
      }
      Ut(t) && ((e = t.yAxisIndex), (t = t.xAxisIndex))
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis('x').index === t || a[i].getAxis('y').index === e)
          return a[i]
    }),
    (r.prototype.getCartesians = function () {
      return this._coordsList.slice()
    }),
    (r.prototype.convertToPixel = function (t, e, n) {
      var i = this._findConvertTarget(e)
      return i.cartesian
        ? i.cartesian.dataToPoint(n)
        : i.axis
        ? i.axis.toGlobalCoord(i.axis.dataToCoord(n))
        : null
    }),
    (r.prototype.convertFromPixel = function (t, e, n) {
      var i = this._findConvertTarget(e)
      return i.cartesian
        ? i.cartesian.pointToData(n)
        : i.axis
        ? i.axis.coordToData(i.axis.toLocalCoord(n))
        : null
    }),
    (r.prototype._findConvertTarget = function (t) {
      var e = t.seriesModel,
        n =
          t.xAxisModel ||
          (e && e.getReferringComponents('xAxis', Pn).models[0]),
        i =
          t.yAxisModel ||
          (e && e.getReferringComponents('yAxis', Pn).models[0]),
        a = t.gridModel,
        o = this._coordsList,
        s,
        l
      if (e) (s = e.coordinateSystem), re(o, s) < 0 && (s = null)
      else if (n && i) s = this.getCartesian(n.componentIndex, i.componentIndex)
      else if (n) l = this.getAxis('x', n.componentIndex)
      else if (i) l = this.getAxis('y', i.componentIndex)
      else if (a) {
        var u = a.coordinateSystem
        u === this && (s = this._coordsList[0])
      }
      return {
        cartesian: s,
        axis: l,
      }
    }),
    (r.prototype.containPoint = function (t) {
      var e = this._coordsList[0]
      if (e) return e.containPoint(t)
    }),
    (r.prototype._initCartesian = function (t, e, n) {
      var i = this,
        a = this,
        o = {
          left: !1,
          right: !1,
          top: !1,
          bottom: !1,
        },
        s = {
          x: {},
          y: {},
        },
        l = {
          x: 0,
          y: 0,
        }
      if (
        (e.eachComponent('xAxis', u('x'), this),
        e.eachComponent('yAxis', u('y'), this),
        !l.x || !l.y)
      ) {
        ;(this._axesMap = {}), (this._axesList = [])
        return
      }
      ;(this._axesMap = s),
        R(s.x, function (c, h) {
          R(s.y, function (f, d) {
            var p = 'x' + h + 'y' + d,
              g = new Cut(p)
            ;(g.master = i),
              (g.model = t),
              (i._coordsMap[p] = g),
              i._coordsList.push(g),
              g.addAxis(c),
              g.addAxis(f)
          })
        })
      function u(c) {
        return function (h, f) {
          if (sS(h, t)) {
            var d = h.get('position')
            c === 'x'
              ? d !== 'top' &&
                d !== 'bottom' &&
                (d = o.bottom ? 'top' : 'bottom')
              : d !== 'left' &&
                d !== 'right' &&
                (d = o.left ? 'right' : 'left'),
              (o[d] = !0)
            var p = new Dut(c, w_(h), [0, 0], h.get('type'), d),
              g = p.type === 'category'
            ;(p.onBand = g && h.get('boundaryGap')),
              (p.inverse = h.get('inverse')),
              (h.axis = p),
              (p.model = h),
              (p.grid = a),
              (p.index = f),
              a._axesList.push(p),
              (s[c][f] = p),
              l[c]++
          }
        }
      }
    }),
    (r.prototype._updateScale = function (t, e) {
      R(this._axesList, function (i) {
        if ((i.scale.setExtent(1 / 0, -1 / 0), i.type === 'category')) {
          var a = i.model.get('categorySortInfo')
          i.scale.setSortInfo(a)
        }
      }),
        t.eachSeries(function (i) {
          if (qI(i)) {
            var a = ZI(i),
              o = a.xAxisModel,
              s = a.yAxisModel
            if (!sS(o, e) || !sS(s, e)) return
            var l = this.getCartesian(o.componentIndex, s.componentIndex),
              u = i.getData(),
              c = l.getAxis('x'),
              h = l.getAxis('y')
            n(u, c), n(u, h)
          }
        }, this)
      function n(i, a) {
        R(o0(i, a.dim), function (o) {
          a.scale.unionExtentFromData(i, o)
        })
      }
    }),
    (r.prototype.getTooltipAxes = function (t) {
      var e = [],
        n = []
      return (
        R(this.getCartesians(), function (i) {
          var a = t != null && t !== 'auto' ? i.getAxis(t) : i.getBaseAxis(),
            o = i.getOtherAxis(a)
          re(e, a) < 0 && e.push(a), re(n, o) < 0 && n.push(o)
        }),
        {
          baseAxes: e,
          otherAxes: n,
        }
      )
    }),
    (r.create = function (t, e) {
      var n = []
      return (
        t.eachComponent('grid', function (i, a) {
          var o = new r(i, t, e)
          ;(o.name = 'grid_' + a),
            o.resize(i, e, !0),
            (i.coordinateSystem = o),
            n.push(o)
        }),
        t.eachSeries(function (i) {
          if (qI(i)) {
            var a = ZI(i),
              o = a.xAxisModel,
              s = a.yAxisModel,
              l = o.getCoordSysModel(),
              u = l.coordinateSystem
            i.coordinateSystem = u.getCartesian(
              o.componentIndex,
              s.componentIndex,
            )
          }
        }),
        n
      )
    }),
    (r.dimensions = Rw),
    r
  )
})()
function sS(r, t) {
  return r.getCoordSysModel() === t
}
function KI(r, t, e, n) {
  e.getAxesOnZeroOf = function () {
    return a ? [a] : []
  }
  var i = r[t],
    a,
    o = e.model,
    s = o.get(['axisLine', 'onZero']),
    l = o.get(['axisLine', 'onZeroAxisIndex'])
  if (!s) return
  if (l != null) jI(i[l]) && (a = i[l])
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && jI(i[u]) && !n[c(i[u])]) {
        a = i[u]
        break
      }
  a && (n[c(a)] = !0)
  function c(h) {
    return h.dim + '_' + h.index
  }
}
function jI(r) {
  return r && r.type !== 'category' && r.type !== 'time' && Vot(r)
}
function Put(r, t) {
  var e = r.getExtent(),
    n = e[0] + e[1]
  ;(r.toGlobalCoord =
    r.dim === 'x'
      ? function (i) {
          return i + t
        }
      : function (i) {
          return n - i + t
        }),
    (r.toLocalCoord =
      r.dim === 'x'
        ? function (i) {
            return i - t
          }
        : function (i) {
            return n - i + t
          })
}
const Rut = Lut
var Gs = Math.PI,
  Fu = (function () {
    function r(t, e) {
      ;(this.group = new Ht()),
        (this.opt = e),
        (this.axisModel = t),
        zt(e, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: !0,
          handleAutoShown: function () {
            return !0
          },
        })
      var n = new Ht({
        x: e.position[0],
        y: e.position[1],
        rotation: e.rotation,
      })
      n.updateTransform(), (this._transformGroup = n)
    }
    return (
      (r.prototype.hasBuilder = function (t) {
        return !!JI[t]
      }),
      (r.prototype.add = function (t) {
        JI[t](this.opt, this.axisModel, this.group, this._transformGroup)
      }),
      (r.prototype.getGroup = function () {
        return this.group
      }),
      (r.innerTextLayout = function (t, e, n) {
        var i = kz(e - t),
          a,
          o
        return (
          Up(i)
            ? ((o = n > 0 ? 'top' : 'bottom'), (a = 'center'))
            : Up(i - Gs)
            ? ((o = n > 0 ? 'bottom' : 'top'), (a = 'center'))
            : ((o = 'middle'),
              i > 0 && i < Gs
                ? (a = n > 0 ? 'right' : 'left')
                : (a = n > 0 ? 'left' : 'right')),
          {
            rotation: i,
            textAlign: a,
            textVerticalAlign: o,
          }
        )
      }),
      (r.makeAxisEventDataBase = function (t) {
        var e = {
          componentType: t.mainType,
          componentIndex: t.componentIndex,
        }
        return (e[t.mainType + 'Index'] = t.componentIndex), e
      }),
      (r.isLabelSilent = function (t) {
        var e = t.get('tooltip')
        return t.get('silent') || !(t.get('triggerEvent') || (e && e.show))
      }),
      r
    )
  })(),
  JI = {
    axisLine: function (r, t, e, n) {
      var i = t.get(['axisLine', 'show'])
      if (
        (i === 'auto' &&
          r.handleAutoShown &&
          (i = r.handleAutoShown('axisLine')),
        !!i)
      ) {
        var a = t.axis.getExtent(),
          o = n.transform,
          s = [a[0], 0],
          l = [a[1], 0],
          u = s[0] > l[0]
        o && (pr(s, s, o), pr(l, l, o))
        var c = Q(
            {
              lineCap: 'round',
            },
            t.getModel(['axisLine', 'lineStyle']).getLineStyle(),
          ),
          h = new rr({
            shape: {
              x1: s[0],
              y1: s[1],
              x2: l[0],
              y2: l[1],
            },
            style: c,
            strokeContainThreshold: r.strokeContainThreshold || 5,
            silent: !0,
            z2: 1,
          })
        ef(h.shape, h.style.lineWidth), (h.anid = 'line'), e.add(h)
        var f = t.get(['axisLine', 'symbol'])
        if (f != null) {
          var d = t.get(['axisLine', 'symbolSize'])
          bt(f) && (f = [f, f]), (bt(d) || be(d)) && (d = [d, d])
          var p = ic(t.get(['axisLine', 'symbolOffset']) || 0, d),
            g = d[0],
            v = d[1]
          R(
            [
              {
                rotate: r.rotation + Math.PI / 2,
                offset: p[0],
                r: 0,
              },
              {
                rotate: r.rotation - Math.PI / 2,
                offset: p[1],
                r: Math.sqrt(
                  (s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]),
                ),
              },
            ],
            function (m, y) {
              if (f[y] !== 'none' && f[y] != null) {
                var _ = Rn(f[y], -g / 2, -v / 2, g, v, c.stroke, !0),
                  x = m.r + m.offset,
                  A = u ? l : s
                _.attr({
                  rotation: m.rotate,
                  x: A[0] + x * Math.cos(r.rotation),
                  y: A[1] - x * Math.sin(r.rotation),
                  silent: !0,
                  z2: 11,
                }),
                  e.add(_)
              }
            },
          )
        }
      }
    },
    axisTickLabel: function (r, t, e, n) {
      var i = Nut(e, n, t, r),
        a = But(e, n, t, r)
      if (
        (Out(t, a, i),
        kut(e, n, t, r.tickDirection),
        t.get(['axisLabel', 'hideOverlap']))
      ) {
        var o = eG(
          st(a, function (s) {
            return {
              label: s,
              priority: s.z2,
              defaultAttr: {
                ignore: s.ignore,
              },
            }
          }),
        )
        iG(o)
      }
    },
    axisName: function (r, t, e, n) {
      var i = nr(r.axisName, t.get('name'))
      if (i) {
        var a = t.get('nameLocation'),
          o = r.nameDirection,
          s = t.getModel('nameTextStyle'),
          l = t.get('nameGap') || 0,
          u = t.axis.getExtent(),
          c = u[0] > u[1] ? -1 : 1,
          h = [
            a === 'start'
              ? u[0] - c * l
              : a === 'end'
              ? u[1] + c * l
              : (u[0] + u[1]) / 2,
            tO(a) ? r.labelOffset + o * l : 0,
          ],
          f,
          d = t.get('nameRotate')
        d != null && (d = (d * Gs) / 180)
        var p
        tO(a)
          ? (f = Fu.innerTextLayout(r.rotation, d ?? r.rotation, o))
          : ((f = Iut(r.rotation, a, d || 0, u)),
            (p = r.axisNameAvailableWidth),
            p != null &&
              ((p = Math.abs(p / Math.sin(f.rotation))),
              !isFinite(p) && (p = null)))
        var g = s.getFont(),
          v = t.get('nameTruncate', !0) || {},
          m = v.ellipsis,
          y = nr(r.nameTruncateMaxWidth, v.maxWidth, p),
          _ = new Ae({
            x: h[0],
            y: h[1],
            rotation: f.rotation,
            silent: Fu.isLabelSilent(t),
            style: $e(s, {
              text: i,
              font: g,
              overflow: 'truncate',
              width: y,
              ellipsis: m,
              fill:
                s.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              align: s.get('align') || f.textAlign,
              verticalAlign: s.get('verticalAlign') || f.textVerticalAlign,
            }),
            z2: 1,
          })
        if (
          (Sf({
            el: _,
            componentModel: t,
            itemName: i,
          }),
          (_.__fullText = i),
          (_.anid = 'name'),
          t.get('triggerEvent'))
        ) {
          var x = Fu.makeAxisEventDataBase(t)
          ;(x.targetType = 'axisName'), (x.name = i), (Wt(_).eventData = x)
        }
        n.add(_), _.updateTransform(), e.add(_), _.decomposeTransform()
      }
    },
  }
function Iut(r, t, e, n) {
  var i = kz(e - r),
    a,
    o,
    s = n[0] > n[1],
    l = (t === 'start' && !s) || (t !== 'start' && s)
  return (
    Up(i - Gs / 2)
      ? ((o = l ? 'bottom' : 'top'), (a = 'center'))
      : Up(i - Gs * 1.5)
      ? ((o = l ? 'top' : 'bottom'), (a = 'center'))
      : ((o = 'middle'),
        i < Gs * 1.5 && i > Gs / 2
          ? (a = l ? 'left' : 'right')
          : (a = l ? 'right' : 'left')),
    {
      rotation: i,
      textAlign: a,
      textVerticalAlign: o,
    }
  )
}
function Out(r, t, e) {
  if (!GV(r.axis)) {
    var n = r.get(['axisLabel', 'showMinLabel']),
      i = r.get(['axisLabel', 'showMaxLabel'])
    ;(t = t || []), (e = e || [])
    var a = t[0],
      o = t[1],
      s = t[t.length - 1],
      l = t[t.length - 2],
      u = e[0],
      c = e[1],
      h = e[e.length - 1],
      f = e[e.length - 2]
    n === !1
      ? (Ri(a), Ri(u))
      : QI(a, o) && (n ? (Ri(o), Ri(c)) : (Ri(a), Ri(u))),
      i === !1
        ? (Ri(s), Ri(h))
        : QI(l, s) && (i ? (Ri(l), Ri(f)) : (Ri(s), Ri(h)))
  }
}
function Ri(r) {
  r && (r.ignore = !0)
}
function QI(r, t) {
  var e = r && r.getBoundingRect().clone(),
    n = t && t.getBoundingRect().clone()
  if (!(!e || !n)) {
    var i = Z0([])
    return (
      ec(i, i, -r.rotation),
      e.applyTransform(Ho([], i, r.getLocalTransform())),
      n.applyTransform(Ho([], i, t.getLocalTransform())),
      e.intersect(n)
    )
  }
}
function tO(r) {
  return r === 'middle' || r === 'center'
}
function UG(r, t, e, n, i) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord
    ;(o[0] = u),
      (o[1] = 0),
      (s[0] = u),
      (s[1] = e),
      t && (pr(o, o, t), pr(s, s, t))
    var c = new rr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1],
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0,
    })
    ef(c.shape, c.style.lineWidth),
      (c.anid = i + '_' + r[l].tickValue),
      a.push(c)
  }
  return a
}
function Nut(r, t, e, n) {
  var i = e.axis,
    a = e.getModel('axisTick'),
    o = a.get('show')
  if (
    (o === 'auto' && n.handleAutoShown && (o = n.handleAutoShown('axisTick')),
    !(!o || i.scale.isBlank()))
  ) {
    for (
      var s = a.getModel('lineStyle'),
        l = n.tickDirection * a.get('length'),
        u = i.getTicksCoords(),
        c = UG(
          u,
          t.transform,
          l,
          zt(s.getLineStyle(), {
            stroke: e.get(['axisLine', 'lineStyle', 'color']),
          }),
          'ticks',
        ),
        h = 0;
      h < c.length;
      h++
    )
      r.add(c[h])
    return c
  }
}
function kut(r, t, e, n) {
  var i = e.axis,
    a = e.getModel('minorTick')
  if (!(!a.get('show') || i.scale.isBlank())) {
    var o = i.getMinorTicksCoords()
    if (o.length)
      for (
        var s = a.getModel('lineStyle'),
          l = n * a.get('length'),
          u = zt(
            s.getLineStyle(),
            zt(e.getModel('axisTick').getLineStyle(), {
              stroke: e.get(['axisLine', 'lineStyle', 'color']),
            }),
          ),
          c = 0;
        c < o.length;
        c++
      )
        for (
          var h = UG(o[c], t.transform, l, u, 'minorticks_' + c), f = 0;
          f < h.length;
          f++
        )
          r.add(h[f])
  }
}
function But(r, t, e, n) {
  var i = e.axis,
    a = nr(n.axisLabelShow, e.get(['axisLabel', 'show']))
  if (!(!a || i.scale.isBlank())) {
    var o = e.getModel('axisLabel'),
      s = o.get('margin'),
      l = i.getViewLabels(),
      u = ((nr(n.labelRotate, o.get('rotate')) || 0) * Gs) / 180,
      c = Fu.innerTextLayout(n.rotation, u, n.labelDirection),
      h = e.getCategories && e.getCategories(!0),
      f = [],
      d = Fu.isLabelSilent(e),
      p = e.get('triggerEvent')
    return (
      R(l, function (g, v) {
        var m =
            i.scale.type === 'ordinal'
              ? i.scale.getRawOrdinalNumber(g.tickValue)
              : g.tickValue,
          y = g.formattedLabel,
          _ = g.rawLabel,
          x = o
        if (h && h[m]) {
          var A = h[m]
          Ut(A) && A.textStyle && (x = new qe(A.textStyle, o, e.ecModel))
        }
        var S = x.getTextColor() || e.get(['axisLine', 'lineStyle', 'color']),
          b = i.dataToCoord(m),
          T = x.getShallow('align', !0) || c.textAlign,
          w = $t(x.getShallow('alignMinLabel', !0), T),
          M = $t(x.getShallow('alignMaxLabel', !0), T),
          C =
            x.getShallow('verticalAlign', !0) ||
            x.getShallow('baseline', !0) ||
            c.textVerticalAlign,
          E = $t(x.getShallow('verticalAlignMinLabel', !0), C),
          D = $t(x.getShallow('verticalAlignMaxLabel', !0), C),
          P = new Ae({
            x: b,
            y: n.labelOffset + n.labelDirection * s,
            rotation: c.rotation,
            silent: d,
            z2: 10 + (g.level || 0),
            style: $e(x, {
              text: y,
              align: v === 0 ? w : v === l.length - 1 ? M : T,
              verticalAlign: v === 0 ? E : v === l.length - 1 ? D : C,
              fill: Nt(S)
                ? S(
                    i.type === 'category' ? _ : i.type === 'value' ? m + '' : m,
                    v,
                  )
                : S,
            }),
          })
        if (((P.anid = 'label_' + m), p)) {
          var L = Fu.makeAxisEventDataBase(e)
          ;(L.targetType = 'axisLabel'),
            (L.value = _),
            (L.tickIndex = v),
            i.type === 'category' && (L.dataIndex = m),
            (Wt(P).eventData = L)
        }
        t.add(P),
          P.updateTransform(),
          f.push(P),
          r.add(P),
          P.decomposeTransform()
      }),
      f
    )
  }
}
const ns = Fu
function Fut(r, t) {
  var e = {
    axesInfo: {},
    seriesInvolved: !1,
    coordSysAxesInfo: {},
    coordSysMap: {},
  }
  return zut(e, r, t), e.seriesInvolved && Vut(e, r), e
}
function zut(r, t, e) {
  var n = t.getComponent('tooltip'),
    i = t.getComponent('axisPointer'),
    a = i.get('link', !0) || [],
    o = []
  R(e.getCoordinateSystems(), function (s) {
    if (!s.axisPointerEnabled) return
    var l = ev(s.model),
      u = (r.coordSysAxesInfo[l] = {})
    r.coordSysMap[l] = s
    var c = s.model,
      h = c.getModel('tooltip', n)
    if (
      (R(s.getAxes(), Zt(g, !1, null)), s.getTooltipAxes && n && h.get('show'))
    ) {
      var f = h.get('trigger') === 'axis',
        d = h.get(['axisPointer', 'type']) === 'cross',
        p = s.getTooltipAxes(h.get(['axisPointer', 'axis']))
      ;(f || d) && R(p.baseAxes, Zt(g, d ? 'cross' : !0, f)),
        d && R(p.otherAxes, Zt(g, 'cross', !1))
    }
    function g(v, m, y) {
      var _ = y.model.getModel('axisPointer', i),
        x = _.get('show')
      if (!(!x || (x === 'auto' && !v && !Ow(_)))) {
        m == null && (m = _.get('triggerTooltip')),
          (_ = v ? Uut(y, h, i, t, v, m) : _)
        var A = _.get('snap'),
          S = _.get('triggerEmphasis'),
          b = ev(y.model),
          T = m || A || y.type === 'category',
          w = (r.axesInfo[b] = {
            key: b,
            axis: y,
            coordSys: s,
            axisPointerModel: _,
            triggerTooltip: m,
            triggerEmphasis: S,
            involveSeries: T,
            snap: A,
            useHandle: Ow(_),
            seriesModels: [],
            linkGroup: null,
          })
        ;(u[b] = w), (r.seriesInvolved = r.seriesInvolved || T)
        var M = Gut(a, y)
        if (M != null) {
          var C =
            o[M] ||
            (o[M] = {
              axesInfo: {},
            })
          ;(C.axesInfo[b] = w), (C.mapper = a[M].mapper), (w.linkGroup = C)
        }
      }
    }
  })
}
function Uut(r, t, e, n, i, a) {
  var o = t.getModel('axisPointer'),
    s = [
      'type',
      'snap',
      'lineStyle',
      'shadowStyle',
      'label',
      'animation',
      'animationDurationUpdate',
      'animationEasingUpdate',
      'z',
    ],
    l = {}
  R(s, function (f) {
    l[f] = Vt(o.get(f))
  }),
    (l.snap = r.type !== 'category' && !!a),
    o.get('type') === 'cross' && (l.type = 'line')
  var u = l.label || (l.label = {})
  if ((u.show == null && (u.show = !1), i === 'cross')) {
    var c = o.get(['label', 'show'])
    if (((u.show = c ?? !0), !a)) {
      var h = (l.lineStyle = o.get('crossStyle'))
      h && zt(u, h.textStyle)
    }
  }
  return r.model.getModel('axisPointer', new qe(l, e, n))
}
function Vut(r, t) {
  t.eachSeries(function (e) {
    var n = e.coordinateSystem,
      i = e.get(['tooltip', 'trigger'], !0),
      a = e.get(['tooltip', 'show'], !0)
    !n ||
      i === 'none' ||
      i === !1 ||
      i === 'item' ||
      a === !1 ||
      e.get(['axisPointer', 'show'], !0) === !1 ||
      R(r.coordSysAxesInfo[ev(n.model)], function (o) {
        var s = o.axis
        n.getAxis(s.dim) === s &&
          (o.seriesModels.push(e),
          o.seriesDataCount == null && (o.seriesDataCount = 0),
          (o.seriesDataCount += e.getData().count()))
      })
  })
}
function Gut(r, t) {
  for (var e = t.model, n = t.dim, i = 0; i < r.length; i++) {
    var a = r[i] || {}
    if (
      lS(a[n + 'AxisId'], e.id) ||
      lS(a[n + 'AxisIndex'], e.componentIndex) ||
      lS(a[n + 'AxisName'], e.name)
    )
      return i
  }
}
function lS(r, t) {
  return r === 'all' || (at(r) && re(r, t) >= 0) || r === t
}
function Hut(r) {
  var t = FC(r)
  if (t) {
    var e = t.axisPointerModel,
      n = t.axis.scale,
      i = e.option,
      a = e.get('status'),
      o = e.get('value')
    o != null && (o = n.parse(o))
    var s = Ow(e)
    a == null && (i.status = s ? 'show' : 'hide')
    var l = n.getExtent().slice()
    l[0] > l[1] && l.reverse(),
      (o == null || o > l[1]) && (o = l[1]),
      o < l[0] && (o = l[0]),
      (i.value = o),
      s && (i.status = t.axis.scale.isBlank() ? 'hide' : 'show')
  }
}
function FC(r) {
  var t = (r.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo
  return t && t.axesInfo[ev(r)]
}
function Wut(r) {
  var t = FC(r)
  return t && t.axisPointerModel
}
function Ow(r) {
  return !!r.get(['handle', 'show'])
}
function ev(r) {
  return r.type + '||' + r.id
}
var eO = {},
  Xut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this.axisPointerClass && Hut(e),
          r.prototype.render.apply(this, arguments),
          this._doUpdateAxisPointerClass(e, i, !0)
      }),
      (t.prototype.updateAxisPointer = function (e, n, i, a) {
        this._doUpdateAxisPointerClass(e, i, !1)
      }),
      (t.prototype.remove = function (e, n) {
        var i = this._axisPointer
        i && i.remove(n)
      }),
      (t.prototype.dispose = function (e, n) {
        this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._doUpdateAxisPointerClass = function (e, n, i) {
        var a = t.getAxisPointerClass(this.axisPointerClass)
        if (a) {
          var o = Wut(e)
          o
            ? (this._axisPointer || (this._axisPointer = new a())).render(
                e,
                o,
                n,
                i,
              )
            : this._disposeAxisPointer(n)
        }
      }),
      (t.prototype._disposeAxisPointer = function (e) {
        this._axisPointer && this._axisPointer.dispose(e),
          (this._axisPointer = null)
      }),
      (t.registerAxisPointerClass = function (e, n) {
        eO[e] = n
      }),
      (t.getAxisPointerClass = function (e) {
        return e && eO[e]
      }),
      (t.type = 'axis'),
      t
    )
  })(dn)
const sc = Xut
var Nw = ve()
function VG(r, t, e, n) {
  var i = e.axis
  if (!i.scale.isBlank()) {
    var a = e.getModel('splitArea'),
      o = a.getModel('areaStyle'),
      s = o.get('color'),
      l = n.coordinateSystem.getRect(),
      u = i.getTicksCoords({
        tickModel: a,
        clamp: !0,
      })
    if (u.length) {
      var c = s.length,
        h = Nw(r).splitAreaColors,
        f = Pt(),
        d = 0
      if (h)
        for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue)
          if (g != null) {
            d = (g + (c - 1) * p) % c
            break
          }
        }
      var v = i.toGlobalCoord(u[0].coord),
        m = o.getAreaStyle()
      s = at(s) ? s : [s]
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord),
          _ = void 0,
          x = void 0,
          A = void 0,
          S = void 0
        i.isHorizontal()
          ? ((_ = v), (x = l.y), (A = y - _), (S = l.height), (v = _ + A))
          : ((_ = l.x), (x = v), (A = l.width), (S = y - x), (v = x + S))
        var b = u[p - 1].tickValue
        b != null && f.set(b, d),
          t.add(
            new ge({
              anid: b != null ? 'area_' + b : null,
              shape: {
                x: _,
                y: x,
                width: A,
                height: S,
              },
              style: zt(
                {
                  fill: s[d],
                },
                m,
              ),
              autoBatch: !0,
              silent: !0,
            }),
          ),
          (d = (d + 1) % c)
      }
      Nw(r).splitAreaColors = f
    }
  }
}
function GG(r) {
  Nw(r).splitAreaColors = null
}
var Yut = ['axisLine', 'axisTickLabel', 'axisName'],
  $ut = ['splitArea', 'splitLine', 'minorSplitLine'],
  HG = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'CartesianAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this.group.removeAll()
        var o = this._axisGroup
        if (
          ((this._axisGroup = new Ht()),
          this.group.add(this._axisGroup),
          !!e.get('show'))
        ) {
          var s = e.getCoordSysModel(),
            l = Iw(s, e),
            u = new ns(
              e,
              Q(
                {
                  handleAutoShown: function (h) {
                    for (
                      var f = s.coordinateSystem.getCartesians(), d = 0;
                      d < f.length;
                      d++
                    )
                      if (Mw(f[d].getOtherAxis(e.axis).scale)) return !0
                    return !1
                  },
                },
                l,
              ),
            )
          R(Yut, u.add, u),
            this._axisGroup.add(u.getGroup()),
            R(
              $ut,
              function (h) {
                e.get([h, 'show']) && qut[h](this, this._axisGroup, e, s)
              },
              this,
            )
          var c = a && a.type === 'changeAxisOrder' && a.isInitSort
          c || xv(o, this._axisGroup, e),
            r.prototype.render.call(this, e, n, i, a)
        }
      }),
      (t.prototype.remove = function () {
        GG(this)
      }),
      (t.type = 'cartesianAxis'),
      t
    )
  })(sc),
  qut = {
    splitLine: function (r, t, e, n) {
      var i = e.axis
      if (!i.scale.isBlank()) {
        var a = e.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = at(s) ? s : [s]
        for (
          var l = n.coordinateSystem.getRect(),
            u = i.isHorizontal(),
            c = 0,
            h = i.getTicksCoords({
              tickModel: a,
            }),
            f = [],
            d = [],
            p = o.getLineStyle(),
            g = 0;
          g < h.length;
          g++
        ) {
          var v = i.toGlobalCoord(h[g].coord)
          u
            ? ((f[0] = v), (f[1] = l.y), (d[0] = v), (d[1] = l.y + l.height))
            : ((f[0] = l.x), (f[1] = v), (d[0] = l.x + l.width), (d[1] = v))
          var m = c++ % s.length,
            y = h[g].tickValue,
            _ = new rr({
              anid: y != null ? 'line_' + h[g].tickValue : null,
              autoBatch: !0,
              shape: {
                x1: f[0],
                y1: f[1],
                x2: d[0],
                y2: d[1],
              },
              style: zt(
                {
                  stroke: s[m],
                },
                p,
              ),
              silent: !0,
            })
          ef(_.shape, p.lineWidth), t.add(_)
        }
      }
    },
    minorSplitLine: function (r, t, e, n) {
      var i = e.axis,
        a = e.getModel('minorSplitLine'),
        o = a.getModel('lineStyle'),
        s = n.coordinateSystem.getRect(),
        l = i.isHorizontal(),
        u = i.getMinorTicksCoords()
      if (u.length)
        for (var c = [], h = [], f = o.getLineStyle(), d = 0; d < u.length; d++)
          for (var p = 0; p < u[d].length; p++) {
            var g = i.toGlobalCoord(u[d][p].coord)
            l
              ? ((c[0] = g), (c[1] = s.y), (h[0] = g), (h[1] = s.y + s.height))
              : ((c[0] = s.x), (c[1] = g), (h[0] = s.x + s.width), (h[1] = g))
            var v = new rr({
              anid: 'minor_line_' + u[d][p].tickValue,
              autoBatch: !0,
              shape: {
                x1: c[0],
                y1: c[1],
                x2: h[0],
                y2: h[1],
              },
              style: f,
              silent: !0,
            })
            ef(v.shape, f.lineWidth), t.add(v)
          }
    },
    splitArea: function (r, t, e, n) {
      VG(r, t, e, n)
    },
  },
  WG = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'xAxis'), t
  })(HG),
  Zut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = WG.type), e
    }
    return (t.type = 'yAxis'), t
  })(HG),
  Kut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'grid'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        this.group.removeAll(),
          e.get('show') &&
            this.group.add(
              new ge({
                shape: e.coordinateSystem.getRect(),
                style: zt(
                  {
                    fill: e.get('backgroundColor'),
                  },
                  e.getItemStyle(),
                ),
                silent: !0,
                z2: -1,
              }),
            )
      }),
      (t.type = 'grid'),
      t
    )
  })(dn),
  nO = {
    offset: 0,
  }
function XG(r) {
  r.registerComponentView(Kut),
    r.registerComponentModel(xut),
    r.registerCoordinateSystem('cartesian2d', Rut),
    sf(r, 'x', Pw, nO),
    sf(r, 'y', Pw, nO),
    r.registerComponentView(WG),
    r.registerComponentView(Zut),
    r.registerPreprocessor(function (t) {
      t.xAxis && t.yAxis && !t.grid && (t.grid = {})
    })
}
function jut(r) {
  ie(XG),
    r.registerSeriesModel(fut),
    r.registerChartView(yut),
    r.registerLayout(Dv('scatter'))
}
function Jut(r) {
  r.eachSeriesByType('radar', function (t) {
    var e = t.getData(),
      n = [],
      i = t.coordinateSystem
    if (i) {
      var a = i.getIndicatorAxes()
      R(a, function (o, s) {
        e.each(e.mapDimension(a[s].dim), function (l, u) {
          n[u] = n[u] || []
          var c = i.dataToPoint(l, s)
          n[u][s] = rO(c) ? c : iO(i)
        })
      }),
        e.each(function (o) {
          var s =
            OJ(n[o], function (l) {
              return rO(l)
            }) || iO(i)
          n[o].push(s.slice()), e.setItemLayout(o, n[o])
        })
    }
  })
}
function rO(r) {
  return !isNaN(r[0]) && !isNaN(r[1])
}
function iO(r) {
  return [r.cx, r.cy]
}
function Qut(r) {
  var t = r.polar
  if (t) {
    at(t) || (t = [t])
    var e = []
    R(t, function (n, i) {
      n.indicator
        ? (n.type && !n.shape && (n.shape = n.type),
          (r.radar = r.radar || []),
          at(r.radar) || (r.radar = [r.radar]),
          r.radar.push(n))
        : e.push(n)
    }),
      (r.polar = e)
  }
  R(r.series, function (n) {
    n && n.type === 'radar' && n.polarIndex && (n.radarIndex = n.polarIndex)
  })
}
var tct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.coordinateSystem,
        o = this.group,
        s = e.getData(),
        l = this._data
      function u(f, d) {
        var p = f.getItemVisual(d, 'symbol') || 'circle'
        if (p !== 'none') {
          var g = Lf(f.getItemVisual(d, 'symbolSize')),
            v = Rn(p, -1, -1, 2, 2),
            m = f.getItemVisual(d, 'symbolRotate') || 0
          return (
            v.attr({
              style: {
                strokeNoScale: !0,
              },
              z2: 100,
              scaleX: g[0] / 2,
              scaleY: g[1] / 2,
              rotation: (m * Math.PI) / 180 || 0,
            }),
            v
          )
        }
      }
      function c(f, d, p, g, v, m) {
        p.removeAll()
        for (var y = 0; y < d.length - 1; y++) {
          var _ = u(g, v)
          _ &&
            ((_.__dimIdx = y),
            f[y]
              ? (_.setPosition(f[y]),
                nc[m ? 'initProps' : 'updateProps'](
                  _,
                  {
                    x: d[y][0],
                    y: d[y][1],
                  },
                  e,
                  v,
                ))
              : _.setPosition(d[y]),
            p.add(_))
        }
      }
      function h(f) {
        return st(f, function (d) {
          return [a.cx, a.cy]
        })
      }
      s
        .diff(l)
        .add(function (f) {
          var d = s.getItemLayout(f)
          if (d) {
            var p = new si(),
              g = new li(),
              v = {
                shape: {
                  points: d,
                },
              }
            ;(p.shape.points = h(d)),
              (g.shape.points = h(d)),
              Je(p, v, e, f),
              Je(g, v, e, f)
            var m = new Ht(),
              y = new Ht()
            m.add(g),
              m.add(p),
              m.add(y),
              c(g.shape.points, d, y, s, f, !0),
              s.setItemGraphicEl(f, m)
          }
        })
        .update(function (f, d) {
          var p = l.getItemGraphicEl(d),
            g = p.childAt(0),
            v = p.childAt(1),
            m = p.childAt(2),
            y = {
              shape: {
                points: s.getItemLayout(f),
              },
            }
          y.shape.points &&
            (c(g.shape.points, y.shape.points, m, s, f, !1),
            Ca(v),
            Ca(g),
            we(g, y, e),
            we(v, y, e),
            s.setItemGraphicEl(f, p))
        })
        .remove(function (f) {
          o.remove(l.getItemGraphicEl(f))
        })
        .execute(),
        s.eachItemGraphicEl(function (f, d) {
          var p = s.getItemModel(d),
            g = f.childAt(0),
            v = f.childAt(1),
            m = f.childAt(2),
            y = s.getItemVisual(d, 'style'),
            _ = y.fill
          o.add(f),
            g.useStyle(
              zt(p.getModel('lineStyle').getLineStyle(), {
                fill: 'none',
                stroke: _,
              }),
            ),
            gr(g, p, 'lineStyle'),
            gr(v, p, 'areaStyle')
          var x = p.getModel('areaStyle'),
            A = x.isEmpty() && x.parentModel.isEmpty()
          ;(v.ignore = A),
            R(['emphasis', 'select', 'blur'], function (T) {
              var w = p.getModel([T, 'areaStyle']),
                M = w.isEmpty() && w.parentModel.isEmpty()
              v.ensureState(T).ignore = M && A
            }),
            v.useStyle(
              zt(x.getAreaStyle(), {
                fill: _,
                opacity: 0.7,
                decal: y.decal,
              }),
            )
          var S = p.getModel('emphasis'),
            b = S.getModel('itemStyle').getItemStyle()
          m.eachChild(function (T) {
            if (T instanceof yr) {
              var w = T.style
              T.useStyle(
                Q(
                  {
                    image: w.image,
                    x: w.x,
                    y: w.y,
                    width: w.width,
                    height: w.height,
                  },
                  y,
                ),
              )
            } else T.useStyle(y), T.setColor(_), (T.style.strokeNoScale = !0)
            var M = T.ensureState('emphasis')
            M.style = Vt(b)
            var C = s.getStore().get(s.getDimensionIndex(T.__dimIdx), d)
            ;(C == null || isNaN(C)) && (C = ''),
              mr(T, Zn(p), {
                labelFetcher: s.hostModel,
                labelDataIndex: d,
                labelDimIndex: T.__dimIdx,
                defaultText: C,
                inheritColor: _,
                defaultOpacity: y.opacity,
              })
          }),
            fn(f, S.get('focus'), S.get('blurScope'), S.get('disabled'))
        }),
        (this._data = s)
    }),
    (t.prototype.remove = function () {
      this.group.removeAll(), (this._data = null)
    }),
    (t.type = 'radar'),
    t
  )
})(Ze)
const ect = tct
var nct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments),
        (this.legendVisualProvider = new Pv(
          Tt(this.getData, this),
          Tt(this.getRawData, this),
        ))
    }),
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, {
        generateCoord: 'indicator_',
        generateCoordCount: 1 / 0,
      })
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = this.coordinateSystem,
        s = o.getIndicatorAxes(),
        l = this.getData().getName(e),
        u = l === '' ? this.name : l,
        c = F5(this, e)
      return Kn('section', {
        header: u,
        sortBlocks: !0,
        blocks: st(s, function (h) {
          var f = a.get(a.mapDimension(h.dim), e)
          return Kn('nameValue', {
            markerType: 'subItem',
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f,
          })
        }),
      })
    }),
    (t.prototype.getTooltipPosition = function (e) {
      if (e != null) {
        for (
          var n = this.getData(),
            i = this.coordinateSystem,
            a = n.getValues(
              st(i.dimensions, function (u) {
                return n.mapDimension(u)
              }),
              e,
            ),
            o = 0,
            s = a.length;
          o < s;
          o++
        )
          if (!isNaN(a[o])) {
            var l = i.getIndicatorAxes()
            return i.coordToPoint(l[o].dataToCoord(a[o]), o)
          }
      }
    }),
    (t.type = 'series.radar'),
    (t.dependencies = ['radar']),
    (t.defaultOption = {
      z: 2,
      colorBy: 'data',
      coordinateSystem: 'radar',
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: 'solid',
        join: 'round',
      },
      label: {
        position: 'top',
      },
      symbolSize: 8,
    }),
    t
  )
})(rn)
const rct = nct
var pd = FG.value
function pm(r, t) {
  return zt(
    {
      show: t,
    },
    r,
  )
}
var ict = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.optionUpdated = function () {
      var e = this.get('boundaryGap'),
        n = this.get('splitNumber'),
        i = this.get('scale'),
        a = this.get('axisLine'),
        o = this.get('axisTick'),
        s = this.get('axisLabel'),
        l = this.get('axisName'),
        u = this.get(['axisName', 'show']),
        c = this.get(['axisName', 'formatter']),
        h = this.get('axisNameGap'),
        f = this.get('triggerEvent'),
        d = st(
          this.get('indicator') || [],
          function (p) {
            p.max != null && p.max > 0 && !p.min
              ? (p.min = 0)
              : p.min != null && p.min < 0 && !p.max && (p.max = 0)
            var g = l
            p.color != null &&
              (g = zt(
                {
                  color: p.color,
                },
                l,
              ))
            var v = te(
              Vt(p),
              {
                boundaryGap: e,
                splitNumber: n,
                scale: i,
                axisLine: a,
                axisTick: o,
                axisLabel: s,
                name: p.text,
                showName: u,
                nameLocation: 'end',
                nameGap: h,
                nameTextStyle: g,
                triggerEvent: f,
              },
              !1,
            )
            if (bt(c)) {
              var m = v.name
              v.name = c.replace('{value}', m ?? '')
            } else Nt(c) && (v.name = c(v.name, v))
            var y = new qe(v, null, this.ecModel)
            return (
              In(y, Mv.prototype),
              (y.mainType = 'radar'),
              (y.componentIndex = this.componentIndex),
              y
            )
          },
          this,
        )
      this._indicatorModels = d
    }),
    (t.prototype.getIndicatorModels = function () {
      return this._indicatorModels
    }),
    (t.type = 'radar'),
    (t.defaultOption = {
      z: 0,
      center: ['50%', '50%'],
      radius: '75%',
      startAngle: 90,
      axisName: {
        show: !0,
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      shape: 'polygon',
      axisLine: te(
        {
          lineStyle: {
            color: '#bbb',
          },
        },
        pd.axisLine,
      ),
      axisLabel: pm(pd.axisLabel, !1),
      axisTick: pm(pd.axisTick, !1),
      splitLine: pm(pd.splitLine, !0),
      splitArea: pm(pd.splitArea, !0),
      indicator: [],
    }),
    t
  )
})(xe)
const act = ict
var oct = ['axisLine', 'axisTickLabel', 'axisName'],
  sct = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this.group
        a.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e)
      }),
      (t.prototype._buildAxes = function (e) {
        var n = e.coordinateSystem,
          i = n.getIndicatorAxes(),
          a = st(i, function (o) {
            var s = o.model.get('showName') ? o.name : '',
              l = new ns(o.model, {
                axisName: s,
                position: [n.cx, n.cy],
                rotation: o.angle,
                labelDirection: -1,
                tickDirection: -1,
                nameDirection: 1,
              })
            return l
          })
        R(
          a,
          function (o) {
            R(oct, o.add, o), this.group.add(o.getGroup())
          },
          this,
        )
      }),
      (t.prototype._buildSplitLineAndArea = function (e) {
        var n = e.coordinateSystem,
          i = n.getIndicatorAxes()
        if (!i.length) return
        var a = e.get('shape'),
          o = e.getModel('splitLine'),
          s = e.getModel('splitArea'),
          l = o.getModel('lineStyle'),
          u = s.getModel('areaStyle'),
          c = o.get('show'),
          h = s.get('show'),
          f = l.get('color'),
          d = u.get('color'),
          p = at(f) ? f : [f],
          g = at(d) ? d : [d],
          v = [],
          m = []
        function y(L, I, F) {
          var k = F % I.length
          return (L[k] = L[k] || []), k
        }
        if (a === 'circle')
          for (
            var _ = i[0].getTicksCoords(), x = n.cx, A = n.cy, S = 0;
            S < _.length;
            S++
          ) {
            if (c) {
              var b = y(v, p, S)
              v[b].push(
                new pl({
                  shape: {
                    cx: x,
                    cy: A,
                    r: _[S].coord,
                  },
                }),
              )
            }
            if (h && S < _.length - 1) {
              var b = y(m, g, S)
              m[b].push(
                new i_({
                  shape: {
                    cx: x,
                    cy: A,
                    r0: _[S].coord,
                    r: _[S + 1].coord,
                  },
                }),
              )
            }
          }
        else
          for (
            var T,
              w = st(i, function (L, I) {
                var F = L.getTicksCoords()
                return (
                  (T = T == null ? F.length - 1 : Math.min(F.length - 1, T)),
                  st(F, function (k) {
                    return n.coordToPoint(k.coord, I)
                  })
                )
              }),
              M = [],
              S = 0;
            S <= T;
            S++
          ) {
            for (var C = [], E = 0; E < i.length; E++) C.push(w[E][S])
            if ((C[0] && C.push(C[0].slice()), c)) {
              var b = y(v, p, S)
              v[b].push(
                new li({
                  shape: {
                    points: C,
                  },
                }),
              )
            }
            if (h && M) {
              var b = y(m, g, S - 1)
              m[b].push(
                new si({
                  shape: {
                    points: C.concat(M),
                  },
                }),
              )
            }
            M = C.slice().reverse()
          }
        var D = l.getLineStyle(),
          P = u.getAreaStyle()
        R(
          m,
          function (L, I) {
            this.group.add(
              Wi(L, {
                style: zt(
                  {
                    stroke: 'none',
                    fill: g[I % g.length],
                  },
                  P,
                ),
                silent: !0,
              }),
            )
          },
          this,
        ),
          R(
            v,
            function (L, I) {
              this.group.add(
                Wi(L, {
                  style: zt(
                    {
                      fill: 'none',
                      stroke: p[I % p.length],
                    },
                    D,
                  ),
                  silent: !0,
                }),
              )
            },
            this,
          )
      }),
      (t.type = 'radar'),
      t
    )
  })(dn)
const lct = sct
var uct = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this, e, n, i) || this
    return (a.type = 'value'), (a.angle = 0), (a.name = ''), a
  }
  return t
})(Ra)
const cct = uct
var hct = (function () {
  function r(t, e, n) {
    ;(this.dimensions = []),
      (this._model = t),
      (this._indicatorAxes = st(
        t.getIndicatorModels(),
        function (i, a) {
          var o = 'indicator_' + a,
            s = new cct(o, new ll())
          return (
            (s.name = i.get('name')),
            (s.model = i),
            (i.axis = s),
            this.dimensions.push(o),
            s
          )
        },
        this,
      )),
      this.resize(t, n)
  }
  return (
    (r.prototype.getIndicatorAxes = function () {
      return this._indicatorAxes
    }),
    (r.prototype.dataToPoint = function (t, e) {
      var n = this._indicatorAxes[e]
      return this.coordToPoint(n.dataToCoord(t), e)
    }),
    (r.prototype.coordToPoint = function (t, e) {
      var n = this._indicatorAxes[e],
        i = n.angle,
        a = this.cx + t * Math.cos(i),
        o = this.cy - t * Math.sin(i)
      return [a, o]
    }),
    (r.prototype.pointToData = function (t) {
      var e = t[0] - this.cx,
        n = t[1] - this.cy,
        i = Math.sqrt(e * e + n * n)
      ;(e /= i), (n /= i)
      for (
        var a = Math.atan2(-n, e), o = 1 / 0, s, l = -1, u = 0;
        u < this._indicatorAxes.length;
        u++
      ) {
        var c = this._indicatorAxes[u],
          h = Math.abs(a - c.angle)
        h < o && ((s = c), (l = u), (o = h))
      }
      return [l, +(s && s.coordToData(i))]
    }),
    (r.prototype.resize = function (t, e) {
      var n = t.get('center'),
        i = e.getWidth(),
        a = e.getHeight(),
        o = Math.min(i, a) / 2
      ;(this.cx = _t(n[0], i)),
        (this.cy = _t(n[1], a)),
        (this.startAngle = (t.get('startAngle') * Math.PI) / 180)
      var s = t.get('radius')
      ;(bt(s) || be(s)) && (s = [0, s]),
        (this.r0 = _t(s[0], o)),
        (this.r = _t(s[1], o)),
        R(
          this._indicatorAxes,
          function (l, u) {
            l.setExtent(this.r0, this.r)
            var c =
              this.startAngle + (u * Math.PI * 2) / this._indicatorAxes.length
            ;(c = Math.atan2(Math.sin(c), Math.cos(c))), (l.angle = c)
          },
          this,
        )
    }),
    (r.prototype.update = function (t, e) {
      var n = this._indicatorAxes,
        i = this._model
      R(n, function (s) {
        s.scale.setExtent(1 / 0, -1 / 0)
      }),
        t.eachSeriesByType(
          'radar',
          function (s, l) {
            if (
              !(
                s.get('coordinateSystem') !== 'radar' ||
                t.getComponent('radar', s.get('radarIndex')) !== i
              )
            ) {
              var u = s.getData()
              R(n, function (c) {
                c.scale.unionExtentFromData(u, u.mapDimension(c.dim))
              })
            }
          },
          this,
        )
      var a = i.get('splitNumber'),
        o = new ll()
      o.setExtent(0, a),
        o.setInterval(1),
        R(n, function (s, l) {
          zG(s.scale, s.model, o)
        })
    }),
    (r.prototype.convertToPixel = function (t, e, n) {
      return console.warn('Not implemented.'), null
    }),
    (r.prototype.convertFromPixel = function (t, e, n) {
      return console.warn('Not implemented.'), null
    }),
    (r.prototype.containPoint = function (t) {
      return console.warn('Not implemented.'), !1
    }),
    (r.create = function (t, e) {
      var n = []
      return (
        t.eachComponent('radar', function (i) {
          var a = new r(i, t, e)
          n.push(a), (i.coordinateSystem = a)
        }),
        t.eachSeriesByType('radar', function (i) {
          i.get('coordinateSystem') === 'radar' &&
            (i.coordinateSystem = n[i.get('radarIndex') || 0])
        }),
        n
      )
    }),
    (r.dimensions = []),
    r
  )
})()
const fct = hct
function dct(r) {
  r.registerCoordinateSystem('radar', fct),
    r.registerComponentModel(act),
    r.registerComponentView(lct),
    r.registerVisual({
      seriesType: 'radar',
      reset: function (t) {
        var e = t.getData()
        e.each(function (n) {
          e.setItemVisual(n, 'legendIcon', 'roundRect')
        }),
          e.setVisual('legendIcon', 'roundRect')
      },
    })
}
function pct(r) {
  ie(dct),
    r.registerChartView(ect),
    r.registerSeriesModel(rct),
    r.registerLayout(Jut),
    r.registerProcessor(Lv('radar')),
    r.registerPreprocessor(Qut)
}
var aO = '\0_ec_interaction_mutex'
function vct(r, t, e) {
  var n = zC(r)
  n[t] = e
}
function gct(r, t, e) {
  var n = zC(r),
    i = n[t]
  i === e && (n[t] = null)
}
function oO(r, t) {
  return !!zC(r)[t]
}
function zC(r) {
  return r[aO] || (r[aO] = {})
}
xo(
  {
    type: 'takeGlobalCursor',
    event: 'globalCursorTaken',
    update: 'update',
  },
  wn,
)
var mct = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this) || this
    n._zr = e
    var i = Tt(n._mousedownHandler, n),
      a = Tt(n._mousemoveHandler, n),
      o = Tt(n._mouseupHandler, n),
      s = Tt(n._mousewheelHandler, n),
      l = Tt(n._pinchHandler, n)
    return (
      (n.enable = function (u, c) {
        this.disable(),
          (this._opt = zt(Vt(c) || {}, {
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            moveOnMouseWheel: !1,
            preventDefaultMouseMove: !0,
          })),
          u == null && (u = !0),
          (u === !0 || u === 'move' || u === 'pan') &&
            (e.on('mousedown', i), e.on('mousemove', a), e.on('mouseup', o)),
          (u === !0 || u === 'scale' || u === 'zoom') &&
            (e.on('mousewheel', s), e.on('pinch', l))
      }),
      (n.disable = function () {
        e.off('mousedown', i),
          e.off('mousemove', a),
          e.off('mouseup', o),
          e.off('mousewheel', s),
          e.off('pinch', l)
      }),
      n
    )
  }
  return (
    (t.prototype.isDragging = function () {
      return this._dragging
    }),
    (t.prototype.isPinching = function () {
      return this._pinching
    }),
    (t.prototype.setPointerChecker = function (e) {
      this.pointerChecker = e
    }),
    (t.prototype.dispose = function () {
      this.disable()
    }),
    (t.prototype._mousedownHandler = function (e) {
      if (!RL(e)) {
        for (var n = e.target; n; ) {
          if (n.draggable) return
          n = n.__hostTarget || n.parent
        }
        var i = e.offsetX,
          a = e.offsetY
        this.pointerChecker &&
          this.pointerChecker(e, i, a) &&
          ((this._x = i), (this._y = a), (this._dragging = !0))
      }
    }),
    (t.prototype._mousemoveHandler = function (e) {
      if (
        !(
          !this._dragging ||
          !oy('moveOnMouseMove', e, this._opt) ||
          e.gestureEvent === 'pinch' ||
          oO(this._zr, 'globalPan')
        )
      ) {
        var n = e.offsetX,
          i = e.offsetY,
          a = this._x,
          o = this._y,
          s = n - a,
          l = i - o
        ;(this._x = n),
          (this._y = i),
          this._opt.preventDefaultMouseMove && jo(e.event),
          YG(this, 'pan', 'moveOnMouseMove', e, {
            dx: s,
            dy: l,
            oldX: a,
            oldY: o,
            newX: n,
            newY: i,
            isAvailableBehavior: null,
          })
      }
    }),
    (t.prototype._mouseupHandler = function (e) {
      RL(e) || (this._dragging = !1)
    }),
    (t.prototype._mousewheelHandler = function (e) {
      var n = oy('zoomOnMouseWheel', e, this._opt),
        i = oy('moveOnMouseWheel', e, this._opt),
        a = e.wheelDelta,
        o = Math.abs(a),
        s = e.offsetX,
        l = e.offsetY
      if (!(a === 0 || (!n && !i))) {
        if (n) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1,
            c = a > 0 ? u : 1 / u
          uS(this, 'zoom', 'zoomOnMouseWheel', e, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null,
          })
        }
        if (i) {
          var h = Math.abs(a),
            f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05)
          uS(this, 'scrollMove', 'moveOnMouseWheel', e, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null,
          })
        }
      }
    }),
    (t.prototype._pinchHandler = function (e) {
      if (!oO(this._zr, 'globalPan')) {
        var n = e.pinchScale > 1 ? 1.1 : 1 / 1.1
        uS(this, 'zoom', null, e, {
          scale: n,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null,
        })
      }
    }),
    t
  )
})(ra)
function uS(r, t, e, n, i) {
  r.pointerChecker &&
    r.pointerChecker(n, i.originX, i.originY) &&
    (jo(n.event), YG(r, t, e, n, i))
}
function YG(r, t, e, n, i) {
  ;(i.isAvailableBehavior = Tt(oy, null, e, n)), r.trigger(t, i)
}
function oy(r, t, e) {
  var n = e[r]
  return !r || (n && (!bt(n) || t.event[n + 'Key']))
}
const Rv = mct
function UC(r, t, e) {
  var n = r.target
  ;(n.x += t), (n.y += e), n.dirty()
}
function VC(r, t, e, n) {
  var i = r.target,
    a = r.zoomLimit,
    o = (r.zoom = r.zoom || 1)
  if (((o *= t), a)) {
    var s = a.min || 0,
      l = a.max || 1 / 0
    o = Math.max(Math.min(l, o), s)
  }
  var u = o / r.zoom
  ;(r.zoom = o),
    (i.x -= (e - i.x) * (u - 1)),
    (i.y -= (n - i.y) * (u - 1)),
    (i.scaleX *= u),
    (i.scaleY *= u),
    i.dirty()
}
var yct = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1,
}
function T_(r, t, e) {
  var n = t.getComponentByElement(r.topTarget),
    i = n && n.coordinateSystem
  return n && n !== e && !yct.hasOwnProperty(n.mainType) && i && i.model !== e
}
function $G(r) {
  if (bt(r)) {
    var t = new DOMParser()
    r = t.parseFromString(r, 'text/xml')
  }
  var e = r
  for (
    e.nodeType === 9 && (e = e.firstChild);
    e.nodeName.toLowerCase() !== 'svg' || e.nodeType !== 1;

  )
    e = e.nextSibling
  return e
}
var cS,
  f0 = {
    fill: 'fill',
    stroke: 'stroke',
    'stroke-width': 'lineWidth',
    opacity: 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-anchor': 'textAlign',
    visibility: 'visibility',
    display: 'display',
  },
  sO = pe(f0),
  d0 = {
    'alignment-baseline': 'textBaseline',
    'stop-color': 'stopColor',
  },
  lO = pe(d0),
  _ct = (function () {
    function r() {
      ;(this._defs = {}), (this._root = null)
    }
    return (
      (r.prototype.parse = function (t, e) {
        e = e || {}
        var n = $G(t)
        this._defsUsePending = []
        var i = new Ht()
        this._root = i
        var a = [],
          o = n.getAttribute('viewBox') || '',
          s = parseFloat(n.getAttribute('width') || e.width),
          l = parseFloat(n.getAttribute('height') || e.height)
        isNaN(s) && (s = null), isNaN(l) && (l = null), di(n, i, null, !0, !1)
        for (var u = n.firstChild; u; )
          this._parseNode(u, i, a, null, !1, !1), (u = u.nextSibling)
        Act(this._defs, this._defsUsePending), (this._defsUsePending = [])
        var c, h
        if (o) {
          var f = C_(o)
          f.length >= 4 &&
            (c = {
              x: parseFloat(f[0] || 0),
              y: parseFloat(f[1] || 0),
              width: parseFloat(f[2]),
              height: parseFloat(f[3]),
            })
        }
        if (
          c &&
          s != null &&
          l != null &&
          ((h = ZG(c, {
            x: 0,
            y: 0,
            width: s,
            height: l,
          })),
          !e.ignoreViewBox)
        ) {
          var d = i
          ;(i = new Ht()),
            i.add(d),
            (d.scaleX = d.scaleY = h.scale),
            (d.x = h.x),
            (d.y = h.y)
        }
        return (
          !e.ignoreRootClip &&
            s != null &&
            l != null &&
            i.setClipPath(
              new ge({
                shape: {
                  x: 0,
                  y: 0,
                  width: s,
                  height: l,
                },
              }),
            ),
          {
            root: i,
            width: s,
            height: l,
            viewBoxRect: c,
            viewBoxTransform: h,
            named: a,
          }
        )
      }),
      (r.prototype._parseNode = function (t, e, n, i, a, o) {
        var s = t.nodeName.toLowerCase(),
          l,
          u = i
        if (
          (s === 'defs' && (a = !0),
          s === 'text' && (o = !0),
          s === 'defs' || s === 'switch')
        )
          l = e
        else {
          if (!a) {
            var c = cS[s]
            if (c && Et(cS, s)) {
              l = c.call(this, t, e)
              var h = t.getAttribute('name')
              if (h) {
                var f = {
                  name: h,
                  namedFrom: null,
                  svgNodeTagLower: s,
                  el: l,
                }
                n.push(f), s === 'g' && (u = f)
              } else
                i &&
                  n.push({
                    name: i.name,
                    namedFrom: i,
                    svgNodeTagLower: s,
                    el: l,
                  })
              e.add(l)
            }
          }
          var d = uO[s]
          if (d && Et(uO, s)) {
            var p = d.call(this, t),
              g = t.getAttribute('id')
            g && (this._defs[g] = p)
          }
        }
        if (l && l.isGroup)
          for (var v = t.firstChild; v; )
            v.nodeType === 1
              ? this._parseNode(v, l, n, u, a, o)
              : v.nodeType === 3 && o && this._parseText(v, l),
              (v = v.nextSibling)
      }),
      (r.prototype._parseText = function (t, e) {
        var n = new Gp({
          style: {
            text: t.textContent,
          },
          silent: !0,
          x: this._textX || 0,
          y: this._textY || 0,
        })
        Ii(e, n), di(t, n, this._defsUsePending, !1, !1), xct(n, e)
        var i = n.style,
          a = i.fontSize
        a &&
          a < 9 &&
          ((i.fontSize = 9), (n.scaleX *= a / 9), (n.scaleY *= a / 9))
        var o =
          (i.fontSize || i.fontFamily) &&
          [
            i.fontStyle,
            i.fontWeight,
            (i.fontSize || 12) + 'px',
            i.fontFamily || 'sans-serif',
          ].join(' ')
        i.font = o
        var s = n.getBoundingRect()
        return (this._textX += s.width), e.add(n), n
      }),
      (r.internalField = (function () {
        cS = {
          g: function (t, e) {
            var n = new Ht()
            return Ii(e, n), di(t, n, this._defsUsePending, !1, !1), n
          },
          rect: function (t, e) {
            var n = new ge()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                x: parseFloat(t.getAttribute('x') || '0'),
                y: parseFloat(t.getAttribute('y') || '0'),
                width: parseFloat(t.getAttribute('width') || '0'),
                height: parseFloat(t.getAttribute('height') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          circle: function (t, e) {
            var n = new pl()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                cx: parseFloat(t.getAttribute('cx') || '0'),
                cy: parseFloat(t.getAttribute('cy') || '0'),
                r: parseFloat(t.getAttribute('r') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          line: function (t, e) {
            var n = new rr()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                x1: parseFloat(t.getAttribute('x1') || '0'),
                y1: parseFloat(t.getAttribute('y1') || '0'),
                x2: parseFloat(t.getAttribute('x2') || '0'),
                y2: parseFloat(t.getAttribute('y2') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          ellipse: function (t, e) {
            var n = new KT()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                cx: parseFloat(t.getAttribute('cx') || '0'),
                cy: parseFloat(t.getAttribute('cy') || '0'),
                rx: parseFloat(t.getAttribute('rx') || '0'),
                ry: parseFloat(t.getAttribute('ry') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          polygon: function (t, e) {
            var n = t.getAttribute('points'),
              i
            n && (i = fO(n))
            var a = new si({
              shape: {
                points: i || [],
              },
              silent: !0,
            })
            return Ii(e, a), di(t, a, this._defsUsePending, !1, !1), a
          },
          polyline: function (t, e) {
            var n = t.getAttribute('points'),
              i
            n && (i = fO(n))
            var a = new li({
              shape: {
                points: i || [],
              },
              silent: !0,
            })
            return Ii(e, a), di(t, a, this._defsUsePending, !1, !1), a
          },
          image: function (t, e) {
            var n = new yr()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setStyle({
                image: t.getAttribute('xlink:href') || t.getAttribute('href'),
                x: +t.getAttribute('x'),
                y: +t.getAttribute('y'),
                width: +t.getAttribute('width'),
                height: +t.getAttribute('height'),
              }),
              (n.silent = !0),
              n
            )
          },
          text: function (t, e) {
            var n = t.getAttribute('x') || '0',
              i = t.getAttribute('y') || '0',
              a = t.getAttribute('dx') || '0',
              o = t.getAttribute('dy') || '0'
            ;(this._textX = parseFloat(n) + parseFloat(a)),
              (this._textY = parseFloat(i) + parseFloat(o))
            var s = new Ht()
            return Ii(e, s), di(t, s, this._defsUsePending, !1, !0), s
          },
          tspan: function (t, e) {
            var n = t.getAttribute('x'),
              i = t.getAttribute('y')
            n != null && (this._textX = parseFloat(n)),
              i != null && (this._textY = parseFloat(i))
            var a = t.getAttribute('dx') || '0',
              o = t.getAttribute('dy') || '0',
              s = new Ht()
            return (
              Ii(e, s),
              di(t, s, this._defsUsePending, !1, !0),
              (this._textX += parseFloat(a)),
              (this._textY += parseFloat(o)),
              s
            )
          },
          path: function (t, e) {
            var n = t.getAttribute('d') || '',
              i = SU(n)
            return (
              Ii(e, i),
              di(t, i, this._defsUsePending, !1, !1),
              (i.silent = !0),
              i
            )
          },
        }
      })()),
      r
    )
  })(),
  uO = {
    lineargradient: function (r) {
      var t = parseInt(r.getAttribute('x1') || '0', 10),
        e = parseInt(r.getAttribute('y1') || '0', 10),
        n = parseInt(r.getAttribute('x2') || '10', 10),
        i = parseInt(r.getAttribute('y2') || '0', 10),
        a = new He(t, e, n, i)
      return cO(r, a), hO(r, a), a
    },
    radialgradient: function (r) {
      var t = parseInt(r.getAttribute('cx') || '0', 10),
        e = parseInt(r.getAttribute('cy') || '0', 10),
        n = parseInt(r.getAttribute('r') || '0', 10),
        i = new OU(t, e, n)
      return cO(r, i), hO(r, i), i
    },
  }
function cO(r, t) {
  var e = r.getAttribute('gradientUnits')
  e === 'userSpaceOnUse' && (t.global = !0)
}
function hO(r, t) {
  for (var e = r.firstChild; e; ) {
    if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === 'stop') {
      var n = e.getAttribute('offset'),
        i = void 0
      n && n.indexOf('%') > 0
        ? (i = parseInt(n, 10) / 100)
        : n
        ? (i = parseFloat(n))
        : (i = 0)
      var a = {}
      qG(e, a, a)
      var o = a.stopColor || e.getAttribute('stop-color') || '#000000'
      t.colorStops.push({
        offset: i,
        color: o,
      })
    }
    e = e.nextSibling
  }
}
function Ii(r, t) {
  r &&
    r.__inheritedStyle &&
    (t.__inheritedStyle || (t.__inheritedStyle = {}),
    zt(t.__inheritedStyle, r.__inheritedStyle))
}
function fO(r) {
  for (var t = C_(r), e = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]),
      a = parseFloat(t[n + 1])
    e.push([i, a])
  }
  return e
}
function di(r, t, e, n, i) {
  var a = t,
    o = (a.__inheritedStyle = a.__inheritedStyle || {}),
    s = {}
  r.nodeType === 1 && (Mct(r, t), qG(r, o, s), n || Tct(r, o, s)),
    (a.style = a.style || {}),
    o.fill != null && (a.style.fill = dO(a, 'fill', o.fill, e)),
    o.stroke != null && (a.style.stroke = dO(a, 'stroke', o.stroke, e)),
    R(
      [
        'lineWidth',
        'opacity',
        'fillOpacity',
        'strokeOpacity',
        'miterLimit',
        'fontSize',
      ],
      function (l) {
        o[l] != null && (a.style[l] = parseFloat(o[l]))
      },
    ),
    R(
      [
        'lineDashOffset',
        'lineCap',
        'lineJoin',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'textAlign',
      ],
      function (l) {
        o[l] != null && (a.style[l] = o[l])
      },
    ),
    i && (a.__selfStyle = s),
    o.lineDash &&
      (a.style.lineDash = st(C_(o.lineDash), function (l) {
        return parseFloat(l)
      })),
    (o.visibility === 'hidden' || o.visibility === 'collapse') &&
      (a.invisible = !0),
    o.display === 'none' && (a.ignore = !0)
}
function xct(r, t) {
  var e = t.__selfStyle
  if (e) {
    var n = e.textBaseline,
      i = n
    !n || n === 'auto' || n === 'baseline'
      ? (i = 'alphabetic')
      : n === 'before-edge' || n === 'text-before-edge'
      ? (i = 'top')
      : n === 'after-edge' || n === 'text-after-edge'
      ? (i = 'bottom')
      : (n === 'central' || n === 'mathematical') && (i = 'middle'),
      (r.style.textBaseline = i)
  }
  var a = t.__inheritedStyle
  if (a) {
    var o = a.textAlign,
      s = o
    o && (o === 'middle' && (s = 'center'), (r.style.textAlign = s))
  }
}
var Sct = /^url\(\s*#(.*?)\)/
function dO(r, t, e, n) {
  var i = e && e.match(Sct)
  if (i) {
    var a = xa(i[1])
    n.push([r, t, a])
    return
  }
  return e === 'none' && (e = null), e
}
function Act(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e]
    n[0].style[n[1]] = r[n[2]]
  }
}
var bct = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
function C_(r) {
  return r.match(bct) || []
}
var wct = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g,
  hS = Math.PI / 180
function Mct(r, t) {
  var e = r.getAttribute('transform')
  if (e) {
    e = e.replace(/,/g, ' ')
    var n = [],
      i = null
    e.replace(wct, function (h, f, d) {
      return n.push(f, d), ''
    })
    for (var a = n.length - 1; a > 0; a -= 2) {
      var o = n[a],
        s = n[a - 1],
        l = C_(o)
      switch (((i = i || bi()), s)) {
        case 'translate':
          ho(i, i, [parseFloat(l[0]), parseFloat(l[1] || '0')])
          break
        case 'scale':
          IT(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])])
          break
        case 'rotate':
          ec(i, i, -parseFloat(l[0]) * hS, [
            parseFloat(l[1] || '0'),
            parseFloat(l[2] || '0'),
          ])
          break
        case 'skewX':
          var u = Math.tan(parseFloat(l[0]) * hS)
          Ho(i, [1, 0, u, 1, 0, 0], i)
          break
        case 'skewY':
          var c = Math.tan(parseFloat(l[0]) * hS)
          Ho(i, [1, c, 0, 1, 0, 0], i)
          break
        case 'matrix':
          ;(i[0] = parseFloat(l[0])),
            (i[1] = parseFloat(l[1])),
            (i[2] = parseFloat(l[2])),
            (i[3] = parseFloat(l[3])),
            (i[4] = parseFloat(l[4])),
            (i[5] = parseFloat(l[5]))
          break
      }
    }
    t.setLocalTransform(i)
  }
}
var pO = /([^\s:;]+)\s*:\s*([^:;]+)/g
function qG(r, t, e) {
  var n = r.getAttribute('style')
  if (n) {
    pO.lastIndex = 0
    for (var i; (i = pO.exec(n)) != null; ) {
      var a = i[1],
        o = Et(f0, a) ? f0[a] : null
      o && (t[o] = i[2])
      var s = Et(d0, a) ? d0[a] : null
      s && (e[s] = i[2])
    }
  }
}
function Tct(r, t, e) {
  for (var n = 0; n < sO.length; n++) {
    var i = sO[n],
      a = r.getAttribute(i)
    a != null && (t[f0[i]] = a)
  }
  for (var n = 0; n < lO.length; n++) {
    var i = lO[n],
      a = r.getAttribute(i)
    a != null && (e[d0[i]] = a)
  }
}
function ZG(r, t) {
  var e = t.width / r.width,
    n = t.height / r.height,
    i = Math.min(e, n)
  return {
    scale: i,
    x: -(r.x + r.width / 2) * i + (t.x + t.width / 2),
    y: -(r.y + r.height / 2) * i + (t.y + t.height / 2),
  }
}
function Cct(r, t) {
  var e = new _ct()
  return e.parse(r, t)
}
var Ect = Pt([
    'rect',
    'circle',
    'line',
    'ellipse',
    'polygon',
    'polyline',
    'path',
    'text',
    'tspan',
    'g',
  ]),
  Dct = (function () {
    function r(t, e) {
      ;(this.type = 'geoSVG'),
        (this._usedGraphicMap = Pt()),
        (this._freedGraphics = []),
        (this._mapName = t),
        (this._parsedXML = $G(e))
    }
    return (
      (r.prototype.load = function () {
        var t = this._firstGraphic
        if (!t) {
          ;(t = this._firstGraphic = this._buildGraphic(this._parsedXML)),
            this._freedGraphics.push(t),
            (this._boundingRect = this._firstGraphic.boundingRect.clone())
          var e = Pct(t.named),
            n = e.regions,
            i = e.regionsMap
          ;(this._regions = n), (this._regionsMap = i)
        }
        return {
          boundingRect: this._boundingRect,
          regions: this._regions,
          regionsMap: this._regionsMap,
        }
      }),
      (r.prototype._buildGraphic = function (t) {
        var e, n
        try {
          ;(e =
            (t &&
              Cct(t, {
                ignoreViewBox: !0,
                ignoreRootClip: !0,
              })) ||
            {}),
            (n = e.root),
            Gr(n != null)
        } catch (v) {
          throw new Error(
            `Invalid svg format
` + v.message,
          )
        }
        var i = new Ht()
        i.add(n), (i.isGeoSVGGraphicRoot = !0)
        var a = e.width,
          o = e.height,
          s = e.viewBoxRect,
          l = this._boundingRect
        if (!l) {
          var u = void 0,
            c = void 0,
            h = void 0,
            f = void 0
          if (
            (a != null ? ((u = 0), (h = a)) : s && ((u = s.x), (h = s.width)),
            o != null ? ((c = 0), (f = o)) : s && ((c = s.y), (f = s.height)),
            u == null || c == null)
          ) {
            var d = n.getBoundingRect()
            u == null && ((u = d.x), (h = d.width)),
              c == null && ((c = d.y), (f = d.height))
          }
          l = this._boundingRect = new ee(u, c, h, f)
        }
        if (s) {
          var p = ZG(s, l)
          ;(n.scaleX = n.scaleY = p.scale), (n.x = p.x), (n.y = p.y)
        }
        i.setClipPath(
          new ge({
            shape: l.plain(),
          }),
        )
        var g = []
        return (
          R(e.named, function (v) {
            Ect.get(v.svgNodeTagLower) != null && (g.push(v), Lct(v.el))
          }),
          {
            root: i,
            boundingRect: l,
            named: g,
          }
        )
      }),
      (r.prototype.useGraphic = function (t) {
        var e = this._usedGraphicMap,
          n = e.get(t)
        return (
          n ||
          ((n =
            this._freedGraphics.pop() || this._buildGraphic(this._parsedXML)),
          e.set(t, n),
          n)
        )
      }),
      (r.prototype.freeGraphic = function (t) {
        var e = this._usedGraphicMap,
          n = e.get(t)
        n && (e.removeKey(t), this._freedGraphics.push(n))
      }),
      r
    )
  })()
function Lct(r) {
  ;(r.silent = !1),
    r.isGroup &&
      r.traverse(function (t) {
        t.silent = !1
      })
}
function Pct(r) {
  var t = [],
    e = Pt()
  return (
    R(r, function (n) {
      if (n.namedFrom == null) {
        var i = new qot(n.name, n.el)
        t.push(i), e.set(n.name, i)
      }
    }),
    {
      regions: t,
      regionsMap: e,
    }
  )
}
var kw = [126, 25],
  vO = '南海诸岛',
  iu = [
    [
      [0, 3.5],
      [7, 11.2],
      [15, 11.9],
      [30, 7],
      [42, 0.7],
      [52, 0.7],
      [56, 7.7],
      [59, 0.7],
      [64, 0.7],
      [64, 0],
      [5, 0],
      [0, 3.5],
    ],
    [
      [13, 16.1],
      [19, 14.7],
      [16, 21.7],
      [11, 23.1],
      [13, 16.1],
    ],
    [
      [12, 32.2],
      [14, 38.5],
      [15, 38.5],
      [13, 32.2],
      [12, 32.2],
    ],
    [
      [16, 47.6],
      [12, 53.2],
      [13, 53.2],
      [18, 47.6],
      [16, 47.6],
    ],
    [
      [6, 64.4],
      [8, 70],
      [9, 70],
      [8, 64.4],
      [6, 64.4],
    ],
    [
      [23, 82.6],
      [29, 79.8],
      [30, 79.8],
      [25, 82.6],
      [23, 82.6],
    ],
    [
      [37, 70.7],
      [43, 62.3],
      [44, 62.3],
      [39, 70.7],
      [37, 70.7],
    ],
    [
      [48, 51.1],
      [51, 45.5],
      [53, 45.5],
      [50, 51.1],
      [48, 51.1],
    ],
    [
      [51, 35],
      [51, 28.7],
      [53, 28.7],
      [53, 35],
      [51, 35],
    ],
    [
      [52, 22.4],
      [55, 17.5],
      [56, 17.5],
      [53, 22.4],
      [52, 22.4],
    ],
    [
      [58, 12.6],
      [62, 7],
      [63, 7],
      [60, 12.6],
      [58, 12.6],
    ],
    [
      [0, 3.5],
      [0, 93.1],
      [64, 93.1],
      [64, 0],
      [63, 0],
      [63, 92.4],
      [1, 92.4],
      [1, 3.5],
      [0, 3.5],
    ],
  ]
for (var Jl = 0; Jl < iu.length; Jl++)
  for (var Kc = 0; Kc < iu[Jl].length; Kc++)
    (iu[Jl][Kc][0] /= 10.5),
      (iu[Jl][Kc][1] /= -10.5 / 0.75),
      (iu[Jl][Kc][0] += kw[0]),
      (iu[Jl][Kc][1] += kw[1])
function Rct(r, t) {
  if (r === 'china') {
    for (var e = 0; e < t.length; e++) if (t[e].name === vO) return
    t.push(
      new WV(
        vO,
        st(iu, function (n) {
          return {
            type: 'polygon',
            exterior: n,
          }
        }),
        kw,
      ),
    )
  }
}
var Ict = {
  南海诸岛: [32, 80],
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  天津: [5, 5],
}
function Oct(r, t) {
  if (r === 'china') {
    var e = Ict[t.name]
    if (e) {
      var n = t.getCenter()
      ;(n[0] += e[0] / 10.5), (n[1] += -e[1] / (10.5 / 0.75)), t.setCenter(n)
    }
  }
}
var Nct = [
  [
    [123.45165252685547, 25.73527164402261],
    [123.49731445312499, 25.73527164402261],
    [123.49731445312499, 25.750734064600884],
    [123.45165252685547, 25.750734064600884],
    [123.45165252685547, 25.73527164402261],
  ],
]
function kct(r, t) {
  r === 'china' &&
    t.name === '台湾' &&
    t.geometries.push({
      type: 'polygon',
      exterior: Nct[0],
    })
}
var Bct = 'name',
  Fct = (function () {
    function r(t, e, n) {
      ;(this.type = 'geoJSON'),
        (this._parsedMap = Pt()),
        (this._mapName = t),
        (this._specialAreas = n),
        (this._geoJSON = Uct(e))
    }
    return (
      (r.prototype.load = function (t, e) {
        e = e || Bct
        var n = this._parsedMap.get(e)
        if (!n) {
          var i = this._parseToRegions(e)
          n = this._parsedMap.set(e, {
            regions: i,
            boundingRect: zct(i),
          })
        }
        var a = Pt(),
          o = []
        return (
          R(n.regions, function (s) {
            var l = s.name
            t && Et(t, l) && (s = s.cloneShallow((l = t[l]))),
              o.push(s),
              a.set(l, s)
          }),
          {
            regions: o,
            boundingRect: n.boundingRect || new ee(0, 0, 0, 0),
            regionsMap: a,
          }
        )
      }),
      (r.prototype._parseToRegions = function (t) {
        var e = this._mapName,
          n = this._geoJSON,
          i
        try {
          i = n ? Kot(n, t) : []
        } catch (a) {
          throw new Error(
            `Invalid geoJson format
` + a.message,
          )
        }
        return (
          Rct(e, i),
          R(
            i,
            function (a) {
              var o = a.name
              Oct(e, a), kct(e, a)
              var s = this._specialAreas && this._specialAreas[o]
              s && a.transformTo(s.left, s.top, s.width, s.height)
            },
            this,
          ),
          i
        )
      }),
      (r.prototype.getMapForUser = function () {
        return {
          geoJson: this._geoJSON,
          geoJSON: this._geoJSON,
          specialAreas: this._specialAreas,
        }
      }),
      r
    )
  })()
function zct(r) {
  for (var t, e = 0; e < r.length; e++) {
    var n = r[e].getBoundingRect()
    ;(t = t || n.clone()), t.union(n)
  }
  return t
}
function Uct(r) {
  return bt(r)
    ? typeof JSON < 'u' && JSON.parse
      ? JSON.parse(r)
      : new Function('return (' + r + ');')()
    : r
}
var vd = Pt()
const rs = {
  registerMap: function (r, t, e) {
    if (t.svg) {
      var n = new Dct(r, t.svg)
      vd.set(r, n)
    } else {
      var i = t.geoJson || t.geoJSON
      i && !t.features ? (e = t.specialAreas) : (i = t)
      var n = new Fct(r, i, e)
      vd.set(r, n)
    }
  },
  getGeoResource: function (r) {
    return vd.get(r)
  },
  getMapForUser: function (r) {
    var t = vd.get(r)
    return t && t.type === 'geoJSON' && t.getMapForUser()
  },
  load: function (r, t, e) {
    var n = vd.get(r)
    if (n) return n.load(t, e)
  },
}
var GC = ['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path'],
  Vct = Pt(GC),
  Gct = Pt(GC.concat(['g'])),
  Hct = Pt(GC.concat(['g'])),
  KG = ve()
function vm(r) {
  var t = r.getItemStyle(),
    e = r.get('areaColor')
  return e != null && (t.fill = e), t
}
function gO(r) {
  var t = r.style
  t && ((t.stroke = t.stroke || t.fill), (t.fill = null))
}
var Wct = (function () {
  function r(t) {
    var e = new Ht()
    ;(this.uid = bf('ec_map_draw')),
      (this._controller = new Rv(t.getZr())),
      (this._controllerHost = {
        target: e,
      }),
      (this.group = e),
      e.add((this._regionsGroup = new Ht())),
      e.add((this._svgGroup = new Ht()))
  }
  return (
    (r.prototype.draw = function (t, e, n, i, a) {
      var o = t.mainType === 'geo',
        s = t.getData && t.getData()
      o &&
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'map',
          },
          function (m) {
            !s && m.getHostGeoModel() === t && (s = m.getData())
          },
        )
      var l = t.coordinateSystem,
        u = this._regionsGroup,
        c = this.group,
        h = l.getTransformInfo(),
        f = h.raw,
        d = h.roam,
        p = !u.childAt(0) || a
      p
        ? ((c.x = d.x),
          (c.y = d.y),
          (c.scaleX = d.scaleX),
          (c.scaleY = d.scaleY),
          c.dirty())
        : we(c, d, t)
      var g =
          s &&
          s.getVisual('visualMeta') &&
          s.getVisual('visualMeta').length > 0,
        v = {
          api: n,
          geo: l,
          mapOrGeoModel: t,
          data: s,
          isVisualEncodedByVisualMap: g,
          isGeo: o,
          transformInfoRaw: f,
        }
      l.resourceType === 'geoJSON'
        ? this._buildGeoJSON(v)
        : l.resourceType === 'geoSVG' && this._buildSVG(v),
        this._updateController(t, e, n),
        this._updateMapSelectHandler(t, u, n, i)
    }),
    (r.prototype._buildGeoJSON = function (t) {
      var e = (this._regionsGroupByName = Pt()),
        n = Pt(),
        i = this._regionsGroup,
        a = t.transformInfoRaw,
        o = t.mapOrGeoModel,
        s = t.data,
        l = t.geo.projection,
        u = l && l.stream
      function c(d, p) {
        return (
          p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y]
        )
      }
      function h(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g)
          m && p.push(m)
        }
        return p
      }
      function f(d) {
        return {
          shape: {
            points: h(d),
          },
        }
      }
      i.removeAll(),
        R(t.geo.regions, function (d) {
          var p = d.name,
            g = e.get(p),
            v = n.get(p) || {},
            m = v.dataIdx,
            y = v.regionModel
          g ||
            ((g = e.set(p, new Ht())),
            i.add(g),
            (m = s ? s.indexOfName(p) : null),
            (y = t.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null),
            n.set(p, {
              dataIdx: m,
              regionModel: y,
            }))
          var _ = [],
            x = []
          R(d.geometries, function (b) {
            if (b.type === 'polygon') {
              var T = [b.exterior].concat(b.interiors || [])
              u && (T = AO(T, u)),
                R(T, function (M) {
                  _.push(new si(f(M)))
                })
            } else {
              var w = b.points
              u && (w = AO(w, u, !0)),
                R(w, function (M) {
                  x.push(new li(f(M)))
                })
            }
          })
          var A = c(d.getCenter(), l && l.project)
          function S(b, T) {
            if (b.length) {
              var w = new JT({
                culling: !0,
                segmentIgnoreThreshold: 1,
                shape: {
                  paths: b,
                },
              })
              g.add(w),
                mO(t, w, m, y),
                yO(t, w, p, y, o, m, A),
                T && (gO(w), R(w.states, gO))
            }
          }
          S(_), S(x, !0)
        }),
        e.each(function (d, p) {
          var g = n.get(p),
            v = g.dataIdx,
            m = g.regionModel
          _O(t, d, p, m, o, v), xO(t, d, p, m, o), SO(t, d, p, m, o)
        }, this)
    }),
    (r.prototype._buildSVG = function (t) {
      var e = t.geo.map,
        n = t.transformInfoRaw
      ;(this._svgGroup.x = n.x),
        (this._svgGroup.y = n.y),
        (this._svgGroup.scaleX = n.scaleX),
        (this._svgGroup.scaleY = n.scaleY),
        this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e))
      var i = (this._svgDispatcherMap = Pt()),
        a = !1
      R(
        this._svgGraphicRecord.named,
        function (o) {
          var s = o.name,
            l = t.mapOrGeoModel,
            u = t.data,
            c = o.svgNodeTagLower,
            h = o.el,
            f = u ? u.indexOfName(s) : null,
            d = l.getRegionModel(s)
          if (
            (Vct.get(c) != null && h instanceof ea && mO(t, h, f, d),
            h instanceof ea && (h.culling = !0),
            (h.z2EmphasisLift = 0),
            !o.namedFrom &&
              (Hct.get(c) != null && yO(t, h, s, d, l, f, null),
              _O(t, h, s, d, l, f),
              xO(t, h, s, d, l),
              Gct.get(c) != null))
          ) {
            var p = SO(t, h, s, d, l)
            p === 'self' && (a = !0)
            var g = i.get(s) || i.set(s, [])
            g.push(h)
          }
        },
        this,
      ),
        this._enableBlurEntireSVG(a, t)
    }),
    (r.prototype._enableBlurEntireSVG = function (t, e) {
      if (t && e.isGeo) {
        var n = e.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle(),
          i = n.opacity
        this._svgGraphicRecord.root.traverse(function (a) {
          if (!a.isGroup) {
            qu(a)
            var o = a.ensureState('blur').style || {}
            o.opacity == null && i != null && (o.opacity = i),
              a.ensureState('emphasis')
          }
        })
      }
    }),
    (r.prototype.remove = function () {
      this._regionsGroup.removeAll(),
        (this._regionsGroupByName = null),
        this._svgGroup.removeAll(),
        this._freeSVG(),
        this._controller.dispose(),
        (this._controllerHost = null)
    }),
    (r.prototype.findHighDownDispatchers = function (t, e) {
      if (t == null) return []
      var n = e.coordinateSystem
      if (n.resourceType === 'geoJSON') {
        var i = this._regionsGroupByName
        if (i) {
          var a = i.get(t)
          return a ? [a] : []
        }
      } else if (n.resourceType === 'geoSVG')
        return (this._svgDispatcherMap && this._svgDispatcherMap.get(t)) || []
    }),
    (r.prototype._svgResourceChanged = function (t) {
      return this._svgMapName !== t
    }),
    (r.prototype._useSVG = function (t) {
      var e = rs.getGeoResource(t)
      if (e && e.type === 'geoSVG') {
        var n = e.useGraphic(this.uid)
        this._svgGroup.add(n.root),
          (this._svgGraphicRecord = n),
          (this._svgMapName = t)
      }
    }),
    (r.prototype._freeSVG = function () {
      var t = this._svgMapName
      if (t != null) {
        var e = rs.getGeoResource(t)
        e && e.type === 'geoSVG' && e.freeGraphic(this.uid),
          (this._svgGraphicRecord = null),
          (this._svgDispatcherMap = null),
          this._svgGroup.removeAll(),
          (this._svgMapName = null)
      }
    }),
    (r.prototype._updateController = function (t, e, n) {
      var i = t.coordinateSystem,
        a = this._controller,
        o = this._controllerHost
      ;(o.zoomLimit = t.get('scaleLimit')),
        (o.zoom = i.getZoom()),
        a.enable(t.get('roam') || !1)
      var s = t.mainType
      function l() {
        var u = {
          type: 'geoRoam',
          componentType: s,
        }
        return (u[s + 'Id'] = t.id), u
      }
      a.off('pan').on(
        'pan',
        function (u) {
          ;(this._mouseDownFlag = !1),
            UC(o, u.dx, u.dy),
            n.dispatchAction(
              Q(l(), {
                dx: u.dx,
                dy: u.dy,
                animation: {
                  duration: 0,
                },
              }),
            )
        },
        this,
      ),
        a.off('zoom').on(
          'zoom',
          function (u) {
            ;(this._mouseDownFlag = !1),
              VC(o, u.scale, u.originX, u.originY),
              n.dispatchAction(
                Q(l(), {
                  totalZoom: o.zoom,
                  zoom: u.scale,
                  originX: u.originX,
                  originY: u.originY,
                  animation: {
                    duration: 0,
                  },
                }),
              )
          },
          this,
        ),
        a.setPointerChecker(function (u, c, h) {
          return i.containPoint([c, h]) && !T_(u, n, t)
        })
    }),
    (r.prototype.resetForLabelLayout = function () {
      this.group.traverse(function (t) {
        var e = t.getTextContent()
        e && (e.ignore = KG(e).ignore)
      })
    }),
    (r.prototype._updateMapSelectHandler = function (t, e, n, i) {
      var a = this
      e.off('mousedown'),
        e.off('click'),
        t.get('selectedMode') &&
          (e.on('mousedown', function () {
            a._mouseDownFlag = !0
          }),
          e.on('click', function (o) {
            a._mouseDownFlag && (a._mouseDownFlag = !1)
          }))
    }),
    r
  )
})()
function mO(r, t, e, n) {
  var i = n.getModel('itemStyle'),
    a = n.getModel(['emphasis', 'itemStyle']),
    o = n.getModel(['blur', 'itemStyle']),
    s = n.getModel(['select', 'itemStyle']),
    l = vm(i),
    u = vm(a),
    c = vm(s),
    h = vm(o),
    f = r.data
  if (f) {
    var d = f.getItemVisual(e, 'style'),
      p = f.getItemVisual(e, 'decal')
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill),
      p && (l.decal = rf(p, r.api))
  }
  t.setStyle(l),
    (t.style.strokeNoScale = !0),
    (t.ensureState('emphasis').style = u),
    (t.ensureState('select').style = c),
    (t.ensureState('blur').style = h),
    qu(t)
}
function yO(r, t, e, n, i, a, o) {
  var s = r.data,
    l = r.isGeo,
    u = s && isNaN(s.get(s.mapDimension('value'), a)),
    c = s && s.getItemLayout(a)
  if (l || u || (c && c.showLabel)) {
    var h = l ? e : a,
      f = void 0
    ;(!s || a >= 0) && (f = i)
    var d = o
      ? {
          normal: {
            align: 'center',
            verticalAlign: 'middle',
          },
        }
      : null
    mr(
      t,
      Zn(n),
      {
        labelFetcher: f,
        labelDataIndex: h,
        defaultText: e,
      },
      d,
    )
    var p = t.getTextContent()
    if (p && ((KG(p).ignore = p.ignore), t.textConfig && o)) {
      var g = t.getBoundingRect().clone()
      ;(t.textConfig.layoutRect = g),
        (t.textConfig.position = [
          ((o[0] - g.x) / g.width) * 100 + '%',
          ((o[1] - g.y) / g.height) * 100 + '%',
        ])
    }
    t.disableLabelAnimation = !0
  } else
    t.removeTextContent(),
      t.removeTextConfig(),
      (t.disableLabelAnimation = null)
}
function _O(r, t, e, n, i, a) {
  r.data
    ? r.data.setItemGraphicEl(a, t)
    : (Wt(t).eventData = {
        componentType: 'geo',
        componentIndex: i.componentIndex,
        geoIndex: i.componentIndex,
        name: e,
        region: (n && n.option) || {},
      })
}
function xO(r, t, e, n, i) {
  r.data ||
    Sf({
      el: t,
      componentModel: i,
      itemName: e,
      itemTooltipOption: n.get('tooltip'),
    })
}
function SO(r, t, e, n, i) {
  t.highDownSilentOnTouch = !!i.get('selectedMode')
  var a = n.getModel('emphasis'),
    o = a.get('focus')
  return (
    fn(t, o, a.get('blurScope'), a.get('disabled')), r.isGeo && Xet(t, i, e), o
  )
}
function AO(r, t, e) {
  var n = [],
    i
  function a() {
    i = []
  }
  function o() {
    i.length && (n.push(i), (i = []))
  }
  var s = t({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function (l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u])
    },
    sphere: function () {},
  })
  return (
    !e && s.polygonStart(),
    R(r, function (l) {
      s.lineStart()
      for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1])
      s.lineEnd()
    }),
    !e && s.polygonEnd(),
    n
  )
}
const jG = Wct
var Xct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      if (!(a && a.type === 'mapToggleSelect' && a.from === this.uid)) {
        var o = this.group
        if ((o.removeAll(), !e.getHostGeoModel())) {
          if (
            (this._mapDraw &&
              a &&
              a.type === 'geoRoam' &&
              this._mapDraw.resetForLabelLayout(),
            a &&
              a.type === 'geoRoam' &&
              a.componentType === 'series' &&
              a.seriesId === e.id)
          ) {
            var s = this._mapDraw
            s && o.add(s.group)
          } else if (e.needsDrawMap) {
            var s = this._mapDraw || new jG(i)
            o.add(s.group), s.draw(e, n, i, this, a), (this._mapDraw = s)
          } else this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
          e.get('showLegendSymbol') &&
            n.getComponent('legend') &&
            this._renderSymbols(e, n, i)
        }
      }
    }),
    (t.prototype.remove = function () {
      this._mapDraw && this._mapDraw.remove(),
        (this._mapDraw = null),
        this.group.removeAll()
    }),
    (t.prototype.dispose = function () {
      this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
    }),
    (t.prototype._renderSymbols = function (e, n, i) {
      var a = e.originalData,
        o = this.group
      a.each(a.mapDimension('value'), function (s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l)
          if (!(!u || !u.point)) {
            var c = u.point,
              h = u.offset,
              f = new pl({
                style: {
                  fill: e.getData().getVisual('style').fill,
                },
                shape: {
                  cx: c[0] + h * 9,
                  cy: c[1],
                  r: 3,
                },
                silent: !0,
                z2: 8 + (h ? 0 : _f + 1),
              })
            if (!h) {
              var d = e.mainSeries.getData(),
                p = a.getName(l),
                g = d.indexOfName(p),
                v = a.getItemModel(l),
                m = v.getModel('label'),
                y = d.getItemGraphicEl(g)
              mr(f, Zn(v), {
                labelFetcher: {
                  getFormattedLabel: function (_, x) {
                    return e.getFormattedLabel(g, x)
                  },
                },
                defaultText: p,
              }),
                (f.disableLabelAnimation = !0),
                m.get('position') ||
                  f.setTextConfig({
                    position: 'bottom',
                  }),
                (y.onHoverStateChange = function (_) {
                  Xy(f, _)
                })
            }
            o.add(f)
          }
        }
      })
    }),
    (t.type = 'map'),
    t
  )
})(Ze)
const Yct = Xct
var $ct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.needsDrawMap = !1),
      (e.seriesGroup = []),
      (e.getTooltipPosition = function (n) {
        if (n != null) {
          var i = this.getData().getName(n),
            a = this.coordinateSystem,
            o = a.getRegion(i)
          return o && a.dataToPoint(o.getCenter())
        }
      }),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e) {
      for (
        var n = Rf(this, {
            coordDimensions: ['value'],
            encodeDefaulter: Zt(lC, this),
          }),
          i = Pt(),
          a = [],
          o = 0,
          s = n.count();
        o < s;
        o++
      ) {
        var l = n.getName(o)
        i.set(l, !0)
      }
      var u = rs.load(
        this.getMapType(),
        this.option.nameMap,
        this.option.nameProperty,
      )
      return (
        R(u.regions, function (c) {
          var h = c.name
          i.get(h) || a.push(h)
        }),
        n.appendValues([], a),
        n
      )
    }),
    (t.prototype.getHostGeoModel = function () {
      var e = this.option.geoIndex
      return e != null ? this.ecModel.getComponent('geo', e) : null
    }),
    (t.prototype.getMapType = function () {
      return (this.getHostGeoModel() || this).option.map
    }),
    (t.prototype.getRawValue = function (e) {
      var n = this.getData()
      return n.get(n.mapDimension('value'), e)
    }),
    (t.prototype.getRegionModel = function (e) {
      var n = this.getData()
      return n.getItemModel(n.indexOfName(e))
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      for (
        var a = this.getData(),
          o = this.getRawValue(e),
          s = a.getName(e),
          l = this.seriesGroup,
          u = [],
          c = 0;
        c < l.length;
        c++
      ) {
        var h = l[c].originalData.indexOfName(s),
          f = a.mapDimension('value')
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name)
      }
      return Kn('section', {
        header: u.join(', '),
        noHeader: !u.length,
        blocks: [
          Kn('nameValue', {
            name: s,
            value: o,
          }),
        ],
      })
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.getLegendIcon = function (e) {
      var n = e.icon || 'roundRect',
        i = Rn(n, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill)
      return (
        i.setStyle(e.itemStyle),
        (i.style.stroke = 'none'),
        n.indexOf('empty') > -1 &&
          ((i.style.stroke = i.style.fill),
          (i.style.fill = '#fff'),
          (i.style.lineWidth = 2)),
        i
      )
    }),
    (t.type = 'series.map'),
    (t.dependencies = ['geo']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'geo',
      map: '',
      left: 'center',
      top: 'center',
      aspectScale: null,
      showLegendSymbol: !0,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: '#000',
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: '#444',
        areaColor: '#eee',
      },
      emphasis: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          areaColor: 'rgba(255,215,0,0.8)',
        },
      },
      select: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      nameProperty: 'name',
    }),
    t
  )
})(rn)
const qct = $ct
function Zct(r, t) {
  var e = {}
  return (
    R(r, function (n) {
      n.each(n.mapDimension('value'), function (i, a) {
        var o = 'ec-' + n.getName(a)
        ;(e[o] = e[o] || []), isNaN(i) || e[o].push(i)
      })
    }),
    r[0].map(r[0].mapDimension('value'), function (n, i) {
      for (
        var a = 'ec-' + r[0].getName(i),
          o = 0,
          s = 1 / 0,
          l = -1 / 0,
          u = e[a].length,
          c = 0;
        c < u;
        c++
      )
        (s = Math.min(s, e[a][c])), (l = Math.max(l, e[a][c])), (o += e[a][c])
      var h
      return (
        t === 'min'
          ? (h = s)
          : t === 'max'
          ? (h = l)
          : t === 'average'
          ? (h = o / u)
          : (h = o),
        u === 0 ? NaN : h
      )
    })
  )
}
function Kct(r) {
  var t = {}
  r.eachSeriesByType('map', function (e) {
    var n = e.getHostGeoModel(),
      i = n ? 'o' + n.id : 'i' + e.getMapType()
    ;(t[i] = t[i] || []).push(e)
  }),
    R(t, function (e, n) {
      for (
        var i = Zct(
            st(e, function (o) {
              return o.getData()
            }),
            e[0].get('mapValueCalculation'),
          ),
          a = 0;
        a < e.length;
        a++
      )
        e[a].originalData = e[a].getData()
      for (var a = 0; a < e.length; a++)
        (e[a].seriesGroup = e),
          (e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel()),
          e[a].setData(i.cloneShallow()),
          (e[a].mainSeries = e[0])
    })
}
function jct(r) {
  var t = {}
  r.eachSeriesByType('map', function (e) {
    var n = e.getMapType()
    if (!(e.getHostGeoModel() || t[n])) {
      var i = {}
      R(e.seriesGroup, function (o) {
        var s = o.coordinateSystem,
          l = o.originalData
        o.get('showLegendSymbol') &&
          r.getComponent('legend') &&
          l.each(l.mapDimension('value'), function (u, c) {
            var h = l.getName(c),
              f = s.getRegion(h)
            if (!(!f || isNaN(u))) {
              var d = i[h] || 0,
                p = s.dataToPoint(f.getCenter())
              ;(i[h] = d + 1),
                l.setItemLayout(c, {
                  point: p,
                  offset: d,
                })
            }
          })
      })
      var a = e.getData()
      a.each(function (o) {
        var s = a.getName(o),
          l = a.getItemLayout(o) || {}
        ;(l.showLabel = !i[s]), a.setItemLayout(o, l)
      }),
        (t[n] = !0)
    }
  })
}
var bO = pr,
  Jct = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this) || this
      return (
        (n.type = 'view'),
        (n.dimensions = ['x', 'y']),
        (n._roamTransformable = new Uo()),
        (n._rawTransformable = new Uo()),
        (n.name = e),
        n
      )
    }
    return (
      (t.prototype.setBoundingRect = function (e, n, i, a) {
        return (this._rect = new ee(e, n, i, a)), this._rect
      }),
      (t.prototype.getBoundingRect = function () {
        return this._rect
      }),
      (t.prototype.setViewRect = function (e, n, i, a) {
        this._transformTo(e, n, i, a), (this._viewRect = new ee(e, n, i, a))
      }),
      (t.prototype._transformTo = function (e, n, i, a) {
        var o = this.getBoundingRect(),
          s = this._rawTransformable
        s.transform = o.calculateTransform(new ee(e, n, i, a))
        var l = s.parent
        ;(s.parent = null),
          s.decomposeTransform(),
          (s.parent = l),
          this._updateTransform()
      }),
      (t.prototype.setCenter = function (e, n) {
        e &&
          ((this._center = [_t(e[0], n.getWidth()), _t(e[1], n.getHeight())]),
          this._updateCenterAndZoom())
      }),
      (t.prototype.setZoom = function (e) {
        e = e || 1
        var n = this.zoomLimit
        n &&
          (n.max != null && (e = Math.min(n.max, e)),
          n.min != null && (e = Math.max(n.min, e))),
          (this._zoom = e),
          this._updateCenterAndZoom()
      }),
      (t.prototype.getDefaultCenter = function () {
        var e = this.getBoundingRect(),
          n = e.x + e.width / 2,
          i = e.y + e.height / 2
        return [n, i]
      }),
      (t.prototype.getCenter = function () {
        return this._center || this.getDefaultCenter()
      }),
      (t.prototype.getZoom = function () {
        return this._zoom || 1
      }),
      (t.prototype.getRoamTransform = function () {
        return this._roamTransformable.getLocalTransform()
      }),
      (t.prototype._updateCenterAndZoom = function () {
        var e = this._rawTransformable.getLocalTransform(),
          n = this._roamTransformable,
          i = this.getDefaultCenter(),
          a = this.getCenter(),
          o = this.getZoom()
        ;(a = pr([], a, e)),
          (i = pr([], i, e)),
          (n.originX = a[0]),
          (n.originY = a[1]),
          (n.x = i[0] - a[0]),
          (n.y = i[1] - a[1]),
          (n.scaleX = n.scaleY = o),
          this._updateTransform()
      }),
      (t.prototype._updateTransform = function () {
        var e = this._roamTransformable,
          n = this._rawTransformable
        ;(n.parent = e),
          e.updateTransform(),
          n.updateTransform(),
          RT(this.transform || (this.transform = []), n.transform || bi()),
          (this._rawTransform = n.getLocalTransform()),
          (this.invTransform = this.invTransform || []),
          mf(this.invTransform, this.transform),
          this.decomposeTransform()
      }),
      (t.prototype.getTransformInfo = function () {
        var e = this._rawTransformable,
          n = this._roamTransformable,
          i = new Uo()
        return (
          (i.transform = n.transform),
          i.decomposeTransform(),
          {
            roam: {
              x: i.x,
              y: i.y,
              scaleX: i.scaleX,
              scaleY: i.scaleY,
            },
            raw: {
              x: e.x,
              y: e.y,
              scaleX: e.scaleX,
              scaleY: e.scaleY,
            },
          }
        )
      }),
      (t.prototype.getViewRect = function () {
        return this._viewRect
      }),
      (t.prototype.getViewRectAfterRoam = function () {
        var e = this.getBoundingRect().clone()
        return e.applyTransform(this.transform), e
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        var a = n ? this._rawTransform : this.transform
        return (i = i || []), a ? bO(i, e, a) : Nr(i, e)
      }),
      (t.prototype.pointToData = function (e) {
        var n = this.invTransform
        return n ? bO([], e, n) : [e[0], e[1]]
      }),
      (t.prototype.convertToPixel = function (e, n, i) {
        var a = wO(n)
        return a === this ? a.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, n, i) {
        var a = wO(n)
        return a === this ? a.pointToData(i) : null
      }),
      (t.prototype.containPoint = function (e) {
        return this.getViewRectAfterRoam().contain(e[0], e[1])
      }),
      (t.dimensions = ['x', 'y']),
      t
    )
  })(Uo)
function wO(r) {
  var t = r.seriesModel
  return t ? t.coordinateSystem : null
}
const Iv = Jct
var Qct = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: !0,
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: !1,
    },
  },
  JG = ['lng', 'lat'],
  QG = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this, e) || this
      ;(a.dimensions = JG),
        (a.type = 'geo'),
        (a._nameCoordMap = Pt()),
        (a.map = n)
      var o = i.projection,
        s = rs.load(n, i.nameMap, i.nameProperty),
        l = rs.getGeoResource(n)
      a.resourceType = l ? l.type : null
      var u = (a.regions = s.regions),
        c = Qct[l.type]
      ;(a._regionsMap = s.regionsMap),
        (a.regions = s.regions),
        (a.projection = o)
      var h
      if (o)
        for (var f = 0; f < u.length; f++) {
          var d = u[f].getBoundingRect(o)
          ;(h = h || d.clone()), h.union(d)
        }
      else h = s.boundingRect
      return (
        a.setBoundingRect(h.x, h.y, h.width, h.height),
        (a.aspectScale = o ? 1 : $t(i.aspectScale, c.aspectScale)),
        (a._invertLongitute = o ? !1 : c.invertLongitute),
        a
      )
    }
    return (
      (t.prototype._transformTo = function (e, n, i, a) {
        var o = this.getBoundingRect(),
          s = this._invertLongitute
        ;(o = o.clone()), s && (o.y = -o.y - o.height)
        var l = this._rawTransformable
        l.transform = o.calculateTransform(new ee(e, n, i, a))
        var u = l.parent
        ;(l.parent = null),
          l.decomposeTransform(),
          (l.parent = u),
          s && (l.scaleY = -l.scaleY),
          this._updateTransform()
      }),
      (t.prototype.getRegion = function (e) {
        return this._regionsMap.get(e)
      }),
      (t.prototype.getRegionByCoord = function (e) {
        for (var n = this.regions, i = 0; i < n.length; i++) {
          var a = n[i]
          if (a.type === 'geoJSON' && a.contain(e)) return n[i]
        }
      }),
      (t.prototype.addGeoCoord = function (e, n) {
        this._nameCoordMap.set(e, n)
      }),
      (t.prototype.getGeoCoord = function (e) {
        var n = this._regionsMap.get(e)
        return this._nameCoordMap.get(e) || (n && n.getCenter())
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        if ((bt(e) && (e = this.getGeoCoord(e)), e)) {
          var a = this.projection
          return a && (e = a.project(e)), e && this.projectedToPoint(e, n, i)
        }
      }),
      (t.prototype.pointToData = function (e) {
        var n = this.projection
        return n && (e = n.unproject(e)), e && this.pointToProjected(e)
      }),
      (t.prototype.pointToProjected = function (e) {
        return r.prototype.pointToData.call(this, e)
      }),
      (t.prototype.projectedToPoint = function (e, n, i) {
        return r.prototype.dataToPoint.call(this, e, n, i)
      }),
      (t.prototype.convertToPixel = function (e, n, i) {
        var a = MO(n)
        return a === this ? a.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, n, i) {
        var a = MO(n)
        return a === this ? a.pointToData(i) : null
      }),
      t
    )
  })(Iv)
In(QG, Iv)
function MO(r) {
  var t = r.geoModel,
    e = r.seriesModel
  return t
    ? t.coordinateSystem
    : e
    ? e.coordinateSystem ||
      (e.getReferringComponents('geo', Pn).models[0] || {}).coordinateSystem
    : null
}
const TO = QG
function CO(r, t) {
  var e = r.get('boundingCoords')
  if (e != null) {
    var n = e[0],
      i = e[1]
    if (isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])) {
      var a = this.projection
      if (a) {
        var o = n[0],
          s = n[1],
          l = i[0],
          u = i[1]
        ;(n = [1 / 0, 1 / 0]), (i = [-1 / 0, -1 / 0])
        var c = function (S, b, T, w) {
          for (var M = T - S, C = w - b, E = 0; E <= 100; E++) {
            var D = E / 100,
              P = a.project([S + M * D, b + C * D])
            Bs(n, n, P), Fs(i, i, P)
          }
        }
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s)
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1])
    }
  }
  var h = this.getBoundingRect(),
    f = r.get('layoutCenter'),
    d = r.get('layoutSize'),
    p = t.getWidth(),
    g = t.getHeight(),
    v = (h.width / h.height) * this.aspectScale,
    m = !1,
    y,
    _
  f &&
    d &&
    ((y = [_t(f[0], p), _t(f[1], g)]),
    (_ = _t(d, Math.min(p, g))),
    !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(_) && (m = !0))
  var x
  if (m)
    (x = {}),
      v > 1
        ? ((x.width = _), (x.height = _ / v))
        : ((x.height = _), (x.width = _ * v)),
      (x.y = y[1] - x.height / 2),
      (x.x = y[0] - x.width / 2)
  else {
    var A = r.getBoxLayoutParams()
    ;(A.aspect = v),
      (x = Vn(A, {
        width: p,
        height: g,
      }))
  }
  this.setViewRect(x.x, x.y, x.width, x.height),
    this.setCenter(r.get('center'), t),
    this.setZoom(r.get('zoom'))
}
function tht(r, t) {
  R(t.get('geoCoord'), function (e, n) {
    r.addGeoCoord(n, e)
  })
}
var eht = (function () {
    function r() {
      this.dimensions = JG
    }
    return (
      (r.prototype.create = function (t, e) {
        var n = []
        function i(o) {
          return {
            nameProperty: o.get('nameProperty'),
            aspectScale: o.get('aspectScale'),
            projection: o.get('projection'),
          }
        }
        t.eachComponent('geo', function (o, s) {
          var l = o.get('map'),
            u = new TO(
              l + s,
              l,
              Q(
                {
                  nameMap: o.get('nameMap'),
                },
                i(o),
              ),
            )
          ;(u.zoomLimit = o.get('scaleLimit')),
            n.push(u),
            (o.coordinateSystem = u),
            (u.model = o),
            (u.resize = CO),
            u.resize(o, e)
        }),
          t.eachSeries(function (o) {
            var s = o.get('coordinateSystem')
            if (s === 'geo') {
              var l = o.get('geoIndex') || 0
              o.coordinateSystem = n[l]
            }
          })
        var a = {}
        return (
          t.eachSeriesByType('map', function (o) {
            if (!o.getHostGeoModel()) {
              var s = o.getMapType()
              ;(a[s] = a[s] || []), a[s].push(o)
            }
          }),
          R(a, function (o, s) {
            var l = st(o, function (c) {
                return c.get('nameMap')
              }),
              u = new TO(
                s,
                s,
                Q(
                  {
                    nameMap: ET(l),
                  },
                  i(o[0]),
                ),
              )
            ;(u.zoomLimit = nr.apply(
              null,
              st(o, function (c) {
                return c.get('scaleLimit')
              }),
            )),
              n.push(u),
              (u.resize = CO),
              u.resize(o[0], e),
              R(o, function (c) {
                ;(c.coordinateSystem = u), tht(u, c)
              })
          }),
          n
        )
      }),
      (r.prototype.getFilledRegions = function (t, e, n, i) {
        for (var a = (t || []).slice(), o = Pt(), s = 0; s < a.length; s++)
          o.set(a[s].name, a[s])
        var l = rs.load(e, n, i)
        return (
          R(l.regions, function (u) {
            var c = u.name
            !o.get(c) &&
              a.push({
                name: c,
              })
          }),
          a
        )
      }),
      r
    )
  })(),
  nht = new eht()
const t4 = nht
var rht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      var a = rs.getGeoResource(e.map)
      if (a && a.type === 'geoJSON') {
        var o = (e.itemStyle = e.itemStyle || {})
        'color' in o || (o.color = '#eee')
      }
      this.mergeDefaultAndTheme(e, i), Xu(e, 'label', ['show'])
    }),
    (t.prototype.optionUpdated = function () {
      var e = this,
        n = this.option
      n.regions = t4.getFilledRegions(
        n.regions,
        n.map,
        n.nameMap,
        n.nameProperty,
      )
      var i = {}
      ;(this._optionModelMap = co(
        n.regions || [],
        function (a, o) {
          var s = o.name
          return (
            s && (a.set(s, new qe(o, e, e.ecModel)), o.selected && (i[s] = !0)),
            a
          )
        },
        Pt(),
      )),
        n.selectedMap || (n.selectedMap = i)
    }),
    (t.prototype.getRegionModel = function (e) {
      return this._optionModelMap.get(e) || new qe(null, this, this.ecModel)
    }),
    (t.prototype.getFormattedLabel = function (e, n) {
      var i = this.getRegionModel(e),
        a =
          n === 'normal'
            ? i.get(['label', 'formatter'])
            : i.get(['emphasis', 'label', 'formatter']),
        o = {
          name: e,
        }
      if (Nt(a)) return (o.status = n), a(o)
      if (bt(a)) return a.replace('{a}', e ?? '')
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.select = function (e) {
      var n = this.option,
        i = n.selectedMode
      if (i) {
        i !== 'multiple' && (n.selectedMap = null)
        var a = n.selectedMap || (n.selectedMap = {})
        a[e] = !0
      }
    }),
    (t.prototype.unSelect = function (e) {
      var n = this.option.selectedMap
      n && (n[e] = !1)
    }),
    (t.prototype.toggleSelected = function (e) {
      this[this.isSelected(e) ? 'unSelect' : 'select'](e)
    }),
    (t.prototype.isSelected = function (e) {
      var n = this.option.selectedMap
      return !!(n && n[e])
    }),
    (t.type = 'geo'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 0,
      show: !0,
      left: 'center',
      top: 'center',
      aspectScale: null,
      silent: !1,
      map: '',
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: !1,
        color: '#000',
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: '#444',
      },
      emphasis: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      select: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      regions: [],
    }),
    t
  )
})(xe)
const iht = rht
function EO(r, t) {
  return r.pointToProjected ? r.pointToProjected(t) : r.pointToData(t)
}
function HC(r, t, e, n) {
  var i = r.getZoom(),
    a = r.getCenter(),
    o = t.zoom,
    s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a)
  if (
    (t.dx != null &&
      t.dy != null &&
      ((s[0] -= t.dx), (s[1] -= t.dy), r.setCenter(EO(r, s), n)),
    o != null)
  ) {
    if (e) {
      var l = e.min || 0,
        u = e.max || 1 / 0
      o = Math.max(Math.min(i * o, u), l) / i
    }
    ;(r.scaleX *= o), (r.scaleY *= o)
    var c = (t.originX - r.x) * (o - 1),
      h = (t.originY - r.y) * (o - 1)
    ;(r.x -= c),
      (r.y -= h),
      r.updateTransform(),
      r.setCenter(EO(r, s), n),
      r.setZoom(o * i)
  }
  return {
    center: r.getCenter(),
    zoom: r.getZoom(),
  }
}
var aht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.focusBlurEnabled = !0), e
  }
  return (
    (t.prototype.init = function (e, n) {
      this._api = n
    }),
    (t.prototype.render = function (e, n, i, a) {
      if (((this._model = e), !e.get('show'))) {
        this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
        return
      }
      this._mapDraw || (this._mapDraw = new jG(i))
      var o = this._mapDraw
      o.draw(e, n, i, this, a),
        o.group.on('click', this._handleRegionClick, this),
        (o.group.silent = e.get('silent')),
        this.group.add(o.group),
        this.updateSelectStatus(e, n, i)
    }),
    (t.prototype._handleRegionClick = function (e) {
      var n
      xu(
        e.target,
        function (i) {
          return (n = Wt(i).eventData) != null
        },
        !0,
      ),
        n &&
          this._api.dispatchAction({
            type: 'geoToggleSelect',
            geoId: this._model.id,
            name: n.name,
          })
    }),
    (t.prototype.updateSelectStatus = function (e, n, i) {
      var a = this
      this._mapDraw.group.traverse(function (o) {
        var s = Wt(o).eventData
        if (s)
          return (
            a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o),
            !0
          )
      })
    }),
    (t.prototype.findHighDownDispatchers = function (e) {
      return (
        this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model)
      )
    }),
    (t.prototype.dispose = function () {
      this._mapDraw && this._mapDraw.remove()
    }),
    (t.type = 'geo'),
    t
  )
})(dn)
const oht = aht
function sht(r, t, e) {
  rs.registerMap(r, t, e)
}
function e4(r) {
  r.registerCoordinateSystem('geo', t4),
    r.registerComponentModel(iht),
    r.registerComponentView(oht),
    r.registerImpl('registerMap', sht),
    r.registerImpl('getMap', function (e) {
      return rs.getMapForUser(e)
    })
  function t(e, n) {
    ;(n.update = 'geo:updateSelectStatus'),
      r.registerAction(n, function (i, a) {
        var o = {},
          s = []
        return (
          a.eachComponent(
            {
              mainType: 'geo',
              query: i,
            },
            function (l) {
              l[e](i.name)
              var u = l.coordinateSystem
              R(u.regions, function (h) {
                o[h.name] = l.isSelected(h.name) || !1
              })
              var c = []
              R(o, function (h, f) {
                o[f] && c.push(f)
              }),
                s.push({
                  geoIndex: l.componentIndex,
                  name: c,
                })
            },
          ),
          {
            selected: o,
            allSelected: s,
            name: i.name,
          }
        )
      })
  }
  t('toggleSelected', {
    type: 'geoToggleSelect',
    event: 'geoselectchanged',
  }),
    t('select', {
      type: 'geoSelect',
      event: 'geoselected',
    }),
    t('unSelect', {
      type: 'geoUnSelect',
      event: 'geounselected',
    }),
    r.registerAction(
      {
        type: 'geoRoam',
        event: 'geoRoam',
        update: 'updateTransform',
      },
      function (e, n, i) {
        var a = e.componentType || 'series'
        n.eachComponent(
          {
            mainType: a,
            query: e,
          },
          function (o) {
            var s = o.coordinateSystem
            if (s.type === 'geo') {
              var l = HC(s, e, o.get('scaleLimit'), i)
              o.setCenter && o.setCenter(l.center),
                o.setZoom && o.setZoom(l.zoom),
                a === 'series' &&
                  R(o.seriesGroup, function (u) {
                    u.setCenter(l.center), u.setZoom(l.zoom)
                  })
            }
          },
        )
      },
    )
}
function lht(r) {
  ie(e4),
    r.registerChartView(Yct),
    r.registerSeriesModel(qct),
    r.registerLayout(jct),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, Kct),
    K5('map', r.registerAction)
}
function uht(r) {
  var t = r
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null,
  }
  for (var e = [t], n, i; (n = e.pop()); )
    if (((i = n.children), n.isExpand && i.length))
      for (var a = i.length, o = a - 1; o >= 0; o--) {
        var s = i[o]
        ;(s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null,
        }),
          e.push(s)
      }
}
function cht(r, t) {
  var e = r.isExpand ? r.children : [],
    n = r.parentNode.children,
    i = r.hierNode.i ? n[r.hierNode.i - 1] : null
  if (e.length) {
    dht(r)
    var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2
    i
      ? ((r.hierNode.prelim = i.hierNode.prelim + t(r, i)),
        (r.hierNode.modifier = r.hierNode.prelim - a))
      : (r.hierNode.prelim = a)
  } else i && (r.hierNode.prelim = i.hierNode.prelim + t(r, i))
  r.parentNode.hierNode.defaultAncestor = pht(
    r,
    i,
    r.parentNode.hierNode.defaultAncestor || n[0],
    t,
  )
}
function hht(r) {
  var t = r.hierNode.prelim + r.parentNode.hierNode.modifier
  r.setLayout(
    {
      x: t,
    },
    !0,
  ),
    (r.hierNode.modifier += r.parentNode.hierNode.modifier)
}
function DO(r) {
  return arguments.length ? r : mht
}
function Gd(r, t) {
  return (
    (r -= Math.PI / 2),
    {
      x: t * Math.cos(r),
      y: t * Math.sin(r),
    }
  )
}
function fht(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function dht(r) {
  for (var t = r.children, e = t.length, n = 0, i = 0; --e >= 0; ) {
    var a = t[e]
    ;(a.hierNode.prelim += n),
      (a.hierNode.modifier += n),
      (i += a.hierNode.change),
      (n += a.hierNode.shift + i)
  }
}
function pht(r, t, e, n) {
  if (t) {
    for (
      var i = r,
        a = r,
        o = a.parentNode.children[0],
        s = t,
        l = i.hierNode.modifier,
        u = a.hierNode.modifier,
        c = o.hierNode.modifier,
        h = s.hierNode.modifier;
      (s = fS(s)), (a = dS(a)), s && a;

    ) {
      ;(i = fS(i)), (o = dS(o)), (i.hierNode.ancestor = r)
      var f = s.hierNode.prelim + h - a.hierNode.prelim - u + n(s, a)
      f > 0 && (ght(vht(s, r, e), r, f), (u += f), (l += f)),
        (h += s.hierNode.modifier),
        (u += a.hierNode.modifier),
        (l += i.hierNode.modifier),
        (c += o.hierNode.modifier)
    }
    s && !fS(i) && ((i.hierNode.thread = s), (i.hierNode.modifier += h - l)),
      a &&
        !dS(o) &&
        ((o.hierNode.thread = a), (o.hierNode.modifier += u - c), (e = r))
  }
  return e
}
function fS(r) {
  var t = r.children
  return t.length && r.isExpand ? t[t.length - 1] : r.hierNode.thread
}
function dS(r) {
  var t = r.children
  return t.length && r.isExpand ? t[0] : r.hierNode.thread
}
function vht(r, t, e) {
  return r.hierNode.ancestor.parentNode === t.parentNode
    ? r.hierNode.ancestor
    : e
}
function ght(r, t, e) {
  var n = e / (t.hierNode.i - r.hierNode.i)
  ;(t.hierNode.change -= n),
    (t.hierNode.shift += e),
    (t.hierNode.modifier += e),
    (t.hierNode.prelim += e),
    (r.hierNode.change += n)
}
function mht(r, t) {
  return r.parentNode === t.parentNode ? 1 : 2
}
var yht = (function () {
    function r() {
      ;(this.parentPoint = []), (this.childPoints = [])
    }
    return r
  })(),
  _ht = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new yht()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.childPoints,
          a = i.length,
          o = n.parentPoint,
          s = i[0],
          l = i[a - 1]
        if (a === 1) {
          e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1])
          return
        }
        var u = n.orient,
          c = u === 'TB' || u === 'BT' ? 0 : 1,
          h = 1 - c,
          f = _t(n.forkPosition, 1),
          d = []
        ;(d[c] = o[c]),
          (d[h] = o[h] + (l[h] - o[h]) * f),
          e.moveTo(o[0], o[1]),
          e.lineTo(d[0], d[1]),
          e.moveTo(s[0], s[1]),
          (d[c] = s[c]),
          e.lineTo(d[0], d[1]),
          (d[c] = l[c]),
          e.lineTo(d[0], d[1]),
          e.lineTo(l[0], l[1])
        for (var p = 1; p < a - 1; p++) {
          var g = i[p]
          e.moveTo(g[0], g[1]), (d[c] = g[c]), e.lineTo(d[0], d[1])
        }
      }),
      t
    )
  })(oe),
  xht = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._mainGroup = new Ht()), e
    }
    return (
      (t.prototype.init = function (e, n) {
        ;(this._controller = new Rv(n.getZr())),
          (this._controllerHost = {
            target: this.group,
          }),
          this.group.add(this._mainGroup)
      }),
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = e.layoutInfo,
          s = this._mainGroup,
          l = e.get('layout')
        l === 'radial'
          ? ((s.x = o.x + o.width / 2), (s.y = o.y + o.height / 2))
          : ((s.x = o.x), (s.y = o.y)),
          this._updateViewCoordSys(e, i),
          this._updateController(e, n, i)
        var u = this._data
        a
          .diff(u)
          .add(function (c) {
            LO(a, c) && PO(a, c, null, s, e)
          })
          .update(function (c, h) {
            var f = u.getItemGraphicEl(h)
            if (!LO(a, c)) {
              f && IO(u, h, f, s, e)
              return
            }
            PO(a, c, f, s, e)
          })
          .remove(function (c) {
            var h = u.getItemGraphicEl(c)
            h && IO(u, c, h, s, e)
          })
          .execute(),
          (this._nodeScaleRatio = e.get('nodeScaleRatio')),
          this._updateNodeAndLinkScale(e),
          e.get('expandAndCollapse') === !0 &&
            a.eachItemGraphicEl(function (c, h) {
              c.off('click').on('click', function () {
                i.dispatchAction({
                  type: 'treeExpandAndCollapse',
                  seriesId: e.id,
                  dataIndex: h,
                })
              })
            }),
          (this._data = a)
      }),
      (t.prototype._updateViewCoordSys = function (e, n) {
        var i = e.getData(),
          a = []
        i.each(function (h) {
          var f = i.getItemLayout(h)
          f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y])
        })
        var o = [],
          s = []
        e_(a, o, s)
        var l = this._min,
          u = this._max
        s[0] - o[0] === 0 &&
          ((o[0] = l ? l[0] : o[0] - 1), (s[0] = u ? u[0] : s[0] + 1)),
          s[1] - o[1] === 0 &&
            ((o[1] = l ? l[1] : o[1] - 1), (s[1] = u ? u[1] : s[1] + 1))
        var c = (e.coordinateSystem = new Iv())
        ;(c.zoomLimit = e.get('scaleLimit')),
          c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]),
          c.setCenter(e.get('center'), n),
          c.setZoom(e.get('zoom')),
          this.group.attr({
            x: c.x,
            y: c.y,
            scaleX: c.scaleX,
            scaleY: c.scaleY,
          }),
          (this._min = o),
          (this._max = s)
      }),
      (t.prototype._updateController = function (e, n, i) {
        var a = this,
          o = this._controller,
          s = this._controllerHost,
          l = this.group
        o.setPointerChecker(function (u, c, h) {
          var f = l.getBoundingRect()
          return f.applyTransform(l.transform), f.contain(c, h) && !T_(u, i, e)
        }),
          o.enable(e.get('roam')),
          (s.zoomLimit = e.get('scaleLimit')),
          (s.zoom = e.coordinateSystem.getZoom()),
          o
            .off('pan')
            .off('zoom')
            .on('pan', function (u) {
              UC(s, u.dx, u.dy),
                i.dispatchAction({
                  seriesId: e.id,
                  type: 'treeRoam',
                  dx: u.dx,
                  dy: u.dy,
                })
            })
            .on('zoom', function (u) {
              VC(s, u.scale, u.originX, u.originY),
                i.dispatchAction({
                  seriesId: e.id,
                  type: 'treeRoam',
                  zoom: u.scale,
                  originX: u.originX,
                  originY: u.originY,
                }),
                a._updateNodeAndLinkScale(e),
                i.updateLabelLayout()
            })
      }),
      (t.prototype._updateNodeAndLinkScale = function (e) {
        var n = e.getData(),
          i = this._getNodeGlobalScale(e)
        n.eachItemGraphicEl(function (a, o) {
          a.setSymbolScale(i)
        })
      }),
      (t.prototype._getNodeGlobalScale = function (e) {
        var n = e.coordinateSystem
        if (n.type !== 'view') return 1
        var i = this._nodeScaleRatio,
          a = n.scaleX || 1,
          o = n.getZoom(),
          s = (o - 1) * i + 1
        return s / a
      }),
      (t.prototype.dispose = function () {
        this._controller && this._controller.dispose(),
          (this._controllerHost = null)
      }),
      (t.prototype.remove = function () {
        this._mainGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'tree'),
      t
    )
  })(Ze)
function LO(r, t) {
  var e = r.getItemLayout(t)
  return e && !isNaN(e.x) && !isNaN(e.y)
}
function PO(r, t, e, n, i) {
  var a = !e,
    o = r.tree.getNodeByDataIndex(t),
    s = o.getModel(),
    l = o.getVisual('style').fill,
    u = o.isExpand === !1 && o.children.length !== 0 ? l : '#fff',
    c = r.tree.root,
    h = o.parentNode === c ? o : o.parentNode || o,
    f = r.getItemGraphicEl(h.dataIndex),
    d = h.getLayout(),
    p = f
      ? {
          x: f.__oldX,
          y: f.__oldY,
          rawX: f.__radialOldRawX,
          rawY: f.__radialOldRawY,
        }
      : d,
    g = o.getLayout()
  a
    ? ((e = new Tv(r, t, null, {
        symbolInnerColor: u,
        useNameLabel: !0,
      })),
      (e.x = p.x),
      (e.y = p.y))
    : e.updateData(r, t, null, {
        symbolInnerColor: u,
        useNameLabel: !0,
      }),
    (e.__radialOldRawX = e.__radialRawX),
    (e.__radialOldRawY = e.__radialRawY),
    (e.__radialRawX = g.rawX),
    (e.__radialRawY = g.rawY),
    n.add(e),
    r.setItemGraphicEl(t, e),
    (e.__oldX = e.x),
    (e.__oldY = e.y),
    we(
      e,
      {
        x: g.x,
        y: g.y,
      },
      i,
    )
  var v = e.getSymbolPath()
  if (i.get('layout') === 'radial') {
    var m = c.children[0],
      y = m.getLayout(),
      _ = m.children.length,
      x = void 0,
      A = void 0
    if (g.x === y.x && o.isExpand === !0 && m.children.length) {
      var S = {
        x: (m.children[0].getLayout().x + m.children[_ - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[_ - 1].getLayout().y) / 2,
      }
      ;(x = Math.atan2(S.y - y.y, S.x - y.x)),
        x < 0 && (x = Math.PI * 2 + x),
        (A = S.x < y.x),
        A && (x = x - Math.PI)
    } else
      (x = Math.atan2(g.y - y.y, g.x - y.x)),
        x < 0 && (x = Math.PI * 2 + x),
        o.children.length === 0 ||
        (o.children.length !== 0 && o.isExpand === !1)
          ? ((A = g.x < y.x), A && (x = x - Math.PI))
          : ((A = g.x > y.x), A || (x = x - Math.PI))
    var b = A ? 'left' : 'right',
      T = s.getModel('label'),
      w = T.get('rotate'),
      M = w * (Math.PI / 180),
      C = v.getTextContent()
    C &&
      (v.setTextConfig({
        position: T.get('position') || b,
        rotation: w == null ? -x : M,
        origin: 'center',
      }),
      C.setStyle('verticalAlign', 'middle'))
  }
  var E = s.get(['emphasis', 'focus']),
    D =
      E === 'relative'
        ? ky(o.getAncestorsIndices(), o.getDescendantIndices())
        : E === 'ancestor'
        ? o.getAncestorsIndices()
        : E === 'descendant'
        ? o.getDescendantIndices()
        : null
  D && (Wt(e).focus = D),
    Sht(i, o, c, e, p, d, g, n),
    e.__edge &&
      (e.onHoverStateChange = function (P) {
        if (P !== 'blur') {
          var L = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex)
          ;(L && L.hoverState === _v) || Xy(e.__edge, P)
        }
      })
}
function Sht(r, t, e, n, i, a, o, s) {
  var l = t.getModel(),
    u = r.get('edgeShape'),
    c = r.get('layout'),
    h = r.getOrient(),
    f = r.get(['lineStyle', 'curveness']),
    d = r.get('edgeForkPosition'),
    p = l.getModel('lineStyle').getLineStyle(),
    g = n.__edge
  if (u === 'curve')
    t.parentNode &&
      t.parentNode !== e &&
      (g ||
        (g = n.__edge =
          new a_({
            shape: Bw(c, h, f, i, i),
          })),
      we(
        g,
        {
          shape: Bw(c, h, f, a, o),
        },
        r,
      ))
  else if (
    u === 'polyline' &&
    c === 'orthogonal' &&
    t !== e &&
    t.children &&
    t.children.length !== 0 &&
    t.isExpand === !0
  ) {
    for (var v = t.children, m = [], y = 0; y < v.length; y++) {
      var _ = v[y].getLayout()
      m.push([_.x, _.y])
    }
    g ||
      (g = n.__edge =
        new _ht({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: h,
            forkPosition: d,
          },
        })),
      we(
        g,
        {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: m,
          },
        },
        r,
      )
  }
  g &&
    !(u === 'polyline' && !t.isExpand) &&
    (g.useStyle(
      zt(
        {
          strokeNoScale: !0,
          fill: null,
        },
        p,
      ),
    ),
    gr(g, l, 'lineStyle'),
    qu(g),
    s.add(g))
}
function RO(r, t, e, n, i) {
  var a = t.tree.root,
    o = n4(a, r),
    s = o.source,
    l = o.sourceLayout,
    u = t.getItemGraphicEl(r.dataIndex)
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex),
      h = c.__edge,
      f =
        u.__edge || (s.isExpand === !1 || s.children.length === 1 ? h : void 0),
      d = n.get('edgeShape'),
      p = n.get('layout'),
      g = n.get('orient'),
      v = n.get(['lineStyle', 'curveness'])
    f &&
      (d === 'curve'
        ? al(
            f,
            {
              shape: Bw(p, g, v, l, l),
              style: {
                opacity: 0,
              },
            },
            n,
            {
              cb: function () {
                e.remove(f)
              },
              removeOpt: i,
            },
          )
        : d === 'polyline' &&
          n.get('layout') === 'orthogonal' &&
          al(
            f,
            {
              shape: {
                parentPoint: [l.x, l.y],
                childPoints: [[l.x, l.y]],
              },
              style: {
                opacity: 0,
              },
            },
            n,
            {
              cb: function () {
                e.remove(f)
              },
              removeOpt: i,
            },
          ))
  }
}
function n4(r, t) {
  for (
    var e = t.parentNode === r ? t : t.parentNode || t, n;
    (n = e.getLayout()), n == null;

  )
    e = e.parentNode === r ? e : e.parentNode || e
  return {
    source: e,
    sourceLayout: n,
  }
}
function IO(r, t, e, n, i) {
  var a = r.tree.getNodeByDataIndex(t),
    o = r.tree.root,
    s = n4(o, a).sourceLayout,
    l = {
      duration: i.get('animationDurationUpdate'),
      easing: i.get('animationEasingUpdate'),
    }
  al(
    e,
    {
      x: s.x + 1,
      y: s.y + 1,
    },
    i,
    {
      cb: function () {
        n.remove(e), r.setItemGraphicEl(t, null)
      },
      removeOpt: l,
    },
  ),
    e.fadeOut(null, r.hostModel, {
      fadeLabel: !0,
      animation: l,
    }),
    a.children.forEach(function (u) {
      RO(u, r, n, i, l)
    }),
    RO(a, r, n, i, l)
}
function Bw(r, t, e, n, i) {
  var a, o, s, l, u, c, h, f
  if (r === 'radial') {
    ;(u = n.rawX), (h = n.rawY), (c = i.rawX), (f = i.rawY)
    var d = Gd(u, h),
      p = Gd(u, h + (f - h) * e),
      g = Gd(c, f + (h - f) * e),
      v = Gd(c, f)
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0,
    }
  } else
    (u = n.x),
      (h = n.y),
      (c = i.x),
      (f = i.y),
      (t === 'LR' || t === 'RL') &&
        ((a = u + (c - u) * e), (o = h), (s = c + (u - c) * e), (l = f)),
      (t === 'TB' || t === 'BT') &&
        ((a = u), (o = h + (f - h) * e), (s = c), (l = f + (h - f) * e))
  return {
    x1: u,
    y1: h,
    x2: c,
    y2: f,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l,
  }
}
const Aht = xht
var Ji = ve()
function r4(r) {
  var t = r.mainData,
    e = r.datas
  e ||
    ((e = {
      main: t,
    }),
    (r.datasAttr = {
      main: 'data',
    })),
    (r.datas = r.mainData = null),
    i4(t, e, r),
    R(e, function (n) {
      R(t.TRANSFERABLE_METHODS, function (i) {
        n.wrapMethod(i, Zt(bht, r))
      })
    }),
    t.wrapMethod('cloneShallow', Zt(Mht, r)),
    R(t.CHANGABLE_METHODS, function (n) {
      t.wrapMethod(n, Zt(wht, r))
    }),
    Gr(e[t.dataType] === t)
}
function bht(r, t) {
  if (Eht(this)) {
    var e = Q({}, Ji(this).datas)
    ;(e[this.dataType] = t), i4(t, e, r)
  } else WC(t, this.dataType, Ji(this).mainData, r)
  return t
}
function wht(r, t) {
  return r.struct && r.struct.update(), t
}
function Mht(r, t) {
  return (
    R(Ji(t).datas, function (e, n) {
      e !== t && WC(e.cloneShallow(), n, t, r)
    }),
    t
  )
}
function Tht(r) {
  var t = Ji(this).mainData
  return r == null || t == null ? t : Ji(t).datas[r]
}
function Cht() {
  var r = Ji(this).mainData
  return r == null
    ? [
        {
          data: r,
        },
      ]
    : st(pe(Ji(r).datas), function (t) {
        return {
          type: t,
          data: Ji(r).datas[t],
        }
      })
}
function Eht(r) {
  return Ji(r).mainData === r
}
function i4(r, t, e) {
  ;(Ji(r).datas = {}),
    R(t, function (n, i) {
      WC(n, i, r, e)
    })
}
function WC(r, t, e, n) {
  ;(Ji(e).datas[t] = r),
    (Ji(r).mainData = e),
    (r.dataType = t),
    n.struct && ((r[n.structAttr] = n.struct), (n.struct[n.datasAttr[t]] = r)),
    (r.getLinkedData = Tht),
    (r.getLinkedDataAll = Cht)
}
var Dht = (function () {
    function r(t, e) {
      ;(this.depth = 0),
        (this.height = 0),
        (this.dataIndex = -1),
        (this.children = []),
        (this.viewChildren = []),
        (this.isExpand = !1),
        (this.name = t || ''),
        (this.hostTree = e)
    }
    return (
      (r.prototype.isRemoved = function () {
        return this.dataIndex < 0
      }),
      (r.prototype.eachNode = function (t, e, n) {
        Nt(t) && ((n = e), (e = t), (t = null)),
          (t = t || {}),
          bt(t) &&
            (t = {
              order: t,
            })
        var i = t.order || 'preorder',
          a = this[t.attr || 'children'],
          o
        i === 'preorder' && (o = e.call(n, this))
        for (var s = 0; !o && s < a.length; s++) a[s].eachNode(t, e, n)
        i === 'postorder' && e.call(n, this)
      }),
      (r.prototype.updateDepthAndHeight = function (t) {
        var e = 0
        this.depth = t
        for (var n = 0; n < this.children.length; n++) {
          var i = this.children[n]
          i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height)
        }
        this.height = e + 1
      }),
      (r.prototype.getNodeById = function (t) {
        if (this.getId() === t) return this
        for (var e = 0, n = this.children, i = n.length; e < i; e++) {
          var a = n[e].getNodeById(t)
          if (a) return a
        }
      }),
      (r.prototype.contains = function (t) {
        if (t === this) return !0
        for (var e = 0, n = this.children, i = n.length; e < i; e++) {
          var a = n[e].contains(t)
          if (a) return a
        }
      }),
      (r.prototype.getAncestors = function (t) {
        for (var e = [], n = t ? this : this.parentNode; n; )
          e.push(n), (n = n.parentNode)
        return e.reverse(), e
      }),
      (r.prototype.getAncestorsIndices = function () {
        for (var t = [], e = this; e; ) t.push(e.dataIndex), (e = e.parentNode)
        return t.reverse(), t
      }),
      (r.prototype.getDescendantIndices = function () {
        var t = []
        return (
          this.eachNode(function (e) {
            t.push(e.dataIndex)
          }),
          t
        )
      }),
      (r.prototype.getValue = function (t) {
        var e = this.hostTree.data
        return e
          .getStore()
          .get(e.getDimensionIndex(t || 'value'), this.dataIndex)
      }),
      (r.prototype.setLayout = function (t, e) {
        this.dataIndex >= 0 &&
          this.hostTree.data.setItemLayout(this.dataIndex, t, e)
      }),
      (r.prototype.getLayout = function () {
        return this.hostTree.data.getItemLayout(this.dataIndex)
      }),
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostTree,
            n = e.data.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getLevelModel = function () {
        return (this.hostTree.levelModels || [])[this.depth]
      }),
      (r.prototype.setVisual = function (t, e) {
        this.dataIndex >= 0 &&
          this.hostTree.data.setItemVisual(this.dataIndex, t, e)
      }),
      (r.prototype.getVisual = function (t) {
        return this.hostTree.data.getItemVisual(this.dataIndex, t)
      }),
      (r.prototype.getRawIndex = function () {
        return this.hostTree.data.getRawIndex(this.dataIndex)
      }),
      (r.prototype.getId = function () {
        return this.hostTree.data.getId(this.dataIndex)
      }),
      (r.prototype.getChildIndex = function () {
        if (this.parentNode) {
          for (var t = this.parentNode.children, e = 0; e < t.length; ++e)
            if (t[e] === this) return e
          return -1
        }
        return -1
      }),
      (r.prototype.isAncestorOf = function (t) {
        for (var e = t.parentNode; e; ) {
          if (e === this) return !0
          e = e.parentNode
        }
        return !1
      }),
      (r.prototype.isDescendantOf = function (t) {
        return t !== this && t.isAncestorOf(this)
      }),
      r
    )
  })(),
  Lht = (function () {
    function r(t) {
      ;(this.type = 'tree'), (this._nodes = []), (this.hostModel = t)
    }
    return (
      (r.prototype.eachNode = function (t, e, n) {
        this.root.eachNode(t, e, n)
      }),
      (r.prototype.getNodeByDataIndex = function (t) {
        var e = this.data.getRawIndex(t)
        return this._nodes[e]
      }),
      (r.prototype.getNodeById = function (t) {
        return this.root.getNodeById(t)
      }),
      (r.prototype.update = function () {
        for (
          var t = this.data, e = this._nodes, n = 0, i = e.length;
          n < i;
          n++
        )
          e[n].dataIndex = -1
        for (var n = 0, i = t.count(); n < i; n++)
          e[t.getRawIndex(n)].dataIndex = n
      }),
      (r.prototype.clearLayouts = function () {
        this.data.clearItemLayouts()
      }),
      (r.createTree = function (t, e, n) {
        var i = new r(e),
          a = [],
          o = 1
        s(t)
        function s(c, h) {
          var f = c.value
          ;(o = Math.max(o, at(f) ? f.length : 1)), a.push(c)
          var d = new Dht(Un(c.name, ''), i)
          h ? Pht(d, h) : (i.root = d), i._nodes.push(d)
          var p = c.children
          if (p) for (var g = 0; g < p.length; g++) s(p[g], d)
        }
        i.root.updateDepthAndHeight(0)
        var l = wv(a, {
            coordDimensions: ['value'],
            dimensionsCount: o,
          }).dimensions,
          u = new Vr(l, e)
        return (
          u.initData(a),
          n && n(u),
          r4({
            mainData: u,
            struct: i,
            structAttr: 'tree',
          }),
          i.update(),
          i
        )
      }),
      r
    )
  })()
function Pht(r, t) {
  var e = t.children
  r.parentNode !== t && (e.push(r), (r.parentNode = t))
}
const XC = Lht
function nv(r, t, e) {
  if (r && re(t, r.type) >= 0) {
    var n = e.getData().tree.root,
      i = r.targetNode
    if ((bt(i) && (i = n.getNodeById(i)), i && n.contains(i)))
      return {
        node: i,
      }
    var a = r.targetNodeId
    if (a != null && (i = n.getNodeById(a)))
      return {
        node: i,
      }
  }
}
function a4(r) {
  for (var t = []; r; ) (r = r.parentNode), r && t.push(r)
  return t.reverse()
}
function YC(r, t) {
  var e = a4(r)
  return re(e, t) >= 0
}
function E_(r, t) {
  for (var e = []; r; ) {
    var n = r.dataIndex
    e.push({
      name: r.name,
      dataIndex: n,
      value: t.getRawValue(n),
    }),
      (r = r.parentNode)
  }
  return e.reverse(), e
}
var Rht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.hasSymbolVisual = !0), (e.ignoreStyleOnData = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e) {
      var n = {
          name: e.name,
          children: e.data,
        },
        i = e.leaves || {},
        a = new qe(i, this, this.ecModel),
        o = XC.createTree(n, this, s)
      function s(h) {
        h.wrapMethod('getItemModel', function (f, d) {
          var p = o.getNodeByDataIndex(d)
          return (
            (p && p.children.length && p.isExpand) || (f.parentModel = a), f
          )
        })
      }
      var l = 0
      o.eachNode('preorder', function (h) {
        h.depth > l && (l = h.depth)
      })
      var u = e.expandAndCollapse,
        c = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l
      return (
        o.root.eachNode('preorder', function (h) {
          var f = h.hostTree.data.getRawDataItem(h.dataIndex)
          h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c
        }),
        o.data
      )
    }),
    (t.prototype.getOrient = function () {
      var e = this.get('orient')
      return e === 'horizontal' ? (e = 'LR') : e === 'vertical' && (e = 'TB'), e
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      for (
        var a = this.getData().tree,
          o = a.root.children[0],
          s = a.getNodeByDataIndex(e),
          l = s.getValue(),
          u = s.name;
        s && s !== o;

      )
        (u = s.parentNode.name + '.' + u), (s = s.parentNode)
      return Kn('nameValue', {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null,
      })
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (n.treeAncestors = E_(i, this)), (n.collapsed = !i.isExpand), n
    }),
    (t.type = 'series.tree'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      left: '12%',
      top: '12%',
      right: '12%',
      bottom: '12%',
      layout: 'orthogonal',
      edgeShape: 'curve',
      edgeForkPosition: '50%',
      roam: !1,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: 'LR',
      symbol: 'emptyCircle',
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: '#ccc',
        width: 1.5,
        curveness: 0.5,
      },
      itemStyle: {
        color: 'lightsteelblue',
        borderWidth: 1.5,
      },
      label: {
        show: !0,
      },
      animationEasing: 'linear',
      animationDuration: 700,
      animationDurationUpdate: 500,
    }),
    t
  )
})(rn)
const Iht = Rht
function Oht(r, t, e) {
  for (var n = [r], i = [], a; (a = n.pop()); )
    if ((i.push(a), a.isExpand)) {
      var o = a.children
      if (o.length) for (var s = 0; s < o.length; s++) n.push(o[s])
    }
  for (; (a = i.pop()); ) t(a, e)
}
function gd(r, t) {
  for (var e = [r], n; (n = e.pop()); )
    if ((t(n), n.isExpand)) {
      var i = n.children
      if (i.length) for (var a = i.length - 1; a >= 0; a--) e.push(i[a])
    }
}
function Nht(r, t) {
  r.eachSeriesByType('tree', function (e) {
    kht(e, t)
  })
}
function kht(r, t) {
  var e = fht(r, t)
  r.layoutInfo = e
  var n = r.get('layout'),
    i = 0,
    a = 0,
    o = null
  n === 'radial'
    ? ((i = 2 * Math.PI),
      (a = Math.min(e.height, e.width) / 2),
      (o = DO(function (_, x) {
        return (_.parentNode === x.parentNode ? 1 : 2) / _.depth
      })))
    : ((i = e.width), (a = e.height), (o = DO()))
  var s = r.getData().tree.root,
    l = s.children[0]
  if (l) {
    uht(s),
      Oht(l, cht, o),
      (s.hierNode.modifier = -l.hierNode.prelim),
      gd(l, hht)
    var u = l,
      c = l,
      h = l
    gd(l, function (_) {
      var x = _.getLayout().x
      x < u.getLayout().x && (u = _),
        x > c.getLayout().x && (c = _),
        _.depth > h.depth && (h = _)
    })
    var f = u === c ? 1 : o(u, c) / 2,
      d = f - u.getLayout().x,
      p = 0,
      g = 0,
      v = 0,
      m = 0
    if (n === 'radial')
      (p = i / (c.getLayout().x + f + d)),
        (g = a / (h.depth - 1 || 1)),
        gd(l, function (_) {
          ;(v = (_.getLayout().x + d) * p), (m = (_.depth - 1) * g)
          var x = Gd(v, m)
          _.setLayout(
            {
              x: x.x,
              y: x.y,
              rawX: v,
              rawY: m,
            },
            !0,
          )
        })
    else {
      var y = r.getOrient()
      y === 'RL' || y === 'LR'
        ? ((g = a / (c.getLayout().x + f + d)),
          (p = i / (h.depth - 1 || 1)),
          gd(l, function (_) {
            ;(m = (_.getLayout().x + d) * g),
              (v = y === 'LR' ? (_.depth - 1) * p : i - (_.depth - 1) * p),
              _.setLayout(
                {
                  x: v,
                  y: m,
                },
                !0,
              )
          }))
        : (y === 'TB' || y === 'BT') &&
          ((p = i / (c.getLayout().x + f + d)),
          (g = a / (h.depth - 1 || 1)),
          gd(l, function (_) {
            ;(v = (_.getLayout().x + d) * p),
              (m = y === 'TB' ? (_.depth - 1) * g : a - (_.depth - 1) * g),
              _.setLayout(
                {
                  x: v,
                  y: m,
                },
                !0,
              )
          }))
    }
  }
}
function Bht(r) {
  r.eachSeriesByType('tree', function (t) {
    var e = t.getData(),
      n = e.tree
    n.eachNode(function (i) {
      var a = i.getModel(),
        o = a.getModel('itemStyle').getItemStyle(),
        s = e.ensureUniqueItemVisual(i.dataIndex, 'style')
      Q(s, o)
    })
  })
}
function Fht(r) {
  r.registerAction(
    {
      type: 'treeExpandAndCollapse',
      event: 'treeExpandAndCollapse',
      update: 'update',
    },
    function (t, e) {
      e.eachComponent(
        {
          mainType: 'series',
          subType: 'tree',
          query: t,
        },
        function (n) {
          var i = t.dataIndex,
            a = n.getData().tree,
            o = a.getNodeByDataIndex(i)
          o.isExpand = !o.isExpand
        },
      )
    },
  ),
    r.registerAction(
      {
        type: 'treeRoam',
        event: 'treeRoam',
        update: 'none',
      },
      function (t, e, n) {
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'tree',
            query: t,
          },
          function (i) {
            var a = i.coordinateSystem,
              o = HC(a, t, void 0, n)
            i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
          },
        )
      },
    )
}
function zht(r) {
  r.registerChartView(Aht),
    r.registerSeriesModel(Iht),
    r.registerLayout(Nht),
    r.registerVisual(Bht),
    Fht(r)
}
var OO = ['treemapZoomToNode', 'treemapRender', 'treemapMove']
function Uht(r) {
  for (var t = 0; t < OO.length; t++)
    r.registerAction(
      {
        type: OO[t],
        update: 'updateView',
      },
      wn,
    )
  r.registerAction(
    {
      type: 'treemapRootToNode',
      update: 'updateView',
    },
    function (e, n) {
      n.eachComponent(
        {
          mainType: 'series',
          subType: 'treemap',
          query: e,
        },
        i,
      )
      function i(a, o) {
        var s = ['treemapZoomToNode', 'treemapRootToNode'],
          l = nv(e, s, a)
        if (l) {
          var u = a.getViewRoot()
          u && (e.direction = YC(u, l.node) ? 'rollUp' : 'drillDown'),
            a.resetViewRoot(l.node)
        }
      }
    },
  )
}
function o4(r) {
  var t = r.getData(),
    e = t.tree,
    n = {}
  e.eachNode(function (i) {
    for (var a = i; a && a.depth > 1; ) a = a.parentNode
    var o = fw(r.ecModel, a.name || a.dataIndex + '', n)
    i.setVisual('decal', o)
  })
}
var Vht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.preventUsingHoverLayer = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = {
        name: e.name,
        children: e.data,
      }
      s4(i)
      var a = e.levels || [],
        o = (this.designatedVisualItemStyle = {}),
        s = new qe(
          {
            itemStyle: o,
          },
          this,
          n,
        )
      a = e.levels = Ght(a, n)
      var l = st(
          a || [],
          function (h) {
            return new qe(h, s, n)
          },
          this,
        ),
        u = XC.createTree(i, this, c)
      function c(h) {
        h.wrapMethod('getItemModel', function (f, d) {
          var p = u.getNodeByDataIndex(d),
            g = p ? l[p.depth] : null
          return (f.parentModel = g || s), f
        })
      }
      return u.data
    }),
    (t.prototype.optionUpdated = function () {
      this.resetViewRoot()
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = this.getRawValue(e),
        s = a.getName(e)
      return Kn('nameValue', {
        name: s,
        value: o,
      })
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (
        (n.treeAncestors = E_(i, this)), (n.treePathInfo = n.treeAncestors), n
      )
    }),
    (t.prototype.setLayoutInfo = function (e) {
      ;(this.layoutInfo = this.layoutInfo || {}), Q(this.layoutInfo, e)
    }),
    (t.prototype.mapIdToIndex = function (e) {
      var n = this._idIndexMap
      n || ((n = this._idIndexMap = Pt()), (this._idIndexMapCount = 0))
      var i = n.get(e)
      return i == null && n.set(e, (i = this._idIndexMapCount++)), i
    }),
    (t.prototype.getViewRoot = function () {
      return this._viewRoot
    }),
    (t.prototype.resetViewRoot = function (e) {
      e ? (this._viewRoot = e) : (e = this._viewRoot)
      var n = this.getRawData().tree.root
      ;(!e || (e !== n && !n.contains(e))) && (this._viewRoot = n)
    }),
    (t.prototype.enableAriaDecal = function () {
      o4(this)
    }),
    (t.type = 'series.treemap'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      progressive: 0,
      left: 'center',
      top: 'middle',
      width: '80%',
      height: '80%',
      sort: !0,
      clipWindow: 'origin',
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: '▶',
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: 'zoomToNode',
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: 'quinticInOut',
      breadcrumb: {
        show: !0,
        height: 22,
        left: 'center',
        top: 'bottom',
        emptyItemWidth: 25,
        itemStyle: {
          color: 'rgba(0,0,0,0.7)',
          textStyle: {
            color: '#fff',
          },
        },
        emphasis: {
          itemStyle: {
            color: 'rgba(0,0,0,0.9)',
          },
        },
      },
      label: {
        show: !0,
        distance: 0,
        padding: 5,
        position: 'inside',
        color: '#fff',
        overflow: 'truncate',
      },
      upperLabel: {
        show: !1,
        position: [0, '50%'],
        height: 20,
        overflow: 'truncate',
        verticalAlign: 'middle',
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: '#fff',
        borderColorSaturation: null,
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, '50%'],
          overflow: 'truncate',
          verticalAlign: 'middle',
        },
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: 'index',
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: [],
    }),
    t
  )
})(rn)
function s4(r) {
  var t = 0
  R(r.children, function (n) {
    s4(n)
    var i = n.value
    at(i) && (i = i[0]), (t += i)
  })
  var e = r.value
  at(e) && (e = e[0]),
    (e == null || isNaN(e)) && (e = t),
    e < 0 && (e = 0),
    at(r.value) ? (r.value[0] = e) : (r.value = e)
}
function Ght(r, t) {
  var e = ke(t.get('color')),
    n = ke(t.get(['aria', 'decal', 'decals']))
  if (e) {
    r = r || []
    var i, a
    R(r, function (s) {
      var l = new qe(s),
        u = l.get('color'),
        c = l.get('decal')
      ;(l.get(['itemStyle', 'color']) || (u && u !== 'none')) && (i = !0),
        (l.get(['itemStyle', 'decal']) || (c && c !== 'none')) && (a = !0)
    })
    var o = r[0] || (r[0] = {})
    return i || (o.color = e.slice()), !a && n && (o.decal = n.slice()), r
  }
}
const Hht = Vht
var Wht = 8,
  NO = 8,
  pS = 5,
  Xht = (function () {
    function r(t) {
      ;(this.group = new Ht()), t.add(this.group)
    }
    return (
      (r.prototype.render = function (t, e, n, i) {
        var a = t.getModel('breadcrumb'),
          o = this.group
        if ((o.removeAll(), !(!a.get('show') || !n))) {
          var s = a.getModel('itemStyle'),
            l = a.getModel('emphasis'),
            u = s.getModel('textStyle'),
            c = l.getModel(['itemStyle', 'textStyle']),
            h = {
              pos: {
                left: a.get('left'),
                right: a.get('right'),
                top: a.get('top'),
                bottom: a.get('bottom'),
              },
              box: {
                width: e.getWidth(),
                height: e.getHeight(),
              },
              emptyItemWidth: a.get('emptyItemWidth'),
              totalWidth: 0,
              renderList: [],
            }
          this._prepare(n, h, u),
            this._renderContent(t, h, s, l, u, c, i),
            p_(o, h.pos, h.box)
        }
      }),
      (r.prototype._prepare = function (t, e, n) {
        for (var i = t; i; i = i.parentNode) {
          var a = Un(i.getModel().get('name'), ''),
            o = n.getTextRect(a),
            s = Math.max(o.width + Wht * 2, e.emptyItemWidth)
          ;(e.totalWidth += s + NO),
            e.renderList.push({
              node: i,
              text: a,
              width: s,
            })
        }
      }),
      (r.prototype._renderContent = function (t, e, n, i, a, o, s) {
        for (
          var l = 0,
            u = e.emptyItemWidth,
            c = t.get(['breadcrumb', 'height']),
            h = trt(e.pos, e.box),
            f = e.totalWidth,
            d = e.renderList,
            p = i.getModel('itemStyle').getItemStyle(),
            g = d.length - 1;
          g >= 0;
          g--
        ) {
          var v = d[g],
            m = v.node,
            y = v.width,
            _ = v.text
          f > h.width && ((f -= y - u), (y = u), (_ = null))
          var x = new si({
            shape: {
              points: Yht(l, 0, y, c, g === d.length - 1, g === 0),
            },
            style: zt(n.getItemStyle(), {
              lineJoin: 'bevel',
            }),
            textContent: new Ae({
              style: $e(a, {
                text: _,
              }),
            }),
            textConfig: {
              position: 'inside',
            },
            z2: _f * 1e4,
            onclick: Zt(s, m),
          })
          ;(x.disableLabelAnimation = !0),
            (x.getTextContent().ensureState('emphasis').style = $e(o, {
              text: _,
            })),
            (x.ensureState('emphasis').style = p),
            fn(x, i.get('focus'), i.get('blurScope'), i.get('disabled')),
            this.group.add(x),
            $ht(x, t, m),
            (l += y + NO)
        }
      }),
      (r.prototype.remove = function () {
        this.group.removeAll()
      }),
      r
    )
  })()
function Yht(r, t, e, n, i, a) {
  var o = [
    [i ? r : r - pS, t],
    [r + e, t],
    [r + e, t + n],
    [i ? r : r - pS, t + n],
  ]
  return (
    !a && o.splice(2, 0, [r + e + pS, t + n / 2]),
    !i && o.push([r, t + n / 2]),
    o
  )
}
function $ht(r, t, e) {
  Wt(r).eventData = {
    componentType: 'series',
    componentSubType: 'treemap',
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: 'treemap',
    selfType: 'breadcrumb',
    nodeData: {
      dataIndex: e && e.dataIndex,
      name: e && e.name,
    },
    treePathInfo: e && E_(e, t),
  }
}
const qht = Xht
var Zht = (function () {
  function r() {
    ;(this._storage = []), (this._elExistsMap = {})
  }
  return (
    (r.prototype.add = function (t, e, n, i, a) {
      return this._elExistsMap[t.id]
        ? !1
        : ((this._elExistsMap[t.id] = !0),
          this._storage.push({
            el: t,
            target: e,
            duration: n,
            delay: i,
            easing: a,
          }),
          !0)
    }),
    (r.prototype.finished = function (t) {
      return (this._finishedCallback = t), this
    }),
    (r.prototype.start = function () {
      for (
        var t = this,
          e = this._storage.length,
          n = function () {
            e--,
              e <= 0 &&
                ((t._storage.length = 0),
                (t._elExistsMap = {}),
                t._finishedCallback && t._finishedCallback())
          },
          i = 0,
          a = this._storage.length;
        i < a;
        i++
      ) {
        var o = this._storage[i]
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: n,
          aborted: n,
        })
      }
      return this
    }),
    r
  )
})()
function Kht() {
  return new Zht()
}
var Fw = Ht,
  kO = ge,
  BO = 3,
  FO = 'label',
  zO = 'upperLabel',
  jht = _f * 10,
  Jht = _f * 2,
  Qht = _f * 3,
  au = $u([
    ['fill', 'color'],
    ['stroke', 'strokeColor'],
    ['lineWidth', 'strokeWidth'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
  ]),
  UO = function (r) {
    var t = au(r)
    return (t.stroke = t.fill = t.lineWidth = null), t
  },
  p0 = ve(),
  tft = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._state = 'ready'), (e._storage = md()), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = n.findComponents({
          mainType: 'series',
          subType: 'treemap',
          query: a,
        })
        if (!(re(o, e) < 0)) {
          ;(this.seriesModel = e), (this.api = i), (this.ecModel = n)
          var s = ['treemapZoomToNode', 'treemapRootToNode'],
            l = nv(a, s, e),
            u = a && a.type,
            c = e.layoutInfo,
            h = !this._oldTree,
            f = this._storage,
            d =
              u === 'treemapRootToNode' && l && f
                ? {
                    rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
                    direction: a.direction,
                  }
                : null,
            p = this._giveContainerGroup(c),
            g = e.get('animation'),
            v = this._doRender(p, e, d)
          g &&
          !h &&
          (!u || u === 'treemapZoomToNode' || u === 'treemapRootToNode')
            ? this._doAnimation(p, v, e, d)
            : v.renderFinally(),
            this._resetController(i),
            this._renderBreadcrumb(e, i, l)
        }
      }),
      (t.prototype._giveContainerGroup = function (e) {
        var n = this._containerGroup
        return (
          n ||
            ((n = this._containerGroup = new Fw()),
            this._initEvents(n),
            this.group.add(n)),
          (n.x = e.x),
          (n.y = e.y),
          n
        )
      }),
      (t.prototype._doRender = function (e, n, i) {
        var a = n.getData().tree,
          o = this._oldTree,
          s = md(),
          l = md(),
          u = this._storage,
          c = []
        function h(y, _, x, A) {
          return eft(n, l, u, i, s, c, y, _, x, A)
        }
        g(
          a.root ? [a.root] : [],
          o && o.root ? [o.root] : [],
          e,
          a === o || !o,
          0,
        )
        var f = v(u)
        if (((this._oldTree = a), (this._storage = l), this._controllerHost)) {
          var d = this.seriesModel.layoutInfo,
            p = a.root.getLayout()
          p.width === d.width &&
            p.height === d.height &&
            (this._controllerHost.zoom = 1)
        }
        return {
          lastsForAnimation: s,
          willDeleteEls: f,
          renderFinally: m,
        }
        function g(y, _, x, A, S) {
          A
            ? ((_ = y),
              R(y, function (w, M) {
                !w.isRemoved() && T(M, M)
              }))
            : new es(_, y, b, b).add(T).update(T).remove(Zt(T, null)).execute()
          function b(w) {
            return w.getId()
          }
          function T(w, M) {
            var C = w != null ? y[w] : null,
              E = M != null ? _[M] : null,
              D = h(C, E, x, S)
            D &&
              g(
                (C && C.viewChildren) || [],
                (E && E.viewChildren) || [],
                D,
                A,
                S + 1,
              )
          }
        }
        function v(y) {
          var _ = md()
          return (
            y &&
              R(y, function (x, A) {
                var S = _[A]
                R(x, function (b) {
                  b && (S.push(b), (p0(b).willDelete = !0))
                })
              }),
            _
          )
        }
        function m() {
          R(f, function (y) {
            R(y, function (_) {
              _.parent && _.parent.remove(_)
            })
          }),
            R(c, function (y) {
              ;(y.invisible = !0), y.dirty()
            })
        }
      }),
      (t.prototype._doAnimation = function (e, n, i, a) {
        var o = i.get('animationDurationUpdate'),
          s = i.get('animationEasing'),
          l = (Nt(o) ? 0 : o) || 0,
          u = (Nt(s) ? null : s) || 'cubicOut',
          c = Kht()
        R(n.willDeleteEls, function (h, f) {
          R(h, function (d, p) {
            if (!d.invisible) {
              var g = d.parent,
                v,
                m = p0(g)
              if (a && a.direction === 'drillDown')
                v =
                  g === a.rootNodeGroup
                    ? {
                        shape: {
                          x: 0,
                          y: 0,
                          width: m.nodeWidth,
                          height: m.nodeHeight,
                        },
                        style: {
                          opacity: 0,
                        },
                      }
                    : {
                        style: {
                          opacity: 0,
                        },
                      }
              else {
                var y = 0,
                  _ = 0
                m.willDelete || ((y = m.nodeWidth / 2), (_ = m.nodeHeight / 2)),
                  (v =
                    f === 'nodeGroup'
                      ? {
                          x: y,
                          y: _,
                          style: {
                            opacity: 0,
                          },
                        }
                      : {
                          shape: {
                            x: y,
                            y: _,
                            width: 0,
                            height: 0,
                          },
                          style: {
                            opacity: 0,
                          },
                        })
              }
              v && c.add(d, v, l, 0, u)
            }
          })
        }),
          R(
            this._storage,
            function (h, f) {
              R(h, function (d, p) {
                var g = n.lastsForAnimation[f][p],
                  v = {}
                g &&
                  (d instanceof Ht
                    ? g.oldX != null &&
                      ((v.x = d.x), (v.y = d.y), (d.x = g.oldX), (d.y = g.oldY))
                    : (g.oldShape &&
                        ((v.shape = Q({}, d.shape)), d.setShape(g.oldShape)),
                      g.fadein
                        ? (d.setStyle('opacity', 0),
                          (v.style = {
                            opacity: 1,
                          }))
                        : d.style.opacity !== 1 &&
                          (v.style = {
                            opacity: 1,
                          })),
                  c.add(d, v, l, 0, u))
              })
            },
            this,
          ),
          (this._state = 'animating'),
          c
            .finished(
              Tt(function () {
                ;(this._state = 'ready'), n.renderFinally()
              }, this),
            )
            .start()
      }),
      (t.prototype._resetController = function (e) {
        var n = this._controller,
          i = this._controllerHost
        i ||
          ((this._controllerHost = {
            target: this.group,
          }),
          (i = this._controllerHost)),
          n ||
            ((n = this._controller = new Rv(e.getZr())),
            n.enable(this.seriesModel.get('roam')),
            (i.zoomLimit = this.seriesModel.get('scaleLimit')),
            (i.zoom = this.seriesModel.get('zoom')),
            n.on('pan', Tt(this._onPan, this)),
            n.on('zoom', Tt(this._onZoom, this)))
        var a = new ee(0, 0, e.getWidth(), e.getHeight())
        n.setPointerChecker(function (o, s, l) {
          return a.contain(s, l)
        })
      }),
      (t.prototype._clearController = function () {
        var e = this._controller
        ;(this._controllerHost = null), e && (e.dispose(), (e = null))
      }),
      (t.prototype._onPan = function (e) {
        if (
          this._state !== 'animating' &&
          (Math.abs(e.dx) > BO || Math.abs(e.dy) > BO)
        ) {
          var n = this.seriesModel.getData().tree.root
          if (!n) return
          var i = n.getLayout()
          if (!i) return
          this.api.dispatchAction({
            type: 'treemapMove',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: i.x + e.dx,
              y: i.y + e.dy,
              width: i.width,
              height: i.height,
            },
          })
        }
      }),
      (t.prototype._onZoom = function (e) {
        var n = e.originX,
          i = e.originY,
          a = e.scale
        if (this._state !== 'animating') {
          var o = this.seriesModel.getData().tree.root
          if (!o) return
          var s = o.getLayout()
          if (!s) return
          var l = new ee(s.x, s.y, s.width, s.height),
            u = null,
            c = this._controllerHost
          u = c.zoomLimit
          var h = (c.zoom = c.zoom || 1)
          if (((h *= a), u)) {
            var f = u.min || 0,
              d = u.max || 1 / 0
            h = Math.max(Math.min(d, h), f)
          }
          var p = h / c.zoom
          c.zoom = h
          var g = this.seriesModel.layoutInfo
          ;(n -= g.x), (i -= g.y)
          var v = bi()
          ho(v, v, [-n, -i]),
            IT(v, v, [p, p]),
            ho(v, v, [n, i]),
            l.applyTransform(v),
            this.api.dispatchAction({
              type: 'treemapRender',
              from: this.uid,
              seriesId: this.seriesModel.id,
              rootRect: {
                x: l.x,
                y: l.y,
                width: l.width,
                height: l.height,
              },
            })
        }
      }),
      (t.prototype._initEvents = function (e) {
        var n = this
        e.on(
          'click',
          function (i) {
            if (n._state === 'ready') {
              var a = n.seriesModel.get('nodeClick', !0)
              if (a) {
                var o = n.findTarget(i.offsetX, i.offsetY)
                if (o) {
                  var s = o.node
                  if (s.getLayout().isLeafRoot) n._rootToNode(o)
                  else if (a === 'zoomToNode') n._zoomToNode(o)
                  else if (a === 'link') {
                    var l = s.hostTree.data.getItemModel(s.dataIndex),
                      u = l.get('link', !0),
                      c = l.get('target', !0) || 'blank'
                    u && jy(u, c)
                  }
                }
              }
            }
          },
          this,
        )
      }),
      (t.prototype._renderBreadcrumb = function (e, n, i) {
        var a = this
        i ||
          ((i =
            e.get('leafDepth', !0) != null
              ? {
                  node: e.getViewRoot(),
                }
              : this.findTarget(n.getWidth() / 2, n.getHeight() / 2)),
          i ||
            (i = {
              node: e.getData().tree.root,
            })),
          (this._breadcrumb || (this._breadcrumb = new qht(this.group))).render(
            e,
            n,
            i.node,
            function (o) {
              a._state !== 'animating' &&
                (YC(e.getViewRoot(), o)
                  ? a._rootToNode({
                      node: o,
                    })
                  : a._zoomToNode({
                      node: o,
                    }))
            },
          )
      }),
      (t.prototype.remove = function () {
        this._clearController(),
          this._containerGroup && this._containerGroup.removeAll(),
          (this._storage = md()),
          (this._state = 'ready'),
          this._breadcrumb && this._breadcrumb.remove()
      }),
      (t.prototype.dispose = function () {
        this._clearController()
      }),
      (t.prototype._zoomToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapZoomToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node,
        })
      }),
      (t.prototype._rootToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapRootToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node,
        })
      }),
      (t.prototype.findTarget = function (e, n) {
        var i,
          a = this.seriesModel.getViewRoot()
        return (
          a.eachNode(
            {
              attr: 'viewChildren',
              order: 'preorder',
            },
            function (o) {
              var s = this._storage.background[o.getRawIndex()]
              if (s) {
                var l = s.transformCoordToLocal(e, n),
                  u = s.shape
                if (
                  u.x <= l[0] &&
                  l[0] <= u.x + u.width &&
                  u.y <= l[1] &&
                  l[1] <= u.y + u.height
                )
                  i = {
                    node: o,
                    offsetX: l[0],
                    offsetY: l[1],
                  }
                else return !1
              }
            },
            this,
          ),
          i
        )
      }),
      (t.type = 'treemap'),
      t
    )
  })(Ze)
function md() {
  return {
    nodeGroup: [],
    background: [],
    content: [],
  }
}
function eft(r, t, e, n, i, a, o, s, l, u) {
  if (!o) return
  var c = o.getLayout(),
    h = r.getData(),
    f = o.getModel()
  if ((h.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)) return
  var d = c.width,
    p = c.height,
    g = c.borderWidth,
    v = c.invisible,
    m = o.getRawIndex(),
    y = s && s.getRawIndex(),
    _ = o.viewChildren,
    x = c.upperHeight,
    A = _ && _.length,
    S = f.getModel('itemStyle'),
    b = f.getModel(['emphasis', 'itemStyle']),
    T = f.getModel(['blur', 'itemStyle']),
    w = f.getModel(['select', 'itemStyle']),
    M = S.get('borderRadius') || 0,
    C = W('nodeGroup', Fw)
  if (!C) return
  if (
    (l.add(C),
    (C.x = c.x || 0),
    (C.y = c.y || 0),
    C.markRedraw(),
    (p0(C).nodeWidth = d),
    (p0(C).nodeHeight = p),
    c.isAboveViewRoot)
  )
    return C
  var E = W('background', kO, u, Jht)
  E && V(C, E, A && c.upperLabelHeight)
  var D = f.getModel('emphasis'),
    P = D.get('focus'),
    L = D.get('blurScope'),
    I = D.get('disabled'),
    F =
      P === 'ancestor'
        ? o.getAncestorsIndices()
        : P === 'descendant'
        ? o.getDescendantIndices()
        : P
  if (A)
    Wp(C) && yu(C, !1),
      E && (yu(E, !I), h.setItemGraphicEl(o.dataIndex, E), iw(E, F, L))
  else {
    var k = W('content', kO, u, Qht)
    k && H(C, k),
      (E.disableMorphing = !0),
      E && Wp(E) && yu(E, !1),
      yu(C, !I),
      h.setItemGraphicEl(o.dataIndex, C),
      iw(C, F, L)
  }
  return C
  function V(lt, ct, At) {
    var gt = Wt(ct)
    if (
      ((gt.dataIndex = o.dataIndex),
      (gt.seriesIndex = r.seriesIndex),
      ct.setShape({
        x: 0,
        y: 0,
        width: d,
        height: p,
        r: M,
      }),
      v)
    )
      Y(ct)
    else {
      ct.invisible = !1
      var dt = o.getVisual('style'),
        B = dt.stroke,
        ht = UO(S)
      ht.fill = B
      var it = au(b)
      it.fill = b.get('borderColor')
      var xt = au(T)
      xt.fill = T.get('borderColor')
      var rt = au(w)
      if (((rt.fill = w.get('borderColor')), At)) {
        var kt = d - 2 * g
        K(ct, B, dt.opacity, {
          x: g,
          y: 0,
          width: kt,
          height: x,
        })
      } else ct.removeTextContent()
      ct.setStyle(ht),
        (ct.ensureState('emphasis').style = it),
        (ct.ensureState('blur').style = xt),
        (ct.ensureState('select').style = rt),
        qu(ct)
    }
    lt.add(ct)
  }
  function H(lt, ct) {
    var At = Wt(ct)
    ;(At.dataIndex = o.dataIndex), (At.seriesIndex = r.seriesIndex)
    var gt = Math.max(d - 2 * g, 0),
      dt = Math.max(p - 2 * g, 0)
    if (
      ((ct.culling = !0),
      ct.setShape({
        x: g,
        y: g,
        width: gt,
        height: dt,
        r: M,
      }),
      v)
    )
      Y(ct)
    else {
      ct.invisible = !1
      var B = o.getVisual('style'),
        ht = B.fill,
        it = UO(S)
      ;(it.fill = ht), (it.decal = B.decal)
      var xt = au(b),
        rt = au(T),
        kt = au(w)
      K(ct, ht, B.opacity, null),
        ct.setStyle(it),
        (ct.ensureState('emphasis').style = xt),
        (ct.ensureState('blur').style = rt),
        (ct.ensureState('select').style = kt),
        qu(ct)
    }
    lt.add(ct)
  }
  function Y(lt) {
    !lt.invisible && a.push(lt)
  }
  function K(lt, ct, At, gt) {
    var dt = f.getModel(gt ? zO : FO),
      B = Un(f.get('name'), null),
      ht = dt.getShallow('show')
    mr(lt, Zn(f, gt ? zO : FO), {
      defaultText: ht ? B : null,
      inheritColor: ct,
      defaultOpacity: At,
      labelFetcher: r,
      labelDataIndex: o.dataIndex,
    })
    var it = lt.getTextContent()
    if (it) {
      var xt = it.style,
        rt = LT(xt.padding || 0)
      gt &&
        (lt.setTextConfig({
          layoutRect: gt,
        }),
        (it.disableLabelLayout = !0)),
        (it.beforeUpdate = function () {
          var Ct = Math.max(
              (gt ? gt.width : lt.shape.width) - rt[1] - rt[3],
              0,
            ),
            Lt = Math.max((gt ? gt.height : lt.shape.height) - rt[0] - rt[2], 0)
          ;(xt.width !== Ct || xt.height !== Lt) &&
            it.setStyle({
              width: Ct,
              height: Lt,
            })
        }),
        (xt.truncateMinChar = 2),
        (xt.lineOverflow = 'truncate'),
        ut(xt, gt, c)
      var kt = it.getState('emphasis')
      ut(kt ? kt.style : null, gt, c)
    }
  }
  function ut(lt, ct, At) {
    var gt = lt ? lt.text : null
    if (!ct && At.isLeafRoot && gt != null) {
      var dt = r.get('drillDownIcon', !0)
      lt.text = dt ? dt + ' ' + gt : gt
    }
  }
  function W(lt, ct, At, gt) {
    var dt = y != null && e[lt][y],
      B = i[lt]
    return (
      dt
        ? ((e[lt][y] = null), Z(B, dt))
        : v ||
          ((dt = new ct()),
          dt instanceof ea && (dt.z2 = nft(At, gt)),
          ft(B, dt)),
      (t[lt][m] = dt)
    )
  }
  function Z(lt, ct) {
    var At = (lt[m] = {})
    ct instanceof Fw
      ? ((At.oldX = ct.x), (At.oldY = ct.y))
      : (At.oldShape = Q({}, ct.shape))
  }
  function ft(lt, ct) {
    var At = (lt[m] = {}),
      gt = o.parentNode,
      dt = ct instanceof Ht
    if (gt && (!n || n.direction === 'drillDown')) {
      var B = 0,
        ht = 0,
        it = i.background[gt.getRawIndex()]
      !n &&
        it &&
        it.oldShape &&
        ((B = it.oldShape.width), (ht = it.oldShape.height)),
        dt
          ? ((At.oldX = 0), (At.oldY = ht))
          : (At.oldShape = {
              x: B,
              y: ht,
              width: 0,
              height: 0,
            })
    }
    At.fadein = !dt
  }
}
function nft(r, t) {
  return r * jht + t
}
const rft = tft
var rv = R,
  ift = Ut,
  v0 = -1,
  $C = (function () {
    function r(t) {
      var e = t.mappingMethod,
        n = t.type,
        i = (this.option = Vt(t))
      ;(this.type = n), (this.mappingMethod = e), (this._normalizeData = sft[e])
      var a = r.visualHandlers[n]
      ;(this.applyVisual = a.applyVisual),
        (this.getColorMapper = a.getColorMapper),
        (this._normalizedToVisual = a._normalizedToVisual[e]),
        e === 'piecewise'
          ? (vS(i), aft(i))
          : e === 'category'
          ? i.categories
            ? oft(i)
            : vS(i, !0)
          : (Gr(e !== 'linear' || i.dataExtent), vS(i))
    }
    return (
      (r.prototype.mapValueToVisual = function (t) {
        var e = this._normalizeData(t)
        return this._normalizedToVisual(e, t)
      }),
      (r.prototype.getNormalizer = function () {
        return Tt(this._normalizeData, this)
      }),
      (r.listVisualTypes = function () {
        return pe(r.visualHandlers)
      }),
      (r.isValidType = function (t) {
        return r.visualHandlers.hasOwnProperty(t)
      }),
      (r.eachVisual = function (t, e, n) {
        Ut(t) ? R(t, e, n) : e.call(n, t)
      }),
      (r.mapVisual = function (t, e, n) {
        var i,
          a = at(t) ? [] : Ut(t) ? {} : ((i = !0), null)
        return (
          r.eachVisual(t, function (o, s) {
            var l = e.call(n, o, s)
            i ? (a = l) : (a[s] = l)
          }),
          a
        )
      }),
      (r.retrieveVisuals = function (t) {
        var e = {},
          n
        return (
          t &&
            rv(r.visualHandlers, function (i, a) {
              t.hasOwnProperty(a) && ((e[a] = t[a]), (n = !0))
            }),
          n ? e : null
        )
      }),
      (r.prepareVisualTypes = function (t) {
        if (at(t)) t = t.slice()
        else if (ift(t)) {
          var e = []
          rv(t, function (n, i) {
            e.push(i)
          }),
            (t = e)
        } else return []
        return (
          t.sort(function (n, i) {
            return i === 'color' && n !== 'color' && n.indexOf('color') === 0
              ? 1
              : -1
          }),
          t
        )
      }),
      (r.dependsOn = function (t, e) {
        return e === 'color' ? !!(t && t.indexOf(e) === 0) : t === e
      }),
      (r.findPieceIndex = function (t, e, n) {
        for (var i, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
          var l = e[o].value
          if (l != null) {
            if (l === t || (bt(l) && l === t + '')) return o
            n && f(l, o)
          }
        }
        for (var o = 0, s = e.length; o < s; o++) {
          var u = e[o],
            c = u.interval,
            h = u.close
          if (c) {
            if (c[0] === -1 / 0) {
              if (mm(h[1], t, c[1])) return o
            } else if (c[1] === 1 / 0) {
              if (mm(h[0], c[0], t)) return o
            } else if (mm(h[0], c[0], t) && mm(h[1], t, c[1])) return o
            n && f(c[0], o), n && f(c[1], o)
          }
        }
        if (n) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : i
        function f(d, p) {
          var g = Math.abs(d - t)
          g < a && ((a = g), (i = p))
        }
      }),
      (r.visualHandlers = {
        color: {
          applyVisual: yd('color'),
          getColorMapper: function () {
            var t = this.option
            return Tt(
              t.mappingMethod === 'category'
                ? function (e, n) {
                    return !n && (e = this._normalizeData(e)), Hd.call(this, e)
                  }
                : function (e, n, i) {
                    var a = !!i
                    return (
                      !n && (e = this._normalizeData(e)),
                      (i = Zx(e, t.parsedVisual, i)),
                      a ? i : Wo(i, 'rgba')
                    )
                  },
              this,
            )
          },
          _normalizedToVisual: {
            linear: function (t) {
              return Wo(Zx(t, this.option.parsedVisual), 'rgba')
            },
            category: Hd,
            piecewise: function (t, e) {
              var n = Uw.call(this, e)
              return (
                n == null && (n = Wo(Zx(t, this.option.parsedVisual), 'rgba')),
                n
              )
            },
            fixed: ou,
          },
        },
        colorHue: gm(function (t, e) {
          return ep(t, e)
        }),
        colorSaturation: gm(function (t, e) {
          return ep(t, null, e)
        }),
        colorLightness: gm(function (t, e) {
          return ep(t, null, null, e)
        }),
        colorAlpha: gm(function (t, e) {
          return zy(t, e)
        }),
        decal: {
          applyVisual: yd('decal'),
          _normalizedToVisual: {
            linear: null,
            category: Hd,
            piecewise: null,
            fixed: null,
          },
        },
        opacity: {
          applyVisual: yd('opacity'),
          _normalizedToVisual: zw([0, 1]),
        },
        liftZ: {
          applyVisual: yd('liftZ'),
          _normalizedToVisual: {
            linear: ou,
            category: ou,
            piecewise: ou,
            fixed: ou,
          },
        },
        symbol: {
          applyVisual: function (t, e, n) {
            var i = this.mapValueToVisual(t)
            n('symbol', i)
          },
          _normalizedToVisual: {
            linear: VO,
            category: Hd,
            piecewise: function (t, e) {
              var n = Uw.call(this, e)
              return n == null && (n = VO.call(this, t)), n
            },
            fixed: ou,
          },
        },
        symbolSize: {
          applyVisual: yd('symbolSize'),
          _normalizedToVisual: zw([0, 1]),
        },
      }),
      r
    )
  })()
function aft(r) {
  var t = r.pieceList
  ;(r.hasSpecialVisual = !1),
    R(t, function (e, n) {
      ;(e.originIndex = n), e.visual != null && (r.hasSpecialVisual = !0)
    })
}
function oft(r) {
  var t = r.categories,
    e = (r.categoryMap = {}),
    n = r.visual
  if (
    (rv(t, function (o, s) {
      e[o] = s
    }),
    !at(n))
  ) {
    var i = []
    Ut(n)
      ? rv(n, function (o, s) {
          var l = e[s]
          i[l ?? v0] = o
        })
      : (i[v0] = n),
      (n = l4(r, i))
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete e[t[a]], t.pop())
}
function vS(r, t) {
  var e = r.visual,
    n = []
  Ut(e)
    ? rv(e, function (a) {
        n.push(a)
      })
    : e != null && n.push(e)
  var i = {
    color: 1,
    symbol: 1,
  }
  !t && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), l4(r, n)
}
function gm(r) {
  return {
    applyVisual: function (t, e, n) {
      var i = this.mapValueToVisual(t)
      n('color', r(e('color'), i))
    },
    _normalizedToVisual: zw([0, 1]),
  }
}
function VO(r) {
  var t = this.option.visual
  return t[Math.round(Re(r, [0, 1], [0, t.length - 1], !0))] || {}
}
function yd(r) {
  return function (t, e, n) {
    n(r, this.mapValueToVisual(t))
  }
}
function Hd(r) {
  var t = this.option.visual
  return t[this.option.loop && r !== v0 ? r % t.length : r]
}
function ou() {
  return this.option.visual[0]
}
function zw(r) {
  return {
    linear: function (t) {
      return Re(t, r, this.option.visual, !0)
    },
    category: Hd,
    piecewise: function (t, e) {
      var n = Uw.call(this, e)
      return n == null && (n = Re(t, r, this.option.visual, !0)), n
    },
    fixed: ou,
  }
}
function Uw(r) {
  var t = this.option,
    e = t.pieceList
  if (t.hasSpecialVisual) {
    var n = $C.findPieceIndex(r, e),
      i = e[n]
    if (i && i.visual) return i.visual[this.type]
  }
}
function l4(r, t) {
  return (
    (r.visual = t),
    r.type === 'color' &&
      (r.parsedVisual = st(t, function (e) {
        var n = wi(e)
        return n || [0, 0, 0, 1]
      })),
    t
  )
}
var sft = {
  linear: function (r) {
    return Re(r, this.option.dataExtent, [0, 1], !0)
  },
  piecewise: function (r) {
    var t = this.option.pieceList,
      e = $C.findPieceIndex(r, t, !0)
    if (e != null) return Re(e, [0, t.length - 1], [0, 1], !0)
  },
  category: function (r) {
    var t = this.option.categories ? this.option.categoryMap[r] : r
    return t ?? v0
  },
  fixed: wn,
}
function mm(r, t, e) {
  return r ? t <= e : t < e
}
const vr = $C
var lft = 'itemStyle',
  u4 = ve()
const uft = {
  seriesType: 'treemap',
  reset: function (r) {
    var t = r.getData().tree,
      e = t.root
    e.isRemoved() || c4(e, {}, r.getViewRoot().getAncestors(), r)
  },
}
function c4(r, t, e, n) {
  var i = r.getModel(),
    a = r.getLayout(),
    o = r.hostTree.data
  if (!(!a || a.invisible || !a.isInView)) {
    var s = i.getModel(lft),
      l = cft(s, t, n),
      u = o.ensureUniqueItemVisual(r.dataIndex, 'style'),
      c = s.get('borderColor'),
      h = s.get('borderColorSaturation'),
      f
    h != null && ((f = GO(l)), (c = hft(h, f))), (u.stroke = c)
    var d = r.viewChildren
    if (!d || !d.length) (f = GO(l)), (u.fill = f)
    else {
      var p = fft(r, i, a, s, l, d)
      R(d, function (g, v) {
        if (g.depth >= e.length || g === e[g.depth]) {
          var m = dft(i, l, g, v, p, n)
          c4(g, m, e, n)
        }
      })
    }
  }
}
function cft(r, t, e) {
  var n = Q({}, t),
    i = e.designatedVisualItemStyle
  return (
    R(['color', 'colorAlpha', 'colorSaturation'], function (a) {
      i[a] = t[a]
      var o = r.get(a)
      ;(i[a] = null), o != null && (n[a] = o)
    }),
    n
  )
}
function GO(r) {
  var t = gS(r, 'color')
  if (t) {
    var e = gS(r, 'colorAlpha'),
      n = gS(r, 'colorSaturation')
    return n && (t = ep(t, null, null, n)), e && (t = zy(t, e)), t
  }
}
function hft(r, t) {
  return t != null ? ep(t, null, null, r) : null
}
function gS(r, t) {
  var e = r[t]
  if (e != null && e !== 'none') return e
}
function fft(r, t, e, n, i, a) {
  if (!(!a || !a.length)) {
    var o =
      mS(t, 'color') ||
      (i.color != null &&
        i.color !== 'none' &&
        (mS(t, 'colorAlpha') || mS(t, 'colorSaturation')))
    if (o) {
      var s = t.get('visualMin'),
        l = t.get('visualMax'),
        u = e.dataExtent.slice()
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l)
      var c = t.get('colorMappingBy'),
        h = {
          type: o.name,
          dataExtent: u,
          visual: o.range,
        }
      h.type === 'color' && (c === 'index' || c === 'id')
        ? ((h.mappingMethod = 'category'), (h.loop = !0))
        : (h.mappingMethod = 'linear')
      var f = new vr(h)
      return (u4(f).drColorMappingBy = c), f
    }
  }
}
function mS(r, t) {
  var e = r.get(t)
  return at(e) && e.length
    ? {
        name: t,
        range: e,
      }
    : null
}
function dft(r, t, e, n, i, a) {
  var o = Q({}, t)
  if (i) {
    var s = i.type,
      l = s === 'color' && u4(i).drColorMappingBy,
      u =
        l === 'index'
          ? n
          : l === 'id'
          ? a.mapIdToIndex(e.getId())
          : e.getValue(r.get('visualDimension'))
    o[s] = i.mapValueToVisual(u)
  }
  return o
}
var iv = Math.max,
  g0 = Math.min,
  HO = nr,
  qC = R,
  h4 = ['itemStyle', 'borderWidth'],
  pft = ['itemStyle', 'gapWidth'],
  vft = ['upperLabel', 'show'],
  gft = ['upperLabel', 'height']
const mft = {
  seriesType: 'treemap',
  reset: function (r, t, e, n) {
    var i = e.getWidth(),
      a = e.getHeight(),
      o = r.option,
      s = Vn(r.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight(),
      }),
      l = o.size || [],
      u = _t(HO(s.width, l[0]), i),
      c = _t(HO(s.height, l[1]), a),
      h = n && n.type,
      f = ['treemapZoomToNode', 'treemapRootToNode'],
      d = nv(n, f, r),
      p = h === 'treemapRender' || h === 'treemapMove' ? n.rootRect : null,
      g = r.getViewRoot(),
      v = a4(g)
    if (h !== 'treemapMove') {
      var m =
          h === 'treemapZoomToNode'
            ? bft(r, d, g, u, c)
            : p
            ? [p.width, p.height]
            : [u, c],
        y = o.sort
      y && y !== 'asc' && y !== 'desc' && (y = 'desc')
      var _ = {
        squareRatio: o.squareRatio,
        sort: y,
        leafDepth: o.leafDepth,
      }
      g.hostTree.clearLayouts()
      var x = {
        x: 0,
        y: 0,
        width: m[0],
        height: m[1],
        area: m[0] * m[1],
      }
      g.setLayout(x),
        f4(g, _, !1, 0),
        (x = g.getLayout()),
        qC(v, function (S, b) {
          var T = (v[b + 1] || g).getValue()
          S.setLayout(
            Q(
              {
                dataExtent: [T, T],
                borderWidth: 0,
                upperHeight: 0,
              },
              x,
            ),
          )
        })
    }
    var A = r.getData().tree.root
    A.setLayout(wft(s, p, d), !0),
      r.setLayoutInfo(s),
      d4(A, new ee(-s.x, -s.y, i, a), v, g, 0)
  },
}
function f4(r, t, e, n) {
  var i, a
  if (!r.isRemoved()) {
    var o = r.getLayout()
    ;(i = o.width), (a = o.height)
    var s = r.getModel(),
      l = s.get(h4),
      u = s.get(pft) / 2,
      c = p4(s),
      h = Math.max(l, c),
      f = l - u,
      d = h - u
    r.setLayout(
      {
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c,
      },
      !0,
    ),
      (i = iv(i - 2 * f, 0)),
      (a = iv(a - f - d, 0))
    var p = i * a,
      g = yft(r, s, p, t, e, n)
    if (g.length) {
      var v = {
          x: f,
          y: d,
          width: i,
          height: a,
        },
        m = g0(i, a),
        y = 1 / 0,
        _ = []
      _.area = 0
      for (var x = 0, A = g.length; x < A; ) {
        var S = g[x]
        _.push(S), (_.area += S.getLayout().area)
        var b = Aft(_, m, t.squareRatio)
        b <= y
          ? (x++, (y = b))
          : ((_.area -= _.pop().getLayout().area),
            WO(_, m, v, u, !1),
            (m = g0(v.width, v.height)),
            (_.length = _.area = 0),
            (y = 1 / 0))
      }
      if ((_.length && WO(_, m, v, u, !0), !e)) {
        var T = s.get('childrenVisibleMin')
        T != null && p < T && (e = !0)
      }
      for (var x = 0, A = g.length; x < A; x++) f4(g[x], t, e, n + 1)
    }
  }
}
function yft(r, t, e, n, i, a) {
  var o = r.children || [],
    s = n.sort
  s !== 'asc' && s !== 'desc' && (s = null)
  var l = n.leafDepth != null && n.leafDepth <= a
  if (i && !l) return (r.viewChildren = [])
  ;(o = Ne(o, function (d) {
    return !d.isRemoved()
  })),
    xft(o, s)
  var u = Sft(t, o, s)
  if (u.sum === 0) return (r.viewChildren = [])
  if (((u.sum = _ft(t, e, u.sum, s, o)), u.sum === 0))
    return (r.viewChildren = [])
  for (var c = 0, h = o.length; c < h; c++) {
    var f = (o[c].getValue() / u.sum) * e
    o[c].setLayout({
      area: f,
    })
  }
  return (
    l &&
      (o.length &&
        r.setLayout(
          {
            isLeafRoot: !0,
          },
          !0,
        ),
      (o.length = 0)),
    (r.viewChildren = o),
    r.setLayout(
      {
        dataExtent: u.dataExtent,
      },
      !0,
    ),
    o
  )
}
function _ft(r, t, e, n, i) {
  if (!n) return e
  for (
    var a = r.get('visibleMin'), o = i.length, s = o, l = o - 1;
    l >= 0;
    l--
  ) {
    var u = i[n === 'asc' ? o - l - 1 : l].getValue()
    ;(u / e) * t < a && ((s = l), (e -= u))
  }
  return n === 'asc' ? i.splice(0, o - s) : i.splice(s, o - s), e
}
function xft(r, t) {
  return (
    t &&
      r.sort(function (e, n) {
        var i =
          t === 'asc'
            ? e.getValue() - n.getValue()
            : n.getValue() - e.getValue()
        return i === 0
          ? t === 'asc'
            ? e.dataIndex - n.dataIndex
            : n.dataIndex - e.dataIndex
          : i
      }),
    r
  )
}
function Sft(r, t, e) {
  for (var n = 0, i = 0, a = t.length; i < a; i++) n += t[i].getValue()
  var o = r.get('visualDimension'),
    s
  return (
    !t || !t.length
      ? (s = [NaN, NaN])
      : o === 'value' && e
      ? ((s = [t[t.length - 1].getValue(), t[0].getValue()]),
        e === 'asc' && s.reverse())
      : ((s = [1 / 0, -1 / 0]),
        qC(t, function (l) {
          var u = l.getValue(o)
          u < s[0] && (s[0] = u), u > s[1] && (s[1] = u)
        })),
    {
      sum: n,
      dataExtent: s,
    }
  )
}
function Aft(r, t, e) {
  for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    (o = r[a].getLayout().area), o && (o < i && (i = o), o > n && (n = o))
  var l = r.area * r.area,
    u = t * t * e
  return l ? iv((u * n) / l, l / (u * i)) : 1 / 0
}
function WO(r, t, e, n, i) {
  var a = t === e.width ? 0 : 1,
    o = 1 - a,
    s = ['x', 'y'],
    l = ['width', 'height'],
    u = e[s[a]],
    c = t ? r.area / t : 0
  ;(i || c > e[l[o]]) && (c = e[l[o]])
  for (var h = 0, f = r.length; h < f; h++) {
    var d = r[h],
      p = {},
      g = c ? d.getLayout().area / c : 0,
      v = (p[l[o]] = iv(c - 2 * n, 0)),
      m = e[s[a]] + e[l[a]] - u,
      y = h === f - 1 || m < g ? m : g,
      _ = (p[l[a]] = iv(y - 2 * n, 0))
    ;(p[s[o]] = e[s[o]] + g0(n, v / 2)),
      (p[s[a]] = u + g0(n, _ / 2)),
      (u += y),
      d.setLayout(p, !0)
  }
  ;(e[s[o]] += c), (e[l[o]] -= c)
}
function bft(r, t, e, n, i) {
  var a = (t || {}).node,
    o = [n, i]
  if (!a || a === e) return o
  for (
    var s, l = n * i, u = l * r.option.zoomToNodeRatio;
    (s = a.parentNode);

  ) {
    for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++)
      c += h[f].getValue()
    var p = a.getValue()
    if (p === 0) return o
    u *= c / p
    var g = s.getModel(),
      v = g.get(h4),
      m = Math.max(v, p4(g))
    ;(u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5)),
      u > nP && (u = nP),
      (a = s)
  }
  u < l && (u = l)
  var y = Math.pow(u / l, 0.5)
  return [n * y, i * y]
}
function wft(r, t, e) {
  if (t)
    return {
      x: t.x,
      y: t.y,
    }
  var n = {
    x: 0,
    y: 0,
  }
  if (!e) return n
  var i = e.node,
    a = i.getLayout()
  if (!a) return n
  for (var o = [a.width / 2, a.height / 2], s = i; s; ) {
    var l = s.getLayout()
    ;(o[0] += l.x), (o[1] += l.y), (s = s.parentNode)
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1],
  }
}
function d4(r, t, e, n, i) {
  var a = r.getLayout(),
    o = e[i],
    s = o && o === r
  if (!((o && !s) || (i === e.length && r !== n))) {
    r.setLayout(
      {
        isInView: !0,
        invisible: !s && !t.intersect(a),
        isAboveViewRoot: s,
      },
      !0,
    )
    var l = new ee(t.x - a.x, t.y - a.y, t.width, t.height)
    qC(r.viewChildren || [], function (u) {
      d4(u, l, e, n, i + 1)
    })
  }
}
function p4(r) {
  return r.get(vft) ? r.get(gft) : 0
}
function Mft(r) {
  r.registerSeriesModel(Hht),
    r.registerChartView(rft),
    r.registerVisual(uft),
    r.registerLayout(mft),
    Uht(r)
}
function Tft(r) {
  var t = r.findComponents({
    mainType: 'legend',
  })
  !t ||
    !t.length ||
    r.eachSeriesByType('graph', function (e) {
      var n = e.getCategoriesData(),
        i = e.getGraph(),
        a = i.data,
        o = n.mapArray(n.getName)
      a.filterSelf(function (s) {
        var l = a.getItemModel(s),
          u = l.getShallow('category')
        if (u != null) {
          be(u) && (u = o[u])
          for (var c = 0; c < t.length; c++) if (!t[c].isSelected(u)) return !1
        }
        return !0
      })
    })
}
function Cft(r) {
  var t = {}
  r.eachSeriesByType('graph', function (e) {
    var n = e.getCategoriesData(),
      i = e.getData(),
      a = {}
    n.each(function (o) {
      var s = n.getName(o)
      a['ec-' + s] = o
      var l = n.getItemModel(o),
        u = l.getModel('itemStyle').getItemStyle()
      u.fill || (u.fill = e.getColorFromPalette(s, t)),
        n.setItemVisual(o, 'style', u)
      for (
        var c = ['symbol', 'symbolSize', 'symbolKeepAspect'], h = 0;
        h < c.length;
        h++
      ) {
        var f = l.getShallow(c[h], !0)
        f != null && n.setItemVisual(o, c[h], f)
      }
    }),
      n.count() &&
        i.each(function (o) {
          var s = i.getItemModel(o),
            l = s.getShallow('category')
          if (l != null) {
            bt(l) && (l = a['ec-' + l])
            var u = n.getItemVisual(l, 'style'),
              c = i.ensureUniqueItemVisual(o, 'style')
            Q(c, u)
            for (
              var h = ['symbol', 'symbolSize', 'symbolKeepAspect'], f = 0;
              f < h.length;
              f++
            )
              i.setItemVisual(o, h[f], n.getItemVisual(l, h[f]))
          }
        })
  })
}
function ym(r) {
  return r instanceof Array || (r = [r, r]), r
}
function Eft(r) {
  r.eachSeriesByType('graph', function (t) {
    var e = t.getGraph(),
      n = t.getEdgeData(),
      i = ym(t.get('edgeSymbol')),
      a = ym(t.get('edgeSymbolSize'))
    n.setVisual('fromSymbol', i && i[0]),
      n.setVisual('toSymbol', i && i[1]),
      n.setVisual('fromSymbolSize', a && a[0]),
      n.setVisual('toSymbolSize', a && a[1]),
      n.setVisual('style', t.getModel('lineStyle').getLineStyle()),
      n.each(function (o) {
        var s = n.getItemModel(o),
          l = e.getEdgeByIndex(o),
          u = ym(s.getShallow('symbol', !0)),
          c = ym(s.getShallow('symbolSize', !0)),
          h = s.getModel('lineStyle').getLineStyle(),
          f = n.ensureUniqueItemVisual(o, 'style')
        switch ((Q(f, h), f.stroke)) {
          case 'source': {
            var d = l.node1.getVisual('style')
            f.stroke = d && d.fill
            break
          }
          case 'target': {
            var d = l.node2.getVisual('style')
            f.stroke = d && d.fill
            break
          }
        }
        u[0] && l.setVisual('fromSymbol', u[0]),
          u[1] && l.setVisual('toSymbol', u[1]),
          c[0] && l.setVisual('fromSymbolSize', c[0]),
          c[1] && l.setVisual('toSymbolSize', c[1])
      })
  })
}
var Vw = '-->',
  D_ = function (r) {
    return r.get('autoCurveness') || null
  },
  v4 = function (r, t) {
    var e = D_(r),
      n = 20,
      i = []
    if (be(e)) n = e
    else if (at(e)) {
      r.__curvenessList = e
      return
    }
    t > n && (n = t)
    var a = n % 2 ? n + 2 : n + 3
    i = []
    for (var o = 0; o < a; o++)
      i.push(((o % 2 ? o + 1 : o) / 10) * (o % 2 ? -1 : 1))
    r.__curvenessList = i
  },
  av = function (r, t, e) {
    var n = [r.id, r.dataIndex].join('.'),
      i = [t.id, t.dataIndex].join('.')
    return [e.uid, n, i].join(Vw)
  },
  g4 = function (r) {
    var t = r.split(Vw)
    return [t[0], t[2], t[1]].join(Vw)
  },
  Dft = function (r, t) {
    var e = av(r.node1, r.node2, t)
    return t.__edgeMap[e]
  },
  Lft = function (r, t) {
    var e = Gw(av(r.node1, r.node2, t), t),
      n = Gw(av(r.node2, r.node1, t), t)
    return e + n
  },
  Gw = function (r, t) {
    var e = t.__edgeMap
    return e[r] ? e[r].length : 0
  }
function Pft(r) {
  D_(r) && ((r.__curvenessList = []), (r.__edgeMap = {}), v4(r))
}
function Rft(r, t, e, n) {
  if (D_(e)) {
    var i = av(r, t, e),
      a = e.__edgeMap,
      o = a[g4(i)]
    a[i] && !o
      ? (a[i].isForward = !0)
      : o && a[i] && ((o.isForward = !0), (a[i].isForward = !1)),
      (a[i] = a[i] || []),
      a[i].push(n)
  }
}
function ZC(r, t, e, n) {
  var i = D_(t),
    a = at(i)
  if (!i) return null
  var o = Dft(r, t)
  if (!o) return null
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === e) {
      s = l
      break
    }
  var u = Lft(r, t)
  v4(t, u), (r.lineStyle = r.lineStyle || {})
  var c = av(r.node1, r.node2, t),
    h = t.__curvenessList,
    f = a || u % 2 ? 0 : 1
  if (o.isForward) return h[f + s]
  var d = g4(c),
    p = Gw(d, t),
    g = h[s + p + f]
  return n
    ? a
      ? i && i[0] === 0
        ? (p + f) % 2
          ? g
          : -g
        : ((p % 2 ? 0 : 1) + f) % 2
        ? g
        : -g
      : (p + f) % 2
      ? g
      : -g
    : h[s + p + f]
}
function m4(r) {
  var t = r.coordinateSystem
  if (!(t && t.type !== 'view')) {
    var e = r.getGraph()
    e.eachNode(function (n) {
      var i = n.getModel()
      n.setLayout([+i.get('x'), +i.get('y')])
    }),
      KC(e, r)
  }
}
function KC(r, t) {
  r.eachEdge(function (e, n) {
    var i = ao(
        e.getModel().get(['lineStyle', 'curveness']),
        -ZC(e, t, n, !0),
        0,
      ),
      a = Go(e.node1.getLayout()),
      o = Go(e.node2.getLayout()),
      s = [a, o]
    ;+i &&
      s.push([
        (a[0] + o[0]) / 2 - (a[1] - o[1]) * i,
        (a[1] + o[1]) / 2 - (o[0] - a[0]) * i,
      ]),
      e.setLayout(s)
  })
}
function Ift(r, t) {
  r.eachSeriesByType('graph', function (e) {
    var n = e.get('layout'),
      i = e.coordinateSystem
    if (i && i.type !== 'view') {
      var a = e.getData(),
        o = []
      R(i.dimensions, function (f) {
        o = o.concat(a.mapDimensionsAll(f))
      })
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var h = a.get(o[c], s)
          isNaN(h) || (u = !0), l.push(h)
        }
        u
          ? a.setItemLayout(s, i.dataToPoint(l))
          : a.setItemLayout(s, [NaN, NaN])
      }
      KC(a.graph, e)
    } else (!n || n === 'none') && m4(e)
  })
}
function Wd(r) {
  var t = r.coordinateSystem
  if (t.type !== 'view') return 1
  var e = r.option.nodeScaleRatio,
    n = t.scaleX,
    i = t.getZoom(),
    a = (i - 1) * e + 1
  return a / n
}
function Xd(r) {
  var t = r.getVisual('symbolSize')
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t
}
var XO = Math.PI,
  yS = []
function jC(r, t, e, n) {
  var i = r.coordinateSystem
  if (!(i && i.type !== 'view')) {
    var a = i.getBoundingRect(),
      o = r.getData(),
      s = o.graph,
      l = a.width / 2 + a.x,
      u = a.height / 2 + a.y,
      c = Math.min(a.width, a.height) / 2,
      h = o.count()
    if (
      (o.setLayout({
        cx: l,
        cy: u,
      }),
      !!h)
    ) {
      if (e) {
        var f = i.pointToData(n),
          d = f[0],
          p = f[1],
          g = [d - l, p - u]
        gf(g, g), Xm(g, g, c), e.setLayout([l + g[0], u + g[1]], !0)
        var v = r.get(['circular', 'rotateLabel'])
        y4(e, v, l, u)
      }
      Oft[t](r, s, o, c, l, u, h),
        s.eachEdge(function (m, y) {
          var _ = ao(
              m.getModel().get(['lineStyle', 'curveness']),
              ZC(m, r, y),
              0,
            ),
            x = Go(m.node1.getLayout()),
            A = Go(m.node2.getLayout()),
            S,
            b = (x[0] + A[0]) / 2,
            T = (x[1] + A[1]) / 2
          ;+_ && ((_ *= 3), (S = [l * _ + b * (1 - _), u * _ + T * (1 - _)])),
            m.setLayout([x, A, S])
        })
    }
  }
}
var Oft = {
  value: function (r, t, e, n, i, a, o) {
    var s = 0,
      l = e.getSum('value'),
      u = (Math.PI * 2) / (l || o)
    t.eachNode(function (c) {
      var h = c.getValue('value'),
        f = (u * (l ? h : 1)) / 2
      ;(s += f),
        c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + a]),
        (s += f)
    })
  },
  symbolSize: function (r, t, e, n, i, a, o) {
    var s = 0
    yS.length = o
    var l = Wd(r)
    t.eachNode(function (h) {
      var f = Xd(h)
      isNaN(f) && (f = 2), f < 0 && (f = 0), (f *= l)
      var d = Math.asin(f / 2 / n)
      isNaN(d) && (d = XO / 2), (yS[h.dataIndex] = d), (s += d * 2)
    })
    var u = (2 * XO - s) / o / 2,
      c = 0
    t.eachNode(function (h) {
      var f = u + yS[h.dataIndex]
      ;(c += f),
        (!h.getLayout() || !h.getLayout().fixed) &&
          h.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + a]),
        (c += f)
    })
  },
}
function y4(r, t, e, n) {
  var i = r.getGraphicEl()
  if (i) {
    var a = r.getModel(),
      o = a.get(['label', 'rotate']) || 0,
      s = i.getSymbolPath()
    if (t) {
      var l = r.getLayout(),
        u = Math.atan2(l[1] - n, l[0] - e)
      u < 0 && (u = Math.PI * 2 + u)
      var c = l[0] < e
      c && (u = u - Math.PI)
      var h = c ? 'left' : 'right'
      s.setTextConfig({
        rotation: -u,
        position: h,
        origin: 'center',
      })
      var f = s.ensureState('emphasis')
      Q(f.textConfig || (f.textConfig = {}), {
        position: h,
      })
    } else
      s.setTextConfig({
        rotation: (o *= Math.PI / 180),
      })
  }
}
function Nft(r) {
  r.eachSeriesByType('graph', function (t) {
    t.get('layout') === 'circular' && jC(t, 'symbolSize')
  })
}
var jc = Eb
function kft(r, t, e) {
  for (
    var n = r,
      i = t,
      a = e.rect,
      o = a.width,
      s = a.height,
      l = [a.x + o / 2, a.y + s / 2],
      u = e.gravity == null ? 0.1 : e.gravity,
      c = 0;
    c < n.length;
    c++
  ) {
    var h = n[c]
    h.p ||
      (h.p = tc(
        o * (Math.random() - 0.5) + l[0],
        s * (Math.random() - 0.5) + l[1],
      )),
      (h.pp = Go(h.p)),
      (h.edges = null)
  }
  var f = e.friction == null ? 0.6 : e.friction,
    d = f,
    p,
    g
  return {
    warmUp: function () {
      d = f * 0.8
    },
    setFixed: function (v) {
      n[v].fixed = !0
    },
    setUnfixed: function (v) {
      n[v].fixed = !1
    },
    beforeStep: function (v) {
      p = v
    },
    afterStep: function (v) {
      g = v
    },
    step: function (v) {
      p && p(n, i)
      for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
        var x = i[_]
        if (!x.ignoreForceLayout) {
          var A = x.n1,
            S = x.n2
          gu(m, S.p, A.p)
          var b = Db(m) - x.d,
            T = S.w / (A.w + S.w)
          isNaN(T) && (T = 0),
            gf(m, m),
            !A.fixed && jc(A.p, A.p, m, T * b * d),
            !S.fixed && jc(S.p, S.p, m, -(1 - T) * b * d)
        }
      }
      for (var _ = 0; _ < y; _++) {
        var w = n[_]
        w.fixed || (gu(m, l, w.p), jc(w.p, w.p, m, u * d))
      }
      for (var _ = 0; _ < y; _++)
        for (var A = n[_], M = _ + 1; M < y; M++) {
          var S = n[M]
          gu(m, S.p, A.p)
          var b = Db(m)
          b === 0 && (VJ(m, Math.random() - 0.5, Math.random() - 0.5), (b = 1))
          var C = (A.rep + S.rep) / b / b
          !A.fixed && jc(A.pp, A.pp, m, C), !S.fixed && jc(S.pp, S.pp, m, -C)
        }
      for (var E = [], _ = 0; _ < y; _++) {
        var w = n[_]
        w.fixed || (gu(E, w.p, w.pp), jc(w.p, w.p, E, d), Nr(w.pp, w.p))
      }
      d = d * 0.992
      var D = d < 0.01
      g && g(n, i, D), v && v(D)
    },
  }
}
function Bft(r) {
  r.eachSeriesByType('graph', function (t) {
    var e = t.coordinateSystem
    if (!(e && e.type !== 'view'))
      if (t.get('layout') === 'force') {
        var n = t.preservedPoints || {},
          i = t.getGraph(),
          a = i.data,
          o = i.edgeData,
          s = t.getModel('force'),
          l = s.get('initLayout')
        t.preservedPoints
          ? a.each(function (_) {
              var x = a.getId(_)
              a.setItemLayout(_, n[x] || [NaN, NaN])
            })
          : !l || l === 'none'
          ? m4(t)
          : l === 'circular' && jC(t, 'value')
        var u = a.getDataExtent('value'),
          c = o.getDataExtent('value'),
          h = s.get('repulsion'),
          f = s.get('edgeLength'),
          d = at(h) ? h : [h, h],
          p = at(f) ? f : [f, f]
        p = [p[1], p[0]]
        var g = a.mapArray('value', function (_, x) {
            var A = a.getItemLayout(x),
              S = Re(_, u, d)
            return (
              isNaN(S) && (S = (d[0] + d[1]) / 2),
              {
                w: S,
                rep: S,
                fixed: a.getItemModel(x).get('fixed'),
                p: !A || isNaN(A[0]) || isNaN(A[1]) ? null : A,
              }
            )
          }),
          v = o.mapArray('value', function (_, x) {
            var A = i.getEdgeByIndex(x),
              S = Re(_, c, p)
            isNaN(S) && (S = (p[0] + p[1]) / 2)
            var b = A.getModel(),
              T = ao(
                A.getModel().get(['lineStyle', 'curveness']),
                -ZC(A, t, x, !0),
                0,
              )
            return {
              n1: g[A.node1.dataIndex],
              n2: g[A.node2.dataIndex],
              d: S,
              curveness: T,
              ignoreForceLayout: b.get('ignoreForceLayout'),
            }
          }),
          m = e.getBoundingRect(),
          y = kft(g, v, {
            rect: m,
            gravity: s.get('gravity'),
            friction: s.get('friction'),
          })
        y.beforeStep(function (_, x) {
          for (var A = 0, S = _.length; A < S; A++)
            _[A].fixed && Nr(_[A].p, i.getNodeByIndex(A).getLayout())
        }),
          y.afterStep(function (_, x, A) {
            for (var S = 0, b = _.length; S < b; S++)
              _[S].fixed || i.getNodeByIndex(S).setLayout(_[S].p),
                (n[a.getId(S)] = _[S].p)
            for (var S = 0, b = x.length; S < b; S++) {
              var T = x[S],
                w = i.getEdgeByIndex(S),
                M = T.n1.p,
                C = T.n2.p,
                E = w.getLayout()
              ;(E = E ? E.slice() : []),
                (E[0] = E[0] || []),
                (E[1] = E[1] || []),
                Nr(E[0], M),
                Nr(E[1], C),
                +T.curveness &&
                  (E[2] = [
                    (M[0] + C[0]) / 2 - (M[1] - C[1]) * T.curveness,
                    (M[1] + C[1]) / 2 - (C[0] - M[0]) * T.curveness,
                  ]),
                w.setLayout(E)
            }
          }),
          (t.forceLayout = y),
          (t.preservedPoints = n),
          y.step()
      } else t.forceLayout = null
  })
}
function Fft(r, t, e) {
  var n = Q(r.getBoxLayoutParams(), {
    aspect: e,
  })
  return Vn(n, {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function zft(r, t) {
  var e = []
  return (
    r.eachSeriesByType('graph', function (n) {
      var i = n.get('coordinateSystem')
      if (!i || i === 'view') {
        var a = n.getData(),
          o = a.mapArray(function (v) {
            var m = a.getItemModel(v)
            return [+m.get('x'), +m.get('y')]
          }),
          s = [],
          l = []
        e_(o, s, l),
          l[0] - s[0] === 0 && ((l[0] += 1), (s[0] -= 1)),
          l[1] - s[1] === 0 && ((l[1] += 1), (s[1] -= 1))
        var u = (l[0] - s[0]) / (l[1] - s[1]),
          c = Fft(n, t, u)
        isNaN(u) && ((s = [c.x, c.y]), (l = [c.x + c.width, c.y + c.height]))
        var h = l[0] - s[0],
          f = l[1] - s[1],
          d = c.width,
          p = c.height,
          g = (n.coordinateSystem = new Iv())
        ;(g.zoomLimit = n.get('scaleLimit')),
          g.setBoundingRect(s[0], s[1], h, f),
          g.setViewRect(c.x, c.y, d, p),
          g.setCenter(n.get('center'), t),
          g.setZoom(n.get('zoom')),
          e.push(g)
      }
    }),
    e
  )
}
var YO = rr.prototype,
  _S = a_.prototype,
  _4 = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.percent = 1)
    }
    return r
  })()
;(function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return t
})(_4)
function xS(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1)
}
var Uft = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this, e) || this
    return (n.type = 'ec-line'), n
  }
  return (
    (t.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null,
      }
    }),
    (t.prototype.getDefaultShape = function () {
      return new _4()
    }),
    (t.prototype.buildPath = function (e, n) {
      xS(n) ? YO.buildPath.call(this, e, n) : _S.buildPath.call(this, e, n)
    }),
    (t.prototype.pointAt = function (e) {
      return xS(this.shape)
        ? YO.pointAt.call(this, e)
        : _S.pointAt.call(this, e)
    }),
    (t.prototype.tangentAt = function (e) {
      var n = this.shape,
        i = xS(n) ? [n.x2 - n.x1, n.y2 - n.y1] : _S.tangentAt.call(this, e)
      return gf(i, i)
    }),
    t
  )
})(oe)
const Vft = Uft
var SS = ['fromSymbol', 'toSymbol']
function $O(r) {
  return '_' + r + 'Type'
}
function qO(r, t, e) {
  var n = t.getItemVisual(e, r)
  if (!n || n === 'none') return n
  var i = t.getItemVisual(e, r + 'Size'),
    a = t.getItemVisual(e, r + 'Rotate'),
    o = t.getItemVisual(e, r + 'Offset'),
    s = t.getItemVisual(e, r + 'KeepAspect'),
    l = Lf(i),
    u = ic(o || 0, l)
  return n + l + u + (a || '') + (s || '')
}
function ZO(r, t, e) {
  var n = t.getItemVisual(e, r)
  if (!(!n || n === 'none')) {
    var i = t.getItemVisual(e, r + 'Size'),
      a = t.getItemVisual(e, r + 'Rotate'),
      o = t.getItemVisual(e, r + 'Offset'),
      s = t.getItemVisual(e, r + 'KeepAspect'),
      l = Lf(i),
      u = ic(o || 0, l),
      c = Rn(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s)
    return (
      (c.__specifiedRotation =
        a == null || isNaN(a) ? void 0 : (+a * Math.PI) / 180 || 0),
      (c.name = r),
      c
    )
  }
}
function Gft(r) {
  var t = new Vft({
    name: 'line',
    subPixelOptimize: !0,
  })
  return Hw(t.shape, r), t
}
function Hw(r, t) {
  ;(r.x1 = t[0][0]),
    (r.y1 = t[0][1]),
    (r.x2 = t[1][0]),
    (r.y2 = t[1][1]),
    (r.percent = 1)
  var e = t[2]
  e ? ((r.cpx1 = e[0]), (r.cpy1 = e[1])) : ((r.cpx1 = NaN), (r.cpy1 = NaN))
}
var Hft = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a._createLine(e, n, i), a
  }
  return (
    (t.prototype._createLine = function (e, n, i) {
      var a = e.hostModel,
        o = e.getItemLayout(n),
        s = Gft(o)
      ;(s.shape.percent = 0),
        Je(
          s,
          {
            shape: {
              percent: 1,
            },
          },
          a,
          n,
        ),
        this.add(s),
        R(
          SS,
          function (l) {
            var u = ZO(l, e, n)
            this.add(u), (this[$O(l)] = qO(l, e, n))
          },
          this,
        ),
        this._updateCommonStl(e, n, i)
    }),
    (t.prototype.updateData = function (e, n, i) {
      var a = e.hostModel,
        o = this.childOfName('line'),
        s = e.getItemLayout(n),
        l = {
          shape: {},
        }
      Hw(l.shape, s),
        we(o, l, a, n),
        R(
          SS,
          function (u) {
            var c = qO(u, e, n),
              h = $O(u)
            if (this[h] !== c) {
              this.remove(this.childOfName(u))
              var f = ZO(u, e, n)
              this.add(f)
            }
            this[h] = c
          },
          this,
        ),
        this._updateCommonStl(e, n, i)
    }),
    (t.prototype.getLinePath = function () {
      return this.childAt(0)
    }),
    (t.prototype._updateCommonStl = function (e, n, i) {
      var a = e.hostModel,
        o = this.childOfName('line'),
        s = i && i.emphasisLineStyle,
        l = i && i.blurLineStyle,
        u = i && i.selectLineStyle,
        c = i && i.labelStatesModels,
        h = i && i.emphasisDisabled,
        f = i && i.focus,
        d = i && i.blurScope
      if (!i || e.hasItemOption) {
        var p = e.getItemModel(n),
          g = p.getModel('emphasis')
        ;(s = g.getModel('lineStyle').getLineStyle()),
          (l = p.getModel(['blur', 'lineStyle']).getLineStyle()),
          (u = p.getModel(['select', 'lineStyle']).getLineStyle()),
          (h = g.get('disabled')),
          (f = g.get('focus')),
          (d = g.get('blurScope')),
          (c = Zn(p))
      }
      var v = e.getItemVisual(n, 'style'),
        m = v.stroke
      o.useStyle(v),
        (o.style.fill = null),
        (o.style.strokeNoScale = !0),
        (o.ensureState('emphasis').style = s),
        (o.ensureState('blur').style = l),
        (o.ensureState('select').style = u),
        R(
          SS,
          function (S) {
            var b = this.childOfName(S)
            if (b) {
              b.setColor(m), (b.style.opacity = v.opacity)
              for (var T = 0; T < Hr.length; T++) {
                var w = Hr[T],
                  M = o.getState(w)
                if (M) {
                  var C = M.style || {},
                    E = b.ensureState(w),
                    D = E.style || (E.style = {})
                  C.stroke != null &&
                    (D[b.__isEmptyBrush ? 'stroke' : 'fill'] = C.stroke),
                    C.opacity != null && (D.opacity = C.opacity)
                }
              }
              b.markRedraw()
            }
          },
          this,
        )
      var y = a.getRawValue(n)
      mr(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function (S, b) {
            return a.getFormattedLabel(S, b, e.dataType)
          },
        },
        inheritColor: m || '#000',
        defaultOpacity: v.opacity,
        defaultText: (y == null ? e.getName(n) : isFinite(y) ? mn(y) : y) + '',
      })
      var _ = this.getTextContent()
      if (_) {
        var x = c.normal
        ;(_.__align = _.style.align),
          (_.__verticalAlign = _.style.verticalAlign),
          (_.__position = x.get('position') || 'middle')
        var A = x.get('distance')
        at(A) || (A = [A, A]), (_.__labelDistance = A)
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1,
      }),
        fn(this, f, d, h)
    }),
    (t.prototype.highlight = function () {
      Qo(this)
    }),
    (t.prototype.downplay = function () {
      ts(this)
    }),
    (t.prototype.updateLayout = function (e, n) {
      this.setLinePoints(e.getItemLayout(n))
    }),
    (t.prototype.setLinePoints = function (e) {
      var n = this.childOfName('line')
      Hw(n.shape, e), n.dirty()
    }),
    (t.prototype.beforeUpdate = function () {
      var e = this,
        n = e.childOfName('fromSymbol'),
        i = e.childOfName('toSymbol'),
        a = e.getTextContent()
      if (!n && !i && (!a || a.ignore)) return
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), (s = s.parent)
      var l = e.childOfName('line')
      if (!this.__dirty && !l.__dirty) return
      var u = l.shape.percent,
        c = l.pointAt(0),
        h = l.pointAt(u),
        f = gu([], h, c)
      gf(f, f)
      function d(M, C) {
        var E = M.__specifiedRotation
        if (E == null) {
          var D = l.tangentAt(C)
          M.attr(
            'rotation',
            ((C === 1 ? -1 : 1) * Math.PI) / 2 - Math.atan2(D[1], D[0]),
          )
        } else M.attr('rotation', E)
      }
      if (
        (n &&
          (n.setPosition(c),
          d(n, 0),
          (n.scaleX = n.scaleY = o * u),
          n.markRedraw()),
        i &&
          (i.setPosition(h),
          d(i, 1),
          (i.scaleX = i.scaleY = o * u),
          i.markRedraw()),
        a && !a.ignore)
      ) {
        ;(a.x = a.y = 0), (a.originX = a.originY = 0)
        var p = void 0,
          g = void 0,
          v = a.__labelDistance,
          m = v[0] * o,
          y = v[1] * o,
          _ = u / 2,
          x = l.tangentAt(_),
          A = [x[1], -x[0]],
          S = l.pointAt(_)
        A[1] > 0 && ((A[0] = -A[0]), (A[1] = -A[1]))
        var b = x[0] < 0 ? -1 : 1
        if (a.__position !== 'start' && a.__position !== 'end') {
          var T = -Math.atan2(x[1], x[0])
          h[0] < c[0] && (T = Math.PI + T), (a.rotation = T)
        }
        var w = void 0
        switch (a.__position) {
          case 'insideStartTop':
          case 'insideMiddleTop':
          case 'insideEndTop':
          case 'middle':
            ;(w = -y), (g = 'bottom')
            break
          case 'insideStartBottom':
          case 'insideMiddleBottom':
          case 'insideEndBottom':
            ;(w = y), (g = 'top')
            break
          default:
            ;(w = 0), (g = 'middle')
        }
        switch (a.__position) {
          case 'end':
            ;(a.x = f[0] * m + h[0]),
              (a.y = f[1] * y + h[1]),
              (p = f[0] > 0.8 ? 'left' : f[0] < -0.8 ? 'right' : 'center'),
              (g = f[1] > 0.8 ? 'top' : f[1] < -0.8 ? 'bottom' : 'middle')
            break
          case 'start':
            ;(a.x = -f[0] * m + c[0]),
              (a.y = -f[1] * y + c[1]),
              (p = f[0] > 0.8 ? 'right' : f[0] < -0.8 ? 'left' : 'center'),
              (g = f[1] > 0.8 ? 'bottom' : f[1] < -0.8 ? 'top' : 'middle')
            break
          case 'insideStartTop':
          case 'insideStart':
          case 'insideStartBottom':
            ;(a.x = m * b + c[0]),
              (a.y = c[1] + w),
              (p = x[0] < 0 ? 'right' : 'left'),
              (a.originX = -m * b),
              (a.originY = -w)
            break
          case 'insideMiddleTop':
          case 'insideMiddle':
          case 'insideMiddleBottom':
          case 'middle':
            ;(a.x = S[0]), (a.y = S[1] + w), (p = 'center'), (a.originY = -w)
            break
          case 'insideEndTop':
          case 'insideEnd':
          case 'insideEndBottom':
            ;(a.x = -m * b + h[0]),
              (a.y = h[1] + w),
              (p = x[0] >= 0 ? 'right' : 'left'),
              (a.originX = m * b),
              (a.originY = -w)
            break
        }
        ;(a.scaleX = a.scaleY = o),
          a.setStyle({
            verticalAlign: a.__verticalAlign || g,
            align: a.__align || p,
          })
      }
    }),
    t
  )
})(Ht)
const JC = Hft
var Wft = (function () {
  function r(t) {
    ;(this.group = new Ht()), (this._LineCtor = t || JC)
  }
  return (
    (r.prototype.updateData = function (t) {
      var e = this
      this._progressiveEls = null
      var n = this,
        i = n.group,
        a = n._lineData
      ;(n._lineData = t), a || i.removeAll()
      var o = KO(t)
      t.diff(a)
        .add(function (s) {
          e._doAdd(t, s, o)
        })
        .update(function (s, l) {
          e._doUpdate(a, t, l, s, o)
        })
        .remove(function (s) {
          i.remove(a.getItemGraphicEl(s))
        })
        .execute()
    }),
    (r.prototype.updateLayout = function () {
      var t = this._lineData
      t &&
        t.eachItemGraphicEl(function (e, n) {
          e.updateLayout(t, n)
        }, this)
    }),
    (r.prototype.incrementalPrepareUpdate = function (t) {
      ;(this._seriesScope = KO(t)),
        (this._lineData = null),
        this.group.removeAll()
    }),
    (r.prototype.incrementalUpdate = function (t, e) {
      this._progressiveEls = []
      function n(s) {
        !s.isGroup &&
          !Xft(s) &&
          ((s.incremental = !0), (s.ensureState('emphasis').hoverLayer = !0))
      }
      for (var i = t.start; i < t.end; i++) {
        var a = e.getItemLayout(i)
        if (AS(a)) {
          var o = new this._LineCtor(e, i, this._seriesScope)
          o.traverse(n),
            this.group.add(o),
            e.setItemGraphicEl(i, o),
            this._progressiveEls.push(o)
        }
      }
    }),
    (r.prototype.remove = function () {
      this.group.removeAll()
    }),
    (r.prototype.eachRendered = function (t) {
      vl(this._progressiveEls || this.group, t)
    }),
    (r.prototype._doAdd = function (t, e, n) {
      var i = t.getItemLayout(e)
      if (AS(i)) {
        var a = new this._LineCtor(t, e, n)
        t.setItemGraphicEl(e, a), this.group.add(a)
      }
    }),
    (r.prototype._doUpdate = function (t, e, n, i, a) {
      var o = t.getItemGraphicEl(n)
      if (!AS(e.getItemLayout(i))) {
        this.group.remove(o)
        return
      }
      o ? o.updateData(e, i, a) : (o = new this._LineCtor(e, i, a)),
        e.setItemGraphicEl(i, o),
        this.group.add(o)
    }),
    r
  )
})()
function Xft(r) {
  return r.animators && r.animators.length > 0
}
function KO(r) {
  var t = r.hostModel,
    e = t.getModel('emphasis')
  return {
    lineStyle: t.getModel('lineStyle').getLineStyle(),
    emphasisLineStyle: e.getModel(['lineStyle']).getLineStyle(),
    blurLineStyle: t.getModel(['blur', 'lineStyle']).getLineStyle(),
    selectLineStyle: t.getModel(['select', 'lineStyle']).getLineStyle(),
    emphasisDisabled: e.get('disabled'),
    blurScope: e.get('blurScope'),
    focus: e.get('focus'),
    labelStatesModels: Zn(t),
  }
}
function jO(r) {
  return isNaN(r[0]) || isNaN(r[1])
}
function AS(r) {
  return r && !jO(r[0]) && !jO(r[1])
}
const QC = Wft
var bS = [],
  wS = [],
  MS = [],
  Jc = tr,
  TS = Lu,
  JO = Math.abs
function QO(r, t, e) {
  for (
    var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = e * e, u = 0.1, c = 0.1;
    c <= 0.9;
    c += 0.1
  ) {
    ;(bS[0] = Jc(n[0], i[0], a[0], c)), (bS[1] = Jc(n[1], i[1], a[1], c))
    var h = JO(TS(bS, t) - l)
    h < o && ((o = h), (s = c))
  }
  for (var f = 0; f < 32; f++) {
    var d = s + u
    ;(wS[0] = Jc(n[0], i[0], a[0], s)),
      (wS[1] = Jc(n[1], i[1], a[1], s)),
      (MS[0] = Jc(n[0], i[0], a[0], d)),
      (MS[1] = Jc(n[1], i[1], a[1], d))
    var h = TS(wS, t) - l
    if (JO(h) < 0.01) break
    var p = TS(MS, t) - l
    ;(u /= 2),
      h < 0
        ? p >= 0
          ? (s = s + u)
          : (s = s - u)
        : p >= 0
        ? (s = s - u)
        : (s = s + u)
  }
  return s
}
function CS(r, t) {
  var e = [],
    n = Bp,
    i = [[], [], []],
    a = [[], []],
    o = []
  ;(t /= 2),
    r.eachEdge(function (s, l) {
      var u = s.getLayout(),
        c = s.getVisual('fromSymbol'),
        h = s.getVisual('toSymbol')
      u.__original ||
        ((u.__original = [Go(u[0]), Go(u[1])]),
        u[2] && u.__original.push(Go(u[2])))
      var f = u.__original
      if (u[2] != null) {
        if (
          (Nr(i[0], f[0]), Nr(i[1], f[2]), Nr(i[2], f[1]), c && c !== 'none')
        ) {
          var d = Xd(s.node1),
            p = QO(i, f[0], d * t)
          n(i[0][0], i[1][0], i[2][0], p, e),
            (i[0][0] = e[3]),
            (i[1][0] = e[4]),
            n(i[0][1], i[1][1], i[2][1], p, e),
            (i[0][1] = e[3]),
            (i[1][1] = e[4])
        }
        if (h && h !== 'none') {
          var d = Xd(s.node2),
            p = QO(i, f[1], d * t)
          n(i[0][0], i[1][0], i[2][0], p, e),
            (i[1][0] = e[1]),
            (i[2][0] = e[2]),
            n(i[0][1], i[1][1], i[2][1], p, e),
            (i[1][1] = e[1]),
            (i[2][1] = e[2])
        }
        Nr(u[0], i[0]), Nr(u[1], i[2]), Nr(u[2], i[1])
      } else {
        if (
          (Nr(a[0], f[0]),
          Nr(a[1], f[1]),
          gu(o, a[1], a[0]),
          gf(o, o),
          c && c !== 'none')
        ) {
          var d = Xd(s.node1)
          Eb(a[0], a[0], o, d * t)
        }
        if (h && h !== 'none') {
          var d = Xd(s.node2)
          Eb(a[1], a[1], o, -d * t)
        }
        Nr(u[0], a[0]), Nr(u[1], a[1])
      }
    })
}
function tN(r) {
  return r.type === 'view'
}
var Yft = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n) {
      var i = new Cv(),
        a = new QC(),
        o = this.group
      ;(this._controller = new Rv(n.getZr())),
        (this._controllerHost = {
          target: o,
        }),
        o.add(i.group),
        o.add(a.group),
        (this._symbolDraw = i),
        (this._lineDraw = a),
        (this._firstRender = !0)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = this,
        o = e.coordinateSystem
      this._model = e
      var s = this._symbolDraw,
        l = this._lineDraw,
        u = this.group
      if (tN(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY,
        }
        this._firstRender ? u.attr(c) : we(u, c, e)
      }
      CS(e.getGraph(), Wd(e))
      var h = e.getData()
      s.updateData(h)
      var f = e.getEdgeData()
      l.updateData(f),
        this._updateNodeAndLinkScale(),
        this._updateController(e, n, i),
        clearTimeout(this._layoutTimeout)
      var d = e.forceLayout,
        p = e.get(['force', 'layoutAnimation'])
      d && this._startForceLayoutIteration(d, p)
      var g = e.get('layout')
      h.graph.eachNode(function (_) {
        var x = _.dataIndex,
          A = _.getGraphicEl(),
          S = _.getModel()
        if (A) {
          A.off('drag').off('dragend')
          var b = S.get('draggable')
          b &&
            A.on('drag', function (w) {
              switch (g) {
                case 'force':
                  d.warmUp(),
                    !a._layouting && a._startForceLayoutIteration(d, p),
                    d.setFixed(x),
                    h.setItemLayout(x, [A.x, A.y])
                  break
                case 'circular':
                  h.setItemLayout(x, [A.x, A.y]),
                    _.setLayout(
                      {
                        fixed: !0,
                      },
                      !0,
                    ),
                    jC(e, 'symbolSize', _, [w.offsetX, w.offsetY]),
                    a.updateLayout(e)
                  break
                case 'none':
                default:
                  h.setItemLayout(x, [A.x, A.y]),
                    KC(e.getGraph(), e),
                    a.updateLayout(e)
                  break
              }
            }).on('dragend', function () {
              d && d.setUnfixed(x)
            }),
            A.setDraggable(b, !!S.get('cursor'))
          var T = S.get(['emphasis', 'focus'])
          T === 'adjacency' && (Wt(A).focus = _.getAdjacentDataIndices())
        }
      }),
        h.graph.eachEdge(function (_) {
          var x = _.getGraphicEl(),
            A = _.getModel().get(['emphasis', 'focus'])
          x &&
            A === 'adjacency' &&
            (Wt(x).focus = {
              edge: [_.dataIndex],
              node: [_.node1.dataIndex, _.node2.dataIndex],
            })
        })
      var v =
          e.get('layout') === 'circular' && e.get(['circular', 'rotateLabel']),
        m = h.getLayout('cx'),
        y = h.getLayout('cy')
      h.graph.eachNode(function (_) {
        y4(_, v, m, y)
      }),
        (this._firstRender = !1)
    }),
    (t.prototype.dispose = function () {
      this.remove(),
        this._controller && this._controller.dispose(),
        (this._controllerHost = null)
    }),
    (t.prototype._startForceLayoutIteration = function (e, n) {
      var i = this
      ;(function a() {
        e.step(function (o) {
          i.updateLayout(i._model),
            (i._layouting = !o) &&
              (n ? (i._layoutTimeout = setTimeout(a, 16)) : a())
        })
      })()
    }),
    (t.prototype._updateController = function (e, n, i) {
      var a = this,
        o = this._controller,
        s = this._controllerHost,
        l = this.group
      if (
        (o.setPointerChecker(function (u, c, h) {
          var f = l.getBoundingRect()
          return f.applyTransform(l.transform), f.contain(c, h) && !T_(u, i, e)
        }),
        !tN(e.coordinateSystem))
      ) {
        o.disable()
        return
      }
      o.enable(e.get('roam')),
        (s.zoomLimit = e.get('scaleLimit')),
        (s.zoom = e.coordinateSystem.getZoom()),
        o
          .off('pan')
          .off('zoom')
          .on('pan', function (u) {
            UC(s, u.dx, u.dy),
              i.dispatchAction({
                seriesId: e.id,
                type: 'graphRoam',
                dx: u.dx,
                dy: u.dy,
              })
          })
          .on('zoom', function (u) {
            VC(s, u.scale, u.originX, u.originY),
              i.dispatchAction({
                seriesId: e.id,
                type: 'graphRoam',
                zoom: u.scale,
                originX: u.originX,
                originY: u.originY,
              }),
              a._updateNodeAndLinkScale(),
              CS(e.getGraph(), Wd(e)),
              a._lineDraw.updateLayout(),
              i.updateLabelLayout()
          })
    }),
    (t.prototype._updateNodeAndLinkScale = function () {
      var e = this._model,
        n = e.getData(),
        i = Wd(e)
      n.eachItemGraphicEl(function (a, o) {
        a && a.setSymbolScale(i)
      })
    }),
    (t.prototype.updateLayout = function (e) {
      CS(e.getGraph(), Wd(e)),
        this._symbolDraw.updateLayout(),
        this._lineDraw.updateLayout()
    }),
    (t.prototype.remove = function () {
      clearTimeout(this._layoutTimeout),
        (this._layouting = !1),
        (this._layoutTimeout = null),
        this._symbolDraw && this._symbolDraw.remove(),
        this._lineDraw && this._lineDraw.remove()
    }),
    (t.type = 'graph'),
    t
  )
})(Ze)
const $ft = Yft
function Qc(r) {
  return '_EC_' + r
}
var qft = (function () {
    function r(t) {
      ;(this.type = 'graph'),
        (this.nodes = []),
        (this.edges = []),
        (this._nodesMap = {}),
        (this._edgesMap = {}),
        (this._directed = t || !1)
    }
    return (
      (r.prototype.isDirected = function () {
        return this._directed
      }),
      (r.prototype.addNode = function (t, e) {
        t = t == null ? '' + e : '' + t
        var n = this._nodesMap
        if (!n[Qc(t)]) {
          var i = new su(t, e)
          return (i.hostGraph = this), this.nodes.push(i), (n[Qc(t)] = i), i
        }
      }),
      (r.prototype.getNodeByIndex = function (t) {
        var e = this.data.getRawIndex(t)
        return this.nodes[e]
      }),
      (r.prototype.getNodeById = function (t) {
        return this._nodesMap[Qc(t)]
      }),
      (r.prototype.addEdge = function (t, e, n) {
        var i = this._nodesMap,
          a = this._edgesMap
        if (
          (be(t) && (t = this.nodes[t]),
          be(e) && (e = this.nodes[e]),
          t instanceof su || (t = i[Qc(t)]),
          e instanceof su || (e = i[Qc(e)]),
          !(!t || !e))
        ) {
          var o = t.id + '-' + e.id,
            s = new x4(t, e, n)
          return (
            (s.hostGraph = this),
            this._directed && (t.outEdges.push(s), e.inEdges.push(s)),
            t.edges.push(s),
            t !== e && e.edges.push(s),
            this.edges.push(s),
            (a[o] = s),
            s
          )
        }
      }),
      (r.prototype.getEdgeByIndex = function (t) {
        var e = this.edgeData.getRawIndex(t)
        return this.edges[e]
      }),
      (r.prototype.getEdge = function (t, e) {
        t instanceof su && (t = t.id), e instanceof su && (e = e.id)
        var n = this._edgesMap
        return this._directed
          ? n[t + '-' + e]
          : n[t + '-' + e] || n[e + '-' + t]
      }),
      (r.prototype.eachNode = function (t, e) {
        for (var n = this.nodes, i = n.length, a = 0; a < i; a++)
          n[a].dataIndex >= 0 && t.call(e, n[a], a)
      }),
      (r.prototype.eachEdge = function (t, e) {
        for (var n = this.edges, i = n.length, a = 0; a < i; a++)
          n[a].dataIndex >= 0 &&
            n[a].node1.dataIndex >= 0 &&
            n[a].node2.dataIndex >= 0 &&
            t.call(e, n[a], a)
      }),
      (r.prototype.breadthFirstTraverse = function (t, e, n, i) {
        if ((e instanceof su || (e = this._nodesMap[Qc(e)]), !!e)) {
          for (
            var a = n === 'out' ? 'outEdges' : n === 'in' ? 'inEdges' : 'edges',
              o = 0;
            o < this.nodes.length;
            o++
          )
            this.nodes[o].__visited = !1
          if (!t.call(i, e, null))
            for (var s = [e]; s.length; )
              for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
                var c = u[o],
                  h = c.node1 === l ? c.node2 : c.node1
                if (!h.__visited) {
                  if (t.call(i, h, l)) return
                  s.push(h), (h.__visited = !0)
                }
              }
        }
      }),
      (r.prototype.update = function () {
        for (
          var t = this.data,
            e = this.edgeData,
            n = this.nodes,
            i = this.edges,
            a = 0,
            o = n.length;
          a < o;
          a++
        )
          n[a].dataIndex = -1
        for (var a = 0, o = t.count(); a < o; a++)
          n[t.getRawIndex(a)].dataIndex = a
        e.filterSelf(function (s) {
          var l = i[e.getRawIndex(s)]
          return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0
        })
        for (var a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1
        for (var a = 0, o = e.count(); a < o; a++)
          i[e.getRawIndex(a)].dataIndex = a
      }),
      (r.prototype.clone = function () {
        for (
          var t = new r(this._directed), e = this.nodes, n = this.edges, i = 0;
          i < e.length;
          i++
        )
          t.addNode(e[i].id, e[i].dataIndex)
        for (var i = 0; i < n.length; i++) {
          var a = n[i]
          t.addEdge(a.node1.id, a.node2.id, a.dataIndex)
        }
        return t
      }),
      r
    )
  })(),
  su = (function () {
    function r(t, e) {
      ;(this.inEdges = []),
        (this.outEdges = []),
        (this.edges = []),
        (this.dataIndex = -1),
        (this.id = t ?? ''),
        (this.dataIndex = e ?? -1)
    }
    return (
      (r.prototype.degree = function () {
        return this.edges.length
      }),
      (r.prototype.inDegree = function () {
        return this.inEdges.length
      }),
      (r.prototype.outDegree = function () {
        return this.outEdges.length
      }),
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostGraph,
            n = e.data.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getAdjacentDataIndices = function () {
        for (
          var t = {
              edge: [],
              node: [],
            },
            e = 0;
          e < this.edges.length;
          e++
        ) {
          var n = this.edges[e]
          n.dataIndex < 0 ||
            (t.edge.push(n.dataIndex),
            t.node.push(n.node1.dataIndex, n.node2.dataIndex))
        }
        return t
      }),
      (r.prototype.getTrajectoryDataIndices = function () {
        for (var t = Pt(), e = Pt(), n = 0; n < this.edges.length; n++) {
          var i = this.edges[n]
          if (!(i.dataIndex < 0)) {
            t.set(i.dataIndex, !0)
            for (var a = [i.node1], o = [i.node2], s = 0; s < a.length; ) {
              var l = a[s]
              s++, e.set(l.dataIndex, !0)
              for (var u = 0; u < l.inEdges.length; u++)
                t.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1)
            }
            for (s = 0; s < o.length; ) {
              var c = o[s]
              s++, e.set(c.dataIndex, !0)
              for (var u = 0; u < c.outEdges.length; u++)
                t.set(c.outEdges[u].dataIndex, !0), o.push(c.outEdges[u].node2)
            }
          }
        }
        return {
          edge: t.keys(),
          node: e.keys(),
        }
      }),
      r
    )
  })(),
  x4 = (function () {
    function r(t, e, n) {
      ;(this.dataIndex = -1),
        (this.node1 = t),
        (this.node2 = e),
        (this.dataIndex = n ?? -1)
    }
    return (
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostGraph,
            n = e.edgeData.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getAdjacentDataIndices = function () {
        return {
          edge: [this.dataIndex],
          node: [this.node1.dataIndex, this.node2.dataIndex],
        }
      }),
      (r.prototype.getTrajectoryDataIndices = function () {
        var t = Pt(),
          e = Pt()
        t.set(this.dataIndex, !0)
        for (var n = [this.node1], i = [this.node2], a = 0; a < n.length; ) {
          var o = n[a]
          a++, e.set(o.dataIndex, !0)
          for (var s = 0; s < o.inEdges.length; s++)
            t.set(o.inEdges[s].dataIndex, !0), n.push(o.inEdges[s].node1)
        }
        for (a = 0; a < i.length; ) {
          var l = i[a]
          a++, e.set(l.dataIndex, !0)
          for (var s = 0; s < l.outEdges.length; s++)
            t.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2)
        }
        return {
          edge: t.keys(),
          node: e.keys(),
        }
      }),
      r
    )
  })()
function S4(r, t) {
  return {
    getValue: function (e) {
      var n = this[r][t]
      return n.getStore().get(n.getDimensionIndex(e || 'value'), this.dataIndex)
    },
    setVisual: function (e, n) {
      this.dataIndex >= 0 && this[r][t].setItemVisual(this.dataIndex, e, n)
    },
    getVisual: function (e) {
      return this[r][t].getItemVisual(this.dataIndex, e)
    },
    setLayout: function (e, n) {
      this.dataIndex >= 0 && this[r][t].setItemLayout(this.dataIndex, e, n)
    },
    getLayout: function () {
      return this[r][t].getItemLayout(this.dataIndex)
    },
    getGraphicEl: function () {
      return this[r][t].getItemGraphicEl(this.dataIndex)
    },
    getRawIndex: function () {
      return this[r][t].getRawIndex(this.dataIndex)
    },
  }
}
In(su, S4('hostGraph', 'data'))
In(x4, S4('hostGraph', 'edgeData'))
const Zft = qft
function A4(r, t, e, n, i) {
  for (var a = new Zft(n), o = 0; o < r.length; o++)
    a.addNode(nr(r[o].id, r[o].name, o), o)
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o],
      h = c.source,
      f = c.target
    a.addEdge(h, f, u) &&
      (l.push(c), s.push(nr(Un(c.id, null), h + ' > ' + f)), u++)
  }
  var d = e.get('coordinateSystem'),
    p
  if (d === 'cartesian2d' || d === 'polar') p = as(r, e)
  else {
    var g = Av.get(d),
      v = g ? g.dimensions || [] : []
    re(v, 'value') < 0 && v.concat(['value'])
    var m = wv(r, {
      coordDimensions: v,
      encodeDefine: e.getEncode(),
    }).dimensions
    ;(p = new Vr(m, e)), p.initData(r)
  }
  var y = new Vr(['value'], e)
  return (
    y.initData(l, s),
    i && i(p, y),
    r4({
      mainData: p,
      struct: a,
      structAttr: 'graph',
      datas: {
        node: p,
        edge: y,
      },
      datasAttr: {
        node: 'data',
        edge: 'edgeData',
      },
    }),
    a.update(),
    a
  )
}
var Kft = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments)
      var n = this
      function i() {
        return n._categoriesData
      }
      ;(this.legendVisualProvider = new Pv(i, i)),
        this.fillDataTextStyle(e.edges || e.links),
        this._updateCategoriesData()
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments),
        this.fillDataTextStyle(e.edges || e.links),
        this._updateCategoriesData()
    }),
    (t.prototype.mergeDefaultAndTheme = function (e) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments),
        Xu(e, 'edgeLabel', ['show'])
    }),
    (t.prototype.getInitialData = function (e, n) {
      var i = e.edges || e.links || [],
        a = e.data || e.nodes || [],
        o = this
      if (a && i) {
        Pft(this)
        var s = A4(a, i, this, !0, l)
        return (
          R(
            s.edges,
            function (u) {
              Rft(u.node1, u.node2, this, u.dataIndex)
            },
            this,
          ),
          s.data
        )
      }
      function l(u, c) {
        u.wrapMethod('getItemModel', function (p) {
          var g = o._categoriesModels,
            v = p.getShallow('category'),
            m = g[v]
          return m && ((m.parentModel = p.parentModel), (p.parentModel = m)), p
        })
        var h = qe.prototype.getModel
        function f(p, g) {
          var v = h.call(this, p, g)
          return (v.resolveParentPath = d), v
        }
        c.wrapMethod('getItemModel', function (p) {
          return (p.resolveParentPath = d), (p.getModel = f), p
        })
        function d(p) {
          if (p && (p[0] === 'label' || p[1] === 'label')) {
            var g = p.slice()
            return (
              p[0] === 'label'
                ? (g[0] = 'edgeLabel')
                : p[1] === 'label' && (g[1] = 'edgeLabel'),
              g
            )
          }
          return p
        }
      }
    }),
    (t.prototype.getGraph = function () {
      return this.getData().graph
    }),
    (t.prototype.getEdgeData = function () {
      return this.getGraph().edgeData
    }),
    (t.prototype.getCategoriesData = function () {
      return this._categoriesData
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      if (i === 'edge') {
        var a = this.getData(),
          o = this.getDataParams(e, i),
          s = a.graph.getEdgeByIndex(e),
          l = a.getName(s.node1.dataIndex),
          u = a.getName(s.node2.dataIndex),
          c = []
        return (
          l != null && c.push(l),
          u != null && c.push(u),
          Kn('nameValue', {
            name: c.join(' > '),
            value: o.value,
            noValue: o.value == null,
          })
        )
      }
      var h = U5({
        series: this,
        dataIndex: e,
        multipleSeries: n,
      })
      return h
    }),
    (t.prototype._updateCategoriesData = function () {
      var e = st(this.option.categories || [], function (i) {
          return i.value != null
            ? i
            : Q(
                {
                  value: 0,
                },
                i,
              )
        }),
        n = new Vr(['value'], this)
      n.initData(e),
        (this._categoriesData = n),
        (this._categoriesModels = n.mapArray(function (i) {
          return n.getItemModel(i)
        }))
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.isAnimationEnabled = function () {
      return (
        r.prototype.isAnimationEnabled.call(this) &&
        !(
          this.get('layout') === 'force' &&
          this.get(['force', 'layoutAnimation'])
        )
      )
    }),
    (t.type = 'series.graph'),
    (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      legendHoverLink: !0,
      layout: null,
      circular: {
        rotateLabel: !1,
      },
      force: {
        initLayout: null,
        repulsion: [0, 50],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: !0,
      },
      left: 'center',
      top: 'center',
      symbol: 'circle',
      symbolSize: 10,
      edgeSymbol: ['none', 'none'],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: 'middle',
        distance: 5,
      },
      draggable: !1,
      roam: !1,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: !1,
        formatter: '{b}',
      },
      itemStyle: {},
      lineStyle: {
        color: '#aaa',
        width: 1,
        opacity: 0.5,
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const jft = Kft
var Jft = {
  type: 'graphRoam',
  event: 'graphRoam',
  update: 'none',
}
function Qft(r) {
  r.registerChartView($ft),
    r.registerSeriesModel(jft),
    r.registerProcessor(Tft),
    r.registerVisual(Cft),
    r.registerVisual(Eft),
    r.registerLayout(Ift),
    r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, Nft),
    r.registerLayout(Bft),
    r.registerCoordinateSystem('graphView', {
      dimensions: Iv.dimensions,
      create: zft,
    }),
    r.registerAction(
      {
        type: 'focusNodeAdjacency',
        event: 'focusNodeAdjacency',
        update: 'series:focusNodeAdjacency',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'unfocusNodeAdjacency',
        event: 'unfocusNodeAdjacency',
        update: 'series:unfocusNodeAdjacency',
      },
      wn,
    ),
    r.registerAction(Jft, function (t, e, n) {
      e.eachComponent(
        {
          mainType: 'series',
          query: t,
        },
        function (i) {
          var a = i.coordinateSystem,
            o = HC(a, t, void 0, n)
          i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
        },
      )
    })
}
var tdt = (function () {
    function r() {
      ;(this.angle = 0),
        (this.width = 10),
        (this.r = 10),
        (this.x = 0),
        (this.y = 0)
    }
    return r
  })(),
  edt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'pointer'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new tdt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = Math.cos,
          a = Math.sin,
          o = n.r,
          s = n.width,
          l = n.angle,
          u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2),
          c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2)
        ;(l = n.angle - Math.PI / 2),
          e.moveTo(u, c),
          e.lineTo(n.x + i(l) * s, n.y + a(l) * s),
          e.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o),
          e.lineTo(n.x - i(l) * s, n.y - a(l) * s),
          e.lineTo(u, c)
      }),
      t
    )
  })(oe)
const ndt = edt
function rdt(r, t) {
  var e = r.get('center'),
    n = t.getWidth(),
    i = t.getHeight(),
    a = Math.min(n, i),
    o = _t(e[0], t.getWidth()),
    s = _t(e[1], t.getHeight()),
    l = _t(r.get('radius'), a / 2)
  return {
    cx: o,
    cy: s,
    r: l,
  }
}
function _m(r, t) {
  var e = r == null ? '' : r + ''
  return t && (bt(t) ? (e = t.replace('{value}', e)) : Nt(t) && (e = t(r))), e
}
var idt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      this.group.removeAll()
      var a = e.get(['axisLine', 'lineStyle', 'color']),
        o = rdt(e, i)
      this._renderMain(e, n, i, a, o), (this._data = e.getData())
    }),
    (t.prototype.dispose = function () {}),
    (t.prototype._renderMain = function (e, n, i, a, o) {
      var s = this.group,
        l = e.get('clockwise'),
        u = (-e.get('startAngle') / 180) * Math.PI,
        c = (-e.get('endAngle') / 180) * Math.PI,
        h = e.getModel('axisLine'),
        f = h.get('roundCap'),
        d = f ? h0 : oi,
        p = h.get('show'),
        g = h.getModel('lineStyle'),
        v = g.get('width'),
        m = [u, c]
      HT(m, !l), (u = m[0]), (c = m[1])
      for (var y = c - u, _ = u, x = [], A = 0; p && A < a.length; A++) {
        var S = Math.min(Math.max(a[A][0], 0), 1)
        c = u + y * S
        var b = new d({
          shape: {
            startAngle: _,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r,
          },
          silent: !0,
        })
        b.setStyle({
          fill: a[A][1],
        }),
          b.setStyle(g.getLineStyle(['color', 'width'])),
          x.push(b),
          (_ = c)
      }
      x.reverse(),
        R(x, function (w) {
          return s.add(w)
        })
      var T = function (w) {
        if (w <= 0) return a[0][1]
        var M
        for (M = 0; M < a.length; M++)
          if (a[M][0] >= w && (M === 0 ? 0 : a[M - 1][0]) < w) return a[M][1]
        return a[M - 1][1]
      }
      this._renderTicks(e, n, i, T, o, u, c, l, v),
        this._renderTitleAndDetail(e, n, i, T, o),
        this._renderAnchor(e, o),
        this._renderPointer(e, n, i, T, o, u, c, l, v)
    }),
    (t.prototype._renderTicks = function (e, n, i, a, o, s, l, u, c) {
      for (
        var h = this.group,
          f = o.cx,
          d = o.cy,
          p = o.r,
          g = +e.get('min'),
          v = +e.get('max'),
          m = e.getModel('splitLine'),
          y = e.getModel('axisTick'),
          _ = e.getModel('axisLabel'),
          x = e.get('splitNumber'),
          A = y.get('splitNumber'),
          S = _t(m.get('length'), p),
          b = _t(y.get('length'), p),
          T = s,
          w = (l - s) / x,
          M = w / A,
          C = m.getModel('lineStyle').getLineStyle(),
          E = y.getModel('lineStyle').getLineStyle(),
          D = m.get('distance'),
          P,
          L,
          I = 0;
        I <= x;
        I++
      ) {
        if (((P = Math.cos(T)), (L = Math.sin(T)), m.get('show'))) {
          var F = D ? D + c : c,
            k = new rr({
              shape: {
                x1: P * (p - F) + f,
                y1: L * (p - F) + d,
                x2: P * (p - S - F) + f,
                y2: L * (p - S - F) + d,
              },
              style: C,
              silent: !0,
            })
          C.stroke === 'auto' &&
            k.setStyle({
              stroke: a(I / x),
            }),
            h.add(k)
        }
        if (_.get('show')) {
          var F = _.get('distance') + D,
            V = _m(mn((I / x) * (v - g) + g), _.get('formatter')),
            H = a(I / x),
            Y = P * (p - S - F) + f,
            K = L * (p - S - F) + d,
            ut = _.get('rotate'),
            W = 0
          ut === 'radial'
            ? ((W = -T + 2 * Math.PI), W > Math.PI / 2 && (W += Math.PI))
            : ut === 'tangential'
            ? (W = -T - Math.PI / 2)
            : be(ut) && (W = (ut * Math.PI) / 180),
            W === 0
              ? h.add(
                  new Ae({
                    style: $e(
                      _,
                      {
                        text: V,
                        x: Y,
                        y: K,
                        verticalAlign:
                          L < -0.8 ? 'top' : L > 0.8 ? 'bottom' : 'middle',
                        align: P < -0.4 ? 'left' : P > 0.4 ? 'right' : 'center',
                      },
                      {
                        inheritColor: H,
                      },
                    ),
                    silent: !0,
                  }),
                )
              : h.add(
                  new Ae({
                    style: $e(
                      _,
                      {
                        text: V,
                        x: Y,
                        y: K,
                        verticalAlign: 'middle',
                        align: 'center',
                      },
                      {
                        inheritColor: H,
                      },
                    ),
                    silent: !0,
                    originX: Y,
                    originY: K,
                    rotation: W,
                  }),
                )
        }
        if (y.get('show') && I !== x) {
          var F = y.get('distance')
          F = F ? F + c : c
          for (var Z = 0; Z <= A; Z++) {
            ;(P = Math.cos(T)), (L = Math.sin(T))
            var ft = new rr({
              shape: {
                x1: P * (p - F) + f,
                y1: L * (p - F) + d,
                x2: P * (p - b - F) + f,
                y2: L * (p - b - F) + d,
              },
              silent: !0,
              style: E,
            })
            E.stroke === 'auto' &&
              ft.setStyle({
                stroke: a((I + Z / A) / x),
              }),
              h.add(ft),
              (T += M)
          }
          T -= M
        } else T += w
      }
    }),
    (t.prototype._renderPointer = function (e, n, i, a, o, s, l, u, c) {
      var h = this.group,
        f = this._data,
        d = this._progressEls,
        p = [],
        g = e.get(['pointer', 'show']),
        v = e.getModel('progress'),
        m = v.get('show'),
        y = e.getData(),
        _ = y.mapDimension('value'),
        x = +e.get('min'),
        A = +e.get('max'),
        S = [x, A],
        b = [s, l]
      function T(M, C) {
        var E = y.getItemModel(M),
          D = E.getModel('pointer'),
          P = _t(D.get('width'), o.r),
          L = _t(D.get('length'), o.r),
          I = e.get(['pointer', 'icon']),
          F = D.get('offsetCenter'),
          k = _t(F[0], o.r),
          V = _t(F[1], o.r),
          H = D.get('keepAspect'),
          Y
        return (
          I
            ? (Y = Rn(I, k - P / 2, V - L, P, L, null, H))
            : (Y = new ndt({
                shape: {
                  angle: -Math.PI / 2,
                  width: P,
                  r: L,
                  x: k,
                  y: V,
                },
              })),
          (Y.rotation = -(C + Math.PI / 2)),
          (Y.x = o.cx),
          (Y.y = o.cy),
          Y
        )
      }
      function w(M, C) {
        var E = v.get('roundCap'),
          D = E ? h0 : oi,
          P = v.get('overlap'),
          L = P ? v.get('width') : c / y.count(),
          I = P ? o.r - L : o.r - (M + 1) * L,
          F = P ? o.r : o.r - M * L,
          k = new D({
            shape: {
              startAngle: s,
              endAngle: C,
              cx: o.cx,
              cy: o.cy,
              clockwise: u,
              r0: I,
              r: F,
            },
          })
        return P && (k.z2 = A - (y.get(_, M) % A)), k
      }
      ;(m || g) &&
        (y
          .diff(f)
          .add(function (M) {
            var C = y.get(_, M)
            if (g) {
              var E = T(M, s)
              Je(
                E,
                {
                  rotation: -(
                    (isNaN(+C) ? b[0] : Re(C, S, b, !0)) +
                    Math.PI / 2
                  ),
                },
                e,
              ),
                h.add(E),
                y.setItemGraphicEl(M, E)
            }
            if (m) {
              var D = w(M, s),
                P = v.get('clip')
              Je(
                D,
                {
                  shape: {
                    endAngle: Re(C, S, b, P),
                  },
                },
                e,
              ),
                h.add(D),
                ew(e.seriesIndex, y.dataType, M, D),
                (p[M] = D)
            }
          })
          .update(function (M, C) {
            var E = y.get(_, M)
            if (g) {
              var D = f.getItemGraphicEl(C),
                P = D ? D.rotation : s,
                L = T(M, P)
              ;(L.rotation = P),
                we(
                  L,
                  {
                    rotation: -(
                      (isNaN(+E) ? b[0] : Re(E, S, b, !0)) +
                      Math.PI / 2
                    ),
                  },
                  e,
                ),
                h.add(L),
                y.setItemGraphicEl(M, L)
            }
            if (m) {
              var I = d[C],
                F = I ? I.shape.endAngle : s,
                k = w(M, F),
                V = v.get('clip')
              we(
                k,
                {
                  shape: {
                    endAngle: Re(E, S, b, V),
                  },
                },
                e,
              ),
                h.add(k),
                ew(e.seriesIndex, y.dataType, M, k),
                (p[M] = k)
            }
          })
          .execute(),
        y.each(function (M) {
          var C = y.getItemModel(M),
            E = C.getModel('emphasis'),
            D = E.get('focus'),
            P = E.get('blurScope'),
            L = E.get('disabled')
          if (g) {
            var I = y.getItemGraphicEl(M),
              F = y.getItemVisual(M, 'style'),
              k = F.fill
            if (I instanceof yr) {
              var V = I.style
              I.useStyle(
                Q(
                  {
                    image: V.image,
                    x: V.x,
                    y: V.y,
                    width: V.width,
                    height: V.height,
                  },
                  F,
                ),
              )
            } else I.useStyle(F), I.type !== 'pointer' && I.setColor(k)
            I.setStyle(C.getModel(['pointer', 'itemStyle']).getItemStyle()),
              I.style.fill === 'auto' &&
                I.setStyle('fill', a(Re(y.get(_, M), S, [0, 1], !0))),
              (I.z2EmphasisLift = 0),
              gr(I, C),
              fn(I, D, P, L)
          }
          if (m) {
            var H = p[M]
            H.useStyle(y.getItemVisual(M, 'style')),
              H.setStyle(C.getModel(['progress', 'itemStyle']).getItemStyle()),
              (H.z2EmphasisLift = 0),
              gr(H, C),
              fn(H, D, P, L)
          }
        }),
        (this._progressEls = p))
    }),
    (t.prototype._renderAnchor = function (e, n) {
      var i = e.getModel('anchor'),
        a = i.get('show')
      if (a) {
        var o = i.get('size'),
          s = i.get('icon'),
          l = i.get('offsetCenter'),
          u = i.get('keepAspect'),
          c = Rn(
            s,
            n.cx - o / 2 + _t(l[0], n.r),
            n.cy - o / 2 + _t(l[1], n.r),
            o,
            o,
            null,
            u,
          )
        ;(c.z2 = i.get('showAbove') ? 1 : 0),
          c.setStyle(i.getModel('itemStyle').getItemStyle()),
          this.group.add(c)
      }
    }),
    (t.prototype._renderTitleAndDetail = function (e, n, i, a, o) {
      var s = this,
        l = e.getData(),
        u = l.mapDimension('value'),
        c = +e.get('min'),
        h = +e.get('max'),
        f = new Ht(),
        d = [],
        p = [],
        g = e.isAnimationEnabled(),
        v = e.get(['pointer', 'showAbove'])
      l
        .diff(this._data)
        .add(function (m) {
          ;(d[m] = new Ae({
            silent: !0,
          })),
            (p[m] = new Ae({
              silent: !0,
            }))
        })
        .update(function (m, y) {
          ;(d[m] = s._titleEls[y]), (p[m] = s._detailEls[y])
        })
        .execute(),
        l.each(function (m) {
          var y = l.getItemModel(m),
            _ = l.get(u, m),
            x = new Ht(),
            A = a(Re(_, [c, h], [0, 1], !0)),
            S = y.getModel('title')
          if (S.get('show')) {
            var b = S.get('offsetCenter'),
              T = o.cx + _t(b[0], o.r),
              w = o.cy + _t(b[1], o.r),
              M = d[m]
            M.attr({
              z2: v ? 0 : 2,
              style: $e(
                S,
                {
                  x: T,
                  y: w,
                  text: l.getName(m),
                  align: 'center',
                  verticalAlign: 'middle',
                },
                {
                  inheritColor: A,
                },
              ),
            }),
              x.add(M)
          }
          var C = y.getModel('detail')
          if (C.get('show')) {
            var E = C.get('offsetCenter'),
              D = o.cx + _t(E[0], o.r),
              P = o.cy + _t(E[1], o.r),
              L = _t(C.get('width'), o.r),
              I = _t(C.get('height'), o.r),
              F = e.get(['progress', 'show'])
                ? l.getItemVisual(m, 'style').fill
                : A,
              M = p[m],
              k = C.get('formatter')
            M.attr({
              z2: v ? 0 : 2,
              style: $e(
                C,
                {
                  x: D,
                  y: P,
                  text: _m(_, k),
                  width: isNaN(L) ? null : L,
                  height: isNaN(I) ? null : I,
                  align: 'center',
                  verticalAlign: 'middle',
                },
                {
                  inheritColor: F,
                },
              ),
            }),
              GU(
                M,
                {
                  normal: C,
                },
                _,
                function (H) {
                  return _m(H, k)
                },
              ),
              g &&
                HU(M, m, l, e, {
                  getFormattedLabel: function (H, Y, K, ut, W, Z) {
                    return _m(Z ? Z.interpolatedValue : _, k)
                  },
                }),
              x.add(M)
          }
          f.add(x)
        }),
        this.group.add(f),
        (this._titleEls = d),
        (this._detailEls = p)
    }),
    (t.type = 'gauge'),
    t
  )
})(Ze)
const adt = idt
var odt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.visualStyleAccessPath = 'itemStyle'), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, ['value'])
    }),
    (t.type = 'series.gauge'),
    (t.defaultOption = {
      z: 2,
      colorBy: 'data',
      center: ['50%', '50%'],
      legendHoverLink: !0,
      radius: '75%',
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, '#E6EBF8']],
          width: 10,
        },
      },
      progress: {
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0,
      },
      splitLine: {
        show: !0,
        length: 10,
        distance: 10,
        lineStyle: {
          color: '#63677A',
          width: 3,
          type: 'solid',
        },
      },
      axisTick: {
        show: !0,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: '#63677A',
          width: 1,
          type: 'solid',
        },
      },
      axisLabel: {
        show: !0,
        distance: 15,
        color: '#464646',
        fontSize: 12,
        rotate: 0,
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: '60%',
        width: 6,
        keepAspect: !1,
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: 'circle',
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: '#fff',
          borderWidth: 0,
          borderColor: '#5470c6',
        },
      },
      title: {
        show: !0,
        offsetCenter: [0, '20%'],
        color: '#464646',
        fontSize: 16,
        valueAnimation: !1,
      },
      detail: {
        show: !0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        borderColor: '#ccc',
        width: 100,
        height: null,
        padding: [5, 10],
        offsetCenter: [0, '40%'],
        color: '#464646',
        fontSize: 30,
        fontWeight: 'bold',
        lineHeight: 30,
        valueAnimation: !1,
      },
    }),
    t
  )
})(rn)
const sdt = odt
function ldt(r) {
  r.registerChartView(adt), r.registerSeriesModel(sdt)
}
var udt = ['itemStyle', 'opacity'],
  cdt = (function (r) {
    X(t, r)
    function t(e, n) {
      var i = r.call(this) || this,
        a = i,
        o = new li(),
        s = new Ae()
      return (
        a.setTextContent(s), i.setTextGuideLine(o), i.updateData(e, n, !0), i
      )
    }
    return (
      (t.prototype.updateData = function (e, n, i) {
        var a = this,
          o = e.hostModel,
          s = e.getItemModel(n),
          l = e.getItemLayout(n),
          u = s.getModel('emphasis'),
          c = s.get(udt)
        ;(c = c ?? 1),
          i || Ca(a),
          a.useStyle(e.getItemVisual(n, 'style')),
          (a.style.lineJoin = 'round'),
          i
            ? (a.setShape({
                points: l.points,
              }),
              (a.style.opacity = 0),
              Je(
                a,
                {
                  style: {
                    opacity: c,
                  },
                },
                o,
                n,
              ))
            : we(
                a,
                {
                  style: {
                    opacity: c,
                  },
                  shape: {
                    points: l.points,
                  },
                },
                o,
                n,
              ),
          gr(a, s),
          this._updateLabel(e, n),
          fn(this, u.get('focus'), u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e, n) {
        var i = this,
          a = this.getTextGuideLine(),
          o = i.getTextContent(),
          s = e.hostModel,
          l = e.getItemModel(n),
          u = e.getItemLayout(n),
          c = u.label,
          h = e.getItemVisual(n, 'style'),
          f = h.fill
        mr(
          o,
          Zn(l),
          {
            labelFetcher: e.hostModel,
            labelDataIndex: n,
            defaultOpacity: h.opacity,
            defaultText: e.getName(n),
          },
          {
            normal: {
              align: c.textAlign,
              verticalAlign: c.verticalAlign,
            },
          },
        ),
          i.setTextConfig({
            local: !0,
            inside: !!c.inside,
            insideStroke: f,
            outsideFill: f,
          })
        var d = c.linePoints
        a.setShape({
          points: d,
        }),
          (i.textGuideLineConfig = {
            anchor: d ? new Qt(d[0][0], d[0][1]) : null,
          }),
          we(
            o,
            {
              style: {
                x: c.x,
                y: c.y,
              },
            },
            s,
            n,
          ),
          o.attr({
            rotation: c.rotation,
            originX: c.x,
            originY: c.y,
            z2: 10,
          }),
          LC(i, PC(l), {
            stroke: f,
          })
      }),
      t
    )
  })(si),
  hdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.ignoreLabelLineUpdate = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = this._data,
          s = this.group
        a
          .diff(o)
          .add(function (l) {
            var u = new cdt(a, l)
            a.setItemGraphicEl(l, u), s.add(u)
          })
          .update(function (l, u) {
            var c = o.getItemGraphicEl(u)
            c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c)
          })
          .remove(function (l) {
            var u = o.getItemGraphicEl(l)
            Xp(u, e, l)
          })
          .execute(),
          (this._data = a)
      }),
      (t.prototype.remove = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'funnel'),
      t
    )
  })(Ze)
const fdt = hdt
var ddt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments),
        (this.legendVisualProvider = new Pv(
          Tt(this.getData, this),
          Tt(this.getRawData, this),
        )),
        this._defaultLabelLine(e)
    }),
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, {
        coordDimensions: ['value'],
        encodeDefaulter: Zt(lC, this),
      })
    }),
    (t.prototype._defaultLabelLine = function (e) {
      Xu(e, 'labelLine', ['show'])
      var n = e.labelLine,
        i = e.emphasis.labelLine
      ;(n.show = n.show && e.label.show),
        (i.show = i.show && e.emphasis.label.show)
    }),
    (t.prototype.getDataParams = function (e) {
      var n = this.getData(),
        i = r.prototype.getDataParams.call(this, e),
        a = n.mapDimension('value'),
        o = n.getSum(a)
      return (
        (i.percent = o ? +((n.get(a, e) / o) * 100).toFixed(2) : 0),
        i.$vars.push('percent'),
        i
      )
    }),
    (t.type = 'series.funnel'),
    (t.defaultOption = {
      z: 2,
      legendHoverLink: !0,
      colorBy: 'data',
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: '0%',
      maxSize: '100%',
      sort: 'descending',
      orient: 'vertical',
      gap: 0,
      funnelAlign: 'center',
      label: {
        show: !0,
        position: 'outer',
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          width: 1,
        },
      },
      itemStyle: {
        borderColor: '#fff',
        borderWidth: 1,
      },
      emphasis: {
        label: {
          show: !0,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const pdt = ddt
function vdt(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function gdt(r, t) {
  for (
    var e = r.mapDimension('value'),
      n = r.mapArray(e, function (l) {
        return l
      }),
      i = [],
      a = t === 'ascending',
      o = 0,
      s = r.count();
    o < s;
    o++
  )
    i[o] = o
  return (
    Nt(t)
      ? i.sort(t)
      : t !== 'none' &&
        i.sort(function (l, u) {
          return a ? n[l] - n[u] : n[u] - n[l]
        }),
    i
  )
}
function mdt(r) {
  var t = r.hostModel,
    e = t.get('orient')
  r.each(function (n) {
    var i = r.getItemModel(n),
      a = i.getModel('label'),
      o = a.get('position'),
      s = i.getModel('labelLine'),
      l = r.getItemLayout(n),
      u = l.points,
      c =
        o === 'inner' ||
        o === 'inside' ||
        o === 'center' ||
        o === 'insideLeft' ||
        o === 'insideRight',
      h,
      f,
      d,
      p
    if (c)
      o === 'insideLeft'
        ? ((f = (u[0][0] + u[3][0]) / 2 + 5),
          (d = (u[0][1] + u[3][1]) / 2),
          (h = 'left'))
        : o === 'insideRight'
        ? ((f = (u[1][0] + u[2][0]) / 2 - 5),
          (d = (u[1][1] + u[2][1]) / 2),
          (h = 'right'))
        : ((f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4),
          (d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4),
          (h = 'center')),
        (p = [
          [f, d],
          [f, d],
        ])
    else {
      var g = void 0,
        v = void 0,
        m = void 0,
        y = void 0,
        _ = s.get('length')
      o === 'left'
        ? ((g = (u[3][0] + u[0][0]) / 2),
          (v = (u[3][1] + u[0][1]) / 2),
          (m = g - _),
          (f = m - 5),
          (h = 'right'))
        : o === 'right'
        ? ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          (m = g + _),
          (f = m + 5),
          (h = 'left'))
        : o === 'top'
        ? ((g = (u[3][0] + u[0][0]) / 2),
          (v = (u[3][1] + u[0][1]) / 2),
          (y = v - _),
          (d = y - 5),
          (h = 'center'))
        : o === 'bottom'
        ? ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          (y = v + _),
          (d = y + 5),
          (h = 'center'))
        : o === 'rightTop'
        ? ((g = e === 'horizontal' ? u[3][0] : u[1][0]),
          (v = e === 'horizontal' ? u[3][1] : u[1][1]),
          e === 'horizontal'
            ? ((y = v - _), (d = y - 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'top')))
        : o === 'rightBottom'
        ? ((g = u[2][0]),
          (v = u[2][1]),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'bottom')))
        : o === 'leftTop'
        ? ((g = u[0][0]),
          (v = e === 'horizontal' ? u[0][1] : u[1][1]),
          e === 'horizontal'
            ? ((y = v - _), (d = y - 5), (h = 'center'))
            : ((m = g - _), (f = m - 5), (h = 'right')))
        : o === 'leftBottom'
        ? ((g = e === 'horizontal' ? u[1][0] : u[3][0]),
          (v = e === 'horizontal' ? u[1][1] : u[2][1]),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g - _), (f = m - 5), (h = 'right')))
        : ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'left'))),
        e === 'horizontal' ? ((m = g), (f = m)) : ((y = v), (d = y)),
        (p = [
          [g, v],
          [m, y],
        ])
    }
    l.label = {
      linePoints: p,
      x: f,
      y: d,
      verticalAlign: 'middle',
      textAlign: h,
      inside: c,
    }
  })
}
function ydt(r, t) {
  r.eachSeriesByType('funnel', function (e) {
    var n = e.getData(),
      i = n.mapDimension('value'),
      a = e.get('sort'),
      o = vdt(e, t),
      s = e.get('orient'),
      l = o.width,
      u = o.height,
      c = gdt(n, a),
      h = o.x,
      f = o.y,
      d =
        s === 'horizontal'
          ? [_t(e.get('minSize'), u), _t(e.get('maxSize'), u)]
          : [_t(e.get('minSize'), l), _t(e.get('maxSize'), l)],
      p = n.getDataExtent(i),
      g = e.get('min'),
      v = e.get('max')
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1])
    var m = e.get('funnelAlign'),
      y = e.get('gap'),
      _ = s === 'horizontal' ? l : u,
      x = (_ - y * (n.count() - 1)) / n.count(),
      A = function (P, L) {
        if (s === 'horizontal') {
          var I = n.get(i, P) || 0,
            F = Re(I, [g, v], d, !0),
            k = void 0
          switch (m) {
            case 'top':
              k = f
              break
            case 'center':
              k = f + (u - F) / 2
              break
            case 'bottom':
              k = f + (u - F)
              break
          }
          return [
            [L, k],
            [L, k + F],
          ]
        }
        var V = n.get(i, P) || 0,
          H = Re(V, [g, v], d, !0),
          Y
        switch (m) {
          case 'left':
            Y = h
            break
          case 'center':
            Y = h + (l - H) / 2
            break
          case 'right':
            Y = h + l - H
            break
        }
        return [
          [Y, L],
          [Y + H, L],
        ]
      }
    a === 'ascending' &&
      ((x = -x),
      (y = -y),
      s === 'horizontal' ? (h += l) : (f += u),
      (c = c.reverse()))
    for (var S = 0; S < c.length; S++) {
      var b = c[S],
        T = c[S + 1],
        w = n.getItemModel(b)
      if (s === 'horizontal') {
        var M = w.get(['itemStyle', 'width'])
        M == null ? (M = x) : ((M = _t(M, l)), a === 'ascending' && (M = -M))
        var C = A(b, h),
          E = A(T, h + M)
        ;(h += M + y),
          n.setItemLayout(b, {
            points: C.concat(E.slice().reverse()),
          })
      } else {
        var D = w.get(['itemStyle', 'height'])
        D == null ? (D = x) : ((D = _t(D, u)), a === 'ascending' && (D = -D))
        var C = A(b, f),
          E = A(T, f + D)
        ;(f += D + y),
          n.setItemLayout(b, {
            points: C.concat(E.slice().reverse()),
          })
      }
    }
    mdt(n)
  })
}
function _dt(r) {
  r.registerChartView(fdt),
    r.registerSeriesModel(pdt),
    r.registerLayout(ydt),
    r.registerProcessor(Lv('funnel'))
}
var xdt = 0.3,
  Sdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type), (e._dataGroup = new Ht()), (e._initialized = !1), e
      )
    }
    return (
      (t.prototype.init = function () {
        this.group.add(this._dataGroup)
      }),
      (t.prototype.render = function (e, n, i, a) {
        this._progressiveEls = null
        var o = this._dataGroup,
          s = e.getData(),
          l = this._data,
          u = e.coordinateSystem,
          c = u.dimensions,
          h = nN(e)
        s.diff(l).add(f).update(d).remove(p).execute()
        function f(v) {
          var m = eN(s, o, v, c, u)
          ES(m, s, v, h)
        }
        function d(v, m) {
          var y = l.getItemGraphicEl(m),
            _ = b4(s, v, c, u)
          s.setItemGraphicEl(v, y),
            we(
              y,
              {
                shape: {
                  points: _,
                },
              },
              e,
              v,
            ),
            Ca(y),
            ES(y, s, v, h)
        }
        function p(v) {
          var m = l.getItemGraphicEl(v)
          o.remove(m)
        }
        if (!this._initialized) {
          this._initialized = !0
          var g = Adt(u, e, function () {
            setTimeout(function () {
              o.removeClipPath()
            })
          })
          o.setClipPath(g)
        }
        this._data = s
      }),
      (t.prototype.incrementalPrepareRender = function (e, n, i) {
        ;(this._initialized = !0),
          (this._data = null),
          this._dataGroup.removeAll()
      }),
      (t.prototype.incrementalRender = function (e, n, i) {
        for (
          var a = n.getData(),
            o = n.coordinateSystem,
            s = o.dimensions,
            l = nN(n),
            u = (this._progressiveEls = []),
            c = e.start;
          c < e.end;
          c++
        ) {
          var h = eN(a, this._dataGroup, c, s, o)
          ;(h.incremental = !0), ES(h, a, c, l), u.push(h)
        }
      }),
      (t.prototype.remove = function () {
        this._dataGroup && this._dataGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'parallel'),
      t
    )
  })(Ze)
function Adt(r, t, e) {
  var n = r.model,
    i = r.getRect(),
    a = new ge({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height,
      },
    }),
    o = n.get('layout') === 'horizontal' ? 'width' : 'height'
  return (
    a.setShape(o, 0),
    Je(
      a,
      {
        shape: {
          width: i.width,
          height: i.height,
        },
      },
      t,
      e,
    ),
    a
  )
}
function b4(r, t, e, n) {
  for (var i = [], a = 0; a < e.length; a++) {
    var o = e[a],
      s = r.get(r.mapDimension(o), t)
    bdt(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o))
  }
  return i
}
function eN(r, t, e, n, i) {
  var a = b4(r, e, n, i),
    o = new li({
      shape: {
        points: a,
      },
      z2: 10,
    })
  return t.add(o), r.setItemGraphicEl(e, o), o
}
function nN(r) {
  var t = r.get('smooth', !0)
  return (
    t === !0 && (t = xdt),
    (t = Jo(t)),
    kp(t) && (t = 0),
    {
      smooth: t,
    }
  )
}
function ES(r, t, e, n) {
  r.useStyle(t.getItemVisual(e, 'style')),
    (r.style.fill = null),
    r.setShape('smooth', n.smooth)
  var i = t.getItemModel(e),
    a = i.getModel('emphasis')
  gr(r, i, 'lineStyle'),
    fn(r, a.get('focus'), a.get('blurScope'), a.get('disabled'))
}
function bdt(r, t) {
  return t === 'category' ? r == null : r == null || isNaN(r)
}
const wdt = Sdt
var Mdt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.visualStyleAccessPath = 'lineStyle'),
      (e.visualDrawType = 'stroke'),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: Tt(Tdt, null, this),
      })
    }),
    (t.prototype.getRawIndicesByActiveState = function (e) {
      var n = this.coordinateSystem,
        i = this.getData(),
        a = []
      return (
        n.eachActiveState(i, function (o, s) {
          e === o && a.push(i.getRawIndex(s))
        }),
        a
      )
    }),
    (t.type = 'series.parallel'),
    (t.dependencies = ['parallel']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'parallel',
      parallelIndex: 0,
      label: {
        show: !1,
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: 'solid',
      },
      emphasis: {
        label: {
          show: !1,
        },
      },
      progressive: 500,
      smooth: !1,
      animationEasing: 'linear',
    }),
    t
  )
})(rn)
function Tdt(r) {
  var t = r.ecModel.getComponent('parallel', r.get('parallelIndex'))
  if (t) {
    var e = {}
    return (
      R(t.dimensions, function (n) {
        var i = Cdt(n)
        e[n] = i
      }),
      e
    )
  }
}
function Cdt(r) {
  return +r.replace('dim', '')
}
const Edt = Mdt
var Ddt = ['lineStyle', 'opacity'],
  Ldt = {
    seriesType: 'parallel',
    reset: function (r, t) {
      var e = r.coordinateSystem,
        n = {
          normal: r.get(['lineStyle', 'opacity']),
          active: r.get('activeOpacity'),
          inactive: r.get('inactiveOpacity'),
        }
      return {
        progress: function (i, a) {
          e.eachActiveState(
            a,
            function (o, s) {
              var l = n[o]
              if (o === 'normal' && a.hasItemOption) {
                var u = a.getItemModel(s).get(Ddt, !0)
                u != null && (l = u)
              }
              var c = a.ensureUniqueItemVisual(s, 'style')
              c.opacity = l
            },
            i.start,
            i.end,
          )
        },
      }
    },
  }
const Pdt = Ldt
function Rdt(r) {
  Idt(r), Odt(r)
}
function Idt(r) {
  if (!r.parallel) {
    var t = !1
    R(r.series, function (e) {
      e && e.type === 'parallel' && (t = !0)
    }),
      t && (r.parallel = [{}])
  }
}
function Odt(r) {
  var t = ke(r.parallelAxis)
  R(t, function (e) {
    if (Ut(e)) {
      var n = e.parallelIndex || 0,
        i = ke(r.parallel)[n]
      i && i.parallelAxisDefault && te(e, i.parallelAxisDefault, !1)
    }
  })
}
var Ndt = 5,
  kdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        ;(this._model = e),
          (this._api = i),
          this._handlers ||
            ((this._handlers = {}),
            R(
              Bdt,
              function (a, o) {
                i.getZr().on(o, (this._handlers[o] = Tt(a, this)))
              },
              this,
            )),
          Df(
            this,
            '_throttledDispatchExpand',
            e.get('axisExpandRate'),
            'fixRate',
          )
      }),
      (t.prototype.dispose = function (e, n) {
        Zp(this, '_throttledDispatchExpand'),
          R(this._handlers, function (i, a) {
            n.getZr().off(a, i)
          }),
          (this._handlers = null)
      }),
      (t.prototype._throttledDispatchExpand = function (e) {
        this._dispatchExpand(e)
      }),
      (t.prototype._dispatchExpand = function (e) {
        e &&
          this._api.dispatchAction(
            Q(
              {
                type: 'parallelAxisExpand',
              },
              e,
            ),
          )
      }),
      (t.type = 'parallel'),
      t
    )
  })(dn),
  Bdt = {
    mousedown: function (r) {
      DS(this, 'click') && (this._mouseDownPoint = [r.offsetX, r.offsetY])
    },
    mouseup: function (r) {
      var t = this._mouseDownPoint
      if (DS(this, 'click') && t) {
        var e = [r.offsetX, r.offsetY],
          n = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2)
        if (n > Ndt) return
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          r.offsetX,
          r.offsetY,
        ])
        i.behavior !== 'none' &&
          this._dispatchExpand({
            axisExpandWindow: i.axisExpandWindow,
          })
      }
      this._mouseDownPoint = null
    },
    mousemove: function (r) {
      if (!(this._mouseDownPoint || !DS(this, 'mousemove'))) {
        var t = this._model,
          e = t.coordinateSystem.getSlidedAxisExpandWindow([
            r.offsetX,
            r.offsetY,
          ]),
          n = e.behavior
        n === 'jump' &&
          this._throttledDispatchExpand.debounceNextCall(
            t.get('axisExpandDebounce'),
          ),
          this._throttledDispatchExpand(
            n === 'none'
              ? null
              : {
                  axisExpandWindow: e.axisExpandWindow,
                  animation:
                    n === 'jump'
                      ? null
                      : {
                          duration: 0,
                        },
                },
          )
      }
    },
  }
function DS(r, t) {
  var e = r._model
  return e.get('axisExpandable') && e.get('axisExpandTriggerOn') === t
}
const Fdt = kdt
var zdt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function () {
      r.prototype.init.apply(this, arguments), this.mergeOption({})
    }),
    (t.prototype.mergeOption = function (e) {
      var n = this.option
      e && te(n, e, !0), this._initDimensions()
    }),
    (t.prototype.contains = function (e, n) {
      var i = e.get('parallelIndex')
      return i != null && n.getComponent('parallel', i) === this
    }),
    (t.prototype.setAxisExpand = function (e) {
      R(
        [
          'axisExpandable',
          'axisExpandCenter',
          'axisExpandCount',
          'axisExpandWidth',
          'axisExpandWindow',
        ],
        function (n) {
          e.hasOwnProperty(n) && (this.option[n] = e[n])
        },
        this,
      )
    }),
    (t.prototype._initDimensions = function () {
      var e = (this.dimensions = []),
        n = (this.parallelAxisIndex = []),
        i = Ne(
          this.ecModel.queryComponents({
            mainType: 'parallelAxis',
          }),
          function (a) {
            return (a.get('parallelIndex') || 0) === this.componentIndex
          },
          this,
        )
      R(i, function (a) {
        e.push('dim' + a.get('dim')), n.push(a.componentIndex)
      })
    }),
    (t.type = 'parallel'),
    (t.dependencies = ['parallelAxis']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: 'horizontal',
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: 'click',
      parallelAxisDefault: null,
    }),
    t
  )
})(xe)
const Udt = zdt
var Vdt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o) {
    var s = r.call(this, e, n, i) || this
    return (s.type = a || 'value'), (s.axisIndex = o), s
  }
  return (
    (t.prototype.isHorizontal = function () {
      return this.coordinateSystem.getModel().get('layout') !== 'horizontal'
    }),
    t
  )
})(Ra)
const Gdt = Vdt
function lc(r, t, e, n, i, a) {
  r = r || 0
  var o = e[1] - e[0]
  if (
    (i != null && (i = th(i, [0, o])),
    a != null && (a = Math.max(a, i ?? 0)),
    n === 'all')
  ) {
    var s = Math.abs(t[1] - t[0])
    ;(s = th(s, [0, o])), (i = a = th(s, [i, a])), (n = 0)
  }
  ;(t[0] = th(t[0], e)), (t[1] = th(t[1], e))
  var l = LS(t, n)
  t[n] += r
  var u = i || 0,
    c = e.slice()
  l.sign < 0 ? (c[0] += u) : (c[1] -= u), (t[n] = th(t[n], c))
  var h
  return (
    (h = LS(t, n)),
    i != null &&
      (h.sign !== l.sign || h.span < i) &&
      (t[1 - n] = t[n] + l.sign * i),
    (h = LS(t, n)),
    a != null && h.span > a && (t[1 - n] = t[n] + h.sign * a),
    t
  )
}
function LS(r, t) {
  var e = r[t] - r[1 - t]
  return {
    span: Math.abs(e),
    sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1,
  }
}
function th(r, t) {
  return Math.min(
    t[1] != null ? t[1] : 1 / 0,
    Math.max(t[0] != null ? t[0] : -1 / 0, r),
  )
}
var PS = R,
  w4 = Math.min,
  M4 = Math.max,
  rN = Math.floor,
  Hdt = Math.ceil,
  iN = mn,
  Wdt = Math.PI,
  Xdt = (function () {
    function r(t, e, n) {
      ;(this.type = 'parallel'),
        (this._axesMap = Pt()),
        (this._axesLayout = {}),
        (this.dimensions = t.dimensions),
        (this._model = t),
        this._init(t, e, n)
    }
    return (
      (r.prototype._init = function (t, e, n) {
        var i = t.dimensions,
          a = t.parallelAxisIndex
        PS(
          i,
          function (o, s) {
            var l = a[s],
              u = e.getComponent('parallelAxis', l),
              c = this._axesMap.set(
                o,
                new Gdt(o, w_(u), [0, 0], u.get('type'), l),
              ),
              h = c.type === 'category'
            ;(c.onBand = h && u.get('boundaryGap')),
              (c.inverse = u.get('inverse')),
              (u.axis = c),
              (c.model = u),
              (c.coordinateSystem = u.coordinateSystem = this)
          },
          this,
        )
      }),
      (r.prototype.update = function (t, e) {
        this._updateAxesFromSeries(this._model, t)
      }),
      (r.prototype.containPoint = function (t) {
        var e = this._makeLayoutInfo(),
          n = e.axisBase,
          i = e.layoutBase,
          a = e.pixelDimIndex,
          o = t[1 - a],
          s = t[a]
        return (
          o >= n && o <= n + e.axisLength && s >= i && s <= i + e.layoutLength
        )
      }),
      (r.prototype.getModel = function () {
        return this._model
      }),
      (r.prototype._updateAxesFromSeries = function (t, e) {
        e.eachSeries(function (n) {
          if (t.contains(n, e)) {
            var i = n.getData()
            PS(
              this.dimensions,
              function (a) {
                var o = this._axesMap.get(a)
                o.scale.unionExtentFromData(i, i.mapDimension(a)),
                  af(o.scale, o.model)
              },
              this,
            )
          }
        }, this)
      }),
      (r.prototype.resize = function (t, e) {
        ;(this._rect = Vn(t.getBoxLayoutParams(), {
          width: e.getWidth(),
          height: e.getHeight(),
        })),
          this._layoutAxes()
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype._makeLayoutInfo = function () {
        var t = this._model,
          e = this._rect,
          n = ['x', 'y'],
          i = ['width', 'height'],
          a = t.get('layout'),
          o = a === 'horizontal' ? 0 : 1,
          s = e[i[o]],
          l = [0, s],
          u = this.dimensions.length,
          c = xm(t.get('axisExpandWidth'), l),
          h = xm(t.get('axisExpandCount') || 0, [0, u]),
          f =
            t.get('axisExpandable') &&
            u > 3 &&
            u > h &&
            h > 1 &&
            c > 0 &&
            s > 0,
          d = t.get('axisExpandWindow'),
          p
        if (d) (p = xm(d[1] - d[0], l)), (d[1] = d[0] + p)
        else {
          p = xm(c * (h - 1), l)
          var g = t.get('axisExpandCenter') || rN(u / 2)
          ;(d = [c * g - p / 2]), (d[1] = d[0] + p)
        }
        var v = (s - p) / (u - h)
        v < 3 && (v = 0)
        var m = [rN(iN(d[0] / c, 1)) + 1, Hdt(iN(d[1] / c, 1)) - 1],
          y = (v / c) * d[0]
        return {
          layout: a,
          pixelDimIndex: o,
          layoutBase: e[n[o]],
          layoutLength: s,
          axisBase: e[n[1 - o]],
          axisLength: e[i[1 - o]],
          axisExpandable: f,
          axisExpandWidth: c,
          axisCollapseWidth: v,
          axisExpandWindow: d,
          axisCount: u,
          winInnerIndices: m,
          axisExpandWindow0Pos: y,
        }
      }),
      (r.prototype._layoutAxes = function () {
        var t = this._rect,
          e = this._axesMap,
          n = this.dimensions,
          i = this._makeLayoutInfo(),
          a = i.layout
        e.each(function (o) {
          var s = [0, i.axisLength],
            l = o.inverse ? 1 : 0
          o.setExtent(s[l], s[1 - l])
        }),
          PS(
            n,
            function (o, s) {
              var l = (i.axisExpandable ? $dt : Ydt)(s, i),
                u = {
                  horizontal: {
                    x: l.position,
                    y: i.axisLength,
                  },
                  vertical: {
                    x: 0,
                    y: l.position,
                  },
                },
                c = {
                  horizontal: Wdt / 2,
                  vertical: 0,
                },
                h = [u[a].x + t.x, u[a].y + t.y],
                f = c[a],
                d = bi()
              ec(d, d, f),
                ho(d, d, h),
                (this._axesLayout[o] = {
                  position: h,
                  rotation: f,
                  transform: d,
                  axisNameAvailableWidth: l.axisNameAvailableWidth,
                  axisLabelShow: l.axisLabelShow,
                  nameTruncateMaxWidth: l.nameTruncateMaxWidth,
                  tickDirection: 1,
                  labelDirection: 1,
                })
            },
            this,
          )
      }),
      (r.prototype.getAxis = function (t) {
        return this._axesMap.get(t)
      }),
      (r.prototype.dataToPoint = function (t, e) {
        return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e)
      }),
      (r.prototype.eachActiveState = function (t, e, n, i) {
        n == null && (n = 0), i == null && (i = t.count())
        var a = this._axesMap,
          o = this.dimensions,
          s = [],
          l = []
        R(o, function (v) {
          s.push(t.mapDimension(v)), l.push(a.get(v).model)
        })
        for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
          var h = void 0
          if (!u) h = 'normal'
          else {
            h = 'active'
            for (var f = t.getValues(s, c), d = 0, p = o.length; d < p; d++) {
              var g = l[d].getActiveState(f[d])
              if (g === 'inactive') {
                h = 'inactive'
                break
              }
            }
          }
          e(h, c)
        }
      }),
      (r.prototype.hasAxisBrushed = function () {
        for (
          var t = this.dimensions,
            e = this._axesMap,
            n = !1,
            i = 0,
            a = t.length;
          i < a;
          i++
        )
          e.get(t[i]).model.getActiveState() !== 'normal' && (n = !0)
        return n
      }),
      (r.prototype.axisCoordToPoint = function (t, e) {
        var n = this._axesLayout[e]
        return ba([t, 0], n.transform)
      }),
      (r.prototype.getAxisLayout = function (t) {
        return Vt(this._axesLayout[t])
      }),
      (r.prototype.getSlidedAxisExpandWindow = function (t) {
        var e = this._makeLayoutInfo(),
          n = e.pixelDimIndex,
          i = e.axisExpandWindow.slice(),
          a = i[1] - i[0],
          o = [0, e.axisExpandWidth * (e.axisCount - 1)]
        if (!this.containPoint(t))
          return {
            behavior: 'none',
            axisExpandWindow: i,
          }
        var s = t[n] - e.layoutBase - e.axisExpandWindow0Pos,
          l,
          u = 'slide',
          c = e.axisCollapseWidth,
          h = this._model.get('axisExpandSlideTriggerArea'),
          f = h[0] != null
        if (c)
          f && c && s < a * h[0]
            ? ((u = 'jump'), (l = s - a * h[2]))
            : f && c && s > a * (1 - h[0])
            ? ((u = 'jump'), (l = s - a * (1 - h[2])))
            : (l = s - a * h[1]) >= 0 &&
              (l = s - a * (1 - h[1])) <= 0 &&
              (l = 0),
            (l *= e.axisExpandWidth / c),
            l ? lc(l, i, o, 'all') : (u = 'none')
        else {
          var d = i[1] - i[0],
            p = (o[1] * s) / d
          ;(i = [M4(0, p - d / 2)]),
            (i[1] = w4(o[1], i[0] + d)),
            (i[0] = i[1] - d)
        }
        return {
          axisExpandWindow: i,
          behavior: u,
        }
      }),
      r
    )
  })()
function xm(r, t) {
  return w4(M4(r, t[0]), t[1])
}
function Ydt(r, t) {
  var e = t.layoutLength / (t.axisCount - 1)
  return {
    position: e * r,
    axisNameAvailableWidth: e,
    axisLabelShow: !0,
  }
}
function $dt(r, t) {
  var e = t.layoutLength,
    n = t.axisExpandWidth,
    i = t.axisCount,
    a = t.axisCollapseWidth,
    o = t.winInnerIndices,
    s,
    l = a,
    u = !1,
    c
  return (
    r < o[0]
      ? ((s = r * a), (c = a))
      : r <= o[1]
      ? ((s = t.axisExpandWindow0Pos + r * n - t.axisExpandWindow[0]),
        (l = n),
        (u = !0))
      : ((s = e - (i - 1 - r) * a), (c = a)),
    {
      position: s,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c,
    }
  )
}
const qdt = Xdt
function Zdt(r, t) {
  var e = []
  return (
    r.eachComponent('parallel', function (n, i) {
      var a = new qdt(n, r, t)
      ;(a.name = 'parallel_' + i),
        a.resize(n, t),
        (n.coordinateSystem = a),
        (a.model = n),
        e.push(a)
    }),
    r.eachSeries(function (n) {
      if (n.get('coordinateSystem') === 'parallel') {
        var i = n.getReferringComponents('parallel', Pn).models[0]
        n.coordinateSystem = i.coordinateSystem
      }
    }),
    e
  )
}
var Kdt = {
  create: Zdt,
}
const jdt = Kdt
var T4 = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.activeIntervals = []), e
  }
  return (
    (t.prototype.getAreaSelectStyle = function () {
      return $u([
        ['fill', 'color'],
        ['lineWidth', 'borderWidth'],
        ['stroke', 'borderColor'],
        ['width', 'width'],
        ['opacity', 'opacity'],
      ])(this.getModel('areaSelectStyle'))
    }),
    (t.prototype.setActiveIntervals = function (e) {
      var n = (this.activeIntervals = Vt(e))
      if (n) for (var i = n.length - 1; i >= 0; i--) Zi(n[i])
    }),
    (t.prototype.getActiveState = function (e) {
      var n = this.activeIntervals
      if (!n.length) return 'normal'
      if (e == null || isNaN(+e)) return 'inactive'
      if (n.length === 1) {
        var i = n[0]
        if (i[0] <= e && e <= i[1]) return 'active'
      } else
        for (var a = 0, o = n.length; a < o; a++)
          if (n[a][0] <= e && e <= n[a][1]) return 'active'
      return 'inactive'
    }),
    t
  )
})(xe)
In(T4, Mv)
const aN = T4
var Ku = !0,
  ov = Math.min,
  lf = Math.max,
  Jdt = Math.pow,
  Qdt = 1e4,
  tpt = 6,
  ept = 6,
  oN = 'globalPan',
  npt = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1],
  },
  rpt = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse',
  },
  sN = {
    brushStyle: {
      lineWidth: 2,
      stroke: 'rgba(210,219,238,0.3)',
      fill: '#D2DBEE',
    },
    transformable: !0,
    brushMode: 'single',
    removeOnClick: !1,
  },
  ipt = 0,
  apt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this) || this
      return (
        (n._track = []),
        (n._covers = []),
        (n._handlers = {}),
        (n._zr = e),
        (n.group = new Ht()),
        (n._uid = 'brushController_' + ipt++),
        R(
          fpt,
          function (i, a) {
            this._handlers[a] = Tt(i, this)
          },
          n,
        ),
        n
      )
    }
    return (
      (t.prototype.enableBrush = function (e) {
        return (
          this._brushType && this._doDisableBrush(),
          e.brushType && this._doEnableBrush(e),
          this
        )
      }),
      (t.prototype._doEnableBrush = function (e) {
        var n = this._zr
        this._enableGlobalPan || vct(n, oN, this._uid),
          R(this._handlers, function (i, a) {
            n.on(a, i)
          }),
          (this._brushType = e.brushType),
          (this._brushOption = te(Vt(sN), e, !0))
      }),
      (t.prototype._doDisableBrush = function () {
        var e = this._zr
        gct(e, oN, this._uid),
          R(this._handlers, function (n, i) {
            e.off(i, n)
          }),
          (this._brushType = this._brushOption = null)
      }),
      (t.prototype.setPanels = function (e) {
        if (e && e.length) {
          var n = (this._panels = {})
          R(e, function (i) {
            n[i.panelId] = Vt(i)
          })
        } else this._panels = null
        return this
      }),
      (t.prototype.mount = function (e) {
        ;(e = e || {}), (this._enableGlobalPan = e.enableGlobalPan)
        var n = this.group
        return (
          this._zr.add(n),
          n.attr({
            x: e.x || 0,
            y: e.y || 0,
            rotation: e.rotation || 0,
            scaleX: e.scaleX || 1,
            scaleY: e.scaleY || 1,
          }),
          (this._transform = n.getLocalTransform()),
          this
        )
      }),
      (t.prototype.updateCovers = function (e) {
        e = st(e, function (f) {
          return te(Vt(sN), f, !0)
        })
        var n = '\0-brush-index-',
          i = this._covers,
          a = (this._covers = []),
          o = this,
          s = this._creatingCover
        return new es(i, e, u, l).add(c).update(c).remove(h).execute(), this
        function l(f, d) {
          return (f.id != null ? f.id : n + d) + '-' + f.brushType
        }
        function u(f, d) {
          return l(f.__brushOption, d)
        }
        function c(f, d) {
          var p = e[f]
          if (d != null && i[d] === s) a[f] = i[d]
          else {
            var g = (a[f] =
              d != null ? ((i[d].__brushOption = p), i[d]) : E4(o, C4(o, p)))
            tE(o, g)
          }
        }
        function h(f) {
          i[f] !== s && o.group.remove(i[f])
        }
      }),
      (t.prototype.unmount = function () {
        return this.enableBrush(!1), Ww(this), this._zr.remove(this.group), this
      }),
      (t.prototype.dispose = function () {
        this.unmount(), this.off()
      }),
      t
    )
  })(ra)
function C4(r, t) {
  var e = L_[t.brushType].createCover(r, t)
  return (e.__brushOption = t), L4(e, t), r.group.add(e), e
}
function E4(r, t) {
  var e = eE(t)
  return e.endCreating && (e.endCreating(r, t), L4(t, t.__brushOption)), t
}
function D4(r, t) {
  var e = t.__brushOption
  eE(t).updateCoverShape(r, t, e.range, e)
}
function L4(r, t) {
  var e = t.z
  e == null && (e = Qdt),
    r.traverse(function (n) {
      ;(n.z = e), (n.z2 = e)
    })
}
function tE(r, t) {
  eE(t).updateCommon(r, t), D4(r, t)
}
function eE(r) {
  return L_[r.__brushOption.brushType]
}
function nE(r, t, e) {
  var n = r._panels
  if (!n) return Ku
  var i,
    a = r._transform
  return (
    R(n, function (o) {
      o.isTargetByCursor(t, e, a) && (i = o)
    }),
    i
  )
}
function P4(r, t) {
  var e = r._panels
  if (!e) return Ku
  var n = t.__brushOption.panelId
  return n != null ? e[n] : Ku
}
function Ww(r) {
  var t = r._covers,
    e = t.length
  return (
    R(
      t,
      function (n) {
        r.group.remove(n)
      },
      r,
    ),
    (t.length = 0),
    !!e
  )
}
function ju(r, t) {
  var e = st(r._covers, function (n) {
    var i = n.__brushOption,
      a = Vt(i.range)
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: a,
    }
  })
  r.trigger('brush', {
    areas: e,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick,
  })
}
function opt(r) {
  var t = r._track
  if (!t.length) return !1
  var e = t[t.length - 1],
    n = t[0],
    i = e[0] - n[0],
    a = e[1] - n[1],
    o = Jdt(i * i + a * a, 0.5)
  return o > tpt
}
function R4(r) {
  var t = r.length - 1
  return t < 0 && (t = 0), [r[0], r[t]]
}
function I4(r, t, e, n) {
  var i = new Ht()
  return (
    i.add(
      new ge({
        name: 'main',
        style: rE(e),
        silent: !0,
        draggable: !0,
        cursor: 'move',
        drift: Zt(lN, r, t, i, ['n', 's', 'w', 'e']),
        ondragend: Zt(ju, t, {
          isEnd: !0,
        }),
      }),
    ),
    R(n, function (a) {
      i.add(
        new ge({
          name: a.join(''),
          style: {
            opacity: 0,
          },
          draggable: !0,
          silent: !0,
          invisible: !0,
          drift: Zt(lN, r, t, i, a),
          ondragend: Zt(ju, t, {
            isEnd: !0,
          }),
        }),
      )
    }),
    i
  )
}
function O4(r, t, e, n) {
  var i = n.brushStyle.lineWidth || 0,
    a = lf(i, ept),
    o = e[0][0],
    s = e[1][0],
    l = o - i / 2,
    u = s - i / 2,
    c = e[0][1],
    h = e[1][1],
    f = c - a + i / 2,
    d = h - a + i / 2,
    p = c - o,
    g = h - s,
    v = p + i,
    m = g + i
  Lo(r, t, 'main', o, s, p, g),
    n.transformable &&
      (Lo(r, t, 'w', l, u, a, m),
      Lo(r, t, 'e', f, u, a, m),
      Lo(r, t, 'n', l, u, v, a),
      Lo(r, t, 's', l, d, v, a),
      Lo(r, t, 'nw', l, u, a, a),
      Lo(r, t, 'ne', f, u, a, a),
      Lo(r, t, 'sw', l, d, a, a),
      Lo(r, t, 'se', f, d, a, a))
}
function Xw(r, t) {
  var e = t.__brushOption,
    n = e.transformable,
    i = t.childAt(0)
  i.useStyle(rE(e)),
    i.attr({
      silent: !n,
      cursor: n ? 'move' : 'default',
    }),
    R(
      [
        ['w'],
        ['e'],
        ['n'],
        ['s'],
        ['s', 'e'],
        ['s', 'w'],
        ['n', 'e'],
        ['n', 'w'],
      ],
      function (a) {
        var o = t.childOfName(a.join('')),
          s = a.length === 1 ? Yw(r, a[0]) : lpt(r, a)
        o &&
          o.attr({
            silent: !n,
            invisible: !n,
            cursor: n ? rpt[s] + '-resize' : null,
          })
      },
    )
}
function Lo(r, t, e, n, i, a, o) {
  var s = t.childOfName(e)
  s &&
    s.setShape(
      cpt(
        iE(r, t, [
          [n, i],
          [n + a, i + o],
        ]),
      ),
    )
}
function rE(r) {
  return zt(
    {
      strokeNoScale: !0,
    },
    r.brushStyle,
  )
}
function N4(r, t, e, n) {
  var i = [ov(r, e), ov(t, n)],
    a = [lf(r, e), lf(t, n)]
  return [
    [i[0], a[0]],
    [i[1], a[1]],
  ]
}
function spt(r) {
  return Nu(r.group)
}
function Yw(r, t) {
  var e = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom',
    },
    n = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's',
    },
    i = s_(e[t], spt(r))
  return n[i]
}
function lpt(r, t) {
  var e = [Yw(r, t[0]), Yw(r, t[1])]
  return (e[0] === 'e' || e[0] === 'w') && e.reverse(), e.join('')
}
function lN(r, t, e, n, i, a) {
  var o = e.__brushOption,
    s = r.toRectRange(o.range),
    l = k4(t, i, a)
  R(n, function (u) {
    var c = npt[u]
    s[c[0]][c[1]] += l[c[0]]
  }),
    (o.range = r.fromRectRange(N4(s[0][0], s[1][0], s[0][1], s[1][1]))),
    tE(t, e),
    ju(t, {
      isEnd: !1,
    })
}
function upt(r, t, e, n) {
  var i = t.__brushOption.range,
    a = k4(r, e, n)
  R(i, function (o) {
    ;(o[0] += a[0]), (o[1] += a[1])
  }),
    tE(r, t),
    ju(r, {
      isEnd: !1,
    })
}
function k4(r, t, e) {
  var n = r.group,
    i = n.transformCoordToLocal(t, e),
    a = n.transformCoordToLocal(0, 0)
  return [i[0] - a[0], i[1] - a[1]]
}
function iE(r, t, e) {
  var n = P4(r, t)
  return n && n !== Ku ? n.clipPath(e, r._transform) : Vt(e)
}
function cpt(r) {
  var t = ov(r[0][0], r[1][0]),
    e = ov(r[0][1], r[1][1]),
    n = lf(r[0][0], r[1][0]),
    i = lf(r[0][1], r[1][1])
  return {
    x: t,
    y: e,
    width: n - t,
    height: i - e,
  }
}
function hpt(r, t, e) {
  if (!(!r._brushType || dpt(r, t.offsetX, t.offsetY))) {
    var n = r._zr,
      i = r._covers,
      a = nE(r, t, e)
    if (!r._dragging)
      for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption
        if (
          a &&
          (a === Ku || s.panelId === a.panelId) &&
          L_[s.brushType].contain(i[o], e[0], e[1])
        )
          return
      }
    a && n.setCursorStyle('crosshair')
  }
}
function $w(r) {
  var t = r.event
  t.preventDefault && t.preventDefault()
}
function qw(r, t, e) {
  return r.childOfName('main').contain(t, e)
}
function B4(r, t, e, n) {
  var i = r._creatingCover,
    a = r._creatingPanel,
    o = r._brushOption,
    s
  if ((r._track.push(e.slice()), opt(r) || i)) {
    if (a && !i) {
      o.brushMode === 'single' && Ww(r)
      var l = Vt(o)
      ;(l.brushType = uN(l.brushType, a)),
        (l.panelId = a === Ku ? null : a.panelId),
        (i = r._creatingCover = C4(r, l)),
        r._covers.push(i)
    }
    if (i) {
      var u = L_[uN(r._brushType, a)],
        c = i.__brushOption
      ;(c.range = u.getCreatingRange(iE(r, i, r._track))),
        n && (E4(r, i), u.updateCommon(r, i)),
        D4(r, i),
        (s = {
          isEnd: n,
        })
    }
  } else
    n &&
      o.brushMode === 'single' &&
      o.removeOnClick &&
      nE(r, t, e) &&
      Ww(r) &&
      (s = {
        isEnd: n,
        removeOnClick: !0,
      })
  return s
}
function uN(r, t) {
  return r === 'auto' ? t.defaultBrushType : r
}
var fpt = {
  mousedown: function (r) {
    if (this._dragging) cN(this, r)
    else if (!r.target || !r.target.draggable) {
      $w(r)
      var t = this.group.transformCoordToLocal(r.offsetX, r.offsetY)
      this._creatingCover = null
      var e = (this._creatingPanel = nE(this, r, t))
      e && ((this._dragging = !0), (this._track = [t.slice()]))
    }
  },
  mousemove: function (r) {
    var t = r.offsetX,
      e = r.offsetY,
      n = this.group.transformCoordToLocal(t, e)
    if ((hpt(this, r, n), this._dragging)) {
      $w(r)
      var i = B4(this, r, n, !1)
      i && ju(this, i)
    }
  },
  mouseup: function (r) {
    cN(this, r)
  },
}
function cN(r, t) {
  if (r._dragging) {
    $w(t)
    var e = t.offsetX,
      n = t.offsetY,
      i = r.group.transformCoordToLocal(e, n),
      a = B4(r, t, i, !0)
    ;(r._dragging = !1),
      (r._track = []),
      (r._creatingCover = null),
      a && ju(r, a)
  }
}
function dpt(r, t, e) {
  var n = r._zr
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight()
}
var L_ = {
  lineX: hN(0),
  lineY: hN(1),
  rect: {
    createCover: function (r, t) {
      function e(n) {
        return n
      }
      return I4(
        {
          toRectRange: e,
          fromRectRange: e,
        },
        r,
        t,
        [
          ['w'],
          ['e'],
          ['n'],
          ['s'],
          ['s', 'e'],
          ['s', 'w'],
          ['n', 'e'],
          ['n', 'w'],
        ],
      )
    },
    getCreatingRange: function (r) {
      var t = R4(r)
      return N4(t[1][0], t[1][1], t[0][0], t[0][1])
    },
    updateCoverShape: function (r, t, e, n) {
      O4(r, t, e, n)
    },
    updateCommon: Xw,
    contain: qw,
  },
  polygon: {
    createCover: function (r, t) {
      var e = new Ht()
      return (
        e.add(
          new li({
            name: 'main',
            style: rE(t),
            silent: !0,
          }),
        ),
        e
      )
    },
    getCreatingRange: function (r) {
      return r
    },
    endCreating: function (r, t) {
      t.remove(t.childAt(0)),
        t.add(
          new si({
            name: 'main',
            draggable: !0,
            drift: Zt(upt, r, t),
            ondragend: Zt(ju, r, {
              isEnd: !0,
            }),
          }),
        )
    },
    updateCoverShape: function (r, t, e, n) {
      t.childAt(0).setShape({
        points: iE(r, t, e),
      })
    },
    updateCommon: Xw,
    contain: qw,
  },
}
function hN(r) {
  return {
    createCover: function (t, e) {
      return I4(
        {
          toRectRange: function (n) {
            var i = [n, [0, 100]]
            return r && i.reverse(), i
          },
          fromRectRange: function (n) {
            return n[r]
          },
        },
        t,
        e,
        [
          [['w'], ['e']],
          [['n'], ['s']],
        ][r],
      )
    },
    getCreatingRange: function (t) {
      var e = R4(t),
        n = ov(e[0][r], e[1][r]),
        i = lf(e[0][r], e[1][r])
      return [n, i]
    },
    updateCoverShape: function (t, e, n, i) {
      var a,
        o = P4(t, e)
      if (o !== Ku && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r)
      else {
        var s = t._zr
        a = [0, [s.getWidth(), s.getHeight()][1 - r]]
      }
      var l = [n, a]
      r && l.reverse(), O4(t, e, l, i)
    },
    updateCommon: Xw,
    contain: qw,
  }
}
const aE = apt
function F4(r) {
  return (
    (r = oE(r)),
    function (t) {
      return zU(t, r)
    }
  )
}
function z4(r, t) {
  return (
    (r = oE(r)),
    function (e) {
      var n = t ?? e,
        i = n ? r.width : r.height,
        a = n ? r.x : r.y
      return [a, a + (i || 0)]
    }
  )
}
function U4(r, t, e) {
  var n = oE(r)
  return function (i, a) {
    return n.contain(a[0], a[1]) && !T_(i, t, e)
  }
}
function oE(r) {
  return ee.create(r)
}
var ppt = ['axisLine', 'axisTickLabel', 'axisName'],
  vpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        r.prototype.init.apply(this, arguments),
          (this._brushController = new aE(n.getZr())).on(
            'brush',
            Tt(this._onBrush, this),
          )
      }),
      (t.prototype.render = function (e, n, i, a) {
        if (!gpt(e, n, a)) {
          ;(this.axisModel = e), (this.api = i), this.group.removeAll()
          var o = this._axisGroup
          if (
            ((this._axisGroup = new Ht()),
            this.group.add(this._axisGroup),
            !!e.get('show'))
          ) {
            var s = ypt(e, n),
              l = s.coordinateSystem,
              u = e.getAreaSelectStyle(),
              c = u.width,
              h = e.axis.dim,
              f = l.getAxisLayout(h),
              d = Q(
                {
                  strokeContainThreshold: c,
                },
                f,
              ),
              p = new ns(e, d)
            R(ppt, p.add, p),
              this._axisGroup.add(p.getGroup()),
              this._refreshBrushController(d, u, e, s, c, i),
              xv(o, this._axisGroup, e)
          }
        }
      }),
      (t.prototype._refreshBrushController = function (e, n, i, a, o, s) {
        var l = i.axis.getExtent(),
          u = l[1] - l[0],
          c = Math.min(30, Math.abs(u) * 0.1),
          h = ee.create({
            x: l[0],
            y: -o / 2,
            width: u,
            height: o,
          })
        ;(h.x -= c),
          (h.width += 2 * c),
          this._brushController
            .mount({
              enableGlobalPan: !0,
              rotation: e.rotation,
              x: e.position[0],
              y: e.position[1],
            })
            .setPanels([
              {
                panelId: 'pl',
                clipPath: F4(h),
                isTargetByCursor: U4(h, s, a),
                getLinearBrushOtherExtent: z4(h, 0),
              },
            ])
            .enableBrush({
              brushType: 'lineX',
              brushStyle: n,
              removeOnClick: !0,
            })
            .updateCovers(mpt(i))
      }),
      (t.prototype._onBrush = function (e) {
        var n = e.areas,
          i = this.axisModel,
          a = i.axis,
          o = st(n, function (s) {
            return [
              a.coordToData(s.range[0], !0),
              a.coordToData(s.range[1], !0),
            ]
          })
        ;(!i.option.realtime === e.isEnd || e.removeOnClick) &&
          this.api.dispatchAction({
            type: 'axisAreaSelect',
            parallelAxisId: i.id,
            intervals: o,
          })
      }),
      (t.prototype.dispose = function () {
        this._brushController.dispose()
      }),
      (t.type = 'parallelAxis'),
      t
    )
  })(dn)
function gpt(r, t, e) {
  return (
    e &&
    e.type === 'axisAreaSelect' &&
    t.findComponents({
      mainType: 'parallelAxis',
      query: e,
    })[0] === r
  )
}
function mpt(r) {
  var t = r.axis
  return st(r.activeIntervals, function (e) {
    return {
      brushType: 'lineX',
      panelId: 'pl',
      range: [t.dataToCoord(e[0], !0), t.dataToCoord(e[1], !0)],
    }
  })
}
function ypt(r, t) {
  return t.getComponent('parallel', r.get('parallelIndex'))
}
const _pt = vpt
var xpt = {
  type: 'axisAreaSelect',
  event: 'axisAreaSelected',
}
function Spt(r) {
  r.registerAction(xpt, function (t, e) {
    e.eachComponent(
      {
        mainType: 'parallelAxis',
        query: t,
      },
      function (n) {
        n.axis.model.setActiveIntervals(t.intervals)
      },
    )
  }),
    r.registerAction('parallelAxisExpand', function (t, e) {
      e.eachComponent(
        {
          mainType: 'parallel',
          query: t,
        },
        function (n) {
          n.setAxisExpand(t)
        },
      )
    })
}
var Apt = {
  type: 'value',
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: 'rgba(160,197,232)',
    color: 'rgba(160,197,232)',
    opacity: 0.3,
  },
  realtime: !0,
  z: 10,
}
function V4(r) {
  r.registerComponentView(Fdt),
    r.registerComponentModel(Udt),
    r.registerCoordinateSystem('parallel', jdt),
    r.registerPreprocessor(Rdt),
    r.registerComponentModel(aN),
    r.registerComponentView(_pt),
    sf(r, 'parallel', aN, Apt),
    Spt(r)
}
function bpt(r) {
  ie(V4),
    r.registerChartView(wdt),
    r.registerSeriesModel(Edt),
    r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Pdt)
}
var wpt = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.cpx1 = 0),
        (this.cpy1 = 0),
        (this.cpx2 = 0),
        (this.cpy2 = 0),
        (this.extent = 0)
    }
    return r
  })(),
  Mpt = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new wpt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.extent
        e.moveTo(n.x1, n.y1),
          e.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2),
          n.orient === 'vertical'
            ? (e.lineTo(n.x2 + i, n.y2),
              e.bezierCurveTo(
                n.cpx2 + i,
                n.cpy2,
                n.cpx1 + i,
                n.cpy1,
                n.x1 + i,
                n.y1,
              ))
            : (e.lineTo(n.x2, n.y2 + i),
              e.bezierCurveTo(
                n.cpx2,
                n.cpy2 + i,
                n.cpx1,
                n.cpy1 + i,
                n.x1,
                n.y1 + i,
              )),
          e.closePath()
      }),
      (t.prototype.highlight = function () {
        Qo(this)
      }),
      (t.prototype.downplay = function () {
        ts(this)
      }),
      t
    )
  })(oe),
  Tpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._focusAdjacencyDisabled = !1), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this,
          o = e.getGraph(),
          s = this.group,
          l = e.layoutInfo,
          u = l.width,
          c = l.height,
          h = e.getData(),
          f = e.getData('edge'),
          d = e.get('orient')
        ;(this._model = e),
          s.removeAll(),
          (s.x = l.x),
          (s.y = l.y),
          o.eachEdge(function (p) {
            var g = new Mpt(),
              v = Wt(g)
            ;(v.dataIndex = p.dataIndex),
              (v.seriesIndex = e.seriesIndex),
              (v.dataType = 'edge')
            var m = p.getModel(),
              y = m.getModel('lineStyle'),
              _ = y.get('curveness'),
              x = p.node1.getLayout(),
              A = p.node1.getModel(),
              S = A.get('localX'),
              b = A.get('localY'),
              T = p.node2.getLayout(),
              w = p.node2.getModel(),
              M = w.get('localX'),
              C = w.get('localY'),
              E = p.getLayout(),
              D,
              P,
              L,
              I,
              F,
              k,
              V,
              H
            ;(g.shape.extent = Math.max(1, E.dy)),
              (g.shape.orient = d),
              d === 'vertical'
                ? ((D = (S != null ? S * u : x.x) + E.sy),
                  (P = (b != null ? b * c : x.y) + x.dy),
                  (L = (M != null ? M * u : T.x) + E.ty),
                  (I = C != null ? C * c : T.y),
                  (F = D),
                  (k = P * (1 - _) + I * _),
                  (V = L),
                  (H = P * _ + I * (1 - _)))
                : ((D = (S != null ? S * u : x.x) + x.dx),
                  (P = (b != null ? b * c : x.y) + E.sy),
                  (L = M != null ? M * u : T.x),
                  (I = (C != null ? C * c : T.y) + E.ty),
                  (F = D * (1 - _) + L * _),
                  (k = P),
                  (V = D * _ + L * (1 - _)),
                  (H = I)),
              g.setShape({
                x1: D,
                y1: P,
                x2: L,
                y2: I,
                cpx1: F,
                cpy1: k,
                cpx2: V,
                cpy2: H,
              }),
              g.useStyle(y.getItemStyle()),
              fN(g.style, d, p)
            var Y = '' + m.get('value'),
              K = Zn(m, 'edgeLabel')
            mr(g, K, {
              labelFetcher: {
                getFormattedLabel: function (Z, ft, lt, ct, At, gt) {
                  return e.getFormattedLabel(
                    Z,
                    ft,
                    'edge',
                    ct,
                    ao(At, K.normal && K.normal.get('formatter'), Y),
                    gt,
                  )
                },
              },
              labelDataIndex: p.dataIndex,
              defaultText: Y,
            }),
              g.setTextConfig({
                position: 'inside',
              })
            var ut = m.getModel('emphasis')
            gr(g, m, 'lineStyle', function (Z) {
              var ft = Z.getItemStyle()
              return fN(ft, d, p), ft
            }),
              s.add(g),
              f.setItemGraphicEl(p.dataIndex, g)
            var W = ut.get('focus')
            fn(
              g,
              W === 'adjacency'
                ? p.getAdjacentDataIndices()
                : W === 'trajectory'
                ? p.getTrajectoryDataIndices()
                : W,
              ut.get('blurScope'),
              ut.get('disabled'),
            )
          }),
          o.eachNode(function (p) {
            var g = p.getLayout(),
              v = p.getModel(),
              m = v.get('localX'),
              y = v.get('localY'),
              _ = v.getModel('emphasis'),
              x = v.get(['itemStyle', 'borderRadius']) || 0,
              A = new ge({
                shape: {
                  x: m != null ? m * u : g.x,
                  y: y != null ? y * c : g.y,
                  width: g.dx,
                  height: g.dy,
                  r: x,
                },
                style: v.getModel('itemStyle').getItemStyle(),
                z2: 10,
              })
            mr(A, Zn(v), {
              labelFetcher: {
                getFormattedLabel: function (b, T) {
                  return e.getFormattedLabel(b, T, 'node')
                },
              },
              labelDataIndex: p.dataIndex,
              defaultText: p.id,
            }),
              (A.disableLabelAnimation = !0),
              A.setStyle('fill', p.getVisual('color')),
              A.setStyle('decal', p.getVisual('style').decal),
              gr(A, v),
              s.add(A),
              h.setItemGraphicEl(p.dataIndex, A),
              (Wt(A).dataType = 'node')
            var S = _.get('focus')
            fn(
              A,
              S === 'adjacency'
                ? p.getAdjacentDataIndices()
                : S === 'trajectory'
                ? p.getTrajectoryDataIndices()
                : S,
              _.get('blurScope'),
              _.get('disabled'),
            )
          }),
          h.eachItemGraphicEl(function (p, g) {
            var v = h.getItemModel(g)
            v.get('draggable') &&
              ((p.drift = function (m, y) {
                ;(a._focusAdjacencyDisabled = !0),
                  (this.shape.x += m),
                  (this.shape.y += y),
                  this.dirty(),
                  i.dispatchAction({
                    type: 'dragNode',
                    seriesId: e.id,
                    dataIndex: h.getRawIndex(g),
                    localX: this.shape.x / u,
                    localY: this.shape.y / c,
                  })
              }),
              (p.ondragend = function () {
                a._focusAdjacencyDisabled = !1
              }),
              (p.draggable = !0),
              (p.cursor = 'move'))
          }),
          !this._data &&
            e.isAnimationEnabled() &&
            s.setClipPath(
              Cpt(s.getBoundingRect(), e, function () {
                s.removeClipPath()
              }),
            ),
          (this._data = e.getData())
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'sankey'),
      t
    )
  })(Ze)
function fN(r, t, e) {
  switch (r.fill) {
    case 'source':
      ;(r.fill = e.node1.getVisual('color')),
        (r.decal = e.node1.getVisual('style').decal)
      break
    case 'target':
      ;(r.fill = e.node2.getVisual('color')),
        (r.decal = e.node2.getVisual('style').decal)
      break
    case 'gradient':
      var n = e.node1.getVisual('color'),
        i = e.node2.getVisual('color')
      bt(n) &&
        bt(i) &&
        (r.fill = new He(0, 0, +(t === 'horizontal'), +(t === 'vertical'), [
          {
            color: n,
            offset: 0,
          },
          {
            color: i,
            offset: 1,
          },
        ]))
  }
}
function Cpt(r, t, e) {
  var n = new ge({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20,
    },
  })
  return (
    Je(
      n,
      {
        shape: {
          width: r.width + 20,
        },
      },
      t,
      e,
    ),
    n
  )
}
const Ept = Tpt
var Dpt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = e.edges || e.links,
        a = e.data || e.nodes,
        o = e.levels
      this.levelModels = []
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        o[l].depth != null &&
          o[l].depth >= 0 &&
          (s[o[l].depth] = new qe(o[l], this, n))
      if (a && i) {
        var u = A4(a, i, this, !0, c)
        return u.data
      }
      function c(h, f) {
        h.wrapMethod('getItemModel', function (d, p) {
          var g = d.parentModel,
            v = g.getData().getItemLayout(p)
          if (v) {
            var m = v.depth,
              y = g.levelModels[m]
            y && (d.parentModel = y)
          }
          return d
        }),
          f.wrapMethod('getItemModel', function (d, p) {
            var g = d.parentModel,
              v = g.getGraph().getEdgeByIndex(p),
              m = v.node1.getLayout()
            if (m) {
              var y = m.depth,
                _ = g.levelModels[y]
              _ && (d.parentModel = _)
            }
            return d
          })
      }
    }),
    (t.prototype.setNodePosition = function (e, n) {
      var i = this.option.data || this.option.nodes,
        a = i[e]
      ;(a.localX = n[0]), (a.localY = n[1])
    }),
    (t.prototype.getGraph = function () {
      return this.getData().graph
    }),
    (t.prototype.getEdgeData = function () {
      return this.getGraph().edgeData
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      function a(d) {
        return isNaN(d) || d == null
      }
      if (i === 'edge') {
        var o = this.getDataParams(e, i),
          s = o.data,
          l = o.value,
          u = s.source + ' -- ' + s.target
        return Kn('nameValue', {
          name: u,
          value: l,
          noValue: a(l),
        })
      } else {
        var c = this.getGraph().getNodeByIndex(e),
          h = c.getLayout().value,
          f = this.getDataParams(e, i).data.name
        return Kn('nameValue', {
          name: f != null ? f + '' : null,
          value: h,
          noValue: a(h),
        })
      }
    }),
    (t.prototype.optionUpdated = function () {}),
    (t.prototype.getDataParams = function (e, n) {
      var i = r.prototype.getDataParams.call(this, e, n)
      if (i.value == null && n === 'node') {
        var a = this.getGraph().getNodeByIndex(e),
          o = a.getLayout().value
        i.value = o
      }
      return i
    }),
    (t.type = 'series.sankey'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      left: '5%',
      top: '5%',
      right: '20%',
      bottom: '5%',
      orient: 'horizontal',
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: 'right',
        fontSize: 12,
      },
      edgeLabel: {
        show: !1,
        fontSize: 12,
      },
      levels: [],
      nodeAlign: 'justify',
      lineStyle: {
        color: '#314656',
        opacity: 0.2,
        curveness: 0.5,
      },
      emphasis: {
        label: {
          show: !0,
        },
        lineStyle: {
          opacity: 0.5,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      animationEasing: 'linear',
      animationDuration: 1e3,
    }),
    t
  )
})(rn)
const Lpt = Dpt
function Ppt(r, t) {
  r.eachSeriesByType('sankey', function (e) {
    var n = e.get('nodeWidth'),
      i = e.get('nodeGap'),
      a = Rpt(e, t)
    e.layoutInfo = a
    var o = a.width,
      s = a.height,
      l = e.getGraph(),
      u = l.nodes,
      c = l.edges
    Opt(u)
    var h = Ne(u, function (g) {
        return g.getLayout().value === 0
      }),
      f = h.length !== 0 ? 0 : e.get('layoutIterations'),
      d = e.get('orient'),
      p = e.get('nodeAlign')
    Ipt(u, c, n, i, o, s, f, d, p)
  })
}
function Rpt(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function Ipt(r, t, e, n, i, a, o, s, l) {
  Npt(r, t, e, i, a, s, l), zpt(r, t, a, i, n, o, s), qpt(r, s)
}
function Opt(r) {
  R(r, function (t) {
    var e = Qs(t.outEdges, m0),
      n = Qs(t.inEdges, m0),
      i = t.getValue() || 0,
      a = Math.max(e, n, i)
    t.setLayout(
      {
        value: a,
      },
      !0,
    )
  })
}
function Npt(r, t, e, n, i, a, o) {
  for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < t.length; f++)
    s[f] = 1
  for (var f = 0; f < r.length; f++)
    (l[f] = r[f].inEdges.length), l[f] === 0 && u.push(r[f])
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p],
        v = g.hostGraph.data.getRawDataItem(g.dataIndex),
        m = v.depth != null && v.depth >= 0
      m && v.depth > d && (d = v.depth),
        g.setLayout(
          {
            depth: m ? v.depth : h,
          },
          !0,
        ),
        a === 'vertical'
          ? g.setLayout(
              {
                dy: e,
              },
              !0,
            )
          : g.setLayout(
              {
                dx: e,
              },
              !0,
            )
      for (var y = 0; y < g.outEdges.length; y++) {
        var _ = g.outEdges[y],
          x = t.indexOf(_)
        s[x] = 0
        var A = _.node2,
          S = r.indexOf(A)
        --l[S] === 0 && c.indexOf(A) < 0 && c.push(A)
      }
    }
    ++h, (u = c), (c = [])
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error('Sankey is a DAG, the original data has cycle!')
  var b = d > h - 1 ? d : h - 1
  o && o !== 'left' && kpt(r, o, a, b)
  var T = a === 'vertical' ? (i - e) / b : (n - e) / b
  Fpt(r, T, a)
}
function G4(r) {
  var t = r.hostGraph.data.getRawDataItem(r.dataIndex)
  return t.depth != null && t.depth >= 0
}
function kpt(r, t, e, n) {
  if (t === 'right') {
    for (var i = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s]
        l.setLayout(
          {
            skNodeHeight: o,
          },
          !0,
        )
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u]
          i.indexOf(c.node1) < 0 && i.push(c.node1)
        }
      }
      ;(a = i), (i = []), ++o
    }
    R(r, function (h) {
      G4(h) ||
        h.setLayout(
          {
            depth: Math.max(0, n - h.getLayout().skNodeHeight),
          },
          !0,
        )
    })
  } else t === 'justify' && Bpt(r, n)
}
function Bpt(r, t) {
  R(r, function (e) {
    !G4(e) &&
      !e.outEdges.length &&
      e.setLayout(
        {
          depth: t,
        },
        !0,
      )
  })
}
function Fpt(r, t, e) {
  R(r, function (n) {
    var i = n.getLayout().depth * t
    e === 'vertical'
      ? n.setLayout(
          {
            y: i,
          },
          !0,
        )
      : n.setLayout(
          {
            x: i,
          },
          !0,
        )
  })
}
function zpt(r, t, e, n, i, a, o) {
  var s = Upt(r, o)
  Vpt(s, t, e, n, i, o), RS(s, i, e, n, o)
  for (var l = 1; a > 0; a--)
    (l *= 0.99),
      Gpt(s, l, o),
      RS(s, i, e, n, o),
      $pt(s, l, o),
      RS(s, i, e, n, o)
}
function Upt(r, t) {
  var e = [],
    n = t === 'vertical' ? 'y' : 'x',
    i = jb(r, function (a) {
      return a.getLayout()[n]
    })
  return (
    i.keys.sort(function (a, o) {
      return a - o
    }),
    R(i.keys, function (a) {
      e.push(i.buckets.get(a))
    }),
    e
  )
}
function Vpt(r, t, e, n, i, a) {
  var o = 1 / 0
  R(r, function (s) {
    var l = s.length,
      u = 0
    R(s, function (h) {
      u += h.getLayout().value
    })
    var c = a === 'vertical' ? (n - (l - 1) * i) / u : (e - (l - 1) * i) / u
    c < o && (o = c)
  }),
    R(r, function (s) {
      R(s, function (l, u) {
        var c = l.getLayout().value * o
        a === 'vertical'
          ? (l.setLayout(
              {
                x: u,
              },
              !0,
            ),
            l.setLayout(
              {
                dx: c,
              },
              !0,
            ))
          : (l.setLayout(
              {
                y: u,
              },
              !0,
            ),
            l.setLayout(
              {
                dy: c,
              },
              !0,
            ))
      })
    }),
    R(t, function (s) {
      var l = +s.getValue() * o
      s.setLayout(
        {
          dy: l,
        },
        !0,
      )
    })
}
function RS(r, t, e, n, i) {
  var a = i === 'vertical' ? 'x' : 'y'
  R(r, function (o) {
    o.sort(function (g, v) {
      return g.getLayout()[a] - v.getLayout()[a]
    })
    for (
      var s,
        l,
        u,
        c = 0,
        h = o.length,
        f = i === 'vertical' ? 'dx' : 'dy',
        d = 0;
      d < h;
      d++
    )
      (l = o[d]),
        (u = c - l.getLayout()[a]),
        u > 0 &&
          ((s = l.getLayout()[a] + u),
          i === 'vertical'
            ? l.setLayout(
                {
                  x: s,
                },
                !0,
              )
            : l.setLayout(
                {
                  y: s,
                },
                !0,
              )),
        (c = l.getLayout()[a] + l.getLayout()[f] + t)
    var p = i === 'vertical' ? n : e
    if (((u = c - t - p), u > 0)) {
      ;(s = l.getLayout()[a] - u),
        i === 'vertical'
          ? l.setLayout(
              {
                x: s,
              },
              !0,
            )
          : l.setLayout(
              {
                y: s,
              },
              !0,
            ),
        (c = s)
      for (var d = h - 2; d >= 0; --d)
        (l = o[d]),
          (u = l.getLayout()[a] + l.getLayout()[f] + t - c),
          u > 0 &&
            ((s = l.getLayout()[a] - u),
            i === 'vertical'
              ? l.setLayout(
                  {
                    x: s,
                  },
                  !0,
                )
              : l.setLayout(
                  {
                    y: s,
                  },
                  !0,
                )),
          (c = l.getLayout()[a])
    }
  })
}
function Gpt(r, t, e) {
  R(r.slice().reverse(), function (n) {
    R(n, function (i) {
      if (i.outEdges.length) {
        var a = Qs(i.outEdges, Hpt, e) / Qs(i.outEdges, m0)
        if (isNaN(a)) {
          var o = i.outEdges.length
          a = o ? Qs(i.outEdges, Wpt, e) / o : 0
        }
        if (e === 'vertical') {
          var s = i.getLayout().x + (a - ul(i, e)) * t
          i.setLayout(
            {
              x: s,
            },
            !0,
          )
        } else {
          var l = i.getLayout().y + (a - ul(i, e)) * t
          i.setLayout(
            {
              y: l,
            },
            !0,
          )
        }
      }
    })
  })
}
function Hpt(r, t) {
  return ul(r.node2, t) * r.getValue()
}
function Wpt(r, t) {
  return ul(r.node2, t)
}
function Xpt(r, t) {
  return ul(r.node1, t) * r.getValue()
}
function Ypt(r, t) {
  return ul(r.node1, t)
}
function ul(r, t) {
  return t === 'vertical'
    ? r.getLayout().x + r.getLayout().dx / 2
    : r.getLayout().y + r.getLayout().dy / 2
}
function m0(r) {
  return r.getValue()
}
function Qs(r, t, e) {
  for (var n = 0, i = r.length, a = -1; ++a < i; ) {
    var o = +t(r[a], e)
    isNaN(o) || (n += o)
  }
  return n
}
function $pt(r, t, e) {
  R(r, function (n) {
    R(n, function (i) {
      if (i.inEdges.length) {
        var a = Qs(i.inEdges, Xpt, e) / Qs(i.inEdges, m0)
        if (isNaN(a)) {
          var o = i.inEdges.length
          a = o ? Qs(i.inEdges, Ypt, e) / o : 0
        }
        if (e === 'vertical') {
          var s = i.getLayout().x + (a - ul(i, e)) * t
          i.setLayout(
            {
              x: s,
            },
            !0,
          )
        } else {
          var l = i.getLayout().y + (a - ul(i, e)) * t
          i.setLayout(
            {
              y: l,
            },
            !0,
          )
        }
      }
    })
  })
}
function qpt(r, t) {
  var e = t === 'vertical' ? 'x' : 'y'
  R(r, function (n) {
    n.outEdges.sort(function (i, a) {
      return i.node2.getLayout()[e] - a.node2.getLayout()[e]
    }),
      n.inEdges.sort(function (i, a) {
        return i.node1.getLayout()[e] - a.node1.getLayout()[e]
      })
  }),
    R(r, function (n) {
      var i = 0,
        a = 0
      R(n.outEdges, function (o) {
        o.setLayout(
          {
            sy: i,
          },
          !0,
        ),
          (i += o.getLayout().dy)
      }),
        R(n.inEdges, function (o) {
          o.setLayout(
            {
              ty: a,
            },
            !0,
          ),
            (a += o.getLayout().dy)
        })
    })
}
function Zpt(r) {
  r.eachSeriesByType('sankey', function (t) {
    var e = t.getGraph(),
      n = e.nodes,
      i = e.edges
    if (n.length) {
      var a = 1 / 0,
        o = -1 / 0
      R(n, function (s) {
        var l = s.getLayout().value
        l < a && (a = l), l > o && (o = l)
      }),
        R(n, function (s) {
          var l = new vr({
              type: 'color',
              mappingMethod: 'linear',
              dataExtent: [a, o],
              visual: t.get('color'),
            }),
            u = l.mapValueToVisual(s.getLayout().value),
            c = s.getModel().get(['itemStyle', 'color'])
          c != null
            ? (s.setVisual('color', c),
              s.setVisual('style', {
                fill: c,
              }))
            : (s.setVisual('color', u),
              s.setVisual('style', {
                fill: u,
              }))
        })
    }
    i.length &&
      R(i, function (s) {
        var l = s.getModel().get('lineStyle')
        s.setVisual('style', l)
      })
  })
}
function Kpt(r) {
  r.registerChartView(Ept),
    r.registerSeriesModel(Lpt),
    r.registerLayout(Ppt),
    r.registerVisual(Zpt),
    r.registerAction(
      {
        type: 'dragNode',
        event: 'dragnode',
        update: 'update',
      },
      function (t, e) {
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'sankey',
            query: t,
          },
          function (n) {
            n.setNodePosition(t.dataIndex, [t.localX, t.localY])
          },
        )
      },
    )
}
var H4 = (function () {
    function r() {}
    return (
      (r.prototype.getInitialData = function (t, e) {
        var n,
          i = e.getComponent('xAxis', this.get('xAxisIndex')),
          a = e.getComponent('yAxis', this.get('yAxisIndex')),
          o = i.get('type'),
          s = a.get('type'),
          l
        o === 'category'
          ? ((t.layout = 'horizontal'), (n = i.getOrdinalMeta()), (l = !0))
          : s === 'category'
          ? ((t.layout = 'vertical'), (n = a.getOrdinalMeta()), (l = !0))
          : (t.layout = t.layout || 'horizontal')
        var u = ['x', 'y'],
          c = t.layout === 'horizontal' ? 0 : 1,
          h = (this._baseAxisDim = u[c]),
          f = u[1 - c],
          d = [i, a],
          p = d[c].get('type'),
          g = d[1 - c].get('type'),
          v = t.data
        if (v && l) {
          var m = []
          R(v, function (x, A) {
            var S
            at(x)
              ? ((S = x.slice()), x.unshift(A))
              : at(x.value)
              ? ((S = Q({}, x)),
                (S.value = S.value.slice()),
                x.value.unshift(A))
              : (S = x),
              m.push(S)
          }),
            (t.data = m)
        }
        var y = this.defaultValueDimensions,
          _ = [
            {
              name: h,
              type: a0(p),
              ordinalMeta: n,
              otherDims: {
                tooltip: !1,
                itemName: 0,
              },
              dimsDef: ['base'],
            },
            {
              name: f,
              type: a0(g),
              dimsDef: y.slice(),
            },
          ]
        return Rf(this, {
          coordDimensions: _,
          dimensionsCount: y.length + 1,
          encodeDefaulter: Zt(h5, _, this),
        })
      }),
      (r.prototype.getBaseAxis = function () {
        var t = this._baseAxisDim
        return this.ecModel.getComponent(t + 'Axis', this.get(t + 'AxisIndex'))
          .axis
      }),
      r
    )
  })(),
  W4 = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.defaultValueDimensions = [
          {
            name: 'min',
            defaultTooltip: !0,
          },
          {
            name: 'Q1',
            defaultTooltip: !0,
          },
          {
            name: 'median',
            defaultTooltip: !0,
          },
          {
            name: 'Q3',
            defaultTooltip: !0,
          },
          {
            name: 'max',
            defaultTooltip: !0,
          },
        ]),
        (e.visualDrawType = 'stroke'),
        e
      )
    }
    return (
      (t.type = 'series.boxplot'),
      (t.dependencies = ['xAxis', 'yAxis', 'grid']),
      (t.defaultOption = {
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: !0,
        layout: null,
        boxWidth: [7, 50],
        itemStyle: {
          color: '#fff',
          borderWidth: 1,
        },
        emphasis: {
          scale: !0,
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            shadowColor: 'rgba(0,0,0,0.2)',
          },
        },
        animationDuration: 800,
      }),
      t
    )
  })(rn)
In(W4, H4, !0)
const jpt = W4
var Jpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = this.group,
          s = this._data
        this._data || o.removeAll()
        var l = e.get('layout') === 'horizontal' ? 1 : 0
        a
          .diff(s)
          .add(function (u) {
            if (a.hasValue(u)) {
              var c = a.getItemLayout(u),
                h = dN(c, a, u, l, !0)
              a.setItemGraphicEl(u, h), o.add(h)
            }
          })
          .update(function (u, c) {
            var h = s.getItemGraphicEl(c)
            if (!a.hasValue(u)) {
              o.remove(h)
              return
            }
            var f = a.getItemLayout(u)
            h ? (Ca(h), X4(f, h, a, u)) : (h = dN(f, a, u, l)),
              o.add(h),
              a.setItemGraphicEl(u, h)
          })
          .remove(function (u) {
            var c = s.getItemGraphicEl(u)
            c && o.remove(c)
          })
          .execute(),
          (this._data = a)
      }),
      (t.prototype.remove = function (e) {
        var n = this.group,
          i = this._data
        ;(this._data = null),
          i &&
            i.eachItemGraphicEl(function (a) {
              a && n.remove(a)
            })
      }),
      (t.type = 'boxplot'),
      t
    )
  })(Ze),
  Qpt = (function () {
    function r() {}
    return r
  })(),
  tvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'boxplotBoxPath'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new Qpt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = 0
        for (e.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)
          e.lineTo(i[a][0], i[a][1])
        for (e.closePath(); a < i.length; a++)
          e.moveTo(i[a][0], i[a][1]), a++, e.lineTo(i[a][0], i[a][1])
      }),
      t
    )
  })(oe)
function dN(r, t, e, n, i) {
  var a = r.ends,
    o = new tvt({
      shape: {
        points: i ? evt(a, n, r) : a,
      },
    })
  return X4(r, o, t, e, i), o
}
function X4(r, t, e, n, i) {
  var a = e.hostModel,
    o = nc[i ? 'initProps' : 'updateProps']
  o(
    t,
    {
      shape: {
        points: r.ends,
      },
    },
    a,
    n,
  ),
    t.useStyle(e.getItemVisual(n, 'style')),
    (t.style.strokeNoScale = !0),
    (t.z2 = 100)
  var s = e.getItemModel(n),
    l = s.getModel('emphasis')
  gr(t, s), fn(t, l.get('focus'), l.get('blurScope'), l.get('disabled'))
}
function evt(r, t, e) {
  return st(r, function (n) {
    return (n = n.slice()), (n[t] = e.initBaseline), n
  })
}
const nvt = Jpt
var pp = R
function rvt(r) {
  var t = ivt(r)
  pp(t, function (e) {
    var n = e.seriesModels
    n.length &&
      (avt(e),
      pp(n, function (i, a) {
        ovt(i, e.boxOffsetList[a], e.boxWidthList[a])
      }))
  })
}
function ivt(r) {
  var t = [],
    e = []
  return (
    r.eachSeriesByType('boxplot', function (n) {
      var i = n.getBaseAxis(),
        a = re(e, i)
      a < 0 &&
        ((a = e.length),
        (e[a] = i),
        (t[a] = {
          axis: i,
          seriesModels: [],
        })),
        t[a].seriesModels.push(n)
    }),
    t
  )
}
function avt(r) {
  var t = r.axis,
    e = r.seriesModels,
    n = e.length,
    i = (r.boxWidthList = []),
    a = (r.boxOffsetList = []),
    o = [],
    s
  if (t.type === 'category') s = t.getBandWidth()
  else {
    var l = 0
    pp(e, function (p) {
      l = Math.max(l, p.getData().count())
    })
    var u = t.getExtent()
    s = Math.abs(u[1] - u[0]) / l
  }
  pp(e, function (p) {
    var g = p.get('boxWidth')
    at(g) || (g = [g, g]), o.push([_t(g[0], s) || 0, _t(g[1], s) || 0])
  })
  var c = s * 0.8 - 2,
    h = (c / n) * 0.3,
    f = (c - h * (n - 1)) / n,
    d = f / 2 - c / 2
  pp(e, function (p, g) {
    a.push(d), (d += h + f), i.push(Math.min(Math.max(f, o[g][0]), o[g][1]))
  })
}
function ovt(r, t, e) {
  var n = r.coordinateSystem,
    i = r.getData(),
    a = e / 2,
    o = r.get('layout') === 'horizontal' ? 0 : 1,
    s = 1 - o,
    l = ['x', 'y'],
    u = i.mapDimension(l[o]),
    c = i.mapDimensionsAll(l[s])
  if (u == null || c.length < 5) return
  for (var h = 0; h < i.count(); h++) {
    var f = i.get(u, h),
      d = _(f, c[2], h),
      p = _(f, c[0], h),
      g = _(f, c[1], h),
      v = _(f, c[3], h),
      m = _(f, c[4], h),
      y = []
    x(y, g, !1),
      x(y, v, !0),
      y.push(p, g, m, v),
      A(y, p),
      A(y, m),
      A(y, d),
      i.setItemLayout(h, {
        initBaseline: d[s],
        ends: y,
      })
  }
  function _(S, b, T) {
    var w = i.get(b, T),
      M = []
    ;(M[o] = S), (M[s] = w)
    var C
    return (
      isNaN(S) || isNaN(w)
        ? (C = [NaN, NaN])
        : ((C = n.dataToPoint(M)), (C[o] += t)),
      C
    )
  }
  function x(S, b, T) {
    var w = b.slice(),
      M = b.slice()
    ;(w[o] += a), (M[o] -= a), T ? S.push(w, M) : S.push(M, w)
  }
  function A(S, b) {
    var T = b.slice(),
      w = b.slice()
    ;(T[o] -= a), (w[o] += a), S.push(T, w)
  }
}
function svt(r, t) {
  t = t || {}
  for (
    var e = [], n = [], i = t.boundIQR, a = i === 'none' || i === 0, o = 0;
    o < r.length;
    o++
  ) {
    var s = Zi(r[o].slice()),
      l = s1(s, 0.25),
      u = s1(s, 0.5),
      c = s1(s, 0.75),
      h = s[0],
      f = s[s.length - 1],
      d = (i ?? 1.5) * (c - l),
      p = a ? h : Math.max(h, l - d),
      g = a ? f : Math.min(f, c + d),
      v = t.itemNameFormatter,
      m = Nt(v)
        ? v({
            value: o,
          })
        : bt(v)
        ? v.replace('{value}', o + '')
        : o + ''
    e.push([m, p, l, u, c, g])
    for (var y = 0; y < s.length; y++) {
      var _ = s[y]
      if (_ < p || _ > g) {
        var x = [m, _]
        n.push(x)
      }
    }
  }
  return {
    boxData: e,
    outliers: n,
  }
}
var lvt = {
  type: 'echarts:boxplot',
  transform: function (t) {
    var e = t.upstream
    if (e.sourceFormat !== Dr) {
      var n = ''
      Ce(n)
    }
    var i = svt(e.getRawData(), t.config)
    return [
      {
        dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],
        data: i.boxData,
      },
      {
        data: i.outliers,
      },
    ]
  },
}
function uvt(r) {
  r.registerSeriesModel(jpt),
    r.registerChartView(nvt),
    r.registerLayout(rvt),
    r.registerTransform(lvt)
}
var cvt = ['color', 'borderColor'],
  hvt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        this.group.removeClipPath(),
          (this._progressiveEls = null),
          this._updateDrawMode(e),
          this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e)
      }),
      (t.prototype.incrementalPrepareRender = function (e, n, i) {
        this._clear(), this._updateDrawMode(e)
      }),
      (t.prototype.incrementalRender = function (e, n, i, a) {
        ;(this._progressiveEls = []),
          this._isLargeDraw
            ? this._incrementalRenderLarge(e, n)
            : this._incrementalRenderNormal(e, n)
      }),
      (t.prototype.eachRendered = function (e) {
        vl(this._progressiveEls || this.group, e)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var n = e.pipelineContext.large
        ;(this._isLargeDraw == null || n !== this._isLargeDraw) &&
          ((this._isLargeDraw = n), this._clear())
      }),
      (t.prototype._renderNormal = function (e) {
        var n = e.getData(),
          i = this._data,
          a = this.group,
          o = n.getLayout('isSimpleBox'),
          s = e.get('clip', !0),
          l = e.coordinateSystem,
          u = l.getArea && l.getArea()
        this._data || a.removeAll(),
          n
            .diff(i)
            .add(function (c) {
              if (n.hasValue(c)) {
                var h = n.getItemLayout(c)
                if (s && pN(u, h)) return
                var f = IS(h, c, !0)
                Je(
                  f,
                  {
                    shape: {
                      points: h.ends,
                    },
                  },
                  e,
                  c,
                ),
                  OS(f, n, c, o),
                  a.add(f),
                  n.setItemGraphicEl(c, f)
              }
            })
            .update(function (c, h) {
              var f = i.getItemGraphicEl(h)
              if (!n.hasValue(c)) {
                a.remove(f)
                return
              }
              var d = n.getItemLayout(c)
              if (s && pN(u, d)) {
                a.remove(f)
                return
              }
              f
                ? (we(
                    f,
                    {
                      shape: {
                        points: d.ends,
                      },
                    },
                    e,
                    c,
                  ),
                  Ca(f))
                : (f = IS(d)),
                OS(f, n, c, o),
                a.add(f),
                n.setItemGraphicEl(c, f)
            })
            .remove(function (c) {
              var h = i.getItemGraphicEl(c)
              h && a.remove(h)
            })
            .execute(),
          (this._data = n)
      }),
      (t.prototype._renderLarge = function (e) {
        this._clear(), vN(e, this.group)
        var n = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
        n ? this.group.setClipPath(n) : this.group.removeClipPath()
      }),
      (t.prototype._incrementalRenderNormal = function (e, n) {
        for (
          var i = n.getData(), a = i.getLayout('isSimpleBox'), o;
          (o = e.next()) != null;

        ) {
          var s = i.getItemLayout(o),
            l = IS(s)
          OS(l, i, o, a),
            (l.incremental = !0),
            this.group.add(l),
            this._progressiveEls.push(l)
        }
      }),
      (t.prototype._incrementalRenderLarge = function (e, n) {
        vN(n, this.group, this._progressiveEls, !0)
      }),
      (t.prototype.remove = function (e) {
        this._clear()
      }),
      (t.prototype._clear = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.type = 'candlestick'),
      t
    )
  })(Ze),
  fvt = (function () {
    function r() {}
    return r
  })(),
  dvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'normalCandlestickBox'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new fvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points
        this.__simpleBox
          ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1]))
          : (e.moveTo(i[0][0], i[0][1]),
            e.lineTo(i[1][0], i[1][1]),
            e.lineTo(i[2][0], i[2][1]),
            e.lineTo(i[3][0], i[3][1]),
            e.closePath(),
            e.moveTo(i[4][0], i[4][1]),
            e.lineTo(i[5][0], i[5][1]),
            e.moveTo(i[6][0], i[6][1]),
            e.lineTo(i[7][0], i[7][1]))
      }),
      t
    )
  })(oe)
function IS(r, t, e) {
  var n = r.ends
  return new dvt({
    shape: {
      points: e ? pvt(n, r) : n,
    },
    z2: 100,
  })
}
function pN(r, t) {
  for (var e = !0, n = 0; n < t.ends.length; n++)
    if (r.contain(t.ends[n][0], t.ends[n][1])) {
      e = !1
      break
    }
  return e
}
function OS(r, t, e, n) {
  var i = t.getItemModel(e)
  r.useStyle(t.getItemVisual(e, 'style')),
    (r.style.strokeNoScale = !0),
    (r.__simpleBox = n),
    gr(r, i)
}
function pvt(r, t) {
  return st(r, function (e) {
    return (e = e.slice()), (e[1] = t.initBaseline), e
  })
}
var vvt = (function () {
    function r() {}
    return r
  })(),
  NS = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'largeCandlestickBox'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new vvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        for (var i = n.points, a = 0; a < i.length; )
          if (this.__sign === i[a++]) {
            var o = i[a++]
            e.moveTo(o, i[a++]), e.lineTo(o, i[a++])
          } else a += 3
      }),
      t
    )
  })(oe)
function vN(r, t, e, n) {
  var i = r.getData(),
    a = i.getLayout('largePoints'),
    o = new NS({
      shape: {
        points: a,
      },
      __sign: 1,
      ignoreCoarsePointer: !0,
    })
  t.add(o)
  var s = new NS({
    shape: {
      points: a,
    },
    __sign: -1,
    ignoreCoarsePointer: !0,
  })
  t.add(s)
  var l = new NS({
    shape: {
      points: a,
    },
    __sign: 0,
    ignoreCoarsePointer: !0,
  })
  t.add(l),
    kS(1, o, r),
    kS(-1, s, r),
    kS(0, l, r),
    n && ((o.incremental = !0), (s.incremental = !0)),
    e && e.push(o, s)
}
function kS(r, t, e, n) {
  var i =
    e.get(['itemStyle', r > 0 ? 'borderColor' : 'borderColor0']) ||
    e.get(['itemStyle', r > 0 ? 'color' : 'color0'])
  r === 0 && (i = e.get(['itemStyle', 'borderColorDoji']))
  var a = e.getModel('itemStyle').getItemStyle(cvt)
  t.useStyle(a), (t.style.fill = null), (t.style.stroke = i)
}
const gvt = hvt
var Y4 = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.defaultValueDimensions = [
        {
          name: 'open',
          defaultTooltip: !0,
        },
        {
          name: 'close',
          defaultTooltip: !0,
        },
        {
          name: 'lowest',
          defaultTooltip: !0,
        },
        {
          name: 'highest',
          defaultTooltip: !0,
        },
      ]),
      e
    )
  }
  return (
    (t.prototype.getShadowDim = function () {
      return 'open'
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      var a = n.getItemLayout(e)
      return a && i.rect(a.brushRect)
    }),
    (t.type = 'series.candlestick'),
    (t.dependencies = ['xAxis', 'yAxis', 'grid']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: '#eb5454',
        color0: '#47b262',
        borderColor: '#eb5454',
        borderColor0: '#47b262',
        borderColorDoji: null,
        borderWidth: 1,
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
        },
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: 'mod',
      animationEasing: 'linear',
      animationDuration: 300,
    }),
    t
  )
})(rn)
In(Y4, H4, !0)
const mvt = Y4
function yvt(r) {
  !r ||
    !at(r.series) ||
    R(r.series, function (t) {
      Ut(t) && t.type === 'k' && (t.type = 'candlestick')
    })
}
var _vt = ['itemStyle', 'borderColor'],
  xvt = ['itemStyle', 'borderColor0'],
  Svt = ['itemStyle', 'borderColorDoji'],
  Avt = ['itemStyle', 'color'],
  bvt = ['itemStyle', 'color0'],
  wvt = {
    seriesType: 'candlestick',
    plan: Ef(),
    performRawSeries: !0,
    reset: function (r, t) {
      function e(a, o) {
        return o.get(a > 0 ? Avt : bvt)
      }
      function n(a, o) {
        return o.get(a === 0 ? Svt : a > 0 ? _vt : xvt)
      }
      if (!t.isSeriesFiltered(r)) {
        var i = r.pipelineContext.large
        return (
          !i && {
            progress: function (a, o) {
              for (var s; (s = a.next()) != null; ) {
                var l = o.getItemModel(s),
                  u = o.getItemLayout(s).sign,
                  c = l.getItemStyle()
                ;(c.fill = e(u, l)), (c.stroke = n(u, l) || c.fill)
                var h = o.ensureUniqueItemVisual(s, 'style')
                Q(h, c)
              }
            },
          }
        )
      }
    },
  }
const Mvt = wvt
var Tvt = {
  seriesType: 'candlestick',
  plan: Ef(),
  reset: function (r) {
    var t = r.coordinateSystem,
      e = r.getData(),
      n = Cvt(r, e),
      i = 0,
      a = 1,
      o = ['x', 'y'],
      s = e.getDimensionIndex(e.mapDimension(o[i])),
      l = st(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e),
      u = l[0],
      c = l[1],
      h = l[2],
      f = l[3]
    if (
      (e.setLayout({
        candleWidth: n,
        isSimpleBox: n <= 1.3,
      }),
      s < 0 || l.length < 4)
    )
      return
    return {
      progress: r.pipelineContext.large ? p : d,
    }
    function d(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var _ = y.get(s, m),
          x = y.get(u, m),
          A = y.get(c, m),
          S = y.get(h, m),
          b = y.get(f, m),
          T = Math.min(x, A),
          w = Math.max(x, A),
          M = F(T, _),
          C = F(w, _),
          E = F(S, _),
          D = F(b, _),
          P = []
        k(P, C, 0), k(P, M, 1), P.push(H(D), H(C), H(E), H(M))
        var L = v.getItemModel(m),
          I = !!L.get(['itemStyle', 'borderColorDoji'])
        v.setItemLayout(m, {
          sign: gN(y, m, x, A, c, I),
          initBaseline: x > A ? C[a] : M[a],
          ends: P,
          brushRect: V(S, b, _),
        })
      }
      function F(Y, K) {
        var ut = []
        return (
          (ut[i] = K),
          (ut[a] = Y),
          isNaN(K) || isNaN(Y) ? [NaN, NaN] : t.dataToPoint(ut)
        )
      }
      function k(Y, K, ut) {
        var W = K.slice(),
          Z = K.slice()
        ;(W[i] = ey(W[i] + n / 2, 1, !1)),
          (Z[i] = ey(Z[i] - n / 2, 1, !0)),
          ut ? Y.push(W, Z) : Y.push(Z, W)
      }
      function V(Y, K, ut) {
        var W = F(Y, ut),
          Z = F(K, ut)
        return (
          (W[i] -= n / 2),
          (Z[i] -= n / 2),
          {
            x: W[0],
            y: W[1],
            width: n,
            height: Z[1] - W[1],
          }
        )
      }
      function H(Y) {
        return (Y[i] = ey(Y[i], 1)), Y
      }
    }
    function p(g, v) {
      for (
        var m = eo(g.count * 4),
          y = 0,
          _,
          x = [],
          A = [],
          S,
          b = v.getStore(),
          T = !!r.get(['itemStyle', 'borderColorDoji']);
        (S = g.next()) != null;

      ) {
        var w = b.get(s, S),
          M = b.get(u, S),
          C = b.get(c, S),
          E = b.get(h, S),
          D = b.get(f, S)
        if (isNaN(w) || isNaN(E) || isNaN(D)) {
          ;(m[y++] = NaN), (y += 3)
          continue
        }
        ;(m[y++] = gN(b, S, M, C, c, T)),
          (x[i] = w),
          (x[a] = E),
          (_ = t.dataToPoint(x, null, A)),
          (m[y++] = _ ? _[0] : NaN),
          (m[y++] = _ ? _[1] : NaN),
          (x[a] = D),
          (_ = t.dataToPoint(x, null, A)),
          (m[y++] = _ ? _[1] : NaN)
      }
      v.setLayout('largePoints', m)
    }
  },
}
function gN(r, t, e, n, i, a) {
  var o
  return (
    e > n
      ? (o = -1)
      : e < n
      ? (o = 1)
      : (o = a ? 0 : t > 0 ? (r.get(i, t - 1) <= n ? 1 : -1) : 1),
    o
  )
}
function Cvt(r, t) {
  var e = r.getBaseAxis(),
    n,
    i =
      e.type === 'category'
        ? e.getBandWidth()
        : ((n = e.getExtent()), Math.abs(n[1] - n[0]) / t.count()),
    a = _t($t(r.get('barMaxWidth'), i), i),
    o = _t($t(r.get('barMinWidth'), 1), i),
    s = r.get('barWidth')
  return s != null ? _t(s, i) : Math.max(Math.min(i / 2, a), o)
}
const Evt = Tvt
function Dvt(r) {
  r.registerChartView(gvt),
    r.registerSeriesModel(mvt),
    r.registerPreprocessor(yvt),
    r.registerVisual(Mvt),
    r.registerLayout(Evt)
}
function mN(r, t) {
  var e = t.rippleEffectColor || t.color
  r.eachChild(function (n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === 'stroke' ? e : null,
        fill: t.brushType === 'fill' ? e : null,
      },
    })
  })
}
var Lvt = (function (r) {
  X(t, r)
  function t(e, n) {
    var i = r.call(this) || this,
      a = new Tv(e, n),
      o = new Ht()
    return i.add(a), i.add(o), i.updateData(e, n), i
  }
  return (
    (t.prototype.stopEffectAnimation = function () {
      this.childAt(1).removeAll()
    }),
    (t.prototype.startEffectAnimation = function (e) {
      for (
        var n = e.symbolType,
          i = e.color,
          a = e.rippleNumber,
          o = this.childAt(1),
          s = 0;
        s < a;
        s++
      ) {
        var l = Rn(n, -1, -1, 2, 2, i)
        l.attr({
          style: {
            strokeNoScale: !0,
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5,
        })
        var u = (-s / a) * e.period + e.effectOffset
        l
          .animate('', !0)
          .when(e.period, {
            scaleX: e.rippleScale / 2,
            scaleY: e.rippleScale / 2,
          })
          .delay(u)
          .start(),
          l
            .animateStyle(!0)
            .when(e.period, {
              opacity: 0,
            })
            .delay(u)
            .start(),
          o.add(l)
      }
      mN(o, e)
    }),
    (t.prototype.updateEffectAnimation = function (e) {
      for (
        var n = this._effectCfg,
          i = this.childAt(1),
          a = ['symbolType', 'period', 'rippleScale', 'rippleNumber'],
          o = 0;
        o < a.length;
        o++
      ) {
        var s = a[o]
        if (n[s] !== e[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(e)
          return
        }
      }
      mN(i, e)
    }),
    (t.prototype.highlight = function () {
      Qo(this)
    }),
    (t.prototype.downplay = function () {
      ts(this)
    }),
    (t.prototype.getSymbolType = function () {
      var e = this.childAt(0)
      return e && e.getSymbolType()
    }),
    (t.prototype.updateData = function (e, n) {
      var i = this,
        a = e.hostModel
      this.childAt(0).updateData(e, n)
      var o = this.childAt(1),
        s = e.getItemModel(n),
        l = e.getItemVisual(n, 'symbol'),
        u = Lf(e.getItemVisual(n, 'symbolSize')),
        c = e.getItemVisual(n, 'style'),
        h = c && c.fill,
        f = s.getModel('emphasis')
      o.setScale(u),
        o.traverse(function (v) {
          v.setStyle('fill', h)
        })
      var d = ic(e.getItemVisual(n, 'symbolOffset'), u)
      d && ((o.x = d[0]), (o.y = d[1]))
      var p = e.getItemVisual(n, 'symbolRotate')
      o.rotation = ((p || 0) * Math.PI) / 180 || 0
      var g = {}
      ;(g.showEffectOn = a.get('showEffectOn')),
        (g.rippleScale = s.get(['rippleEffect', 'scale'])),
        (g.brushType = s.get(['rippleEffect', 'brushType'])),
        (g.period = s.get(['rippleEffect', 'period']) * 1e3),
        (g.effectOffset = n / e.count()),
        (g.z = a.getShallow('z') || 0),
        (g.zlevel = a.getShallow('zlevel') || 0),
        (g.symbolType = l),
        (g.color = h),
        (g.rippleEffectColor = s.get(['rippleEffect', 'color'])),
        (g.rippleNumber = s.get(['rippleEffect', 'number'])),
        g.showEffectOn === 'render'
          ? (this._effectCfg
              ? this.updateEffectAnimation(g)
              : this.startEffectAnimation(g),
            (this._effectCfg = g))
          : ((this._effectCfg = null),
            this.stopEffectAnimation(),
            (this.onHoverStateChange = function (v) {
              v === 'emphasis'
                ? g.showEffectOn !== 'render' && i.startEffectAnimation(g)
                : v === 'normal' &&
                  g.showEffectOn !== 'render' &&
                  i.stopEffectAnimation()
            })),
        (this._effectCfg = g),
        fn(this, f.get('focus'), f.get('blurScope'), f.get('disabled'))
    }),
    (t.prototype.fadeOut = function (e) {
      e && e()
    }),
    t
  )
})(Ht)
const Pvt = Lvt
var Rvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function () {
      this._symbolDraw = new Cv(Pvt)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._symbolDraw
      o.updateData(a, {
        clipShape: this._getClipShape(e),
      }),
        this.group.add(o.group)
    }),
    (t.prototype._getClipShape = function (e) {
      var n = e.coordinateSystem,
        i = n && n.getArea && n.getArea()
      return e.get('clip', !0) ? i : null
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData()
      this.group.dirty()
      var o = Dv('').reset(e, n, i)
      o.progress &&
        o.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._symbolDraw.updateLayout()
    }),
    (t.prototype._updateGroupTransform = function (e) {
      var n = e.coordinateSystem
      n &&
        n.getRoamTransform &&
        ((this.group.transform = aQ(n.getRoamTransform())),
        this.group.decomposeTransform())
    }),
    (t.prototype.remove = function (e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0)
    }),
    (t.type = 'effectScatter'),
    t
  )
})(Ze)
const Ivt = Rvt
var Ovt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.point(n.getItemLayout(e))
    }),
    (t.type = 'series.effectScatter'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      legendHoverLink: !0,
      effectType: 'ripple',
      progressive: 0,
      showEffectOn: 'render',
      clip: !0,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: 'fill',
        number: 3,
      },
      universalTransition: {
        divideShape: 'clone',
      },
      symbolSize: 10,
    }),
    t
  )
})(rn)
const Nvt = Ovt
function kvt(r) {
  r.registerChartView(Ivt),
    r.registerSeriesModel(Nvt),
    r.registerLayout(Dv('effectScatter'))
}
var Bvt = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a.add(a.createLine(e, n, i)), a._updateEffectSymbol(e, n), a
  }
  return (
    (t.prototype.createLine = function (e, n, i) {
      return new JC(e, n, i)
    }),
    (t.prototype._updateEffectSymbol = function (e, n) {
      var i = e.getItemModel(n),
        a = i.getModel('effect'),
        o = a.get('symbolSize'),
        s = a.get('symbol')
      at(o) || (o = [o, o])
      var l = e.getItemVisual(n, 'style'),
        u = a.get('color') || (l && l.stroke),
        c = this.childAt(1)
      this._symbolType !== s &&
        (this.remove(c),
        (c = Rn(s, -0.5, -0.5, 1, 1, u)),
        (c.z2 = 100),
        (c.culling = !0),
        this.add(c)),
        c &&
          (c.setStyle('shadowColor', u),
          c.setStyle(a.getItemStyle(['color'])),
          (c.scaleX = o[0]),
          (c.scaleY = o[1]),
          c.setColor(u),
          (this._symbolType = s),
          (this._symbolScale = o),
          this._updateEffectAnimation(e, a, n))
    }),
    (t.prototype._updateEffectAnimation = function (e, n, i) {
      var a = this.childAt(1)
      if (a) {
        var o = e.getItemLayout(i),
          s = n.get('period') * 1e3,
          l = n.get('loop'),
          u = n.get('roundTrip'),
          c = n.get('constantSpeed'),
          h = nr(n.get('delay'), function (d) {
            return ((d / e.count()) * s) / 3
          })
        if (
          ((a.ignore = !0),
          this._updateAnimationPoints(a, o),
          c > 0 && (s = (this._getLineLength(a) / c) * 1e3),
          s !== this._period || l !== this._loop || u !== this._roundTrip)
        ) {
          a.stopAnimation()
          var f = void 0
          Nt(h) ? (f = h(i)) : (f = h),
            a.__t > 0 && (f = -s * a.__t),
            this._animateSymbol(a, s, f, l, u)
        }
        ;(this._period = s), (this._loop = l), (this._roundTrip = u)
      }
    }),
    (t.prototype._animateSymbol = function (e, n, i, a, o) {
      if (n > 0) {
        e.__t = 0
        var s = this,
          l = e
            .animate('', a)
            .when(o ? n * 2 : n, {
              __t: o ? 2 : 1,
            })
            .delay(i)
            .during(function () {
              s._updateSymbolPosition(e)
            })
        a ||
          l.done(function () {
            s.remove(e)
          }),
          l.start()
      }
    }),
    (t.prototype._getLineLength = function (e) {
      return ks(e.__p1, e.__cp1) + ks(e.__cp1, e.__p2)
    }),
    (t.prototype._updateAnimationPoints = function (e, n) {
      ;(e.__p1 = n[0]),
        (e.__p2 = n[1]),
        (e.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2])
    }),
    (t.prototype.updateData = function (e, n, i) {
      this.childAt(0).updateData(e, n, i), this._updateEffectSymbol(e, n)
    }),
    (t.prototype._updateSymbolPosition = function (e) {
      var n = e.__p1,
        i = e.__p2,
        a = e.__cp1,
        o = e.__t < 1 ? e.__t : 2 - e.__t,
        s = [e.x, e.y],
        l = s.slice(),
        u = tr,
        c = kb
      ;(s[0] = u(n[0], a[0], i[0], o)), (s[1] = u(n[1], a[1], i[1], o))
      var h = e.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o),
        f = e.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o)
      ;(e.rotation = -Math.atan2(f, h) - Math.PI / 2),
        (this._symbolType === 'line' ||
          this._symbolType === 'rect' ||
          this._symbolType === 'roundRect') &&
          (e.__lastT !== void 0 && e.__lastT < e.__t
            ? ((e.scaleY = ks(l, s) * 1.05),
              o === 1 &&
                ((s[0] = l[0] + (s[0] - l[0]) / 2),
                (s[1] = l[1] + (s[1] - l[1]) / 2)))
            : e.__lastT === 1
            ? (e.scaleY = 2 * ks(n, s))
            : (e.scaleY = this._symbolScale[1])),
        (e.__lastT = e.__t),
        (e.ignore = !1),
        (e.x = s[0]),
        (e.y = s[1])
    }),
    (t.prototype.updateLayout = function (e, n) {
      this.childAt(0).updateLayout(e, n)
      var i = e.getItemModel(n).getModel('effect')
      this._updateEffectAnimation(e, i, n)
    }),
    t
  )
})(Ht)
const $4 = Bvt
var Fvt = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a._createPolyline(e, n, i), a
  }
  return (
    (t.prototype._createPolyline = function (e, n, i) {
      var a = e.getItemLayout(n),
        o = new li({
          shape: {
            points: a,
          },
        })
      this.add(o), this._updateCommonStl(e, n, i)
    }),
    (t.prototype.updateData = function (e, n, i) {
      var a = e.hostModel,
        o = this.childAt(0),
        s = {
          shape: {
            points: e.getItemLayout(n),
          },
        }
      we(o, s, a, n), this._updateCommonStl(e, n, i)
    }),
    (t.prototype._updateCommonStl = function (e, n, i) {
      var a = this.childAt(0),
        o = e.getItemModel(n),
        s = i && i.emphasisLineStyle,
        l = i && i.focus,
        u = i && i.blurScope,
        c = i && i.emphasisDisabled
      if (!i || e.hasItemOption) {
        var h = o.getModel('emphasis')
        ;(s = h.getModel('lineStyle').getLineStyle()),
          (c = h.get('disabled')),
          (l = h.get('focus')),
          (u = h.get('blurScope'))
      }
      a.useStyle(e.getItemVisual(n, 'style')),
        (a.style.fill = null),
        (a.style.strokeNoScale = !0)
      var f = a.ensureState('emphasis')
      ;(f.style = s), fn(this, l, u, c)
    }),
    (t.prototype.updateLayout = function (e, n) {
      var i = this.childAt(0)
      i.setShape('points', e.getItemLayout(n))
    }),
    t
  )
})(Ht)
const q4 = Fvt
var zvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e._lastFrame = 0), (e._lastFramePercent = 0), e
  }
  return (
    (t.prototype.createLine = function (e, n, i) {
      return new q4(e, n, i)
    }),
    (t.prototype._updateAnimationPoints = function (e, n) {
      this._points = n
      for (var i = [0], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1],
          l = n[o]
        ;(a += ks(s, l)), i.push(a)
      }
      if (a === 0) {
        this._length = 0
        return
      }
      for (var o = 0; o < i.length; o++) i[o] /= a
      ;(this._offsets = i), (this._length = a)
    }),
    (t.prototype._getLineLength = function () {
      return this._length
    }),
    (t.prototype._updateSymbolPosition = function (e) {
      var n = e.__t < 1 ? e.__t : 2 - e.__t,
        i = this._points,
        a = this._offsets,
        o = i.length
      if (a) {
        var s = this._lastFrame,
          l
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1)
          for (l = u; l >= 0 && !(a[l] <= n); l--);
          l = Math.min(l, o - 2)
        } else {
          for (l = s; l < o && !(a[l] > n); l++);
          l = Math.min(l - 1, o - 2)
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]),
          h = i[l],
          f = i[l + 1]
        ;(e.x = h[0] * (1 - c) + c * f[0]), (e.y = h[1] * (1 - c) + c * f[1])
        var d = e.__t < 1 ? f[0] - h[0] : h[0] - f[0],
          p = e.__t < 1 ? f[1] - h[1] : h[1] - f[1]
        ;(e.rotation = -Math.atan2(p, d) - Math.PI / 2),
          (this._lastFrame = l),
          (this._lastFramePercent = n),
          (e.ignore = !1)
      }
    }),
    t
  )
})($4)
const Uvt = zvt
var Vvt = (function () {
    function r() {
      ;(this.polyline = !1), (this.curveness = 0), (this.segs = [])
    }
    return r
  })(),
  Gvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n._off = 0), (n.hoverDataIdx = -1), n
    }
    return (
      (t.prototype.reset = function () {
        ;(this.notClear = !1), (this._off = 0)
      }),
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new Vvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.segs,
          a = n.curveness,
          o
        if (n.polyline)
          for (o = this._off; o < i.length; ) {
            var s = i[o++]
            if (s > 0) {
              e.moveTo(i[o++], i[o++])
              for (var l = 1; l < s; l++) e.lineTo(i[o++], i[o++])
            }
          }
        else
          for (o = this._off; o < i.length; ) {
            var u = i[o++],
              c = i[o++],
              h = i[o++],
              f = i[o++]
            if ((e.moveTo(u, c), a > 0)) {
              var d = (u + h) / 2 - (c - f) * a,
                p = (c + f) / 2 - (h - u) * a
              e.quadraticCurveTo(d, p, h, f)
            } else e.lineTo(h, f)
          }
        this.incremental && ((this._off = o), (this.notClear = !0))
      }),
      (t.prototype.findDataIndex = function (e, n) {
        var i = this.shape,
          a = i.segs,
          o = i.curveness,
          s = this.style.lineWidth
        if (i.polyline)
          for (var l = 0, u = 0; u < a.length; ) {
            var c = a[u++]
            if (c > 0)
              for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
                var p = a[u++],
                  g = a[u++]
                if (Es(h, f, p, g, s, e, n)) return l
              }
            l++
          }
        else
          for (var l = 0, u = 0; u < a.length; ) {
            var h = a[u++],
              f = a[u++],
              p = a[u++],
              g = a[u++]
            if (o > 0) {
              var v = (h + p) / 2 - (f - g) * o,
                m = (f + g) / 2 - (p - h) * o
              if (Jz(h, f, v, m, p, g, s, e, n)) return l
            } else if (Es(h, f, p, g, s, e, n)) return l
            l++
          }
        return -1
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        if (((e = i[0]), (n = i[1]), a.contain(e, n))) {
          var o = (this.hoverDataIdx = this.findDataIndex(e, n))
          return o >= 0
        }
        return (this.hoverDataIdx = -1), !1
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect
        if (!e) {
          for (
            var n = this.shape,
              i = n.segs,
              a = 1 / 0,
              o = 1 / 0,
              s = -1 / 0,
              l = -1 / 0,
              u = 0;
            u < i.length;

          ) {
            var c = i[u++],
              h = i[u++]
            ;(a = Math.min(c, a)),
              (s = Math.max(c, s)),
              (o = Math.min(h, o)),
              (l = Math.max(h, l))
          }
          e = this._rect = new ee(a, o, s, l)
        }
        return e
      }),
      t
    )
  })(oe),
  Hvt = (function () {
    function r() {
      this.group = new Ht()
    }
    return (
      (r.prototype.updateData = function (t) {
        this._clear()
        var e = this._create()
        e.setShape({
          segs: t.getLayout('linesPoints'),
        }),
          this._setCommon(e, t)
      }),
      (r.prototype.incrementalPrepareUpdate = function (t) {
        this.group.removeAll(), this._clear()
      }),
      (r.prototype.incrementalUpdate = function (t, e) {
        var n = this._newAdded[0],
          i = e.getLayout('linesPoints'),
          a = n && n.shape.segs
        if (a && a.length < 2e4) {
          var o = a.length,
            s = new Float32Array(o + i.length)
          s.set(a),
            s.set(i, o),
            n.setShape({
              segs: s,
            })
        } else {
          this._newAdded = []
          var l = this._create()
          ;(l.incremental = !0),
            l.setShape({
              segs: i,
            }),
            this._setCommon(l, e),
            (l.__startIndex = t.start)
        }
      }),
      (r.prototype.remove = function () {
        this._clear()
      }),
      (r.prototype.eachRendered = function (t) {
        this._newAdded[0] && t(this._newAdded[0])
      }),
      (r.prototype._create = function () {
        var t = new Gvt({
          cursor: 'default',
          ignoreCoarsePointer: !0,
        })
        return this._newAdded.push(t), this.group.add(t), t
      }),
      (r.prototype._setCommon = function (t, e, n) {
        var i = e.hostModel
        t.setShape({
          polyline: i.get('polyline'),
          curveness: i.get(['lineStyle', 'curveness']),
        }),
          t.useStyle(i.getModel('lineStyle').getLineStyle()),
          (t.style.strokeNoScale = !0)
        var a = e.getVisual('style')
        a && a.stroke && t.setStyle('stroke', a.stroke),
          t.setStyle('fill', null)
        var o = Wt(t)
        ;(o.seriesIndex = i.seriesIndex),
          t.on('mousemove', function (s) {
            o.dataIndex = null
            var l = t.hoverDataIdx
            l > 0 && (o.dataIndex = l + t.__startIndex)
          })
      }),
      (r.prototype._clear = function () {
        ;(this._newAdded = []), this.group.removeAll()
      }),
      r
    )
  })()
const Wvt = Hvt
var Xvt = {
  seriesType: 'lines',
  plan: Ef(),
  reset: function (r) {
    var t = r.coordinateSystem
    if (t) {
      var e = r.get('polyline'),
        n = r.pipelineContext.large
      return {
        progress: function (i, a) {
          var o = []
          if (n) {
            var s = void 0,
              l = i.end - i.start
            if (e) {
              for (var u = 0, c = i.start; c < i.end; c++)
                u += r.getLineCoordsCount(c)
              s = new Float32Array(l + u * 2)
            } else s = new Float32Array(l * 4)
            for (var h = 0, f = [], c = i.start; c < i.end; c++) {
              var d = r.getLineCoords(c, o)
              e && (s[h++] = d)
              for (var p = 0; p < d; p++)
                (f = t.dataToPoint(o[p], !1, f)),
                  (s[h++] = f[0]),
                  (s[h++] = f[1])
            }
            a.setLayout('linesPoints', s)
          } else
            for (var c = i.start; c < i.end; c++) {
              var g = a.getItemModel(c),
                d = r.getLineCoords(c, o),
                v = []
              if (e) for (var m = 0; m < d; m++) v.push(t.dataToPoint(o[m]))
              else {
                ;(v[0] = t.dataToPoint(o[0])), (v[1] = t.dataToPoint(o[1]))
                var y = g.get(['lineStyle', 'curveness'])
                ;+y &&
                  (v[2] = [
                    (v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y,
                    (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y,
                  ])
              }
              a.setItemLayout(c, v)
            }
        },
      }
    }
  },
}
const Z4 = Xvt
var Yvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._updateLineDraw(a, e),
        s = e.get('zlevel'),
        l = e.get(['effect', 'trailLength']),
        u = i.getZr(),
        c = u.painter.getType() === 'svg'
      c || u.painter.getLayer(s).clear(!0),
        this._lastZlevel != null &&
          !c &&
          u.configLayer(this._lastZlevel, {
            motionBlur: !1,
          }),
        this._showEffect(e) &&
          l > 0 &&
          (c ||
            u.configLayer(s, {
              motionBlur: !0,
              lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0),
            })),
        o.updateData(a)
      var h = e.get('clip', !0) && Ev(e.coordinateSystem, !1, e)
      h ? this.group.setClipPath(h) : this.group.removeClipPath(),
        (this._lastZlevel = s),
        (this._finished = !0)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      var a = e.getData(),
        o = this._updateLineDraw(a, e)
      o.incrementalPrepareUpdate(a), this._clearLayer(i), (this._finished = !1)
    }),
    (t.prototype.incrementalRender = function (e, n, i) {
      this._lineDraw.incrementalUpdate(e, n.getData()),
        (this._finished = e.end === n.getData().count())
    }),
    (t.prototype.eachRendered = function (e) {
      this._lineDraw && this._lineDraw.eachRendered(e)
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData(),
        o = e.pipelineContext
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0,
        }
      var s = Z4.reset(e, n, i)
      s.progress &&
        s.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._lineDraw.updateLayout(),
        this._clearLayer(i)
    }),
    (t.prototype._updateLineDraw = function (e, n) {
      var i = this._lineDraw,
        a = this._showEffect(n),
        o = !!n.get('polyline'),
        s = n.pipelineContext,
        l = s.large
      return (
        (!i ||
          a !== this._hasEffet ||
          o !== this._isPolyline ||
          l !== this._isLargeDraw) &&
          (i && i.remove(),
          (i = this._lineDraw =
            l ? new Wvt() : new QC(o ? (a ? Uvt : q4) : a ? $4 : JC)),
          (this._hasEffet = a),
          (this._isPolyline = o),
          (this._isLargeDraw = l)),
        this.group.add(i.group),
        i
      )
    }),
    (t.prototype._showEffect = function (e) {
      return !!e.get(['effect', 'show'])
    }),
    (t.prototype._clearLayer = function (e) {
      var n = e.getZr(),
        i = n.painter.getType() === 'svg'
      !i &&
        this._lastZlevel != null &&
        n.painter.getLayer(this._lastZlevel).clear(!0)
    }),
    (t.prototype.remove = function (e, n) {
      this._lineDraw && this._lineDraw.remove(),
        (this._lineDraw = null),
        this._clearLayer(n)
    }),
    (t.prototype.dispose = function (e, n) {
      this.remove(e, n)
    }),
    (t.type = 'lines'),
    t
  )
})(Ze)
const $vt = Yvt
var qvt = typeof Uint32Array > 'u' ? Array : Uint32Array,
  Zvt = typeof Float64Array > 'u' ? Array : Float64Array
function yN(r) {
  var t = r.data
  t &&
    t[0] &&
    t[0][0] &&
    t[0][0].coord &&
    (r.data = st(t, function (e) {
      var n = [e[0].coord, e[1].coord],
        i = {
          coords: n,
        }
      return (
        e[0].name && (i.fromName = e[0].name),
        e[1].name && (i.toName = e[1].name),
        ET([i, e[0], e[1]])
      )
    }))
}
var Kvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.visualStyleAccessPath = 'lineStyle'),
      (e.visualDrawType = 'stroke'),
      e
    )
  }
  return (
    (t.prototype.init = function (e) {
      ;(e.data = e.data || []), yN(e)
      var n = this._processFlatCoordsArray(e.data)
      ;(this._flatCoords = n.flatCoords),
        (this._flatCoordsOffset = n.flatCoordsOffset),
        n.flatCoords && (e.data = new Float32Array(n.count)),
        r.prototype.init.apply(this, arguments)
    }),
    (t.prototype.mergeOption = function (e) {
      if ((yN(e), e.data)) {
        var n = this._processFlatCoordsArray(e.data)
        ;(this._flatCoords = n.flatCoords),
          (this._flatCoordsOffset = n.flatCoordsOffset),
          n.flatCoords && (e.data = new Float32Array(n.count))
      }
      r.prototype.mergeOption.apply(this, arguments)
    }),
    (t.prototype.appendData = function (e) {
      var n = this._processFlatCoordsArray(e.data)
      n.flatCoords &&
        (this._flatCoords
          ? ((this._flatCoords = ky(this._flatCoords, n.flatCoords)),
            (this._flatCoordsOffset = ky(
              this._flatCoordsOffset,
              n.flatCoordsOffset,
            )))
          : ((this._flatCoords = n.flatCoords),
            (this._flatCoordsOffset = n.flatCoordsOffset)),
        (e.data = new Float32Array(n.count))),
        this.getRawData().appendData(e.data)
    }),
    (t.prototype._getCoordsFromItemModel = function (e) {
      var n = this.getData().getItemModel(e),
        i = n.option instanceof Array ? n.option : n.getShallow('coords')
      return i
    }),
    (t.prototype.getLineCoordsCount = function (e) {
      return this._flatCoordsOffset
        ? this._flatCoordsOffset[e * 2 + 1]
        : this._getCoordsFromItemModel(e).length
    }),
    (t.prototype.getLineCoords = function (e, n) {
      if (this._flatCoordsOffset) {
        for (
          var i = this._flatCoordsOffset[e * 2],
            a = this._flatCoordsOffset[e * 2 + 1],
            o = 0;
          o < a;
          o++
        )
          (n[o] = n[o] || []),
            (n[o][0] = this._flatCoords[i + o * 2]),
            (n[o][1] = this._flatCoords[i + o * 2 + 1])
        return a
      } else {
        for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++)
          (n[o] = n[o] || []), (n[o][0] = s[o][0]), (n[o][1] = s[o][1])
        return s.length
      }
    }),
    (t.prototype._processFlatCoordsArray = function (e) {
      var n = 0
      if ((this._flatCoords && (n = this._flatCoords.length), be(e[0]))) {
        for (
          var i = e.length,
            a = new qvt(i),
            o = new Zvt(i),
            s = 0,
            l = 0,
            u = 0,
            c = 0;
          c < i;

        ) {
          u++
          var h = e[c++]
          ;(a[l++] = s + n), (a[l++] = h)
          for (var f = 0; f < h; f++) {
            var d = e[c++],
              p = e[c++]
            ;(o[s++] = d), (o[s++] = p)
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u,
        }
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: e.length,
      }
    }),
    (t.prototype.getInitialData = function (e, n) {
      var i = new Vr(['value'], this)
      return (
        (i.hasItemOption = !1),
        i.initData(e.data, [], function (a, o, s, l) {
          if (a instanceof Array) return NaN
          i.hasItemOption = !0
          var u = a.value
          if (u != null) return u instanceof Array ? u[l] : u
        }),
        i
      )
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = a.getItemModel(e),
        s = o.get('name')
      if (s) return s
      var l = o.get('fromName'),
        u = o.get('toName'),
        c = []
      return (
        l != null && c.push(l),
        u != null && c.push(u),
        Kn('nameValue', {
          name: c.join(' > '),
        })
      )
    }),
    (t.prototype.preventIncremental = function () {
      return !!this.get(['effect', 'show'])
    }),
    (t.prototype.getProgressive = function () {
      var e = this.option.progressive
      return e ?? (this.option.large ? 1e4 : this.get('progressive'))
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.option.progressiveThreshold
      return e ?? (this.option.large ? 2e4 : this.get('progressiveThreshold'))
    }),
    (t.prototype.getZLevelKey = function () {
      var e = this.getModel('effect'),
        n = e.get('trailLength')
      return this.getData().count() > this.getProgressiveThreshold()
        ? this.id
        : e.get('show') && n > 0
        ? n + ''
        : ''
    }),
    (t.type = 'series.lines'),
    (t.dependencies = ['grid', 'polar', 'geo', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'geo',
      z: 2,
      legendHoverLink: !0,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ['none', 'none'],
      symbolSize: [10, 10],
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: 'circle',
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2,
      },
      large: !1,
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: 'end',
      },
      lineStyle: {
        opacity: 0.5,
      },
    }),
    t
  )
})(rn)
const jvt = Kvt
function Sm(r) {
  return r instanceof Array || (r = [r, r]), r
}
var Jvt = {
  seriesType: 'lines',
  reset: function (r) {
    var t = Sm(r.get('symbol')),
      e = Sm(r.get('symbolSize')),
      n = r.getData()
    n.setVisual('fromSymbol', t && t[0]),
      n.setVisual('toSymbol', t && t[1]),
      n.setVisual('fromSymbolSize', e && e[0]),
      n.setVisual('toSymbolSize', e && e[1])
    function i(a, o) {
      var s = a.getItemModel(o),
        l = Sm(s.getShallow('symbol', !0)),
        u = Sm(s.getShallow('symbolSize', !0))
      l[0] && a.setItemVisual(o, 'fromSymbol', l[0]),
        l[1] && a.setItemVisual(o, 'toSymbol', l[1]),
        u[0] && a.setItemVisual(o, 'fromSymbolSize', u[0]),
        u[1] && a.setItemVisual(o, 'toSymbolSize', u[1])
    }
    return {
      dataEach: n.hasItemOption ? i : null,
    }
  },
}
const Qvt = Jvt
function tgt(r) {
  r.registerChartView($vt),
    r.registerSeriesModel(jvt),
    r.registerLayout(Z4),
    r.registerVisual(Qvt)
}
var egt = 256,
  ngt = (function () {
    function r() {
      ;(this.blurSize = 30),
        (this.pointSize = 20),
        (this.maxOpacity = 1),
        (this.minOpacity = 0),
        (this._gradientPixels = {
          inRange: null,
          outOfRange: null,
        })
      var t = rl.createCanvas()
      this.canvas = t
    }
    return (
      (r.prototype.update = function (t, e, n, i, a, o) {
        var s = this._getBrush(),
          l = this._getGradient(a, 'inRange'),
          u = this._getGradient(a, 'outOfRange'),
          c = this.pointSize + this.blurSize,
          h = this.canvas,
          f = h.getContext('2d'),
          d = t.length
        ;(h.width = e), (h.height = n)
        for (var p = 0; p < d; ++p) {
          var g = t[p],
            v = g[0],
            m = g[1],
            y = g[2],
            _ = i(y)
          ;(f.globalAlpha = _), f.drawImage(s, v - c, m - c)
        }
        if (!h.width || !h.height) return h
        for (
          var x = f.getImageData(0, 0, h.width, h.height),
            A = x.data,
            S = 0,
            b = A.length,
            T = this.minOpacity,
            w = this.maxOpacity,
            M = w - T;
          S < b;

        ) {
          var _ = A[S + 3] / 256,
            C = Math.floor(_ * (egt - 1)) * 4
          if (_ > 0) {
            var E = o(_) ? l : u
            _ > 0 && (_ = _ * M + T),
              (A[S++] = E[C]),
              (A[S++] = E[C + 1]),
              (A[S++] = E[C + 2]),
              (A[S++] = E[C + 3] * _ * 256)
          } else S += 4
        }
        return f.putImageData(x, 0, 0), h
      }),
      (r.prototype._getBrush = function () {
        var t = this._brushCanvas || (this._brushCanvas = rl.createCanvas()),
          e = this.pointSize + this.blurSize,
          n = e * 2
        ;(t.width = n), (t.height = n)
        var i = t.getContext('2d')
        return (
          i.clearRect(0, 0, n, n),
          (i.shadowOffsetX = n),
          (i.shadowBlur = this.blurSize),
          (i.shadowColor = '#000'),
          i.beginPath(),
          i.arc(-e, e, this.pointSize, 0, Math.PI * 2, !0),
          i.closePath(),
          i.fill(),
          t
        )
      }),
      (r.prototype._getGradient = function (t, e) {
        for (
          var n = this._gradientPixels,
            i = n[e] || (n[e] = new Uint8ClampedArray(256 * 4)),
            a = [0, 0, 0, 0],
            o = 0,
            s = 0;
          s < 256;
          s++
        )
          t[e](s / 255, !0, a),
            (i[o++] = a[0]),
            (i[o++] = a[1]),
            (i[o++] = a[2]),
            (i[o++] = a[3])
        return i
      }),
      r
    )
  })()
const rgt = ngt
function igt(r, t, e) {
  var n = r[1] - r[0]
  t = st(t, function (o) {
    return {
      interval: [(o.interval[0] - r[0]) / n, (o.interval[1] - r[0]) / n],
    }
  })
  var i = t.length,
    a = 0
  return function (o) {
    var s
    for (s = a; s < i; s++) {
      var l = t[s].interval
      if (l[0] <= o && o <= l[1]) {
        a = s
        break
      }
    }
    if (s === i)
      for (s = a - 1; s >= 0; s--) {
        var l = t[s].interval
        if (l[0] <= o && o <= l[1]) {
          a = s
          break
        }
      }
    return s >= 0 && s < i && e[s]
  }
}
function agt(r, t) {
  var e = r[1] - r[0]
  return (
    (t = [(t[0] - r[0]) / e, (t[1] - r[0]) / e]),
    function (n) {
      return n >= t[0] && n <= t[1]
    }
  )
}
function _N(r) {
  var t = r.dimensions
  return t[0] === 'lng' && t[1] === 'lat'
}
var ogt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a
      n.eachComponent('visualMap', function (s) {
        s.eachTargetSeries(function (l) {
          l === e && (a = s)
        })
      }),
        (this._progressiveEls = null),
        this.group.removeAll()
      var o = e.coordinateSystem
      o.type === 'cartesian2d' || o.type === 'calendar'
        ? this._renderOnCartesianAndCalendar(e, i, 0, e.getData().count())
        : _N(o) && this._renderOnGeo(o, e, a, i)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      this.group.removeAll()
    }),
    (t.prototype.incrementalRender = function (e, n, i, a) {
      var o = n.coordinateSystem
      o &&
        (_N(o)
          ? this.render(n, i, a)
          : ((this._progressiveEls = []),
            this._renderOnCartesianAndCalendar(n, a, e.start, e.end, !0)))
    }),
    (t.prototype.eachRendered = function (e) {
      vl(this._progressiveEls || this.group, e)
    }),
    (t.prototype._renderOnCartesianAndCalendar = function (e, n, i, a, o) {
      var s = e.coordinateSystem,
        l = oc(s, 'cartesian2d'),
        u,
        c,
        h,
        f
      if (l) {
        var d = s.getAxis('x'),
          p = s.getAxis('y')
        ;(u = d.getBandWidth() + 0.5),
          (c = p.getBandWidth() + 0.5),
          (h = d.scale.getExtent()),
          (f = p.scale.getExtent())
      }
      for (
        var g = this.group,
          v = e.getData(),
          m = e.getModel(['emphasis', 'itemStyle']).getItemStyle(),
          y = e.getModel(['blur', 'itemStyle']).getItemStyle(),
          _ = e.getModel(['select', 'itemStyle']).getItemStyle(),
          x = e.get(['itemStyle', 'borderRadius']),
          A = Zn(e),
          S = e.getModel('emphasis'),
          b = S.get('focus'),
          T = S.get('blurScope'),
          w = S.get('disabled'),
          M = l
            ? [
                v.mapDimension('x'),
                v.mapDimension('y'),
                v.mapDimension('value'),
              ]
            : [v.mapDimension('time'), v.mapDimension('value')],
          C = i;
        C < a;
        C++
      ) {
        var E = void 0,
          D = v.getItemVisual(C, 'style')
        if (l) {
          var P = v.get(M[0], C),
            L = v.get(M[1], C)
          if (
            isNaN(v.get(M[2], C)) ||
            isNaN(P) ||
            isNaN(L) ||
            P < h[0] ||
            P > h[1] ||
            L < f[0] ||
            L > f[1]
          )
            continue
          var I = s.dataToPoint([P, L])
          E = new ge({
            shape: {
              x: I[0] - u / 2,
              y: I[1] - c / 2,
              width: u,
              height: c,
            },
            style: D,
          })
        } else {
          if (isNaN(v.get(M[1], C))) continue
          E = new ge({
            z2: 1,
            shape: s.dataToRect([v.get(M[0], C)]).contentShape,
            style: D,
          })
        }
        if (v.hasItemOption) {
          var F = v.getItemModel(C),
            k = F.getModel('emphasis')
          ;(m = k.getModel('itemStyle').getItemStyle()),
            (y = F.getModel(['blur', 'itemStyle']).getItemStyle()),
            (_ = F.getModel(['select', 'itemStyle']).getItemStyle()),
            (x = F.get(['itemStyle', 'borderRadius'])),
            (b = k.get('focus')),
            (T = k.get('blurScope')),
            (w = k.get('disabled')),
            (A = Zn(F))
        }
        E.shape.r = x
        var V = e.getRawValue(C),
          H = '-'
        V && V[2] != null && (H = V[2] + ''),
          mr(E, A, {
            labelFetcher: e,
            labelDataIndex: C,
            defaultOpacity: D.opacity,
            defaultText: H,
          }),
          (E.ensureState('emphasis').style = m),
          (E.ensureState('blur').style = y),
          (E.ensureState('select').style = _),
          fn(E, b, T, w),
          (E.incremental = o),
          o && (E.states.emphasis.hoverLayer = !0),
          g.add(E),
          v.setItemGraphicEl(C, E),
          this._progressiveEls && this._progressiveEls.push(E)
      }
    }),
    (t.prototype._renderOnGeo = function (e, n, i, a) {
      var o = i.targetVisuals.inRange,
        s = i.targetVisuals.outOfRange,
        l = n.getData(),
        u = this._hmLayer || this._hmLayer || new rgt()
      ;(u.blurSize = n.get('blurSize')),
        (u.pointSize = n.get('pointSize')),
        (u.minOpacity = n.get('minOpacity')),
        (u.maxOpacity = n.get('maxOpacity'))
      var c = e.getViewRect().clone(),
        h = e.getRoamTransform()
      c.applyTransform(h)
      var f = Math.max(c.x, 0),
        d = Math.max(c.y, 0),
        p = Math.min(c.width + c.x, a.getWidth()),
        g = Math.min(c.height + c.y, a.getHeight()),
        v = p - f,
        m = g - d,
        y = [
          l.mapDimension('lng'),
          l.mapDimension('lat'),
          l.mapDimension('value'),
        ],
        _ = l.mapArray(y, function (b, T, w) {
          var M = e.dataToPoint([b, T])
          return (M[0] -= f), (M[1] -= d), M.push(w), M
        }),
        x = i.getExtent(),
        A =
          i.type === 'visualMap.continuous'
            ? agt(x, i.option.range)
            : igt(x, i.getPieceList(), i.option.selected)
      u.update(
        _,
        v,
        m,
        o.color.getNormalizer(),
        {
          inRange: o.color.getColorMapper(),
          outOfRange: s.color.getColorMapper(),
        },
        A,
      )
      var S = new yr({
        style: {
          width: v,
          height: m,
          x: f,
          y: d,
          image: u.canvas,
        },
        silent: !0,
      })
      this.group.add(S)
    }),
    (t.type = 'heatmap'),
    t
  )
})(Ze)
const sgt = ogt
var lgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        generateCoord: 'value',
      })
    }),
    (t.prototype.preventIncremental = function () {
      var e = Av.get(this.get('coordinateSystem'))
      if (e && e.dimensions)
        return e.dimensions[0] === 'lng' && e.dimensions[1] === 'lat'
    }),
    (t.type = 'series.heatmap'),
    (t.dependencies = ['grid', 'geo', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const ugt = lgt
function cgt(r) {
  r.registerChartView(sgt), r.registerSeriesModel(ugt)
}
var hgt = ['itemStyle', 'borderWidth'],
  xN = [
    {
      xy: 'x',
      wh: 'width',
      index: 0,
      posDesc: ['left', 'right'],
    },
    {
      xy: 'y',
      wh: 'height',
      index: 1,
      posDesc: ['top', 'bottom'],
    },
  ],
  BS = new pl(),
  fgt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this.group,
          o = e.getData(),
          s = this._data,
          l = e.coordinateSystem,
          u = l.getBaseAxis(),
          c = u.isHorizontal(),
          h = l.master.getRect(),
          f = {
            ecSize: {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            seriesModel: e,
            coordSys: l,
            coordSysExtent: [
              [h.x, h.x + h.width],
              [h.y, h.y + h.height],
            ],
            isHorizontal: c,
            valueDim: xN[+c],
            categoryDim: xN[1 - +c],
          }
        o.diff(s)
          .add(function (p) {
            if (o.hasValue(p)) {
              var g = AN(o, p),
                v = SN(o, p, g, f),
                m = bN(o, f, v)
              o.setItemGraphicEl(p, m), a.add(m), MN(m, f, v)
            }
          })
          .update(function (p, g) {
            var v = s.getItemGraphicEl(g)
            if (!o.hasValue(p)) {
              a.remove(v)
              return
            }
            var m = AN(o, p),
              y = SN(o, p, m, f),
              _ = eH(o, y)
            v &&
              _ !== v.__pictorialShapeStr &&
              (a.remove(v), o.setItemGraphicEl(p, null), (v = null)),
              v ? _gt(v, f, y) : (v = bN(o, f, y, !0)),
              o.setItemGraphicEl(p, v),
              (v.__pictorialSymbolMeta = y),
              a.add(v),
              MN(v, f, y)
          })
          .remove(function (p) {
            var g = s.getItemGraphicEl(p)
            g && wN(s, p, g.__pictorialSymbolMeta.animationModel, g)
          })
          .execute()
        var d = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
        return (
          d ? a.setClipPath(d) : a.removeClipPath(),
          (this._data = o),
          this.group
        )
      }),
      (t.prototype.remove = function (e, n) {
        var i = this.group,
          a = this._data
        e.get('animation')
          ? a &&
            a.eachItemGraphicEl(function (o) {
              wN(a, Wt(o).dataIndex, e, o)
            })
          : i.removeAll()
      }),
      (t.type = 'pictorialBar'),
      t
    )
  })(Ze)
function SN(r, t, e, n) {
  var i = r.getItemLayout(t),
    a = e.get('symbolRepeat'),
    o = e.get('symbolClip'),
    s = e.get('symbolPosition') || 'start',
    l = e.get('symbolRotate'),
    u = ((l || 0) * Math.PI) / 180 || 0,
    c = e.get('symbolPatternSize') || 2,
    h = e.isAnimationEnabled(),
    f = {
      dataIndex: t,
      layout: i,
      itemModel: e,
      symbolType: r.getItemVisual(t, 'symbol') || 'circle',
      style: r.getItemVisual(t, 'style'),
      symbolClip: o,
      symbolRepeat: a,
      symbolRepeatDirection: e.get('symbolRepeatDirection'),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? e : null,
      hoverScale: h && e.get(['emphasis', 'scale']),
      z2: e.getShallow('z', !0) || 0,
    }
  dgt(e, a, i, n, f),
    pgt(r, t, i, a, o, f.boundingLength, f.pxSign, c, n, f),
    vgt(e, f.symbolScale, u, n, f)
  var d = f.symbolSize,
    p = ic(e.get('symbolOffset'), d)
  return (
    ggt(
      e,
      d,
      i,
      a,
      o,
      p,
      s,
      f.valueLineWidth,
      f.boundingLength,
      f.repeatCutLength,
      n,
      f,
    ),
    f
  )
}
function dgt(r, t, e, n, i) {
  var a = n.valueDim,
    o = r.get('symbolBoundingData'),
    s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()),
    l = s.toGlobalCoord(s.dataToCoord(0)),
    u = 1 - +(e[a.wh] <= 0),
    c
  if (at(o)) {
    var h = [FS(s, o[0]) - l, FS(s, o[1]) - l]
    h[1] < h[0] && h.reverse(), (c = h[u])
  } else
    o != null
      ? (c = FS(s, o) - l)
      : t
      ? (c = n.coordSysExtent[a.index][u] - l)
      : (c = e[a.wh])
  ;(i.boundingLength = c),
    t && (i.repeatCutLength = e[a.wh]),
    (i.pxSign = c > 0 ? 1 : -1)
}
function FS(r, t) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(t)))
}
function pgt(r, t, e, n, i, a, o, s, l, u) {
  var c = l.valueDim,
    h = l.categoryDim,
    f = Math.abs(e[h.wh]),
    d = r.getItemVisual(t, 'symbolSize'),
    p
  at(d) ? (p = d.slice()) : d == null ? (p = ['100%', '100%']) : (p = [d, d]),
    (p[h.index] = _t(p[h.index], f)),
    (p[c.index] = _t(p[c.index], n ? f : Math.abs(a))),
    (u.symbolSize = p)
  var g = (u.symbolScale = [p[0] / s, p[1] / s])
  g[c.index] *= (l.isHorizontal ? -1 : 1) * o
}
function vgt(r, t, e, n, i) {
  var a = r.get(hgt) || 0
  a &&
    (BS.attr({
      scaleX: t[0],
      scaleY: t[1],
      rotation: e,
    }),
    BS.updateTransform(),
    (a /= BS.getLineScale()),
    (a *= t[n.valueDim.index])),
    (i.valueLineWidth = a || 0)
}
function ggt(r, t, e, n, i, a, o, s, l, u, c, h) {
  var f = c.categoryDim,
    d = c.valueDim,
    p = h.pxSign,
    g = Math.max(t[d.index] + s, 0),
    v = g
  if (n) {
    var m = Math.abs(l),
      y = nr(r.get('symbolMargin'), '15%') + '',
      _ = !1
    y.lastIndexOf('!') === y.length - 1 &&
      ((_ = !0), (y = y.slice(0, y.length - 1)))
    var x = _t(y, t[d.index]),
      A = Math.max(g + x * 2, 0),
      S = _ ? 0 : x * 2,
      b = Fz(n),
      T = b ? n : TN((m + S) / A),
      w = m - T * g
    ;(x = w / 2 / (_ ? T : Math.max(T - 1, 1))),
      (A = g + x * 2),
      (S = _ ? 0 : x * 2),
      !b && n !== 'fixed' && (T = u ? TN((Math.abs(u) + S) / A) : 0),
      (v = T * A - S),
      (h.repeatTimes = T),
      (h.symbolMargin = x)
  }
  var M = p * (v / 2),
    C = (h.pathPosition = [])
  ;(C[f.index] = e[f.wh] / 2),
    (C[d.index] = o === 'start' ? M : o === 'end' ? l - M : l / 2),
    a && ((C[0] += a[0]), (C[1] += a[1]))
  var E = (h.bundlePosition = [])
  ;(E[f.index] = e[f.xy]), (E[d.index] = e[d.xy])
  var D = (h.barRectShape = Q({}, e))
  ;(D[d.wh] = p * Math.max(Math.abs(e[d.wh]), Math.abs(C[d.index] + M))),
    (D[f.wh] = e[f.wh])
  var P = (h.clipShape = {})
  ;(P[f.xy] = -e[f.xy]),
    (P[f.wh] = c.ecSize[f.wh]),
    (P[d.xy] = 0),
    (P[d.wh] = e[d.wh])
}
function K4(r) {
  var t = r.symbolPatternSize,
    e = Rn(r.symbolType, -t / 2, -t / 2, t, t)
  return (
    e.attr({
      culling: !0,
    }),
    e.type !== 'image' &&
      e.setStyle({
        strokeNoScale: !0,
      }),
    e
  )
}
function j4(r, t, e, n) {
  var i = r.__pictorialBundle,
    a = e.symbolSize,
    o = e.valueLineWidth,
    s = e.pathPosition,
    l = t.valueDim,
    u = e.repeatTimes || 0,
    c = 0,
    h = a[t.valueDim.index] + o + e.symbolMargin * 2
  for (
    sE(r, function (g) {
      ;(g.__pictorialAnimationIndex = c),
        (g.__pictorialRepeatTimes = u),
        c < u
          ? kh(g, null, p(c), e, n)
          : kh(
              g,
              null,
              {
                scaleX: 0,
                scaleY: 0,
              },
              e,
              n,
              function () {
                i.remove(g)
              },
            ),
        c++
    });
    c < u;
    c++
  ) {
    var f = K4(e)
    ;(f.__pictorialAnimationIndex = c), (f.__pictorialRepeatTimes = u), i.add(f)
    var d = p(c)
    kh(
      f,
      {
        x: d.x,
        y: d.y,
        scaleX: 0,
        scaleY: 0,
      },
      {
        scaleX: d.scaleX,
        scaleY: d.scaleY,
        rotation: d.rotation,
      },
      e,
      n,
    )
  }
  function p(g) {
    var v = s.slice(),
      m = e.pxSign,
      y = g
    return (
      (e.symbolRepeatDirection === 'start' ? m > 0 : m < 0) && (y = u - 1 - g),
      (v[l.index] = h * (y - u / 2 + 0.5) + s[l.index]),
      {
        x: v[0],
        y: v[1],
        scaleX: e.symbolScale[0],
        scaleY: e.symbolScale[1],
        rotation: e.rotation,
      }
    )
  }
}
function J4(r, t, e, n) {
  var i = r.__pictorialBundle,
    a = r.__pictorialMainPath
  a
    ? kh(
        a,
        null,
        {
          x: e.pathPosition[0],
          y: e.pathPosition[1],
          scaleX: e.symbolScale[0],
          scaleY: e.symbolScale[1],
          rotation: e.rotation,
        },
        e,
        n,
      )
    : ((a = r.__pictorialMainPath = K4(e)),
      i.add(a),
      kh(
        a,
        {
          x: e.pathPosition[0],
          y: e.pathPosition[1],
          scaleX: 0,
          scaleY: 0,
          rotation: e.rotation,
        },
        {
          scaleX: e.symbolScale[0],
          scaleY: e.symbolScale[1],
        },
        e,
        n,
      ))
}
function Q4(r, t, e) {
  var n = Q({}, t.barRectShape),
    i = r.__pictorialBarRect
  i
    ? kh(
        i,
        null,
        {
          shape: n,
        },
        t,
        e,
      )
    : ((i = r.__pictorialBarRect =
        new ge({
          z2: 2,
          shape: n,
          silent: !0,
          style: {
            stroke: 'transparent',
            fill: 'transparent',
            lineWidth: 0,
          },
        })),
      (i.disableMorphing = !0),
      r.add(i))
}
function tH(r, t, e, n) {
  if (e.symbolClip) {
    var i = r.__pictorialClipPath,
      a = Q({}, e.clipShape),
      o = t.valueDim,
      s = e.animationModel,
      l = e.dataIndex
    if (i)
      we(
        i,
        {
          shape: a,
        },
        s,
        l,
      )
    else {
      ;(a[o.wh] = 0),
        (i = new ge({
          shape: a,
        })),
        r.__pictorialBundle.setClipPath(i),
        (r.__pictorialClipPath = i)
      var u = {}
      ;(u[o.wh] = e.clipShape[o.wh]),
        nc[n ? 'updateProps' : 'initProps'](
          i,
          {
            shape: u,
          },
          s,
          l,
        )
    }
  }
}
function AN(r, t) {
  var e = r.getItemModel(t)
  return (e.getAnimationDelayParams = mgt), (e.isAnimationEnabled = ygt), e
}
function mgt(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes,
  }
}
function ygt() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation')
}
function bN(r, t, e, n) {
  var i = new Ht(),
    a = new Ht()
  return (
    i.add(a),
    (i.__pictorialBundle = a),
    (a.x = e.bundlePosition[0]),
    (a.y = e.bundlePosition[1]),
    e.symbolRepeat ? j4(i, t, e) : J4(i, t, e),
    Q4(i, e, n),
    tH(i, t, e, n),
    (i.__pictorialShapeStr = eH(r, e)),
    (i.__pictorialSymbolMeta = e),
    i
  )
}
function _gt(r, t, e) {
  var n = e.animationModel,
    i = e.dataIndex,
    a = r.__pictorialBundle
  we(
    a,
    {
      x: e.bundlePosition[0],
      y: e.bundlePosition[1],
    },
    n,
    i,
  ),
    e.symbolRepeat ? j4(r, t, e, !0) : J4(r, t, e, !0),
    Q4(r, e, !0),
    tH(r, t, e, !0)
}
function wN(r, t, e, n) {
  var i = n.__pictorialBarRect
  i && i.removeTextContent()
  var a = []
  sE(n, function (o) {
    a.push(o)
  }),
    n.__pictorialMainPath && a.push(n.__pictorialMainPath),
    n.__pictorialClipPath && (e = null),
    R(a, function (o) {
      al(
        o,
        {
          scaleX: 0,
          scaleY: 0,
        },
        e,
        t,
        function () {
          n.parent && n.parent.remove(n)
        },
      )
    }),
    r.setItemGraphicEl(t, null)
}
function eH(r, t) {
  return [
    r.getItemVisual(t.dataIndex, 'symbol') || 'none',
    !!t.symbolRepeat,
    !!t.symbolClip,
  ].join(':')
}
function sE(r, t, e) {
  R(r.__pictorialBundle.children(), function (n) {
    n !== r.__pictorialBarRect && t.call(e, n)
  })
}
function kh(r, t, e, n, i, a) {
  t && r.attr(t),
    n.symbolClip && !i
      ? e && r.attr(e)
      : e &&
        nc[i ? 'updateProps' : 'initProps'](
          r,
          e,
          n.animationModel,
          n.dataIndex,
          a,
        )
}
function MN(r, t, e) {
  var n = e.dataIndex,
    i = e.itemModel,
    a = i.getModel('emphasis'),
    o = a.getModel('itemStyle').getItemStyle(),
    s = i.getModel(['blur', 'itemStyle']).getItemStyle(),
    l = i.getModel(['select', 'itemStyle']).getItemStyle(),
    u = i.getShallow('cursor'),
    c = a.get('focus'),
    h = a.get('blurScope'),
    f = a.get('scale')
  sE(r, function (g) {
    if (g instanceof yr) {
      var v = g.style
      g.useStyle(
        Q(
          {
            image: v.image,
            x: v.x,
            y: v.y,
            width: v.width,
            height: v.height,
          },
          e.style,
        ),
      )
    } else g.useStyle(e.style)
    var m = g.ensureState('emphasis')
    ;(m.style = o),
      f && ((m.scaleX = g.scaleX * 1.1), (m.scaleY = g.scaleY * 1.1)),
      (g.ensureState('blur').style = s),
      (g.ensureState('select').style = l),
      u && (g.cursor = u),
      (g.z2 = e.z2)
  })
  var d = t.valueDim.posDesc[+(e.boundingLength > 0)],
    p = r.__pictorialBarRect
  ;(p.ignoreClip = !0),
    mr(p, Zn(i), {
      labelFetcher: t.seriesModel,
      labelDataIndex: n,
      defaultText: of(t.seriesModel.getData(), n),
      inheritColor: e.style.fill,
      defaultOpacity: e.style.opacity,
      defaultOutsidePosition: d,
    }),
    fn(r, c, h, a.get('disabled'))
}
function TN(r) {
  var t = Math.round(r)
  return Math.abs(r - t) < 1e-4 ? t : Math.ceil(r)
}
const xgt = fgt
var Sgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.hasSymbolVisual = !0),
      (e.defaultSymbol = 'roundRect'),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e) {
      return (e.stack = null), r.prototype.getInitialData.apply(this, arguments)
    }),
    (t.type = 'series.pictorialBar'),
    (t.dependencies = ['grid']),
    (t.defaultOption = gl(c0.defaultOption, {
      symbol: 'circle',
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: 'end',
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: '-100%',
      clip: !1,
      progressive: 0,
      emphasis: {
        scale: !1,
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    })),
    t
  )
})(c0)
const Agt = Sgt
function bgt(r) {
  r.registerChartView(xgt),
    r.registerSeriesModel(Agt),
    r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Zt(IV, 'pictorialBar')),
    r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OV('pictorialBar'))
}
var wgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e._layers = []), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this,
        s = this.group,
        l = e.getLayerSeries(),
        u = a.getLayout('layoutInfo'),
        c = u.rect,
        h = u.boundaryGap
      ;(s.x = 0), (s.y = c.y + h[0])
      function f(v) {
        return v.name
      }
      var d = new es(this._layersSeries || [], l, f, f),
        p = []
      d.add(Tt(g, this, 'add'))
        .update(Tt(g, this, 'update'))
        .remove(Tt(g, this, 'remove'))
        .execute()
      function g(v, m, y) {
        var _ = o._layers
        if (v === 'remove') {
          s.remove(_[m])
          return
        }
        for (
          var x = [], A = [], S, b = l[m].indices, T = 0;
          T < b.length;
          T++
        ) {
          var w = a.getItemLayout(b[T]),
            M = w.x,
            C = w.y0,
            E = w.y
          x.push(M, C), A.push(M, C + E), (S = a.getItemVisual(b[T], 'style'))
        }
        var D,
          P = a.getItemLayout(b[0]),
          L = e.getModel('label'),
          I = L.get('margin'),
          F = e.getModel('emphasis')
        if (v === 'add') {
          var k = (p[m] = new Ht())
          ;(D = new wG({
            shape: {
              points: x,
              stackedOnPoints: A,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1,
            },
            z2: 0,
          })),
            k.add(D),
            s.add(k),
            e.isAnimationEnabled() &&
              D.setClipPath(
                Mgt(D.getBoundingRect(), e, function () {
                  D.removeClipPath()
                }),
              )
        } else {
          var k = _[y]
          ;(D = k.childAt(0)),
            s.add(k),
            (p[m] = k),
            we(
              D,
              {
                shape: {
                  points: x,
                  stackedOnPoints: A,
                },
              },
              e,
            ),
            Ca(D)
        }
        mr(
          D,
          Zn(e),
          {
            labelDataIndex: b[T - 1],
            defaultText: a.getName(b[T - 1]),
            inheritColor: S.fill,
          },
          {
            normal: {
              verticalAlign: 'middle',
            },
          },
        ),
          D.setTextConfig({
            position: null,
            local: !0,
          })
        var V = D.getTextContent()
        V && ((V.x = P.x - I), (V.y = P.y0 + P.y / 2)),
          D.useStyle(S),
          a.setItemGraphicEl(m, D),
          gr(D, e),
          fn(D, F.get('focus'), F.get('blurScope'), F.get('disabled'))
      }
      ;(this._layersSeries = l), (this._layers = p)
    }),
    (t.type = 'themeRiver'),
    t
  )
})(Ze)
function Mgt(r, t, e) {
  var n = new ge({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20,
    },
  })
  return (
    Je(
      n,
      {
        shape: {
          x: r.x - 50,
          width: r.width + 100,
          height: r.height + 20,
        },
      },
      t,
      e,
    ),
    n
  )
}
const Tgt = wgt
var zS = 2,
  Cgt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e) {
        r.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new Pv(
            Tt(this.getData, this),
            Tt(this.getRawData, this),
          ))
      }),
      (t.prototype.fixData = function (e) {
        var n = e.length,
          i = {},
          a = jb(e, function (f) {
            return i.hasOwnProperty(f[0] + '') || (i[f[0] + ''] = -1), f[2]
          }),
          o = []
        a.buckets.each(function (f, d) {
          o.push({
            name: d,
            dataList: f,
          })
        })
        for (var s = o.length, l = 0; l < s; ++l) {
          for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
            var h = o[l].dataList[c][0] + ''
            i[h] = l
          }
          for (var h in i)
            i.hasOwnProperty(h) &&
              i[h] !== l &&
              ((i[h] = l), (e[n] = [h, 0, u]), n++)
        }
        return e
      }),
      (t.prototype.getInitialData = function (e, n) {
        for (
          var i = this.getReferringComponents('singleAxis', Pn).models[0],
            a = i.get('type'),
            o = Ne(e.data, function (p) {
              return p[2] !== void 0
            }),
            s = this.fixData(o || []),
            l = [],
            u = (this.nameMap = Pt()),
            c = 0,
            h = 0;
          h < s.length;
          ++h
        )
          l.push(s[h][zS]), u.get(s[h][zS]) || (u.set(s[h][zS], c), c++)
        var f = wv(s, {
            coordDimensions: ['single'],
            dimensionsDefine: [
              {
                name: 'time',
                type: a0(a),
              },
              {
                name: 'value',
                type: 'float',
              },
              {
                name: 'name',
                type: 'ordinal',
              },
            ],
            encodeDefine: {
              single: 0,
              value: 1,
              itemName: 2,
            },
          }).dimensions,
          d = new Vr(f, this)
        return d.initData(s), d
      }),
      (t.prototype.getLayerSeries = function () {
        for (var e = this.getData(), n = e.count(), i = [], a = 0; a < n; ++a)
          i[a] = a
        var o = e.mapDimension('single'),
          s = jb(i, function (u) {
            return e.get('name', u)
          }),
          l = []
        return (
          s.buckets.each(function (u, c) {
            u.sort(function (h, f) {
              return e.get(o, h) - e.get(o, f)
            }),
              l.push({
                name: c,
                indices: u,
              })
          }),
          l
        )
      }),
      (t.prototype.getAxisTooltipData = function (e, n, i) {
        at(e) || (e = e ? [e] : [])
        for (
          var a = this.getData(),
            o = this.getLayerSeries(),
            s = [],
            l = o.length,
            u,
            c = 0;
          c < l;
          ++c
        ) {
          for (
            var h = Number.MAX_VALUE, f = -1, d = o[c].indices.length, p = 0;
            p < d;
            ++p
          ) {
            var g = a.get(e[0], o[c].indices[p]),
              v = Math.abs(g - n)
            v <= h && ((u = g), (h = v), (f = o[c].indices[p]))
          }
          s.push(f)
        }
        return {
          dataIndices: s,
          nestestValue: u,
        }
      }),
      (t.prototype.formatTooltip = function (e, n, i) {
        var a = this.getData(),
          o = a.getName(e),
          s = a.get(a.mapDimension('value'), e)
        return Kn('nameValue', {
          name: o,
          value: s,
        })
      }),
      (t.type = 'series.themeRiver'),
      (t.dependencies = ['singleAxis']),
      (t.defaultOption = {
        z: 2,
        colorBy: 'data',
        coordinateSystem: 'singleAxis',
        boundaryGap: ['10%', '10%'],
        singleAxisIndex: 0,
        animationEasing: 'linear',
        label: {
          margin: 4,
          show: !0,
          position: 'left',
          fontSize: 11,
        },
        emphasis: {
          label: {
            show: !0,
          },
        },
      }),
      t
    )
  })(rn)
const Egt = Cgt
function Dgt(r, t) {
  r.eachSeriesByType('themeRiver', function (e) {
    var n = e.getData(),
      i = e.coordinateSystem,
      a = {},
      o = i.getRect()
    a.rect = o
    var s = e.get('boundaryGap'),
      l = i.getAxis()
    if (((a.boundaryGap = s), l.orient === 'horizontal')) {
      ;(s[0] = _t(s[0], o.height)), (s[1] = _t(s[1], o.height))
      var u = o.height - s[0] - s[1]
      CN(n, e, u)
    } else {
      ;(s[0] = _t(s[0], o.width)), (s[1] = _t(s[1], o.width))
      var c = o.width - s[0] - s[1]
      CN(n, e, c)
    }
    n.setLayout('layoutInfo', a)
  })
}
function CN(r, t, e) {
  if (r.count())
    for (
      var n = t.coordinateSystem,
        i = t.getLayerSeries(),
        a = r.mapDimension('single'),
        o = r.mapDimension('value'),
        s = st(i, function (v) {
          return st(v.indices, function (m) {
            var y = n.dataToPoint(r.get(a, m))
            return (y[1] = r.get(o, m)), y
          })
        }),
        l = Lgt(s),
        u = l.y0,
        c = e / l.max,
        h = i.length,
        f = i[0].indices.length,
        d,
        p = 0;
      p < f;
      ++p
    ) {
      ;(d = u[p] * c),
        r.setItemLayout(i[0].indices[p], {
          layerIndex: 0,
          x: s[0][p][0],
          y0: d,
          y: s[0][p][1] * c,
        })
      for (var g = 1; g < h; ++g)
        (d += s[g - 1][p][1] * c),
          r.setItemLayout(i[g].indices[p], {
            layerIndex: g,
            x: s[g][p][0],
            y0: d,
            y: s[g][p][1] * c,
          })
    }
}
function Lgt(r) {
  for (
    var t = r.length, e = r[0].length, n = [], i = [], a = 0, o = 0;
    o < e;
    ++o
  ) {
    for (var s = 0, l = 0; l < t; ++l) s += r[l][o][1]
    s > a && (a = s), n.push(s)
  }
  for (var u = 0; u < e; ++u) i[u] = (a - n[u]) / 2
  a = 0
  for (var c = 0; c < e; ++c) {
    var h = n[c] + i[c]
    h > a && (a = h)
  }
  return {
    y0: i,
    max: a,
  }
}
function Pgt(r) {
  r.registerChartView(Tgt),
    r.registerSeriesModel(Egt),
    r.registerLayout(Dgt),
    r.registerProcessor(Lv('themeRiver'))
}
var Rgt = 2,
  Igt = 4,
  Ogt = (function (r) {
    X(t, r)
    function t(e, n, i, a) {
      var o = r.call(this) || this
      ;(o.z2 = Rgt),
        (o.textConfig = {
          inside: !0,
        }),
        (Wt(o).seriesIndex = n.seriesIndex)
      var s = new Ae({
        z2: Igt,
        silent: e.getModel().get(['label', 'silent']),
      })
      return o.setTextContent(s), o.updateData(!0, e, n, i, a), o
    }
    return (
      (t.prototype.updateData = function (e, n, i, a, o) {
        ;(this.node = n),
          (n.piece = this),
          (i = i || this._seriesModel),
          (a = a || this._ecModel)
        var s = this
        Wt(s).dataIndex = n.dataIndex
        var l = n.getModel(),
          u = l.getModel('emphasis'),
          c = n.getLayout(),
          h = Q({}, c)
        h.label = null
        var f = n.getVisual('style')
        f.lineJoin = 'bevel'
        var d = n.getVisual('decal')
        d && (f.decal = rf(d, o))
        var p = bu(l.getModel('itemStyle'), h, !0)
        Q(h, p),
          R(Hr, function (y) {
            var _ = s.ensureState(y),
              x = l.getModel([y, 'itemStyle'])
            _.style = x.getItemStyle()
            var A = bu(x, h)
            A && (_.shape = A)
          }),
          e
            ? (s.setShape(h),
              (s.shape.r = c.r0),
              Je(
                s,
                {
                  shape: {
                    r: c.r,
                  },
                },
                i,
                n.dataIndex,
              ))
            : (we(
                s,
                {
                  shape: h,
                },
                i,
              ),
              Ca(s)),
          s.useStyle(f),
          this._updateLabel(i)
        var g = l.getShallow('cursor')
        g && s.attr('cursor', g),
          (this._seriesModel = i || this._seriesModel),
          (this._ecModel = a || this._ecModel)
        var v = u.get('focus'),
          m =
            v === 'ancestor'
              ? n.getAncestorsIndices()
              : v === 'descendant'
              ? n.getDescendantIndices()
              : v
        fn(this, m, u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e) {
        var n = this,
          i = this.node.getModel(),
          a = i.getModel('label'),
          o = this.node.getLayout(),
          s = o.endAngle - o.startAngle,
          l = (o.startAngle + o.endAngle) / 2,
          u = Math.cos(l),
          c = Math.sin(l),
          h = this,
          f = h.getTextContent(),
          d = this.node.dataIndex,
          p = (a.get('minAngle') / 180) * Math.PI,
          g = a.get('show') && !(p != null && Math.abs(s) < p)
        ;(f.ignore = !g),
          R(Hp, function (m) {
            var y =
                m === 'normal' ? i.getModel('label') : i.getModel([m, 'label']),
              _ = m === 'normal',
              x = _ ? f : f.ensureState(m),
              A = e.getFormattedLabel(d, m)
            _ && (A = A || n.node.name),
              (x.style = $e(y, {}, null, m !== 'normal', !0)),
              A && (x.style.text = A)
            var S = y.get('show')
            S != null && !_ && (x.ignore = !S)
            var b = v(y, 'position'),
              T = _ ? h : h.states[m],
              w = T.style.fill
            T.textConfig = {
              outsideFill: y.get('color') === 'inherit' ? w : null,
              inside: b !== 'outside',
            }
            var M,
              C = v(y, 'distance') || 0,
              E = v(y, 'align'),
              D = v(y, 'rotate'),
              P = Math.PI * 0.5,
              L = Math.PI * 1.5,
              I = xi(D === 'tangential' ? Math.PI / 2 - l : l),
              F = I > P && !Up(I - P) && I < L
            b === 'outside'
              ? ((M = o.r + C), (E = F ? 'right' : 'left'))
              : !E || E === 'center'
              ? (s === 2 * Math.PI && o.r0 === 0
                  ? (M = 0)
                  : (M = (o.r + o.r0) / 2),
                (E = 'center'))
              : E === 'left'
              ? ((M = o.r0 + C), (E = F ? 'right' : 'left'))
              : E === 'right' && ((M = o.r - C), (E = F ? 'left' : 'right')),
              (x.style.align = E),
              (x.style.verticalAlign = v(y, 'verticalAlign') || 'middle'),
              (x.x = M * u + o.cx),
              (x.y = M * c + o.cy)
            var k = 0
            D === 'radial'
              ? (k = xi(-l) + (F ? Math.PI : 0))
              : D === 'tangential'
              ? (k = xi(Math.PI / 2 - l) + (F ? Math.PI : 0))
              : be(D) && (k = (D * Math.PI) / 180),
              (x.rotation = xi(k))
          })
        function v(m, y) {
          var _ = m.get(y)
          return _ ?? a.get(y)
        }
        f.dirtyStyle()
      }),
      t
    )
  })(oi)
const EN = Ogt
var Zw = 'sunburstRootToNode',
  DN = 'sunburstHighlight',
  Ngt = 'sunburstUnhighlight'
function kgt(r) {
  r.registerAction(
    {
      type: Zw,
      update: 'updateView',
    },
    function (t, e) {
      e.eachComponent(
        {
          mainType: 'series',
          subType: 'sunburst',
          query: t,
        },
        n,
      )
      function n(i, a) {
        var o = nv(t, [Zw], i)
        if (o) {
          var s = i.getViewRoot()
          s && (t.direction = YC(s, o.node) ? 'rollUp' : 'drillDown'),
            i.resetViewRoot(o.node)
        }
      }
    },
  ),
    r.registerAction(
      {
        type: DN,
        update: 'none',
      },
      function (t, e, n) {
        ;(t = Q({}, t)),
          e.eachComponent(
            {
              mainType: 'series',
              subType: 'sunburst',
              query: t,
            },
            i,
          )
        function i(a) {
          var o = nv(t, [DN], a)
          o && (t.dataIndex = o.node.dataIndex)
        }
        n.dispatchAction(
          Q(t, {
            type: 'highlight',
          }),
        )
      },
    ),
    r.registerAction(
      {
        type: Ngt,
        update: 'updateView',
      },
      function (t, e, n) {
        ;(t = Q({}, t)),
          n.dispatchAction(
            Q(t, {
              type: 'downplay',
            }),
          )
      },
    )
}
var Bgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      var o = this
      ;(this.seriesModel = e), (this.api = i), (this.ecModel = n)
      var s = e.getData(),
        l = s.tree.root,
        u = e.getViewRoot(),
        c = this.group,
        h = e.get('renderLabelForZeroData'),
        f = []
      u.eachNode(function (y) {
        f.push(y)
      })
      var d = this._oldChildren || []
      p(f, d), m(l, u), this._initEvents(), (this._oldChildren = f)
      function p(y, _) {
        if (y.length === 0 && _.length === 0) return
        new es(_, y, x, x).add(A).update(A).remove(Zt(A, null)).execute()
        function x(S) {
          return S.getId()
        }
        function A(S, b) {
          var T = S == null ? null : y[S],
            w = b == null ? null : _[b]
          g(T, w)
        }
      }
      function g(y, _) {
        if ((!h && y && !y.getValue() && (y = null), y !== l && _ !== l)) {
          if (_ && _.piece)
            y
              ? (_.piece.updateData(!1, y, e, n, i),
                s.setItemGraphicEl(y.dataIndex, _.piece))
              : v(_)
          else if (y) {
            var x = new EN(y, e, n, i)
            c.add(x), s.setItemGraphicEl(y.dataIndex, x)
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), (y.piece = null))
      }
      function m(y, _) {
        _.depth > 0
          ? (o.virtualPiece
              ? o.virtualPiece.updateData(!1, y, e, n, i)
              : ((o.virtualPiece = new EN(y, e, n, i)), c.add(o.virtualPiece)),
            _.piece.off('click'),
            o.virtualPiece.on('click', function (x) {
              o._rootToNode(_.parentNode)
            }))
          : o.virtualPiece &&
            (c.remove(o.virtualPiece), (o.virtualPiece = null))
      }
    }),
    (t.prototype._initEvents = function () {
      var e = this
      this.group.off('click'),
        this.group.on('click', function (n) {
          var i = !1,
            a = e.seriesModel.getViewRoot()
          a.eachNode(function (o) {
            if (!i && o.piece && o.piece === n.target) {
              var s = o.getModel().get('nodeClick')
              if (s === 'rootToNode') e._rootToNode(o)
              else if (s === 'link') {
                var l = o.getModel(),
                  u = l.get('link')
                if (u) {
                  var c = l.get('target', !0) || '_blank'
                  jy(u, c)
                }
              }
              i = !0
            }
          })
        })
    }),
    (t.prototype._rootToNode = function (e) {
      e !== this.seriesModel.getViewRoot() &&
        this.api.dispatchAction({
          type: Zw,
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e,
        })
    }),
    (t.prototype.containPoint = function (e, n) {
      var i = n.getData(),
        a = i.getItemLayout(0)
      if (a) {
        var o = e[0] - a.cx,
          s = e[1] - a.cy,
          l = Math.sqrt(o * o + s * s)
        return l <= a.r && l >= a.r0
      }
    }),
    (t.type = 'sunburst'),
    t
  )
})(Ze)
const Fgt = Bgt
var zgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.ignoreStyleOnData = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = {
        name: e.name,
        children: e.data,
      }
      nH(i)
      var a = (this._levelModels = st(
          e.levels || [],
          function (l) {
            return new qe(l, this, n)
          },
          this,
        )),
        o = XC.createTree(i, this, s)
      function s(l) {
        l.wrapMethod('getItemModel', function (u, c) {
          var h = o.getNodeByDataIndex(c),
            f = a[h.depth]
          return f && (u.parentModel = f), u
        })
      }
      return o.data
    }),
    (t.prototype.optionUpdated = function () {
      this.resetViewRoot()
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (n.treePathInfo = E_(i, this)), n
    }),
    (t.prototype.getLevelModel = function (e) {
      return this._levelModels && this._levelModels[e.depth]
    }),
    (t.prototype.getViewRoot = function () {
      return this._viewRoot
    }),
    (t.prototype.resetViewRoot = function (e) {
      e ? (this._viewRoot = e) : (e = this._viewRoot)
      var n = this.getRawData().tree.root
      ;(!e || (e !== n && !n.contains(e))) && (this._viewRoot = n)
    }),
    (t.prototype.enableAriaDecal = function () {
      o4(this)
    }),
    (t.type = 'series.sunburst'),
    (t.defaultOption = {
      z: 2,
      center: ['50%', '50%'],
      radius: [0, '75%'],
      clockwise: !0,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: !0,
      nodeClick: 'rootToNode',
      renderLabelForZeroData: !1,
      label: {
        rotate: 'radial',
        show: !0,
        opacity: 1,
        align: 'center',
        position: 'inside',
        distance: 5,
        silent: !0,
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: 'white',
        borderType: 'solid',
        shadowBlur: 0,
        shadowColor: 'rgba(0, 0, 0, 0.2)',
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1,
      },
      emphasis: {
        focus: 'descendant',
      },
      blur: {
        itemStyle: {
          opacity: 0.2,
        },
        label: {
          opacity: 0.1,
        },
      },
      animationType: 'expansion',
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: 'desc',
    }),
    t
  )
})(rn)
function nH(r) {
  var t = 0
  R(r.children, function (n) {
    nH(n)
    var i = n.value
    at(i) && (i = i[0]), (t += i)
  })
  var e = r.value
  at(e) && (e = e[0]),
    (e == null || isNaN(e)) && (e = t),
    e < 0 && (e = 0),
    at(r.value) ? (r.value[0] = e) : (r.value = e)
}
const Ugt = zgt
var LN = Math.PI / 180
function Vgt(r, t, e) {
  t.eachSeriesByType(r, function (n) {
    var i = n.get('center'),
      a = n.get('radius')
    at(a) || (a = [0, a]), at(i) || (i = [i, i])
    var o = e.getWidth(),
      s = e.getHeight(),
      l = Math.min(o, s),
      u = _t(i[0], o),
      c = _t(i[1], s),
      h = _t(a[0], l / 2),
      f = _t(a[1], l / 2),
      d = -n.get('startAngle') * LN,
      p = n.get('minAngle') * LN,
      g = n.getData().tree.root,
      v = n.getViewRoot(),
      m = v.depth,
      y = n.get('sort')
    y != null && rH(v, y)
    var _ = 0
    R(v.children, function (I) {
      !isNaN(I.getValue()) && _++
    })
    var x = v.getValue(),
      A = (Math.PI / (x || _)) * 2,
      S = v.depth > 0,
      b = v.height - (S ? -1 : 1),
      T = (f - h) / (b || 1),
      w = n.get('clockwise'),
      M = n.get('stillShowZeroSum'),
      C = w ? 1 : -1,
      E = function (I, F) {
        if (I) {
          var k = F
          if (I !== g) {
            var V = I.getValue(),
              H = x === 0 && M ? A : V * A
            H < p && (H = p), (k = F + C * H)
            var Y = I.depth - m - (S ? -1 : 1),
              K = h + T * Y,
              ut = h + T * (Y + 1),
              W = n.getLevelModel(I)
            if (W) {
              var Z = W.get('r0', !0),
                ft = W.get('r', !0),
                lt = W.get('radius', !0)
              lt != null && ((Z = lt[0]), (ft = lt[1])),
                Z != null && (K = _t(Z, l / 2)),
                ft != null && (ut = _t(ft, l / 2))
            }
            I.setLayout({
              angle: H,
              startAngle: F,
              endAngle: k,
              clockwise: w,
              cx: u,
              cy: c,
              r0: K,
              r: ut,
            })
          }
          if (I.children && I.children.length) {
            var ct = 0
            R(I.children, function (At) {
              ct += E(At, F + ct)
            })
          }
          return k - F
        }
      }
    if (S) {
      var D = h,
        P = h + T,
        L = Math.PI * 2
      g.setLayout({
        angle: L,
        startAngle: d,
        endAngle: d + L,
        clockwise: w,
        cx: u,
        cy: c,
        r0: D,
        r: P,
      })
    }
    E(v, d)
  })
}
function rH(r, t) {
  var e = r.children || []
  ;(r.children = Ggt(e, t)),
    e.length &&
      R(r.children, function (n) {
        rH(n, t)
      })
}
function Ggt(r, t) {
  if (Nt(t)) {
    var e = st(r, function (i, a) {
      var o = i.getValue()
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function () {
            return o
          },
        },
        index: a,
      }
    })
    return (
      e.sort(function (i, a) {
        return t(i.params, a.params)
      }),
      st(e, function (i) {
        return r[i.index]
      })
    )
  } else {
    var n = t === 'asc'
    return r.sort(function (i, a) {
      var o = (i.getValue() - a.getValue()) * (n ? 1 : -1)
      return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o
    })
  }
}
function Hgt(r) {
  var t = {}
  function e(n, i, a) {
    for (var o = n; o && o.depth > 1; ) o = o.parentNode
    var s = i.getColorFromPalette(o.name || o.dataIndex + '', t)
    return (
      n.depth > 1 && bt(s) && (s = zb(s, ((n.depth - 1) / (a - 1)) * 0.5)), s
    )
  }
  r.eachSeriesByType('sunburst', function (n) {
    var i = n.getData(),
      a = i.tree
    a.eachNode(function (o) {
      var s = o.getModel(),
        l = s.getModel('itemStyle').getItemStyle()
      l.fill || (l.fill = e(o, n, a.root.height))
      var u = i.ensureUniqueItemVisual(o.dataIndex, 'style')
      Q(u, l)
    })
  })
}
function Wgt(r) {
  r.registerChartView(Fgt),
    r.registerSeriesModel(Ugt),
    r.registerLayout(Zt(Vgt, 'sunburst')),
    r.registerProcessor(Zt(Lv, 'sunburst')),
    r.registerVisual(Hgt),
    kgt(r)
}
var PN = {
    color: 'fill',
    borderColor: 'stroke',
  },
  Xgt = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1,
  },
  Xo = ve(),
  Ygt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.optionUpdated = function () {
        ;(this.currentZLevel = this.get('zlevel', !0)),
          (this.currentZ = this.get('z', !0))
      }),
      (t.prototype.getInitialData = function (e, n) {
        return as(null, this)
      }),
      (t.prototype.getDataParams = function (e, n, i) {
        var a = r.prototype.getDataParams.call(this, e, n)
        return i && (a.info = Xo(i).info), a
      }),
      (t.type = 'series.custom'),
      (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        z: 2,
        legendHoverLink: !0,
        clip: !1,
      }),
      t
    )
  })(rn)
const $gt = Ygt
function qgt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      ['x', 'y'],
      function (e, n) {
        var i = this.getAxis(e),
          a = t[n],
          o = r[n] / 2
        return i.type === 'category'
          ? i.getBandWidth()
          : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o))
      },
      this,
    )
  )
}
function Zgt(r) {
  var t = r.master.getRect()
  return {
    coordSys: {
      type: 'cartesian2d',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(qgt, r),
    },
  }
}
function Kgt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      [0, 1],
      function (e) {
        var n = t[e],
          i = r[e] / 2,
          a = [],
          o = []
        return (
          (a[e] = n - i),
          (o[e] = n + i),
          (a[1 - e] = o[1 - e] = t[1 - e]),
          Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e])
        )
      },
      this,
    )
  )
}
function jgt(r) {
  var t = r.getBoundingRect()
  return {
    coordSys: {
      type: 'geo',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: r.getZoom(),
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(Kgt, r),
    },
  }
}
function Jgt(r, t) {
  var e = this.getAxis(),
    n = t instanceof Array ? t[0] : t,
    i = (r instanceof Array ? r[0] : r) / 2
  return e.type === 'category'
    ? e.getBandWidth()
    : Math.abs(e.dataToCoord(n - i) - e.dataToCoord(n + i))
}
function Qgt(r) {
  var t = r.getRect()
  return {
    coordSys: {
      type: 'singleAxis',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(Jgt, r),
    },
  }
}
function tmt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      ['Radius', 'Angle'],
      function (e, n) {
        var i = 'get' + e + 'Axis',
          a = this[i](),
          o = t[n],
          s = r[n] / 2,
          l =
            a.type === 'category'
              ? a.getBandWidth()
              : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s))
        return e === 'Angle' && (l = (l * Math.PI) / 180), l
      },
      this,
    )
  )
}
function emt(r) {
  var t = r.getRadiusAxis(),
    e = r.getAngleAxis(),
    n = t.getExtent()
  return (
    n[0] > n[1] && n.reverse(),
    {
      coordSys: {
        type: 'polar',
        cx: r.cx,
        cy: r.cy,
        r: n[1],
        r0: n[0],
      },
      api: {
        coord: function (i) {
          var a = t.dataToRadius(i[0]),
            o = e.dataToAngle(i[1]),
            s = r.coordToPoint([a, o])
          return s.push(a, (o * Math.PI) / 180), s
        },
        size: Tt(tmt, r),
      },
    }
  )
}
function nmt(r) {
  var t = r.getRect(),
    e = r.getRangeInfo()
  return {
    coordSys: {
      type: 'calendar',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: e.start,
        end: e.end,
        weeks: e.weeks,
        dayCount: e.allDay,
      },
    },
    api: {
      coord: function (n, i) {
        return r.dataToPoint(n, i)
      },
    },
  }
}
function iH(r, t, e, n) {
  return (
    r &&
    (r.legacy ||
      (r.legacy !== !1 &&
        !e &&
        !n &&
        t !== 'tspan' &&
        (t === 'text' || Et(r, 'text'))))
  )
}
function aH(r, t, e) {
  var n = r,
    i,
    a,
    o
  if (t === 'text') o = n
  else {
    ;(o = {}),
      Et(n, 'text') && (o.text = n.text),
      Et(n, 'rich') && (o.rich = n.rich),
      Et(n, 'textFill') && (o.fill = n.textFill),
      Et(n, 'textStroke') && (o.stroke = n.textStroke),
      Et(n, 'fontFamily') && (o.fontFamily = n.fontFamily),
      Et(n, 'fontSize') && (o.fontSize = n.fontSize),
      Et(n, 'fontStyle') && (o.fontStyle = n.fontStyle),
      Et(n, 'fontWeight') && (o.fontWeight = n.fontWeight),
      (a = {
        type: 'text',
        style: o,
        silent: !0,
      }),
      (i = {})
    var s = Et(n, 'textPosition')
    e
      ? (i.position = s ? n.textPosition : 'inside')
      : s && (i.position = n.textPosition),
      Et(n, 'textPosition') && (i.position = n.textPosition),
      Et(n, 'textOffset') && (i.offset = n.textOffset),
      Et(n, 'textRotation') && (i.rotation = n.textRotation),
      Et(n, 'textDistance') && (i.distance = n.textDistance)
  }
  return (
    RN(o, r),
    R(o.rich, function (l) {
      RN(l, l)
    }),
    {
      textConfig: i,
      textContent: a,
    }
  )
}
function RN(r, t) {
  t &&
    ((t.font = t.textFont || t.font),
    Et(t, 'textStrokeWidth') && (r.lineWidth = t.textStrokeWidth),
    Et(t, 'textAlign') && (r.align = t.textAlign),
    Et(t, 'textVerticalAlign') && (r.verticalAlign = t.textVerticalAlign),
    Et(t, 'textLineHeight') && (r.lineHeight = t.textLineHeight),
    Et(t, 'textWidth') && (r.width = t.textWidth),
    Et(t, 'textHeight') && (r.height = t.textHeight),
    Et(t, 'textBackgroundColor') && (r.backgroundColor = t.textBackgroundColor),
    Et(t, 'textPadding') && (r.padding = t.textPadding),
    Et(t, 'textBorderColor') && (r.borderColor = t.textBorderColor),
    Et(t, 'textBorderWidth') && (r.borderWidth = t.textBorderWidth),
    Et(t, 'textBorderRadius') && (r.borderRadius = t.textBorderRadius),
    Et(t, 'textBoxShadowColor') && (r.shadowColor = t.textBoxShadowColor),
    Et(t, 'textBoxShadowBlur') && (r.shadowBlur = t.textBoxShadowBlur),
    Et(t, 'textBoxShadowOffsetX') && (r.shadowOffsetX = t.textBoxShadowOffsetX),
    Et(t, 'textBoxShadowOffsetY') && (r.shadowOffsetY = t.textBoxShadowOffsetY))
}
function IN(r, t, e) {
  var n = r
  ;(n.textPosition = n.textPosition || e.position || 'inside'),
    e.offset != null && (n.textOffset = e.offset),
    e.rotation != null && (n.textRotation = e.rotation),
    e.distance != null && (n.textDistance = e.distance)
  var i = n.textPosition.indexOf('inside') >= 0,
    a = r.fill || '#000'
  ON(n, t)
  var o = n.textFill == null
  return (
    i
      ? o &&
        ((n.textFill = e.insideFill || '#fff'),
        !n.textStroke && e.insideStroke && (n.textStroke = e.insideStroke),
        !n.textStroke && (n.textStroke = a),
        n.textStrokeWidth == null && (n.textStrokeWidth = 2))
      : (o && (n.textFill = r.fill || e.outsideFill || '#000'),
        !n.textStroke && e.outsideStroke && (n.textStroke = e.outsideStroke)),
    (n.text = t.text),
    (n.rich = t.rich),
    R(t.rich, function (s) {
      ON(s, s)
    }),
    n
  )
}
function ON(r, t) {
  t &&
    (Et(t, 'fill') && (r.textFill = t.fill),
    Et(t, 'stroke') && (r.textStroke = t.fill),
    Et(t, 'lineWidth') && (r.textStrokeWidth = t.lineWidth),
    Et(t, 'font') && (r.font = t.font),
    Et(t, 'fontStyle') && (r.fontStyle = t.fontStyle),
    Et(t, 'fontWeight') && (r.fontWeight = t.fontWeight),
    Et(t, 'fontSize') && (r.fontSize = t.fontSize),
    Et(t, 'fontFamily') && (r.fontFamily = t.fontFamily),
    Et(t, 'align') && (r.textAlign = t.align),
    Et(t, 'verticalAlign') && (r.textVerticalAlign = t.verticalAlign),
    Et(t, 'lineHeight') && (r.textLineHeight = t.lineHeight),
    Et(t, 'width') && (r.textWidth = t.width),
    Et(t, 'height') && (r.textHeight = t.height),
    Et(t, 'backgroundColor') && (r.textBackgroundColor = t.backgroundColor),
    Et(t, 'padding') && (r.textPadding = t.padding),
    Et(t, 'borderColor') && (r.textBorderColor = t.borderColor),
    Et(t, 'borderWidth') && (r.textBorderWidth = t.borderWidth),
    Et(t, 'borderRadius') && (r.textBorderRadius = t.borderRadius),
    Et(t, 'shadowColor') && (r.textBoxShadowColor = t.shadowColor),
    Et(t, 'shadowBlur') && (r.textBoxShadowBlur = t.shadowBlur),
    Et(t, 'shadowOffsetX') && (r.textBoxShadowOffsetX = t.shadowOffsetX),
    Et(t, 'shadowOffsetY') && (r.textBoxShadowOffsetY = t.shadowOffsetY),
    Et(t, 'textShadowColor') && (r.textShadowColor = t.textShadowColor),
    Et(t, 'textShadowBlur') && (r.textShadowBlur = t.textShadowBlur),
    Et(t, 'textShadowOffsetX') && (r.textShadowOffsetX = t.textShadowOffsetX),
    Et(t, 'textShadowOffsetY') && (r.textShadowOffsetY = t.textShadowOffsetY))
}
var oH = {
    position: ['x', 'y'],
    scale: ['scaleX', 'scaleY'],
    origin: ['originX', 'originY'],
  },
  NN = pe(oH)
co(
  fo,
  function (r, t) {
    return (r[t] = 1), r
  },
  {},
)
fo.join(', ')
var y0 = ['', 'style', 'shape', 'extra'],
  uf = ve()
function lE(r, t, e, n, i) {
  var a = r + 'Animation',
    o = xf(r, n, i) || {},
    s = uf(t).userDuring
  return (
    o.duration > 0 &&
      ((o.during = s
        ? Tt(smt, {
            el: t,
            userDuring: s,
          })
        : null),
      (o.setToFinal = !0),
      (o.scope = r)),
    Q(o, e[a]),
    o
  )
}
function sy(r, t, e, n) {
  n = n || {}
  var i = n.dataIndex,
    a = n.isInit,
    o = n.clearStyle,
    s = e.isAnimationEnabled(),
    l = uf(r),
    u = t.style
  l.userDuring = t.during
  var c = {},
    h = {}
  if (
    (umt(r, t, h),
    BN('shape', t, h),
    BN('extra', t, h),
    !a &&
      s &&
      (lmt(r, t, c),
      kN('shape', r, t, c),
      kN('extra', r, t, c),
      cmt(r, t, u, c)),
    (h.style = u),
    rmt(r, h, o),
    amt(r, t),
    s)
  )
    if (a) {
      var f = {}
      R(y0, function (p) {
        var g = p ? t[p] : t
        g &&
          g.enterFrom &&
          (p && (f[p] = f[p] || {}), Q(p ? f[p] : f, g.enterFrom))
      })
      var d = lE('enter', r, t, e, i)
      d.duration > 0 && r.animateFrom(f, d)
    } else imt(r, t, i || 0, e, c)
  sH(r, t), u ? r.dirty() : r.markRedraw()
}
function sH(r, t) {
  for (var e = uf(r).leaveToProps, n = 0; n < y0.length; n++) {
    var i = y0[n],
      a = i ? t[i] : t
    a &&
      a.leaveTo &&
      (e || (e = uf(r).leaveToProps = {}),
      i && (e[i] = e[i] || {}),
      Q(i ? e[i] : e, a.leaveTo))
  }
}
function P_(r, t, e, n) {
  if (r) {
    var i = r.parent,
      a = uf(r).leaveToProps
    if (a) {
      var o = lE('update', r, t, e, 0)
      ;(o.done = function () {
        i.remove(r), n && n()
      }),
        r.animateTo(a, o)
    } else i.remove(r), n && n()
  }
}
function zu(r) {
  return r === 'all'
}
function rmt(r, t, e) {
  var n = t.style
  if (!r.isGroup && n) {
    if (e) {
      r.useStyle({})
      for (var i = r.animators, a = 0; a < i.length; a++) {
        var o = i[a]
        o.targetName === 'style' && o.changeTarget(r.style)
      }
    }
    r.setStyle(n)
  }
  t && ((t.style = null), t && r.attr(t), (t.style = n))
}
function imt(r, t, e, n, i) {
  if (i) {
    var a = lE('update', r, t, n, e)
    a.duration > 0 && r.animateFrom(i, a)
  }
}
function amt(r, t) {
  Et(t, 'silent') && (r.silent = t.silent),
    Et(t, 'ignore') && (r.ignore = t.ignore),
    r instanceof ea && Et(t, 'invisible') && (r.invisible = t.invisible),
    r instanceof oe && Et(t, 'autoBatch') && (r.autoBatch = t.autoBatch)
}
var Va = {},
  omt = {
    setTransform: function (r, t) {
      return (Va.el[r] = t), this
    },
    getTransform: function (r) {
      return Va.el[r]
    },
    setShape: function (r, t) {
      var e = Va.el,
        n = e.shape || (e.shape = {})
      return (n[r] = t), e.dirtyShape && e.dirtyShape(), this
    },
    getShape: function (r) {
      var t = Va.el.shape
      if (t) return t[r]
    },
    setStyle: function (r, t) {
      var e = Va.el,
        n = e.style
      return n && ((n[r] = t), e.dirtyStyle && e.dirtyStyle()), this
    },
    getStyle: function (r) {
      var t = Va.el.style
      if (t) return t[r]
    },
    setExtra: function (r, t) {
      var e = Va.el.extra || (Va.el.extra = {})
      return (e[r] = t), this
    },
    getExtra: function (r) {
      var t = Va.el.extra
      if (t) return t[r]
    },
  }
function smt() {
  var r = this,
    t = r.el
  if (t) {
    var e = uf(t).userDuring,
      n = r.userDuring
    if (e !== n) {
      r.el = r.userDuring = null
      return
    }
    ;(Va.el = t), n(omt)
  }
}
function kN(r, t, e, n) {
  var i = e[r]
  if (i) {
    var a = t[r],
      o
    if (a) {
      var s = e.transition,
        l = i.transition
      if (l)
        if ((!o && (o = n[r] = {}), zu(l))) Q(o, a)
        else
          for (var u = ke(l), c = 0; c < u.length; c++) {
            var h = u[c],
              f = a[h]
            o[h] = f
          }
      else if (zu(s) || re(s, r) >= 0) {
        !o && (o = n[r] = {})
        for (var d = pe(a), c = 0; c < d.length; c++) {
          var h = d[c],
            f = a[h]
          hmt(i[h], f) && (o[h] = f)
        }
      }
    }
  }
}
function BN(r, t, e) {
  var n = t[r]
  if (n)
    for (var i = (e[r] = {}), a = pe(n), o = 0; o < a.length; o++) {
      var s = a[o]
      i[s] = np(n[s])
    }
}
function lmt(r, t, e) {
  for (
    var n = t.transition, i = zu(n) ? fo : ke(n || []), a = 0;
    a < i.length;
    a++
  ) {
    var o = i[a]
    if (!(o === 'style' || o === 'shape' || o === 'extra')) {
      var s = r[o]
      e[o] = s
    }
  }
}
function umt(r, t, e) {
  for (var n = 0; n < NN.length; n++) {
    var i = NN[n],
      a = oH[i],
      o = t[i]
    o && ((e[a[0]] = o[0]), (e[a[1]] = o[1]))
  }
  for (var n = 0; n < fo.length; n++) {
    var s = fo[n]
    t[s] != null && (e[s] = t[s])
  }
}
function cmt(r, t, e, n) {
  if (e) {
    var i = r.style,
      a
    if (i) {
      var o = e.transition,
        s = t.transition
      if (o && !zu(o)) {
        var l = ke(o)
        !a && (a = n.style = {})
        for (var u = 0; u < l.length; u++) {
          var c = l[u],
            h = i[c]
          a[c] = h
        }
      } else if (
        r.getAnimationStyleProps &&
        (zu(s) || zu(o) || re(s, 'style') >= 0)
      ) {
        var f = r.getAnimationStyleProps(),
          d = f ? f.style : null
        if (d) {
          !a && (a = n.style = {})
          for (var p = pe(e), u = 0; u < p.length; u++) {
            var c = p[u]
            if (d[c]) {
              var h = i[c]
              a[c] = h
            }
          }
        }
      }
    }
  }
}
function hmt(r, t) {
  return Er(r) ? r !== t : r != null && isFinite(r)
}
var lH = ve(),
  fmt = ['percent', 'easing', 'shape', 'style', 'extra']
function uH(r) {
  r.stopAnimation('keyframe'), r.attr(lH(r))
}
function _0(r, t, e) {
  if (!(!e.isAnimationEnabled() || !t)) {
    if (at(t)) {
      R(t, function (s) {
        _0(r, s, e)
      })
      return
    }
    var n = t.keyframes,
      i = t.duration
    if (e && i == null) {
      var a = xf('enter', e, 0)
      i = a && a.duration
    }
    if (!(!n || !i)) {
      var o = lH(r)
      R(y0, function (s) {
        if (!(s && !r[s])) {
          var l
          n.sort(function (u, c) {
            return u.percent - c.percent
          }),
            R(n, function (u) {
              var c = r.animators,
                h = s ? u[s] : u
              if (h) {
                var f = pe(h)
                if (
                  (s ||
                    (f = Ne(f, function (g) {
                      return re(fmt, g) < 0
                    })),
                  !!f.length)
                ) {
                  l || ((l = r.animate(s, t.loop, !0)), (l.scope = 'keyframe'))
                  for (var d = 0; d < c.length; d++)
                    c[d] !== l &&
                      c[d].targetName === l.targetName &&
                      c[d].stopTracks(f)
                  s && (o[s] = o[s] || {})
                  var p = s ? o[s] : o
                  R(f, function (g) {
                    p[g] = ((s ? r[s] : r) || {})[g]
                  }),
                    l.whenWithKeys(i * u.percent, h, f, u.easing)
                }
              }
            }),
            l &&
              l
                .delay(t.delay || 0)
                .duration(i)
                .start(t.easing)
        }
      })
    }
  }
}
var Yo = 'emphasis',
  Hs = 'normal',
  uE = 'blur',
  cE = 'select',
  cl = [Hs, Yo, uE, cE],
  US = {
    normal: ['itemStyle'],
    emphasis: [Yo, 'itemStyle'],
    blur: [uE, 'itemStyle'],
    select: [cE, 'itemStyle'],
  },
  VS = {
    normal: ['label'],
    emphasis: [Yo, 'label'],
    blur: [uE, 'label'],
    select: [cE, 'label'],
  },
  dmt = ['x', 'y'],
  pmt = 'e\0\0',
  Oi = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {},
  },
  vmt = {
    cartesian2d: Zgt,
    geo: jgt,
    single: Qgt,
    polar: emt,
    calendar: nmt,
  }
function Kw(r) {
  return r instanceof oe
}
function jw(r) {
  return r instanceof ea
}
function gmt(r, t) {
  t.copyTransform(r),
    jw(t) &&
      jw(r) &&
      (t.setStyle(r.style),
      (t.z = r.z),
      (t.z2 = r.z2),
      (t.zlevel = r.zlevel),
      (t.invisible = r.invisible),
      (t.ignore = r.ignore),
      Kw(t) && Kw(r) && t.setShape(r.shape))
}
var mmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      this._progressiveEls = null
      var o = this._data,
        s = e.getData(),
        l = this.group,
        u = FN(e, s, n, i)
      o || l.removeAll(),
        s
          .diff(o)
          .add(function (h) {
            GS(i, null, h, u(h, a), e, l, s)
          })
          .remove(function (h) {
            var f = o.getItemGraphicEl(h)
            f && P_(f, Xo(f).option, e)
          })
          .update(function (h, f) {
            var d = o.getItemGraphicEl(f)
            GS(i, d, h, u(h, a), e, l, s)
          })
          .execute()
      var c = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
      c ? l.setClipPath(c) : l.removeClipPath(), (this._data = s)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      this.group.removeAll(), (this._data = null)
    }),
    (t.prototype.incrementalRender = function (e, n, i, a, o) {
      var s = n.getData(),
        l = FN(n, s, i, a),
        u = (this._progressiveEls = [])
      function c(d) {
        d.isGroup ||
          ((d.incremental = !0), (d.ensureState('emphasis').hoverLayer = !0))
      }
      for (var h = e.start; h < e.end; h++) {
        var f = GS(null, null, h, l(h, o), n, this.group, s)
        f && (f.traverse(c), u.push(f))
      }
    }),
    (t.prototype.eachRendered = function (e) {
      vl(this._progressiveEls || this.group, e)
    }),
    (t.prototype.filterForExposedEvent = function (e, n, i, a) {
      var o = n.element
      if (o == null || i.name === o) return !0
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === o) return !0
      return !1
    }),
    (t.type = 'custom'),
    t
  )
})(Ze)
const ymt = mmt
function hE(r) {
  var t = r.type,
    e
  if (t === 'path') {
    var n = r.shape,
      i =
        n.width != null && n.height != null
          ? {
              x: n.x || 0,
              y: n.y || 0,
              width: n.width,
              height: n.height,
            }
          : null,
      a = fH(n)
    ;(e = o_(a, null, i, n.layout || 'center')), (Xo(e).customPathData = a)
  } else if (t === 'image')
    (e = new yr({})), (Xo(e).customImagePath = r.style.image)
  else if (t === 'text') e = new Ae({})
  else if (t === 'group') e = new Ht()
  else {
    if (t === 'compoundPath')
      throw new Error('"compoundPath" is not supported yet.')
    var o = tC(t)
    if (!o) {
      var s = ''
      Ce(s)
    }
    e = new o()
  }
  return (
    (Xo(e).customGraphicType = t),
    (e.name = r.name),
    (e.z2EmphasisLift = 1),
    (e.z2SelectLift = 1),
    e
  )
}
function fE(r, t, e, n, i, a, o) {
  uH(t)
  var s = i && i.normal.cfg
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = dmt)
  var l = n && n.style
  if (l) {
    if (t.type === 'text') {
      var u = l
      Et(u, 'textFill') && (u.fill = u.textFill),
        Et(u, 'textStroke') && (u.stroke = u.textStroke)
    }
    var c = void 0,
      h = Kw(t) ? l.decal : null
    r && h && ((h.dirty = !0), (c = rf(h, r))), (l.__decalPattern = c)
  }
  if (jw(t) && l) {
    var c = l.__decalPattern
    c && (l.decal = c)
  }
  sy(t, n, a, {
    dataIndex: e,
    isInit: o,
    clearStyle: !0,
  }),
    _0(t, n.keyframeAnimation, a)
}
function cH(r, t, e, n, i) {
  var a = t.isGroup ? null : t,
    o = i && i[r].cfg
  if (a) {
    var s = a.ensureState(r)
    if (n === !1) {
      var l = a.getState(r)
      l && (l.style = null)
    } else s.style = n || null
    o && (s.textConfig = o), qu(a)
  }
}
function _mt(r, t, e) {
  if (!r.isGroup) {
    var n = r,
      i = e.currentZ,
      a = e.currentZLevel
    ;(n.z = i), (n.zlevel = a)
    var o = t.z2
    o != null && (n.z2 = o || 0)
    for (var s = 0; s < cl.length; s++) xmt(n, t, cl[s])
  }
}
function xmt(r, t, e) {
  var n = e === Hs,
    i = n ? t : x0(t, e),
    a = i ? i.z2 : null,
    o
  a != null && ((o = n ? r : r.ensureState(e)), (o.z2 = a || 0))
}
function FN(r, t, e, n) {
  var i = r.get('renderItem'),
    a = r.coordinateSystem,
    o = {}
  a && (o = a.prepareCustoms ? a.prepareCustoms(a) : vmt[a.type](a))
  for (
    var s = zt(
        {
          getWidth: n.getWidth,
          getHeight: n.getHeight,
          getZr: n.getZr,
          getDevicePixelRatio: n.getDevicePixelRatio,
          value: x,
          style: S,
          ordinalRawValue: A,
          styleEmphasis: b,
          visual: M,
          barLayout: C,
          currentSeriesIndices: E,
          font: D,
        },
        o.api || {},
      ),
      l = {
        context: {},
        seriesId: r.id,
        seriesName: r.name,
        seriesIndex: r.seriesIndex,
        coordSys: o.coordSys,
        dataInsideLength: t.count(),
        encode: Smt(r.getData()),
      },
      u,
      c,
      h = {},
      f = {},
      d = {},
      p = {},
      g = 0;
    g < cl.length;
    g++
  ) {
    var v = cl[g]
    ;(d[v] = r.getModel(US[v])), (p[v] = r.getModel(VS[v]))
  }
  function m(P) {
    return P === u ? c || (c = t.getItemModel(P)) : t.getItemModel(P)
  }
  function y(P, L) {
    return t.hasItemOption
      ? P === u
        ? h[L] || (h[L] = m(P).getModel(US[L]))
        : m(P).getModel(US[L])
      : d[L]
  }
  function _(P, L) {
    return t.hasItemOption
      ? P === u
        ? f[L] || (f[L] = m(P).getModel(VS[L]))
        : m(P).getModel(VS[L])
      : p[L]
  }
  return function (P, L) {
    return (
      (u = P),
      (c = null),
      (h = {}),
      (f = {}),
      i &&
        i(
          zt(
            {
              dataIndexInside: P,
              dataIndex: t.getRawIndex(P),
              actionType: L ? L.type : null,
            },
            l,
          ),
          s,
        )
    )
  }
  function x(P, L) {
    return (
      L == null && (L = u), t.getStore().get(t.getDimensionIndex(P || 0), L)
    )
  }
  function A(P, L) {
    L == null && (L = u), (P = P || 0)
    var I = t.getDimensionInfo(P)
    if (!I) {
      var F = t.getDimensionIndex(P)
      return F >= 0 ? t.getStore().get(F, L) : void 0
    }
    var k = t.get(I.name, L),
      V = I && I.ordinalMeta
    return V ? V.categories[k] : k
  }
  function S(P, L) {
    L == null && (L = u)
    var I = t.getItemVisual(L, 'style'),
      F = I && I.fill,
      k = I && I.opacity,
      V = y(L, Hs).getItemStyle()
    F != null && (V.fill = F), k != null && (V.opacity = k)
    var H = {
        inheritColor: bt(F) ? F : '#000',
      },
      Y = _(L, Hs),
      K = $e(Y, null, H, !1, !0)
    K.text = Y.getShallow('show')
      ? $t(r.getFormattedLabel(L, Hs), of(t, L))
      : null
    var ut = Zy(Y, H, !1)
    return w(P, V), (V = IN(V, K, ut)), P && T(V, P), (V.legacy = !0), V
  }
  function b(P, L) {
    L == null && (L = u)
    var I = y(L, Yo).getItemStyle(),
      F = _(L, Yo),
      k = $e(F, null, null, !0, !0)
    k.text = F.getShallow('show')
      ? ao(r.getFormattedLabel(L, Yo), r.getFormattedLabel(L, Hs), of(t, L))
      : null
    var V = Zy(F, null, !0)
    return w(P, I), (I = IN(I, k, V)), P && T(I, P), (I.legacy = !0), I
  }
  function T(P, L) {
    for (var I in L) Et(L, I) && (P[I] = L[I])
  }
  function w(P, L) {
    P &&
      (P.textFill && (L.textFill = P.textFill),
      P.textPosition && (L.textPosition = P.textPosition))
  }
  function M(P, L) {
    if ((L == null && (L = u), Et(PN, P))) {
      var I = t.getItemVisual(L, 'style')
      return I ? I[PN[P]] : null
    }
    if (Et(Xgt, P)) return t.getItemVisual(L, P)
  }
  function C(P) {
    if (a.type === 'cartesian2d') {
      var L = a.getBaseAxis()
      return Sot(
        zt(
          {
            axis: L,
          },
          P,
        ),
      )
    }
  }
  function E() {
    return e.getCurrentSeriesIndices()
  }
  function D(P) {
    return eC(P, e)
  }
}
function Smt(r) {
  var t = {}
  return (
    R(r.dimensions, function (e) {
      var n = r.getDimensionInfo(e)
      if (!n.isExtraCoord) {
        var i = n.coordDim,
          a = (t[i] = t[i] || [])
        a[n.coordDimIndex] = r.getDimensionIndex(e)
      }
    }),
    t
  )
}
function GS(r, t, e, n, i, a, o) {
  if (!n) {
    a.remove(t)
    return
  }
  var s = dE(r, t, e, n, i, a)
  return (
    s && o.setItemGraphicEl(e, s),
    s && fn(s, n.focus, n.blurScope, n.emphasisDisabled),
    s
  )
}
function dE(r, t, e, n, i, a) {
  var o = -1,
    s = t
  t && hH(t, n, i) && ((o = re(a.childrenRef(), t)), (t = null))
  var l = !t,
    u = t
  u ? u.clearStates() : ((u = hE(n)), s && gmt(s, u)),
    n.morph === !1
      ? (u.disableMorphing = !0)
      : u.disableMorphing && (u.disableMorphing = !1),
    (Oi.normal.cfg =
      Oi.normal.conOpt =
      Oi.emphasis.cfg =
      Oi.emphasis.conOpt =
      Oi.blur.cfg =
      Oi.blur.conOpt =
      Oi.select.cfg =
      Oi.select.conOpt =
        null),
    (Oi.isLegacy = !1),
    bmt(u, e, n, i, l, Oi),
    Amt(u, e, n, i, l),
    fE(r, u, e, n, Oi, i, l),
    Et(n, 'info') && (Xo(u).info = n.info)
  for (var c = 0; c < cl.length; c++) {
    var h = cl[c]
    if (h !== Hs) {
      var f = x0(n, h),
        d = pE(n, f, h)
      cH(h, u, f, d, Oi)
    }
  }
  return (
    _mt(u, n, i),
    n.type === 'group' && wmt(r, u, e, n, i),
    o >= 0 ? a.replaceAt(u, o) : a.add(u),
    u
  )
}
function hH(r, t, e) {
  var n = Xo(r),
    i = t.type,
    a = t.shape,
    o = t.style
  return (
    e.isUniversalTransitionEnabled() ||
    (i != null && i !== n.customGraphicType) ||
    (i === 'path' && Emt(a) && fH(a) !== n.customPathData) ||
    (i === 'image' && Et(o, 'image') && o.image !== n.customImagePath)
  )
}
function Amt(r, t, e, n, i) {
  var a = e.clipPath
  if (a === !1) r && r.getClipPath() && r.removeClipPath()
  else if (a) {
    var o = r.getClipPath()
    o && hH(o, a, n) && (o = null),
      o || ((o = hE(a)), r.setClipPath(o)),
      fE(null, o, t, a, null, n, i)
  }
}
function bmt(r, t, e, n, i, a) {
  if (!r.isGroup) {
    zN(e, null, a), zN(e, Yo, a)
    var o = a.normal.conOpt,
      s = a.emphasis.conOpt,
      l = a.blur.conOpt,
      u = a.select.conOpt
    if (o != null || s != null || u != null || l != null) {
      var c = r.getTextContent()
      if (o === !1) c && r.removeTextContent()
      else {
        ;(o = a.normal.conOpt =
          o || {
            type: 'text',
          }),
          c ? c.clearStates() : ((c = hE(o)), r.setTextContent(c)),
          fE(null, c, t, o, null, n, i)
        for (var h = o && o.style, f = 0; f < cl.length; f++) {
          var d = cl[f]
          if (d !== Hs) {
            var p = a[d].conOpt
            cH(d, c, p, pE(o, p, d), null)
          }
        }
        h ? c.dirty() : c.markRedraw()
      }
    }
  }
}
function zN(r, t, e) {
  var n = t ? x0(r, t) : r,
    i = t ? pE(r, n, Yo) : r.style,
    a = r.type,
    o = n ? n.textConfig : null,
    s = r.textContent,
    l = s ? (t ? x0(s, t) : s) : null
  if (i && (e.isLegacy || iH(i, a, !!o, !!l))) {
    e.isLegacy = !0
    var u = aH(i, a, !t)
    !o && u.textConfig && (o = u.textConfig),
      !l && u.textContent && (l = u.textContent)
  }
  if (!t && l) {
    var c = l
    !c.type && (c.type = 'text')
  }
  var h = t ? e[t] : e.normal
  ;(h.cfg = o), (h.conOpt = l)
}
function x0(r, t) {
  return t ? (r ? r[t] : null) : r
}
function pE(r, t, e) {
  var n = t && t.style
  return n == null && e === Yo && r && (n = r.styleEmphasis), n
}
function wmt(r, t, e, n, i) {
  var a = n.children,
    o = a ? a.length : 0,
    s = n.$mergeChildren,
    l = s === 'byName' || n.diffChildrenByName,
    u = s === !1
  if (!(!o && !l && !u)) {
    if (l) {
      Tmt({
        api: r,
        oldChildren: t.children() || [],
        newChildren: a || [],
        dataIndex: e,
        seriesModel: i,
        group: t,
      })
      return
    }
    u && t.removeAll()
    for (var c = 0; c < o; c++) {
      var h = a[c],
        f = t.childAt(c)
      h
        ? (h.ignore == null && (h.ignore = !1), dE(r, f, e, h, i, t))
        : (f.ignore = !0)
    }
    for (var d = t.childCount() - 1; d >= c; d--) {
      var p = t.childAt(d)
      Mmt(t, p, i)
    }
  }
}
function Mmt(r, t, e) {
  t && P_(t, Xo(r).option, e)
}
function Tmt(r) {
  new es(r.oldChildren, r.newChildren, UN, UN, r)
    .add(VN)
    .update(VN)
    .remove(Cmt)
    .execute()
}
function UN(r, t) {
  var e = r && r.name
  return e ?? pmt + t
}
function VN(r, t) {
  var e = this.context,
    n = r != null ? e.newChildren[r] : null,
    i = t != null ? e.oldChildren[t] : null
  dE(e.api, i, e.dataIndex, n, e.seriesModel, e.group)
}
function Cmt(r) {
  var t = this.context,
    e = t.oldChildren[r]
  e && P_(e, Xo(e).option, t.seriesModel)
}
function fH(r) {
  return r && (r.pathData || r.d)
}
function Emt(r) {
  return r && (Et(r, 'pathData') || Et(r, 'd'))
}
function Dmt(r) {
  r.registerChartView(ymt), r.registerSeriesModel($gt)
}
var du = ve(),
  GN = Vt,
  HS = Tt,
  Lmt = (function () {
    function r() {
      ;(this._dragging = !1), (this.animationThreshold = 15)
    }
    return (
      (r.prototype.render = function (t, e, n, i) {
        var a = e.get('value'),
          o = e.get('status')
        if (
          ((this._axisModel = t),
          (this._axisPointerModel = e),
          (this._api = n),
          !(!i && this._lastValue === a && this._lastStatus === o))
        ) {
          ;(this._lastValue = a), (this._lastStatus = o)
          var s = this._group,
            l = this._handle
          if (!o || o === 'hide') {
            s && s.hide(), l && l.hide()
            return
          }
          s && s.show(), l && l.show()
          var u = {}
          this.makeElOption(u, a, t, e, n)
          var c = u.graphicKey
          c !== this._lastGraphicKey && this.clear(n),
            (this._lastGraphicKey = c)
          var h = (this._moveAnimation = this.determineAnimation(t, e))
          if (!s)
            (s = this._group = new Ht()),
              this.createPointerEl(s, u, t, e),
              this.createLabelEl(s, u, t, e),
              n.getZr().add(s)
          else {
            var f = Zt(HN, e, h)
            this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, e)
          }
          XN(s, e, !0), this._renderHandle(a)
        }
      }),
      (r.prototype.remove = function (t) {
        this.clear(t)
      }),
      (r.prototype.dispose = function (t) {
        this.clear(t)
      }),
      (r.prototype.determineAnimation = function (t, e) {
        var n = e.get('animation'),
          i = t.axis,
          a = i.type === 'category',
          o = e.get('snap')
        if (!o && !a) return !1
        if (n === 'auto' || n == null) {
          var s = this.animationThreshold
          if (a && i.getBandWidth() > s) return !0
          if (o) {
            var l = FC(t).seriesDataCount,
              u = i.getExtent()
            return Math.abs(u[0] - u[1]) / l > s
          }
          return !1
        }
        return n === !0
      }),
      (r.prototype.makeElOption = function (t, e, n, i, a) {}),
      (r.prototype.createPointerEl = function (t, e, n, i) {
        var a = e.pointer
        if (a) {
          var o = (du(t).pointerEl = new nc[a.type](GN(e.pointer)))
          t.add(o)
        }
      }),
      (r.prototype.createLabelEl = function (t, e, n, i) {
        if (e.label) {
          var a = (du(t).labelEl = new Ae(GN(e.label)))
          t.add(a), WN(a, i)
        }
      }),
      (r.prototype.updatePointerEl = function (t, e, n) {
        var i = du(t).pointerEl
        i &&
          e.pointer &&
          (i.setStyle(e.pointer.style),
          n(i, {
            shape: e.pointer.shape,
          }))
      }),
      (r.prototype.updateLabelEl = function (t, e, n, i) {
        var a = du(t).labelEl
        a &&
          (a.setStyle(e.label.style),
          n(a, {
            x: e.label.x,
            y: e.label.y,
          }),
          WN(a, i))
      }),
      (r.prototype._renderHandle = function (t) {
        if (!(this._dragging || !this.updateHandleTransform)) {
          var e = this._axisPointerModel,
            n = this._api.getZr(),
            i = this._handle,
            a = e.getModel('handle'),
            o = e.get('status')
          if (!a.get('show') || !o || o === 'hide') {
            i && n.remove(i), (this._handle = null)
            return
          }
          var s
          this._handle ||
            ((s = !0),
            (i = this._handle =
              Sv(a.get('icon'), {
                cursor: 'move',
                draggable: !0,
                onmousemove: function (u) {
                  jo(u.event)
                },
                onmousedown: HS(this._onHandleDragMove, this, 0, 0),
                drift: HS(this._onHandleDragMove, this),
                ondragend: HS(this._onHandleDragEnd, this),
              })),
            n.add(i)),
            XN(i, e, !1),
            i.setStyle(
              a.getItemStyle(null, [
                'color',
                'borderColor',
                'borderWidth',
                'opacity',
                'shadowColor',
                'shadowBlur',
                'shadowOffsetX',
                'shadowOffsetY',
              ]),
            )
          var l = a.get('size')
          at(l) || (l = [l, l]),
            (i.scaleX = l[0] / 2),
            (i.scaleY = l[1] / 2),
            Df(
              this,
              '_doDispatchAxisPointer',
              a.get('throttle') || 0,
              'fixRate',
            ),
            this._moveHandleToValue(t, s)
        }
      }),
      (r.prototype._moveHandleToValue = function (t, e) {
        HN(
          this._axisPointerModel,
          !e && this._moveAnimation,
          this._handle,
          WS(
            this.getHandleTransform(t, this._axisModel, this._axisPointerModel),
          ),
        )
      }),
      (r.prototype._onHandleDragMove = function (t, e) {
        var n = this._handle
        if (n) {
          this._dragging = !0
          var i = this.updateHandleTransform(
            WS(n),
            [t, e],
            this._axisModel,
            this._axisPointerModel,
          )
          ;(this._payloadInfo = i),
            n.stopAnimation(),
            n.attr(WS(i)),
            (du(n).lastProp = null),
            this._doDispatchAxisPointer()
        }
      }),
      (r.prototype._doDispatchAxisPointer = function () {
        var t = this._handle
        if (t) {
          var e = this._payloadInfo,
            n = this._axisModel
          this._api.dispatchAction({
            type: 'updateAxisPointer',
            x: e.cursorPoint[0],
            y: e.cursorPoint[1],
            tooltipOption: e.tooltipOption,
            axesInfo: [
              {
                axisDim: n.axis.dim,
                axisIndex: n.componentIndex,
              },
            ],
          })
        }
      }),
      (r.prototype._onHandleDragEnd = function () {
        this._dragging = !1
        var t = this._handle
        if (t) {
          var e = this._axisPointerModel.get('value')
          this._moveHandleToValue(e),
            this._api.dispatchAction({
              type: 'hideTip',
            })
        }
      }),
      (r.prototype.clear = function (t) {
        ;(this._lastValue = null), (this._lastStatus = null)
        var e = t.getZr(),
          n = this._group,
          i = this._handle
        e &&
          n &&
          ((this._lastGraphicKey = null),
          n && e.remove(n),
          i && e.remove(i),
          (this._group = null),
          (this._handle = null),
          (this._payloadInfo = null)),
          Zp(this, '_doDispatchAxisPointer')
      }),
      (r.prototype.doClear = function () {}),
      (r.prototype.buildLabel = function (t, e, n) {
        return (
          (n = n || 0),
          {
            x: t[n],
            y: t[1 - n],
            width: e[n],
            height: e[1 - n],
          }
        )
      }),
      r
    )
  })()
function HN(r, t, e, n) {
  dH(du(e).lastProp, n) ||
    ((du(e).lastProp = n), t ? we(e, n, r) : (e.stopAnimation(), e.attr(n)))
}
function dH(r, t) {
  if (Ut(r) && Ut(t)) {
    var e = !0
    return (
      R(t, function (n, i) {
        e = e && dH(r[i], n)
      }),
      !!e
    )
  } else return r === t
}
function WN(r, t) {
  r[t.get(['label', 'show']) ? 'show' : 'hide']()
}
function WS(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0,
  }
}
function XN(r, t, e) {
  var n = t.get('z'),
    i = t.get('zlevel')
  r &&
    r.traverse(function (a) {
      a.type !== 'group' &&
        (n != null && (a.z = n), i != null && (a.zlevel = i), (a.silent = e))
    })
}
const vE = Lmt
function gE(r) {
  var t = r.get('type'),
    e = r.getModel(t + 'Style'),
    n
  return (
    t === 'line'
      ? ((n = e.getLineStyle()), (n.fill = null))
      : t === 'shadow' && ((n = e.getAreaStyle()), (n.stroke = null)),
    n
  )
}
function pH(r, t, e, n, i) {
  var a = e.get('value'),
    o = vH(a, t.axis, t.ecModel, e.get('seriesDataIndices'), {
      precision: e.get(['label', 'precision']),
      formatter: e.get(['label', 'formatter']),
    }),
    s = e.getModel('label'),
    l = wf(s.get('padding') || 0),
    u = s.getFont(),
    c = mv(o, u),
    h = i.position,
    f = c.width + l[1] + l[3],
    d = c.height + l[0] + l[2],
    p = i.align
  p === 'right' && (h[0] -= f), p === 'center' && (h[0] -= f / 2)
  var g = i.verticalAlign
  g === 'bottom' && (h[1] -= d),
    g === 'middle' && (h[1] -= d / 2),
    Pmt(h, f, d, n)
  var v = s.get('backgroundColor')
  ;(!v || v === 'auto') && (v = t.get(['axisLine', 'lineStyle', 'color'])),
    (r.label = {
      x: h[0],
      y: h[1],
      style: $e(s, {
        text: o,
        font: u,
        fill: s.getTextColor(),
        padding: l,
        backgroundColor: v,
      }),
      z2: 10,
    })
}
function Pmt(r, t, e, n) {
  var i = n.getWidth(),
    a = n.getHeight()
  ;(r[0] = Math.min(r[0] + t, i) - t),
    (r[1] = Math.min(r[1] + e, a) - e),
    (r[0] = Math.max(r[0], 0)),
    (r[1] = Math.max(r[1], 0))
}
function vH(r, t, e, n, i) {
  r = t.scale.parse(r)
  var a = t.scale.getLabel(
      {
        value: r,
      },
      {
        precision: i.precision,
      },
    ),
    o = i.formatter
  if (o) {
    var s = {
      value: EC(t, {
        value: r,
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: [],
    }
    R(n, function (l) {
      var u = e.getSeriesByIndex(l.seriesIndex),
        c = l.dataIndexInside,
        h = u && u.getDataParams(c)
      h && s.seriesData.push(h)
    }),
      bt(o) ? (a = o.replace('{value}', a)) : Nt(o) && (a = o(s))
  }
  return a
}
function mE(r, t, e) {
  var n = bi()
  return (
    ec(n, n, e.rotation),
    ho(n, n, e.position),
    ba(
      [
        r.dataToCoord(t),
        (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0),
      ],
      n,
    )
  )
}
function gH(r, t, e, n, i, a) {
  var o = ns.innerTextLayout(e.rotation, 0, e.labelDirection)
  ;(e.labelMargin = i.get(['label', 'margin'])),
    pH(t, n, i, a, {
      position: mE(n.axis, r, e),
      align: o.textAlign,
      verticalAlign: o.textVerticalAlign,
    })
}
function yE(r, t, e) {
  return (
    (e = e || 0),
    {
      x1: r[e],
      y1: r[1 - e],
      x2: t[e],
      y2: t[1 - e],
    }
  )
}
function mH(r, t, e) {
  return (
    (e = e || 0),
    {
      x: r[e],
      y: r[1 - e],
      width: t[e],
      height: t[1 - e],
    }
  )
}
function YN(r, t, e, n, i, a) {
  return {
    cx: r,
    cy: t,
    r0: e,
    r: n,
    startAngle: i,
    endAngle: a,
    clockwise: !0,
  }
}
var Rmt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.makeElOption = function (e, n, i, a, o) {
      var s = i.axis,
        l = s.grid,
        u = a.get('type'),
        c = $N(l, s).getOtherAxis(s).getGlobalExtent(),
        h = s.toGlobalCoord(s.dataToCoord(n, !0))
      if (u && u !== 'none') {
        var f = gE(a),
          d = Imt[u](s, h, c)
        ;(d.style = f), (e.graphicKey = d.type), (e.pointer = d)
      }
      var p = Iw(l.model, i)
      gH(n, e, p, i, a, o)
    }),
    (t.prototype.getHandleTransform = function (e, n, i) {
      var a = Iw(n.axis.grid.model, n, {
        labelInside: !1,
      })
      a.labelMargin = i.get(['handle', 'margin'])
      var o = mE(n.axis, e, a)
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0),
      }
    }),
    (t.prototype.updateHandleTransform = function (e, n, i, a) {
      var o = i.axis,
        s = o.grid,
        l = o.getGlobalExtent(!0),
        u = $N(s, o).getOtherAxis(o).getGlobalExtent(),
        c = o.dim === 'x' ? 0 : 1,
        h = [e.x, e.y]
      ;(h[c] += n[c]),
        (h[c] = Math.min(l[1], h[c])),
        (h[c] = Math.max(l[0], h[c]))
      var f = (u[1] + u[0]) / 2,
        d = [f, f]
      d[c] = h[c]
      var p = [
        {
          verticalAlign: 'middle',
        },
        {
          align: 'center',
        },
      ]
      return {
        x: h[0],
        y: h[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: p[c],
      }
    }),
    t
  )
})(vE)
function $N(r, t) {
  var e = {}
  return (e[t.dim + 'AxisIndex'] = t.index), r.getCartesian(e)
}
var Imt = {
  line: function (r, t, e) {
    var n = yE([t, e[0]], [t, e[1]], qN(r))
    return {
      type: 'Line',
      subPixelOptimize: !0,
      shape: n,
    }
  },
  shadow: function (r, t, e) {
    var n = Math.max(1, r.getBandWidth()),
      i = e[1] - e[0]
    return {
      type: 'Rect',
      shape: mH([t - n / 2, e[0]], [n, i], qN(r)),
    }
  },
}
function qN(r) {
  return r.dim === 'x' ? 0 : 1
}
const Omt = Rmt
var Nmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'axisPointer'),
    (t.defaultOption = {
      show: 'auto',
      z: 50,
      type: 'line',
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: '#B9BEC9',
        width: 1,
        type: 'dashed',
      },
      shadowStyle: {
        color: 'rgba(210,219,238,0.2)',
      },
      label: {
        show: !0,
        formatter: null,
        precision: 'auto',
        margin: 3,
        color: '#fff',
        padding: [5, 7, 5, 7],
        backgroundColor: 'auto',
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3,
      },
      handle: {
        show: !1,
        icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
        size: 45,
        margin: 50,
        color: '#333',
        shadowBlur: 3,
        shadowColor: '#aaa',
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40,
      },
    }),
    t
  )
})(xe)
const kmt = Nmt
var Vo = ve(),
  Bmt = R
function yH(r, t, e) {
  if (!Se.node) {
    var n = t.getZr()
    Vo(n).records || (Vo(n).records = {}), Fmt(n, t)
    var i = Vo(n).records[r] || (Vo(n).records[r] = {})
    i.handler = e
  }
}
function Fmt(r, t) {
  if (Vo(r).initialized) return
  ;(Vo(r).initialized = !0),
    e('click', Zt(ZN, 'click')),
    e('mousemove', Zt(ZN, 'mousemove')),
    e('globalout', Umt)
  function e(n, i) {
    r.on(n, function (a) {
      var o = Vmt(t)
      Bmt(Vo(r).records, function (s) {
        s && i(s, a, o.dispatchAction)
      }),
        zmt(o.pendings, t)
    })
  }
}
function zmt(r, t) {
  var e = r.showTip.length,
    n = r.hideTip.length,
    i
  e ? (i = r.showTip[e - 1]) : n && (i = r.hideTip[n - 1]),
    i && ((i.dispatchAction = null), t.dispatchAction(i))
}
function Umt(r, t, e) {
  r.handler('leave', null, e)
}
function ZN(r, t, e, n) {
  t.handler(r, e, n)
}
function Vmt(r) {
  var t = {
      showTip: [],
      hideTip: [],
    },
    e = function (n) {
      var i = t[n.type]
      i ? i.push(n) : ((n.dispatchAction = e), r.dispatchAction(n))
    }
  return {
    dispatchAction: e,
    pendings: t,
  }
}
function Jw(r, t) {
  if (!Se.node) {
    var e = t.getZr(),
      n = (Vo(e).records || {})[r]
    n && (Vo(e).records[r] = null)
  }
}
var Gmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = n.getComponent('tooltip'),
        o = e.get('triggerOn') || (a && a.get('triggerOn')) || 'mousemove|click'
      yH('axisPointer', i, function (s, l, u) {
        o !== 'none' &&
          (s === 'leave' || o.indexOf(s) >= 0) &&
          u({
            type: 'updateAxisPointer',
            currTrigger: s,
            x: l && l.offsetX,
            y: l && l.offsetY,
          })
      })
    }),
    (t.prototype.remove = function (e, n) {
      Jw('axisPointer', n)
    }),
    (t.prototype.dispose = function (e, n) {
      Jw('axisPointer', n)
    }),
    (t.type = 'axisPointer'),
    t
  )
})(dn)
const Hmt = Gmt
function _H(r, t) {
  var e = [],
    n = r.seriesIndex,
    i
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: [],
    }
  var a = i.getData(),
    o = Yu(a, r)
  if (o == null || o < 0 || at(o))
    return {
      point: [],
    }
  var s = a.getItemGraphicEl(o),
    l = i.coordinateSystem
  if (i.getTooltipPosition) e = i.getTooltipPosition(o) || []
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(),
        c = l.getOtherAxis(u),
        h = c.dim,
        f = u.dim,
        d = h === 'x' || h === 'radius' ? 1 : 0,
        p = a.mapDimension(f),
        g = []
      ;(g[d] = a.get(p, o)),
        (g[1 - d] = a.get(a.getCalculationInfo('stackResultDimension'), o)),
        (e = l.dataToPoint(g) || [])
    } else
      e =
        l.dataToPoint(
          a.getValues(
            st(l.dimensions, function (m) {
              return a.mapDimension(m)
            }),
            o,
          ),
        ) || []
  else if (s) {
    var v = s.getBoundingRect().clone()
    v.applyTransform(s.transform), (e = [v.x + v.width / 2, v.y + v.height / 2])
  }
  return {
    point: e,
    el: s,
  }
}
var KN = ve()
function Wmt(r, t, e) {
  var n = r.currTrigger,
    i = [r.x, r.y],
    a = r,
    o = r.dispatchAction || Tt(e.dispatchAction, e),
    s = t.getComponent('axisPointer').coordSysAxesInfo
  if (s) {
    ly(i) &&
      (i = _H(
        {
          seriesIndex: a.seriesIndex,
          dataIndex: a.dataIndex,
        },
        t,
      ).point)
    var l = ly(i),
      u = a.axesInfo,
      c = s.axesInfo,
      h = n === 'leave' || ly(i),
      f = {},
      d = {},
      p = {
        list: [],
        map: {},
      },
      g = {
        showPointer: Zt(Ymt, d),
        showTooltip: Zt($mt, p),
      }
    R(s.coordSysMap, function (m, y) {
      var _ = l || m.containPoint(i)
      R(s.coordSysAxesInfo[y], function (x, A) {
        var S = x.axis,
          b = jmt(u, x)
        if (!h && _ && (!u || b)) {
          var T = b && b.value
          T == null && !l && (T = S.pointToData(i)),
            T != null && jN(x, T, g, !1, f)
        }
      })
    })
    var v = {}
    return (
      R(c, function (m, y) {
        var _ = m.linkGroup
        _ &&
          !d[y] &&
          R(_.axesInfo, function (x, A) {
            var S = d[A]
            if (x !== m && S) {
              var b = S.value
              _.mapper && (b = m.axis.scale.parse(_.mapper(b, JN(x), JN(m)))),
                (v[m.key] = b)
            }
          })
      }),
      R(v, function (m, y) {
        jN(c[y], m, g, !0, f)
      }),
      qmt(d, c, f),
      Zmt(p, i, r, o),
      Kmt(c, o, e),
      f
    )
  }
}
function jN(r, t, e, n, i) {
  var a = r.axis
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!r.involveSeries) {
      e.showPointer(r, t)
      return
    }
    var o = Xmt(t, r),
      s = o.payloadBatch,
      l = o.snapToValue
    s[0] && i.seriesIndex == null && Q(i, s[0]),
      !n && r.snap && a.containData(l) && l != null && (t = l),
      e.showPointer(r, t, s),
      e.showTooltip(r, o, l)
  }
}
function Xmt(r, t) {
  var e = t.axis,
    n = e.dim,
    i = r,
    a = [],
    o = Number.MAX_VALUE,
    s = -1
  return (
    R(t.seriesModels, function (l, u) {
      var c = l.getData().mapDimensionsAll(n),
        h,
        f
      if (l.getAxisTooltipData) {
        var d = l.getAxisTooltipData(c, r, e)
        ;(f = d.dataIndices), (h = d.nestestValue)
      } else {
        if (
          ((f = l
            .getData()
            .indicesOfNearest(c[0], r, e.type === 'category' ? 0.5 : null)),
          !f.length)
        )
          return
        h = l.getData().get(c[0], f[0])
      }
      if (!(h == null || !isFinite(h))) {
        var p = r - h,
          g = Math.abs(p)
        g <= o &&
          ((g < o || (p >= 0 && s < 0)) &&
            ((o = g), (s = p), (i = h), (a.length = 0)),
          R(f, function (v) {
            a.push({
              seriesIndex: l.seriesIndex,
              dataIndexInside: v,
              dataIndex: l.getData().getRawIndex(v),
            })
          }))
      }
    }),
    {
      payloadBatch: a,
      snapToValue: i,
    }
  )
}
function Ymt(r, t, e, n) {
  r[t.key] = {
    value: e,
    payloadBatch: n,
  }
}
function $mt(r, t, e, n) {
  var i = e.payloadBatch,
    a = t.axis,
    o = a.model,
    s = t.axisPointerModel
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model,
      u = ev(l),
      c = r.map[u]
    c ||
      ((c = r.map[u] =
        {
          coordSysId: l.id,
          coordSysIndex: l.componentIndex,
          coordSysType: l.type,
          coordSysMainType: l.mainType,
          dataByAxis: [],
        }),
      r.list.push(c)),
      c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: o.componentIndex,
        axisType: o.type,
        axisId: o.id,
        value: n,
        valueLabelOpt: {
          precision: s.get(['label', 'precision']),
          formatter: s.get(['label', 'formatter']),
        },
        seriesDataIndices: i.slice(),
      })
  }
}
function qmt(r, t, e) {
  var n = (e.axesInfo = [])
  R(t, function (i, a) {
    var o = i.axisPointerModel.option,
      s = r[a]
    s
      ? (!i.useHandle && (o.status = 'show'),
        (o.value = s.value),
        (o.seriesDataIndices = (s.payloadBatch || []).slice()))
      : !i.useHandle && (o.status = 'hide'),
      o.status === 'show' &&
        n.push({
          axisDim: i.axis.dim,
          axisIndex: i.axis.model.componentIndex,
          value: o.value,
        })
  })
}
function Zmt(r, t, e, n) {
  if (ly(t) || !r.list.length) {
    n({
      type: 'hideTip',
    })
    return
  }
  var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}
  n({
    type: 'showTip',
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: e.tooltipOption,
    position: e.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: r.list,
  })
}
function Kmt(r, t, e) {
  var n = e.getZr(),
    i = 'axisPointerLastHighlights',
    a = KN(n)[i] || {},
    o = (KN(n)[i] = {})
  R(r, function (u, c) {
    var h = u.axisPointerModel.option
    h.status === 'show' &&
      u.triggerEmphasis &&
      R(h.seriesDataIndices, function (f) {
        var d = f.seriesIndex + ' | ' + f.dataIndex
        o[d] = f
      })
  })
  var s = [],
    l = []
  R(a, function (u, c) {
    !o[c] && l.push(u)
  }),
    R(o, function (u, c) {
      !a[c] && s.push(u)
    }),
    l.length &&
      e.dispatchAction({
        type: 'downplay',
        escapeConnect: !0,
        notBlur: !0,
        batch: l,
      }),
    s.length &&
      e.dispatchAction({
        type: 'highlight',
        escapeConnect: !0,
        notBlur: !0,
        batch: s,
      })
}
function jmt(r, t) {
  for (var e = 0; e < (r || []).length; e++) {
    var n = r[e]
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n
  }
}
function JN(r) {
  var t = r.axis.model,
    e = {},
    n = (e.axisDim = r.axis.dim)
  return (
    (e.axisIndex = e[n + 'AxisIndex'] = t.componentIndex),
    (e.axisName = e[n + 'AxisName'] = t.name),
    (e.axisId = e[n + 'AxisId'] = t.id),
    e
  )
}
function ly(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1])
}
function Ov(r) {
  sc.registerAxisPointerClass('CartesianAxisPointer', Omt),
    r.registerComponentModel(kmt),
    r.registerComponentView(Hmt),
    r.registerPreprocessor(function (t) {
      if (t) {
        ;(!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {})
        var e = t.axisPointer.link
        e && !at(e) && (t.axisPointer.link = [e])
      }
    }),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function (t, e) {
      t.getComponent('axisPointer').coordSysAxesInfo = Fut(t, e)
    }),
    r.registerAction(
      {
        type: 'updateAxisPointer',
        event: 'updateAxisPointer',
        update: ':updateAxisPointer',
      },
      Wmt,
    )
}
function Jmt(r) {
  ie(XG), ie(Ov)
}
var Qmt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.makeElOption = function (e, n, i, a, o) {
      var s = i.axis
      s.dim === 'angle' && (this.animationThreshold = Math.PI / 18)
      var l = s.polar,
        u = l.getOtherAxis(s),
        c = u.getExtent(),
        h = s.dataToCoord(n),
        f = a.get('type')
      if (f && f !== 'none') {
        var d = gE(a),
          p = eyt[f](s, l, h, c)
        ;(p.style = d), (e.graphicKey = p.type), (e.pointer = p)
      }
      var g = a.get(['label', 'margin']),
        v = tyt(n, i, a, l, g)
      pH(e, i, a, o, v)
    }),
    t
  )
})(vE)
function tyt(r, t, e, n, i) {
  var a = t.axis,
    o = a.dataToCoord(r),
    s = n.getAngleAxis().getExtent()[0]
  s = (s / 180) * Math.PI
  var l = n.getRadiusAxis().getExtent(),
    u,
    c,
    h
  if (a.dim === 'radius') {
    var f = bi()
    ec(f, f, s), ho(f, f, [n.cx, n.cy]), (u = ba([o, -i], f))
    var d = t.getModel('axisLabel').get('rotate') || 0,
      p = ns.innerTextLayout(s, (d * Math.PI) / 180, -1)
    ;(c = p.textAlign), (h = p.textVerticalAlign)
  } else {
    var g = l[1]
    u = n.coordToPoint([g + i, o])
    var v = n.cx,
      m = n.cy
    ;(c =
      Math.abs(u[0] - v) / g < 0.3 ? 'center' : u[0] > v ? 'left' : 'right'),
      (h =
        Math.abs(u[1] - m) / g < 0.3 ? 'middle' : u[1] > m ? 'top' : 'bottom')
  }
  return {
    position: u,
    align: c,
    verticalAlign: h,
  }
}
var eyt = {
  line: function (r, t, e, n) {
    return r.dim === 'angle'
      ? {
          type: 'Line',
          shape: yE(t.coordToPoint([n[0], e]), t.coordToPoint([n[1], e])),
        }
      : {
          type: 'Circle',
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: e,
          },
        }
  },
  shadow: function (r, t, e, n) {
    var i = Math.max(1, r.getBandWidth()),
      a = Math.PI / 180
    return r.dim === 'angle'
      ? {
          type: 'Sector',
          shape: YN(t.cx, t.cy, n[0], n[1], (-e - i / 2) * a, (-e + i / 2) * a),
        }
      : {
          type: 'Sector',
          shape: YN(t.cx, t.cy, e - i / 2, e + i / 2, 0, Math.PI * 2),
        }
  },
}
const nyt = Qmt
var ryt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.findAxisModel = function (e) {
      var n,
        i = this.ecModel
      return (
        i.eachComponent(
          e,
          function (a) {
            a.getCoordSysModel() === this && (n = a)
          },
          this,
        ),
        n
      )
    }),
    (t.type = 'polar'),
    (t.dependencies = ['radiusAxis', 'angleAxis']),
    (t.defaultOption = {
      z: 0,
      center: ['50%', '50%'],
      radius: '80%',
    }),
    t
  )
})(xe)
const iyt = ryt
var _E = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this.getReferringComponents('polar', Pn).models[0]
    }),
    (t.type = 'polarAxis'),
    t
  )
})(xe)
In(_E, Mv)
var ayt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'angleAxis'), t
  })(_E),
  oyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'radiusAxis'), t
  })(_E),
  xE = (function (r) {
    X(t, r)
    function t(e, n) {
      return r.call(this, 'radius', e, n) || this
    }
    return (
      (t.prototype.pointToData = function (e, n) {
        return this.polar.pointToData(e, n)[this.dim === 'radius' ? 0 : 1]
      }),
      t
    )
  })(Ra)
xE.prototype.dataToRadius = Ra.prototype.dataToCoord
xE.prototype.radiusToData = Ra.prototype.coordToData
const syt = xE
var lyt = ve(),
  SE = (function (r) {
    X(t, r)
    function t(e, n) {
      return r.call(this, 'angle', e, n || [0, 360]) || this
    }
    return (
      (t.prototype.pointToData = function (e, n) {
        return this.polar.pointToData(e, n)[this.dim === 'radius' ? 0 : 1]
      }),
      (t.prototype.calculateCategoryInterval = function () {
        var e = this,
          n = e.getLabelModel(),
          i = e.scale,
          a = i.getExtent(),
          o = i.count()
        if (a[1] - a[0] < 1) return 0
        var s = a[0],
          l = e.dataToCoord(s + 1) - e.dataToCoord(s),
          u = Math.abs(l),
          c = mv(s == null ? '' : s + '', n.getFont(), 'center', 'top'),
          h = Math.max(c.height, 7),
          f = h / u
        isNaN(f) && (f = 1 / 0)
        var d = Math.max(0, Math.floor(f)),
          p = lyt(e.model),
          g = p.lastAutoInterval,
          v = p.lastTickCount
        return (
          g != null &&
          v != null &&
          Math.abs(g - d) <= 1 &&
          Math.abs(v - o) <= 1 &&
          g > d
            ? (d = g)
            : ((p.lastTickCount = o), (p.lastAutoInterval = d)),
          d
        )
      }),
      t
    )
  })(Ra)
SE.prototype.dataToAngle = Ra.prototype.dataToCoord
SE.prototype.angleToData = Ra.prototype.coordToData
const uyt = SE
var xH = ['radius', 'angle'],
  cyt = (function () {
    function r(t) {
      ;(this.dimensions = xH),
        (this.type = 'polar'),
        (this.cx = 0),
        (this.cy = 0),
        (this._radiusAxis = new syt()),
        (this._angleAxis = new uyt()),
        (this.axisPointerEnabled = !0),
        (this.name = t || ''),
        (this._radiusAxis.polar = this._angleAxis.polar = this)
    }
    return (
      (r.prototype.containPoint = function (t) {
        var e = this.pointToCoord(t)
        return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1])
      }),
      (r.prototype.containData = function (t) {
        return (
          this._radiusAxis.containData(t[0]) &&
          this._angleAxis.containData(t[1])
        )
      }),
      (r.prototype.getAxis = function (t) {
        var e = '_' + t + 'Axis'
        return this[e]
      }),
      (r.prototype.getAxes = function () {
        return [this._radiusAxis, this._angleAxis]
      }),
      (r.prototype.getAxesByScale = function (t) {
        var e = [],
          n = this._angleAxis,
          i = this._radiusAxis
        return (
          n.scale.type === t && e.push(n), i.scale.type === t && e.push(i), e
        )
      }),
      (r.prototype.getAngleAxis = function () {
        return this._angleAxis
      }),
      (r.prototype.getRadiusAxis = function () {
        return this._radiusAxis
      }),
      (r.prototype.getOtherAxis = function (t) {
        var e = this._angleAxis
        return t === e ? this._radiusAxis : e
      }),
      (r.prototype.getBaseAxis = function () {
        return (
          this.getAxesByScale('ordinal')[0] ||
          this.getAxesByScale('time')[0] ||
          this.getAngleAxis()
        )
      }),
      (r.prototype.getTooltipAxes = function (t) {
        var e = t != null && t !== 'auto' ? this.getAxis(t) : this.getBaseAxis()
        return {
          baseAxes: [e],
          otherAxes: [this.getOtherAxis(e)],
        }
      }),
      (r.prototype.dataToPoint = function (t, e) {
        return this.coordToPoint([
          this._radiusAxis.dataToRadius(t[0], e),
          this._angleAxis.dataToAngle(t[1], e),
        ])
      }),
      (r.prototype.pointToData = function (t, e) {
        var n = this.pointToCoord(t)
        return [
          this._radiusAxis.radiusToData(n[0], e),
          this._angleAxis.angleToData(n[1], e),
        ]
      }),
      (r.prototype.pointToCoord = function (t) {
        var e = t[0] - this.cx,
          n = t[1] - this.cy,
          i = this.getAngleAxis(),
          a = i.getExtent(),
          o = Math.min(a[0], a[1]),
          s = Math.max(a[0], a[1])
        i.inverse ? (o = s - 360) : (s = o + 360)
        var l = Math.sqrt(e * e + n * n)
        ;(e /= l), (n /= l)
        for (
          var u = (Math.atan2(-n, e) / Math.PI) * 180, c = u < o ? 1 : -1;
          u < o || u > s;

        )
          u += c * 360
        return [l, u]
      }),
      (r.prototype.coordToPoint = function (t) {
        var e = t[0],
          n = (t[1] / 180) * Math.PI,
          i = Math.cos(n) * e + this.cx,
          a = -Math.sin(n) * e + this.cy
        return [i, a]
      }),
      (r.prototype.getArea = function () {
        var t = this.getAngleAxis(),
          e = this.getRadiusAxis(),
          n = e.getExtent().slice()
        n[0] > n[1] && n.reverse()
        var i = t.getExtent(),
          a = Math.PI / 180
        return {
          cx: this.cx,
          cy: this.cy,
          r0: n[0],
          r: n[1],
          startAngle: -i[0] * a,
          endAngle: -i[1] * a,
          clockwise: t.inverse,
          contain: function (o, s) {
            var l = o - this.cx,
              u = s - this.cy,
              c = l * l + u * u - 1e-4,
              h = this.r,
              f = this.r0
            return c <= h * h && c >= f * f
          },
        }
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = QN(e)
        return i === this ? this.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = QN(e)
        return i === this ? this.pointToData(n) : null
      }),
      r
    )
  })()
function QN(r) {
  var t = r.seriesModel,
    e = r.polarModel
  return (e && e.coordinateSystem) || (t && t.coordinateSystem)
}
const hyt = cyt
function fyt(r, t, e) {
  var n = t.get('center'),
    i = e.getWidth(),
    a = e.getHeight()
  ;(r.cx = _t(n[0], i)), (r.cy = _t(n[1], a))
  var o = r.getRadiusAxis(),
    s = Math.min(i, a) / 2,
    l = t.get('radius')
  l == null ? (l = [0, '100%']) : at(l) || (l = [0, l])
  var u = [_t(l[0], s), _t(l[1], s)]
  o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1])
}
function dyt(r, t) {
  var e = this,
    n = e.getAngleAxis(),
    i = e.getRadiusAxis()
  if (
    (n.scale.setExtent(1 / 0, -1 / 0),
    i.scale.setExtent(1 / 0, -1 / 0),
    r.eachSeries(function (s) {
      if (s.coordinateSystem === e) {
        var l = s.getData()
        R(o0(l, 'radius'), function (u) {
          i.scale.unionExtentFromData(l, u)
        }),
          R(o0(l, 'angle'), function (u) {
            n.scale.unionExtentFromData(l, u)
          })
      }
    }),
    af(n.scale, n.model),
    af(i.scale, i.model),
    n.type === 'category' && !n.onBand)
  ) {
    var a = n.getExtent(),
      o = 360 / n.scale.count()
    n.inverse ? (a[1] += o) : (a[1] -= o), n.setExtent(a[0], a[1])
  }
}
function pyt(r) {
  return r.mainType === 'angleAxis'
}
function t3(r, t) {
  var e
  if (
    ((r.type = t.get('type')),
    (r.scale = w_(t)),
    (r.onBand = t.get('boundaryGap') && r.type === 'category'),
    (r.inverse = t.get('inverse')),
    pyt(t))
  ) {
    r.inverse = r.inverse !== t.get('clockwise')
    var n = t.get('startAngle'),
      i =
        (e = t.get('endAngle')) !== null && e !== void 0
          ? e
          : n + (r.inverse ? -360 : 360)
    r.setExtent(n, i)
  }
  ;(t.axis = r), (r.model = t)
}
var vyt = {
  dimensions: xH,
  create: function (r, t) {
    var e = []
    return (
      r.eachComponent('polar', function (n, i) {
        var a = new hyt(i + '')
        a.update = dyt
        var o = a.getRadiusAxis(),
          s = a.getAngleAxis(),
          l = n.findAxisModel('radiusAxis'),
          u = n.findAxisModel('angleAxis')
        t3(o, l),
          t3(s, u),
          fyt(a, n, t),
          e.push(a),
          (n.coordinateSystem = a),
          (a.model = n)
      }),
      r.eachSeries(function (n) {
        if (n.get('coordinateSystem') === 'polar') {
          var i = n.getReferringComponents('polar', Pn).models[0]
          n.coordinateSystem = i.coordinateSystem
        }
      }),
      e
    )
  },
}
const gyt = vyt
var myt = [
  'axisLine',
  'axisLabel',
  'axisTick',
  'minorTick',
  'splitLine',
  'minorSplitLine',
  'splitArea',
]
function Am(r, t, e) {
  t[1] > t[0] && (t = t.slice().reverse())
  var n = r.coordToPoint([t[0], e]),
    i = r.coordToPoint([t[1], e])
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1],
  }
}
function bm(r) {
  var t = r.getRadiusAxis()
  return t.inverse ? 0 : 1
}
function e3(r) {
  var t = r[0],
    e = r[r.length - 1]
  t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && r.pop()
}
var yyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'PolarAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var i = e.axis,
            a = i.polar,
            o = a.getRadiusAxis().getExtent(),
            s = i.getTicksCoords(),
            l = i.getMinorTicksCoords(),
            u = st(i.getViewLabels(), function (c) {
              c = Vt(c)
              var h = i.scale,
                f =
                  h.type === 'ordinal'
                    ? h.getRawOrdinalNumber(c.tickValue)
                    : c.tickValue
              return (c.coord = i.dataToCoord(f)), c
            })
          e3(u),
            e3(s),
            R(
              myt,
              function (c) {
                e.get([c, 'show']) &&
                  (!i.scale.isBlank() || c === 'axisLine') &&
                  _yt[c](this.group, e, a, s, l, o, u)
              },
              this,
            )
        }
      }),
      (t.type = 'angleAxis'),
      t
    )
  })(sc),
  _yt = {
    axisLine: function (r, t, e, n, i, a) {
      var o = t.getModel(['axisLine', 'lineStyle']),
        s = e.getAngleAxis(),
        l = Math.PI / 180,
        u = s.getExtent(),
        c = bm(e),
        h = c ? 0 : 1,
        f,
        d = Math.abs(u[1] - u[0]) === 360 ? 'Circle' : 'Arc'
      a[h] === 0
        ? (f = new nc[d]({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: a[c],
              startAngle: -u[0] * l,
              endAngle: -u[1] * l,
              clockwise: s.inverse,
            },
            style: o.getLineStyle(),
            z2: 1,
            silent: !0,
          }))
        : (f = new i_({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: a[c],
              r0: a[h],
            },
            style: o.getLineStyle(),
            z2: 1,
            silent: !0,
          })),
        (f.style.fill = null),
        r.add(f)
    },
    axisTick: function (r, t, e, n, i, a) {
      var o = t.getModel('axisTick'),
        s = (o.get('inside') ? -1 : 1) * o.get('length'),
        l = a[bm(e)],
        u = st(n, function (c) {
          return new rr({
            shape: Am(e, [l, l + s], c.coord),
          })
        })
      r.add(
        Wi(u, {
          style: zt(o.getModel('lineStyle').getLineStyle(), {
            stroke: t.get(['axisLine', 'lineStyle', 'color']),
          }),
        }),
      )
    },
    minorTick: function (r, t, e, n, i, a) {
      if (i.length) {
        for (
          var o = t.getModel('axisTick'),
            s = t.getModel('minorTick'),
            l = (o.get('inside') ? -1 : 1) * s.get('length'),
            u = a[bm(e)],
            c = [],
            h = 0;
          h < i.length;
          h++
        )
          for (var f = 0; f < i[h].length; f++)
            c.push(
              new rr({
                shape: Am(e, [u, u + l], i[h][f].coord),
              }),
            )
        r.add(
          Wi(c, {
            style: zt(
              s.getModel('lineStyle').getLineStyle(),
              zt(o.getLineStyle(), {
                stroke: t.get(['axisLine', 'lineStyle', 'color']),
              }),
            ),
          }),
        )
      }
    },
    axisLabel: function (r, t, e, n, i, a, o) {
      var s = t.getCategories(!0),
        l = t.getModel('axisLabel'),
        u = l.get('margin'),
        c = t.get('triggerEvent')
      R(
        o,
        function (h, f) {
          var d = l,
            p = h.tickValue,
            g = a[bm(e)],
            v = e.coordToPoint([g + u, h.coord]),
            m = e.cx,
            y = e.cy,
            _ =
              Math.abs(v[0] - m) / g < 0.3
                ? 'center'
                : v[0] > m
                ? 'left'
                : 'right',
            x =
              Math.abs(v[1] - y) / g < 0.3
                ? 'middle'
                : v[1] > y
                ? 'top'
                : 'bottom'
          if (s && s[p]) {
            var A = s[p]
            Ut(A) && A.textStyle && (d = new qe(A.textStyle, l, l.ecModel))
          }
          var S = new Ae({
            silent: ns.isLabelSilent(t),
            style: $e(d, {
              x: v[0],
              y: v[1],
              fill:
                d.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              text: h.formattedLabel,
              align: _,
              verticalAlign: x,
            }),
          })
          if ((r.add(S), c)) {
            var b = ns.makeAxisEventDataBase(t)
            ;(b.targetType = 'axisLabel'),
              (b.value = h.rawLabel),
              (Wt(S).eventData = b)
          }
        },
        this,
      )
    },
    splitLine: function (r, t, e, n, i, a) {
      var o = t.getModel('splitLine'),
        s = o.getModel('lineStyle'),
        l = s.get('color'),
        u = 0
      l = l instanceof Array ? l : [l]
      for (var c = [], h = 0; h < n.length; h++) {
        var f = u++ % l.length
        ;(c[f] = c[f] || []),
          c[f].push(
            new rr({
              shape: Am(e, a, n[h].coord),
            }),
          )
      }
      for (var h = 0; h < c.length; h++)
        r.add(
          Wi(c[h], {
            style: zt(
              {
                stroke: l[h % l.length],
              },
              s.getLineStyle(),
            ),
            silent: !0,
            z: t.get('z'),
          }),
        )
    },
    minorSplitLine: function (r, t, e, n, i, a) {
      if (i.length) {
        for (
          var o = t.getModel('minorSplitLine'),
            s = o.getModel('lineStyle'),
            l = [],
            u = 0;
          u < i.length;
          u++
        )
          for (var c = 0; c < i[u].length; c++)
            l.push(
              new rr({
                shape: Am(e, a, i[u][c].coord),
              }),
            )
        r.add(
          Wi(l, {
            style: s.getLineStyle(),
            silent: !0,
            z: t.get('z'),
          }),
        )
      }
    },
    splitArea: function (r, t, e, n, i, a) {
      if (n.length) {
        var o = t.getModel('splitArea'),
          s = o.getModel('areaStyle'),
          l = s.get('color'),
          u = 0
        l = l instanceof Array ? l : [l]
        for (
          var c = [],
            h = Math.PI / 180,
            f = -n[0].coord * h,
            d = Math.min(a[0], a[1]),
            p = Math.max(a[0], a[1]),
            g = t.get('clockwise'),
            v = 1,
            m = n.length;
          v <= m;
          v++
        ) {
          var y = v === m ? n[0].coord : n[v].coord,
            _ = u++ % l.length
          ;(c[_] = c[_] || []),
            c[_].push(
              new oi({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r0: d,
                  r: p,
                  startAngle: f,
                  endAngle: -y * h,
                  clockwise: g,
                },
                silent: !0,
              }),
            ),
            (f = -y * h)
        }
        for (var v = 0; v < c.length; v++)
          r.add(
            Wi(c[v], {
              style: zt(
                {
                  fill: l[v % l.length],
                },
                s.getAreaStyle(),
              ),
              silent: !0,
            }),
          )
      }
    },
  }
const xyt = yyt
var Syt = ['axisLine', 'axisTickLabel', 'axisName'],
  Ayt = ['splitLine', 'splitArea', 'minorSplitLine'],
  byt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'PolarAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var i = this._axisGroup,
            a = (this._axisGroup = new Ht())
          this.group.add(a)
          var o = e.axis,
            s = o.polar,
            l = s.getAngleAxis(),
            u = o.getTicksCoords(),
            c = o.getMinorTicksCoords(),
            h = l.getExtent()[0],
            f = o.getExtent(),
            d = Myt(s, e, h),
            p = new ns(e, d)
          R(Syt, p.add, p),
            a.add(p.getGroup()),
            xv(i, a, e),
            R(
              Ayt,
              function (g) {
                e.get([g, 'show']) &&
                  !o.scale.isBlank() &&
                  wyt[g](this.group, e, s, h, f, u, c)
              },
              this,
            )
        }
      }),
      (t.type = 'radiusAxis'),
      t
    )
  })(sc),
  wyt = {
    splitLine: function (r, t, e, n, i, a) {
      var o = t.getModel('splitLine'),
        s = o.getModel('lineStyle'),
        l = s.get('color'),
        u = 0,
        c = e.getAngleAxis(),
        h = Math.PI / 180,
        f = c.getExtent(),
        d = Math.abs(f[1] - f[0]) === 360 ? 'Circle' : 'Arc'
      l = l instanceof Array ? l : [l]
      for (var p = [], g = 0; g < a.length; g++) {
        var v = u++ % l.length
        ;(p[v] = p[v] || []),
          p[v].push(
            new nc[d]({
              shape: {
                cx: e.cx,
                cy: e.cy,
                r: Math.max(a[g].coord, 0),
                startAngle: -f[0] * h,
                endAngle: -f[1] * h,
                clockwise: c.inverse,
              },
            }),
          )
      }
      for (var g = 0; g < p.length; g++)
        r.add(
          Wi(p[g], {
            style: zt(
              {
                stroke: l[g % l.length],
                fill: null,
              },
              s.getLineStyle(),
            ),
            silent: !0,
          }),
        )
    },
    minorSplitLine: function (r, t, e, n, i, a, o) {
      if (o.length) {
        for (
          var s = t.getModel('minorSplitLine'),
            l = s.getModel('lineStyle'),
            u = [],
            c = 0;
          c < o.length;
          c++
        )
          for (var h = 0; h < o[c].length; h++)
            u.push(
              new pl({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r: o[c][h].coord,
                },
              }),
            )
        r.add(
          Wi(u, {
            style: zt(
              {
                fill: null,
              },
              l.getLineStyle(),
            ),
            silent: !0,
          }),
        )
      }
    },
    splitArea: function (r, t, e, n, i, a) {
      if (a.length) {
        var o = t.getModel('splitArea'),
          s = o.getModel('areaStyle'),
          l = s.get('color'),
          u = 0
        l = l instanceof Array ? l : [l]
        for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
          var d = u++ % l.length
          ;(c[d] = c[d] || []),
            c[d].push(
              new oi({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r0: h,
                  r: a[f].coord,
                  startAngle: 0,
                  endAngle: Math.PI * 2,
                },
                silent: !0,
              }),
            ),
            (h = a[f].coord)
        }
        for (var f = 0; f < c.length; f++)
          r.add(
            Wi(c[f], {
              style: zt(
                {
                  fill: l[f % l.length],
                },
                s.getAreaStyle(),
              ),
              silent: !0,
            }),
          )
      }
    },
  }
function Myt(r, t, e) {
  return {
    position: [r.cx, r.cy],
    rotation: (e / 180) * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel('axisLabel').get('rotate'),
    z2: 1,
  }
}
const Tyt = byt
function SH(r) {
  return r.get('stack') || '__ec_stack_' + r.seriesIndex
}
function AH(r, t) {
  return t.dim + r.model.componentIndex
}
function Cyt(r, t, e) {
  var n = {},
    i = Eyt(
      Ne(t.getSeriesByType(r), function (a) {
        return (
          !t.isSeriesFiltered(a) &&
          a.coordinateSystem &&
          a.coordinateSystem.type === 'polar'
        )
      }),
    )
  t.eachSeriesByType(r, function (a) {
    if (a.coordinateSystem.type === 'polar') {
      var o = a.getData(),
        s = a.coordinateSystem,
        l = s.getBaseAxis(),
        u = AH(s, l),
        c = SH(a),
        h = i[u][c],
        f = h.offset,
        d = h.width,
        p = s.getOtherAxis(l),
        g = a.coordinateSystem.cx,
        v = a.coordinateSystem.cy,
        m = a.get('barMinHeight') || 0,
        y = a.get('barMinAngle') || 0
      n[c] = n[c] || []
      for (
        var _ = o.mapDimension(p.dim),
          x = o.mapDimension(l.dim),
          A = sl(o, _),
          S = l.dim !== 'radius' || !a.get('roundCap', !0),
          b = p.model,
          T = b.get('startValue'),
          w = p.dataToCoord(T || 0),
          M = 0,
          C = o.count();
        M < C;
        M++
      ) {
        var E = o.get(_, M),
          D = o.get(x, M),
          P = E >= 0 ? 'p' : 'n',
          L = w
        A &&
          (n[c][D] ||
            (n[c][D] = {
              p: w,
              n: w,
            }),
          (L = n[c][D][P]))
        var I = void 0,
          F = void 0,
          k = void 0,
          V = void 0
        if (p.dim === 'radius') {
          var H = p.dataToCoord(E) - w,
            Y = l.dataToCoord(D)
          Math.abs(H) < m && (H = (H < 0 ? -1 : 1) * m),
            (I = L),
            (F = L + H),
            (k = Y - f),
            (V = k - d),
            A && (n[c][D][P] = F)
        } else {
          var K = p.dataToCoord(E, S) - w,
            ut = l.dataToCoord(D)
          Math.abs(K) < y && (K = (K < 0 ? -1 : 1) * y),
            (I = ut + f),
            (F = I + d),
            (k = L),
            (V = L + K),
            A && (n[c][D][P] = V)
        }
        o.setItemLayout(M, {
          cx: g,
          cy: v,
          r0: I,
          r: F,
          startAngle: (-k * Math.PI) / 180,
          endAngle: (-V * Math.PI) / 180,
          clockwise: k >= V,
        })
      }
    }
  })
}
function Eyt(r) {
  var t = {}
  R(r, function (n, i) {
    var a = n.getData(),
      o = n.coordinateSystem,
      s = o.getBaseAxis(),
      l = AH(o, s),
      u = s.getExtent(),
      c =
        s.type === 'category'
          ? s.getBandWidth()
          : Math.abs(u[1] - u[0]) / a.count(),
      h = t[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {},
      },
      f = h.stacks
    t[l] = h
    var d = SH(n)
    f[d] || h.autoWidthCount++,
      (f[d] = f[d] || {
        width: 0,
        maxWidth: 0,
      })
    var p = _t(n.get('barWidth'), c),
      g = _t(n.get('barMaxWidth'), c),
      v = n.get('barGap'),
      m = n.get('barCategoryGap')
    p &&
      !f[d].width &&
      ((p = Math.min(h.remainedWidth, p)),
      (f[d].width = p),
      (h.remainedWidth -= p)),
      g && (f[d].maxWidth = g),
      v != null && (h.gap = v),
      m != null && (h.categoryGap = m)
  })
  var e = {}
  return (
    R(t, function (n, i) {
      e[i] = {}
      var a = n.stacks,
        o = n.bandWidth,
        s = _t(n.categoryGap, o),
        l = _t(n.gap, 1),
        u = n.remainedWidth,
        c = n.autoWidthCount,
        h = (u - s) / (c + (c - 1) * l)
      ;(h = Math.max(h, 0)),
        R(a, function (g, v) {
          var m = g.maxWidth
          m &&
            m < h &&
            ((m = Math.min(m, u)),
            g.width && (m = Math.min(m, g.width)),
            (u -= m),
            (g.width = m),
            c--)
        }),
        (h = (u - s) / (c + (c - 1) * l)),
        (h = Math.max(h, 0))
      var f = 0,
        d
      R(a, function (g, v) {
        g.width || (g.width = h), (d = g), (f += g.width * (1 + l))
      }),
        d && (f -= d.width * l)
      var p = -f / 2
      R(a, function (g, v) {
        ;(e[i][v] = e[i][v] || {
          offset: p,
          width: g.width,
        }),
          (p += g.width * (1 + l))
      })
    }),
    e
  )
}
var Dyt = {
    startAngle: 90,
    clockwise: !0,
    splitNumber: 12,
    axisLabel: {
      rotate: 0,
    },
  },
  Lyt = {
    splitNumber: 5,
  },
  Pyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'polar'), t
  })(dn)
function Ryt(r) {
  ie(Ov),
    sc.registerAxisPointerClass('PolarAxisPointer', nyt),
    r.registerCoordinateSystem('polar', gyt),
    r.registerComponentModel(iyt),
    r.registerComponentView(Pyt),
    sf(r, 'angle', ayt, Dyt),
    sf(r, 'radius', oyt, Lyt),
    r.registerComponentView(xyt),
    r.registerComponentView(Tyt),
    r.registerLayout(Zt(Cyt, 'bar'))
}
function Qw(r, t) {
  t = t || {}
  var e = r.coordinateSystem,
    n = r.axis,
    i = {},
    a = n.position,
    o = n.orient,
    s = e.getRect(),
    l = [s.x, s.x + s.width, s.y, s.y + s.height],
    u = {
      horizontal: {
        top: l[2],
        bottom: l[3],
      },
      vertical: {
        left: l[0],
        right: l[1],
      },
    }
  i.position = [
    o === 'vertical' ? u.vertical[a] : l[0],
    o === 'horizontal' ? u.horizontal[a] : l[3],
  ]
  var c = {
    horizontal: 0,
    vertical: 1,
  }
  i.rotation = (Math.PI / 2) * c[o]
  var h = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1,
  }
  ;(i.labelDirection = i.tickDirection = i.nameDirection = h[a]),
    r.get(['axisTick', 'inside']) && (i.tickDirection = -i.tickDirection),
    nr(t.labelInside, r.get(['axisLabel', 'inside'])) &&
      (i.labelDirection = -i.labelDirection)
  var f = t.rotate
  return (
    f == null && (f = r.get(['axisLabel', 'rotate'])),
    (i.labelRotation = a === 'top' ? -f : f),
    (i.z2 = 1),
    i
  )
}
var Iyt = ['axisLine', 'axisTickLabel', 'axisName'],
  Oyt = ['splitArea', 'splitLine'],
  Nyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'SingleAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = this.group
        o.removeAll()
        var s = this._axisGroup
        this._axisGroup = new Ht()
        var l = Qw(e),
          u = new ns(e, l)
        R(Iyt, u.add, u),
          o.add(this._axisGroup),
          o.add(u.getGroup()),
          R(
            Oyt,
            function (c) {
              e.get([c, 'show']) && kyt[c](this, this.group, this._axisGroup, e)
            },
            this,
          ),
          xv(s, this._axisGroup, e),
          r.prototype.render.call(this, e, n, i, a)
      }),
      (t.prototype.remove = function () {
        GG(this)
      }),
      (t.type = 'singleAxis'),
      t
    )
  })(sc),
  kyt = {
    splitLine: function (r, t, e, n) {
      var i = n.axis
      if (!i.scale.isBlank()) {
        var a = n.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = s instanceof Array ? s : [s]
        for (
          var l = o.get('width'),
            u = n.coordinateSystem.getRect(),
            c = i.isHorizontal(),
            h = [],
            f = 0,
            d = i.getTicksCoords({
              tickModel: a,
            }),
            p = [],
            g = [],
            v = 0;
          v < d.length;
          ++v
        ) {
          var m = i.toGlobalCoord(d[v].coord)
          c
            ? ((p[0] = m), (p[1] = u.y), (g[0] = m), (g[1] = u.y + u.height))
            : ((p[0] = u.x), (p[1] = m), (g[0] = u.x + u.width), (g[1] = m))
          var y = new rr({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: g[0],
              y2: g[1],
            },
            silent: !0,
          })
          ef(y.shape, l)
          var _ = f++ % s.length
          ;(h[_] = h[_] || []), h[_].push(y)
        }
        for (var x = o.getLineStyle(['color']), v = 0; v < h.length; ++v)
          t.add(
            Wi(h[v], {
              style: zt(
                {
                  stroke: s[v % s.length],
                },
                x,
              ),
              silent: !0,
            }),
          )
      }
    },
    splitArea: function (r, t, e, n) {
      VG(r, e, n, n)
    },
  }
const Byt = Nyt
var bH = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this
    }),
    (t.type = 'singleAxis'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      left: '5%',
      top: '5%',
      right: '5%',
      bottom: '5%',
      type: 'value',
      position: 'bottom',
      orient: 'horizontal',
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: 'solid',
        },
      },
      tooltip: {
        show: !0,
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1,
        },
      },
      axisLabel: {
        show: !0,
        interval: 'auto',
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: 'dashed',
          opacity: 0.2,
        },
      },
    }),
    t
  )
})(xe)
In(bH, Mv.prototype)
const XS = bH
var Fyt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o) {
    var s = r.call(this, e, n, i) || this
    return (s.type = a || 'value'), (s.position = o || 'bottom'), s
  }
  return (
    (t.prototype.isHorizontal = function () {
      var e = this.position
      return e === 'top' || e === 'bottom'
    }),
    (t.prototype.pointToData = function (e, n) {
      return this.coordinateSystem.pointToData(e)[0]
    }),
    t
  )
})(Ra)
const zyt = Fyt
var wH = ['single'],
  Uyt = (function () {
    function r(t, e, n) {
      ;(this.type = 'single'),
        (this.dimension = 'single'),
        (this.dimensions = wH),
        (this.axisPointerEnabled = !0),
        (this.model = t),
        this._init(t, e, n)
    }
    return (
      (r.prototype._init = function (t, e, n) {
        var i = this.dimension,
          a = new zyt(i, w_(t), [0, 0], t.get('type'), t.get('position')),
          o = a.type === 'category'
        ;(a.onBand = o && t.get('boundaryGap')),
          (a.inverse = t.get('inverse')),
          (a.orient = t.get('orient')),
          (t.axis = a),
          (a.model = t),
          (a.coordinateSystem = this),
          (this._axis = a)
      }),
      (r.prototype.update = function (t, e) {
        t.eachSeries(function (n) {
          if (n.coordinateSystem === this) {
            var i = n.getData()
            R(
              i.mapDimensionsAll(this.dimension),
              function (a) {
                this._axis.scale.unionExtentFromData(i, a)
              },
              this,
            ),
              af(this._axis.scale, this._axis.model)
          }
        }, this)
      }),
      (r.prototype.resize = function (t, e) {
        ;(this._rect = Vn(
          {
            left: t.get('left'),
            top: t.get('top'),
            right: t.get('right'),
            bottom: t.get('bottom'),
            width: t.get('width'),
            height: t.get('height'),
          },
          {
            width: e.getWidth(),
            height: e.getHeight(),
          },
        )),
          this._adjustAxis()
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype._adjustAxis = function () {
        var t = this._rect,
          e = this._axis,
          n = e.isHorizontal(),
          i = n ? [0, t.width] : [0, t.height],
          a = e.inverse ? 1 : 0
        e.setExtent(i[a], i[1 - a]), this._updateAxisTransform(e, n ? t.x : t.y)
      }),
      (r.prototype._updateAxisTransform = function (t, e) {
        var n = t.getExtent(),
          i = n[0] + n[1],
          a = t.isHorizontal()
        ;(t.toGlobalCoord = a
          ? function (o) {
              return o + e
            }
          : function (o) {
              return i - o + e
            }),
          (t.toLocalCoord = a
            ? function (o) {
                return o - e
              }
            : function (o) {
                return i - o + e
              })
      }),
      (r.prototype.getAxis = function () {
        return this._axis
      }),
      (r.prototype.getBaseAxis = function () {
        return this._axis
      }),
      (r.prototype.getAxes = function () {
        return [this._axis]
      }),
      (r.prototype.getTooltipAxes = function () {
        return {
          baseAxes: [this.getAxis()],
          otherAxes: [],
        }
      }),
      (r.prototype.containPoint = function (t) {
        var e = this.getRect(),
          n = this.getAxis(),
          i = n.orient
        return i === 'horizontal'
          ? n.contain(n.toLocalCoord(t[0])) &&
              t[1] >= e.y &&
              t[1] <= e.y + e.height
          : n.contain(n.toLocalCoord(t[1])) &&
              t[0] >= e.y &&
              t[0] <= e.y + e.height
      }),
      (r.prototype.pointToData = function (t) {
        var e = this.getAxis()
        return [
          e.coordToData(e.toLocalCoord(t[e.orient === 'horizontal' ? 0 : 1])),
        ]
      }),
      (r.prototype.dataToPoint = function (t) {
        var e = this.getAxis(),
          n = this.getRect(),
          i = [],
          a = e.orient === 'horizontal' ? 0 : 1
        return (
          t instanceof Array && (t = t[0]),
          (i[a] = e.toGlobalCoord(e.dataToCoord(+t))),
          (i[1 - a] = a === 0 ? n.y + n.height / 2 : n.x + n.width / 2),
          i
        )
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = n3(e)
        return i === this ? this.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = n3(e)
        return i === this ? this.pointToData(n) : null
      }),
      r
    )
  })()
function n3(r) {
  var t = r.seriesModel,
    e = r.singleAxisModel
  return (e && e.coordinateSystem) || (t && t.coordinateSystem)
}
function Vyt(r, t) {
  var e = []
  return (
    r.eachComponent('singleAxis', function (n, i) {
      var a = new Uyt(n, r, t)
      ;(a.name = 'single_' + i),
        a.resize(n, t),
        (n.coordinateSystem = a),
        e.push(a)
    }),
    r.eachSeries(function (n) {
      if (n.get('coordinateSystem') === 'singleAxis') {
        var i = n.getReferringComponents('singleAxis', Pn).models[0]
        n.coordinateSystem = i && i.coordinateSystem
      }
    }),
    e
  )
}
var Gyt = {
  create: Vyt,
  dimensions: wH,
}
const Hyt = Gyt
var r3 = ['x', 'y'],
  Wyt = ['width', 'height'],
  Xyt = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.makeElOption = function (e, n, i, a, o) {
        var s = i.axis,
          l = s.coordinateSystem,
          u = YS(l, 1 - S0(s)),
          c = l.dataToPoint(n)[0],
          h = a.get('type')
        if (h && h !== 'none') {
          var f = gE(a),
            d = Yyt[h](s, c, u)
          ;(d.style = f), (e.graphicKey = d.type), (e.pointer = d)
        }
        var p = Qw(i)
        gH(n, e, p, i, a, o)
      }),
      (t.prototype.getHandleTransform = function (e, n, i) {
        var a = Qw(n, {
          labelInside: !1,
        })
        a.labelMargin = i.get(['handle', 'margin'])
        var o = mE(n.axis, e, a)
        return {
          x: o[0],
          y: o[1],
          rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0),
        }
      }),
      (t.prototype.updateHandleTransform = function (e, n, i, a) {
        var o = i.axis,
          s = o.coordinateSystem,
          l = S0(o),
          u = YS(s, l),
          c = [e.x, e.y]
        ;(c[l] += n[l]),
          (c[l] = Math.min(u[1], c[l])),
          (c[l] = Math.max(u[0], c[l]))
        var h = YS(s, 1 - l),
          f = (h[1] + h[0]) / 2,
          d = [f, f]
        return (
          (d[l] = c[l]),
          {
            x: c[0],
            y: c[1],
            rotation: e.rotation,
            cursorPoint: d,
            tooltipOption: {
              verticalAlign: 'middle',
            },
          }
        )
      }),
      t
    )
  })(vE),
  Yyt = {
    line: function (r, t, e) {
      var n = yE([t, e[0]], [t, e[1]], S0(r))
      return {
        type: 'Line',
        subPixelOptimize: !0,
        shape: n,
      }
    },
    shadow: function (r, t, e) {
      var n = r.getBandWidth(),
        i = e[1] - e[0]
      return {
        type: 'Rect',
        shape: mH([t - n / 2, e[0]], [n, i], S0(r)),
      }
    },
  }
function S0(r) {
  return r.isHorizontal() ? 0 : 1
}
function YS(r, t) {
  var e = r.getRect()
  return [e[r3[t]], e[r3[t]] + e[Wyt[t]]]
}
const $yt = Xyt
var qyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'single'), t
})(dn)
function Zyt(r) {
  ie(Ov),
    sc.registerAxisPointerClass('SingleAxisPointer', $yt),
    r.registerComponentView(qyt),
    r.registerComponentView(Byt),
    r.registerComponentModel(XS),
    sf(r, 'single', XS, XS.defaultOption),
    r.registerCoordinateSystem('single', Hyt)
}
var Kyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      var a = Mf(e)
      r.prototype.init.apply(this, arguments), i3(e, a)
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments), i3(this.option, e)
    }),
    (t.prototype.getCellSize = function () {
      return this.option.cellSize
    }),
    (t.type = 'calendar'),
    (t.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: 'horizontal',
      splitLine: {
        show: !0,
        lineStyle: {
          color: '#000',
          width: 1,
          type: 'solid',
        },
      },
      itemStyle: {
        color: '#fff',
        borderWidth: 1,
        borderColor: '#ccc',
      },
      dayLabel: {
        show: !0,
        firstDay: 0,
        position: 'start',
        margin: '50%',
        color: '#000',
      },
      monthLabel: {
        show: !0,
        position: 'start',
        margin: 5,
        align: 'center',
        formatter: null,
        color: '#000',
      },
      yearLabel: {
        show: !0,
        position: null,
        margin: 30,
        formatter: null,
        color: '#ccc',
        fontFamily: 'sans-serif',
        fontWeight: 'bolder',
        fontSize: 20,
      },
    }),
    t
  )
})(xe)
function i3(r, t) {
  var e = r.cellSize,
    n
  at(e) ? (n = e) : (n = r.cellSize = [e, e]), n.length === 1 && (n[1] = n[0])
  var i = st([0, 1], function (a) {
    return ert(t, a) && (n[a] = 'auto'), n[a] != null && n[a] !== 'auto'
  })
  ol(r, t, {
    type: 'box',
    ignoreSize: i,
  })
}
const jyt = Kyt
var Jyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = this.group
      a.removeAll()
      var o = e.coordinateSystem,
        s = o.getRangeInfo(),
        l = o.getOrient(),
        u = n.getLocaleModel()
      this._renderDayRect(e, s, a),
        this._renderLines(e, s, l, a),
        this._renderYearText(e, s, l, a),
        this._renderMonthText(e, u, l, a),
        this._renderWeekText(e, u, s, l, a)
    }),
    (t.prototype._renderDayRect = function (e, n, i) {
      for (
        var a = e.coordinateSystem,
          o = e.getModel('itemStyle').getItemStyle(),
          s = a.getCellWidth(),
          l = a.getCellHeight(),
          u = n.start.time;
        u <= n.end.time;
        u = a.getNextNDay(u, 1).time
      ) {
        var c = a.dataToRect([u], !1).tl,
          h = new ge({
            shape: {
              x: c[0],
              y: c[1],
              width: s,
              height: l,
            },
            cursor: 'default',
            style: o,
          })
        i.add(h)
      }
    }),
    (t.prototype._renderLines = function (e, n, i, a) {
      var o = this,
        s = e.coordinateSystem,
        l = e.getModel(['splitLine', 'lineStyle']).getLineStyle(),
        u = e.get(['splitLine', 'show']),
        c = l.lineWidth
      ;(this._tlpoints = []),
        (this._blpoints = []),
        (this._firstDayOfMonth = []),
        (this._firstDayPoints = [])
      for (var h = n.start, f = 0; h.time <= n.end.time; f++) {
        p(h.formatedDate),
          f === 0 && (h = s.getDateInfo(n.start.y + '-' + n.start.m))
        var d = h.date
        d.setMonth(d.getMonth() + 1), (h = s.getDateInfo(d))
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate)
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)),
          o._firstDayPoints.push(s.dataToRect([g], !1).tl)
        var v = o._getLinePointsOfOneWeek(e, g, i)
        o._tlpoints.push(v[0]),
          o._blpoints.push(v[v.length - 1]),
          u && o._drawSplitline(v, l, a)
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a),
        u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a)
    }),
    (t.prototype._getEdgesPoints = function (e, n, i) {
      var a = [e[0].slice(), e[e.length - 1].slice()],
        o = i === 'horizontal' ? 0 : 1
      return (a[0][o] = a[0][o] - n / 2), (a[1][o] = a[1][o] + n / 2), a
    }),
    (t.prototype._drawSplitline = function (e, n, i) {
      var a = new li({
        z2: 20,
        shape: {
          points: e,
        },
        style: n,
      })
      i.add(a)
    }),
    (t.prototype._getLinePointsOfOneWeek = function (e, n, i) {
      for (
        var a = e.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0;
        l < 7;
        l++
      ) {
        var u = a.getNextNDay(o.time, l),
          c = a.dataToRect([u.time], !1)
        ;(s[2 * u.day] = c.tl),
          (s[2 * u.day + 1] = c[i === 'horizontal' ? 'bl' : 'tr'])
      }
      return s
    }),
    (t.prototype._formatterLabel = function (e, n) {
      return bt(e) && e ? Jnt(e, n) : Nt(e) ? e(n) : n.nameMap
    }),
    (t.prototype._yearTextPositionControl = function (e, n, i, a, o) {
      var s = n[0],
        l = n[1],
        u = ['center', 'bottom']
      a === 'bottom'
        ? ((l += o), (u = ['center', 'top']))
        : a === 'left'
        ? (s -= o)
        : a === 'right'
        ? ((s += o), (u = ['center', 'top']))
        : (l -= o)
      var c = 0
      return (
        (a === 'left' || a === 'right') && (c = Math.PI / 2),
        {
          rotation: c,
          x: s,
          y: l,
          style: {
            align: u[0],
            verticalAlign: u[1],
          },
        }
      )
    }),
    (t.prototype._renderYearText = function (e, n, i, a) {
      var o = e.getModel('yearLabel')
      if (o.get('show')) {
        var s = o.get('margin'),
          l = o.get('position')
        l || (l = i !== 'horizontal' ? 'top' : 'left')
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
          c = (u[0][0] + u[1][0]) / 2,
          h = (u[0][1] + u[1][1]) / 2,
          f = i === 'horizontal' ? 0 : 1,
          d = {
            top: [c, u[f][1]],
            bottom: [c, u[1 - f][1]],
            left: [u[1 - f][0], h],
            right: [u[f][0], h],
          },
          p = n.start.y
        ;+n.end.y > +n.start.y && (p = p + '-' + n.end.y)
        var g = o.get('formatter'),
          v = {
            start: n.start.y,
            end: n.end.y,
            nameMap: p,
          },
          m = this._formatterLabel(g, v),
          y = new Ae({
            z2: 30,
            style: $e(o, {
              text: m,
            }),
          })
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y)
      }
    }),
    (t.prototype._monthTextPositionControl = function (e, n, i, a, o) {
      var s = 'left',
        l = 'top',
        u = e[0],
        c = e[1]
      return (
        i === 'horizontal'
          ? ((c = c + o), n && (s = 'center'), a === 'start' && (l = 'bottom'))
          : ((u = u + o), n && (l = 'middle'), a === 'start' && (s = 'right')),
        {
          x: u,
          y: c,
          align: s,
          verticalAlign: l,
        }
      )
    }),
    (t.prototype._renderMonthText = function (e, n, i, a) {
      var o = e.getModel('monthLabel')
      if (o.get('show')) {
        var s = o.get('nameMap'),
          l = o.get('margin'),
          u = o.get('position'),
          c = o.get('align'),
          h = [this._tlpoints, this._blpoints]
        ;(!s || bt(s)) &&
          (s && (n = uw(s) || n), (s = n.get(['time', 'monthAbbr']) || []))
        var f = u === 'start' ? 0 : 1,
          d = i === 'horizontal' ? 0 : 1
        l = u === 'start' ? -l : l
        for (var p = c === 'center', g = 0; g < h[f].length - 1; g++) {
          var v = h[f][g].slice(),
            m = this._firstDayOfMonth[g]
          if (p) {
            var y = this._firstDayPoints[g]
            v[d] = (y[d] + h[0][g + 1][d]) / 2
          }
          var _ = o.get('formatter'),
            x = s[+m.m - 1],
            A = {
              yyyy: m.y,
              yy: (m.y + '').slice(2),
              MM: m.m,
              M: +m.m,
              nameMap: x,
            },
            S = this._formatterLabel(_, A),
            b = new Ae({
              z2: 30,
              style: Q(
                $e(o, {
                  text: S,
                }),
                this._monthTextPositionControl(v, p, i, u, l),
              ),
            })
          a.add(b)
        }
      }
    }),
    (t.prototype._weekTextPositionControl = function (e, n, i, a, o) {
      var s = 'center',
        l = 'middle',
        u = e[0],
        c = e[1],
        h = i === 'start'
      return (
        n === 'horizontal'
          ? ((u = u + a + ((h ? 1 : -1) * o[0]) / 2),
            (s = h ? 'right' : 'left'))
          : ((c = c + a + ((h ? 1 : -1) * o[1]) / 2),
            (l = h ? 'bottom' : 'top')),
        {
          x: u,
          y: c,
          align: s,
          verticalAlign: l,
        }
      )
    }),
    (t.prototype._renderWeekText = function (e, n, i, a, o) {
      var s = e.getModel('dayLabel')
      if (s.get('show')) {
        var l = e.coordinateSystem,
          u = s.get('position'),
          c = s.get('nameMap'),
          h = s.get('margin'),
          f = l.getFirstDayOfWeek()
        if (!c || bt(c)) {
          c && (n = uw(c) || n)
          var d = n.get(['time', 'dayOfWeekShort'])
          c =
            d ||
            st(n.get(['time', 'dayOfWeekAbbr']), function (A) {
              return A[0]
            })
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time,
          g = [l.getCellWidth(), l.getCellHeight()]
        ;(h = _t(h, Math.min(g[1], g[0]))),
          u === 'start' &&
            ((p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time), (h = -h))
        for (var v = 0; v < 7; v++) {
          var m = l.getNextNDay(p, v),
            y = l.dataToRect([m.time], !1).center,
            _ = v
          _ = Math.abs((v + f) % 7)
          var x = new Ae({
            z2: 30,
            style: Q(
              $e(s, {
                text: c[_],
              }),
              this._weekTextPositionControl(y, a, u, h, g),
            ),
          })
          o.add(x)
        }
      }
    }),
    (t.type = 'calendar'),
    t
  )
})(dn)
const Qyt = Jyt
var $S = 864e5,
  t0t = (function () {
    function r(t, e, n) {
      ;(this.type = 'calendar'),
        (this.dimensions = r.dimensions),
        (this.getDimensionsInfo = r.getDimensionsInfo),
        (this._model = t)
    }
    return (
      (r.getDimensionsInfo = function () {
        return [
          {
            name: 'time',
            type: 'time',
          },
          'value',
        ]
      }),
      (r.prototype.getRangeInfo = function () {
        return this._rangeInfo
      }),
      (r.prototype.getModel = function () {
        return this._model
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype.getCellWidth = function () {
        return this._sw
      }),
      (r.prototype.getCellHeight = function () {
        return this._sh
      }),
      (r.prototype.getOrient = function () {
        return this._orient
      }),
      (r.prototype.getFirstDayOfWeek = function () {
        return this._firstDayOfWeek
      }),
      (r.prototype.getDateInfo = function (t) {
        t = po(t)
        var e = t.getFullYear(),
          n = t.getMonth() + 1,
          i = n < 10 ? '0' + n : '' + n,
          a = t.getDate(),
          o = a < 10 ? '0' + a : '' + a,
          s = t.getDay()
        return (
          (s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7)),
          {
            y: e + '',
            m: i,
            d: o,
            day: s,
            time: t.getTime(),
            formatedDate: e + '-' + i + '-' + o,
            date: t,
          }
        )
      }),
      (r.prototype.getNextNDay = function (t, e) {
        return (
          (e = e || 0),
          e === 0
            ? this.getDateInfo(t)
            : ((t = new Date(this.getDateInfo(t).time)),
              t.setDate(t.getDate() + e),
              this.getDateInfo(t))
        )
      }),
      (r.prototype.update = function (t, e) {
        ;(this._firstDayOfWeek = +this._model
          .getModel('dayLabel')
          .get('firstDay')),
          (this._orient = this._model.get('orient')),
          (this._lineWidth =
            this._model.getModel('itemStyle').getItemStyle().lineWidth || 0),
          (this._rangeInfo = this._getRangeInfo(this._initRangeOption()))
        var n = this._rangeInfo.weeks || 1,
          i = ['width', 'height'],
          a = this._model.getCellSize().slice(),
          o = this._model.getBoxLayoutParams(),
          s = this._orient === 'horizontal' ? [n, 7] : [7, n]
        R([0, 1], function (h) {
          c(a, h) && (o[i[h]] = a[h] * s[h])
        })
        var l = {
            width: e.getWidth(),
            height: e.getHeight(),
          },
          u = (this._rect = Vn(o, l))
        R([0, 1], function (h) {
          c(a, h) || (a[h] = u[i[h]] / s[h])
        })
        function c(h, f) {
          return h[f] != null && h[f] !== 'auto'
        }
        ;(this._sw = a[0]), (this._sh = a[1])
      }),
      (r.prototype.dataToPoint = function (t, e) {
        at(t) && (t = t[0]), e == null && (e = !0)
        var n = this.getDateInfo(t),
          i = this._rangeInfo,
          a = n.formatedDate
        if (e && !(n.time >= i.start.time && n.time < i.end.time + $S))
          return [NaN, NaN]
        var o = n.day,
          s = this._getRangeInfo([i.start.time, a]).nthWeek
        return this._orient === 'vertical'
          ? [
              this._rect.x + o * this._sw + this._sw / 2,
              this._rect.y + s * this._sh + this._sh / 2,
            ]
          : [
              this._rect.x + s * this._sw + this._sw / 2,
              this._rect.y + o * this._sh + this._sh / 2,
            ]
      }),
      (r.prototype.pointToData = function (t) {
        var e = this.pointToDate(t)
        return e && e.time
      }),
      (r.prototype.dataToRect = function (t, e) {
        var n = this.dataToPoint(t, e)
        return {
          contentShape: {
            x: n[0] - (this._sw - this._lineWidth) / 2,
            y: n[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth,
          },
          center: n,
          tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
          tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
          br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
          bl: [n[0] - this._sw / 2, n[1] + this._sh / 2],
        }
      }),
      (r.prototype.pointToDate = function (t) {
        var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1,
          n = Math.floor((t[1] - this._rect.y) / this._sh) + 1,
          i = this._rangeInfo.range
        return this._orient === 'vertical'
          ? this._getDateByWeeksAndDay(n, e - 1, i)
          : this._getDateByWeeksAndDay(e, n - 1, i)
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = a3(e)
        return i === this ? i.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = a3(e)
        return i === this ? i.pointToData(n) : null
      }),
      (r.prototype.containPoint = function (t) {
        return console.warn('Not implemented.'), !1
      }),
      (r.prototype._initRangeOption = function () {
        var t = this._model.get('range'),
          e
        if ((at(t) && t.length === 1 && (t = t[0]), at(t))) e = t
        else {
          var n = t.toString()
          if (
            (/^\d{4}$/.test(n) && (e = [n + '-01-01', n + '-12-31']),
            /^\d{4}[\/|-]\d{1,2}$/.test(n))
          ) {
            var i = this.getDateInfo(n),
              a = i.date
            a.setMonth(a.getMonth() + 1)
            var o = this.getNextNDay(a, -1)
            e = [i.formatedDate, o.formatedDate]
          }
          ;/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (e = [n, n])
        }
        if (!e) return t
        var s = this._getRangeInfo(e)
        return s.start.time > s.end.time && e.reverse(), e
      }),
      (r.prototype._getRangeInfo = function (t) {
        var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])],
          n
        e[0].time > e[1].time && ((n = !0), e.reverse())
        var i = Math.floor(e[1].time / $S) - Math.floor(e[0].time / $S) + 1,
          a = new Date(e[0].time),
          o = a.getDate(),
          s = e[1].date.getDate()
        a.setDate(o + i - 1)
        var l = a.getDate()
        if (l !== s)
          for (
            var u = a.getTime() - e[1].time > 0 ? 1 : -1;
            (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0;

          )
            (i -= u), a.setDate(l - u)
        var c = Math.floor((i + e[0].day + 6) / 7),
          h = n ? -c + 1 : c - 1
        return (
          n && e.reverse(),
          {
            range: [e[0].formatedDate, e[1].formatedDate],
            start: e[0],
            end: e[1],
            allDay: i,
            weeks: c,
            nthWeek: h,
            fweek: e[0].day,
            lweek: e[1].day,
          }
        )
      }),
      (r.prototype._getDateByWeeksAndDay = function (t, e, n) {
        var i = this._getRangeInfo(n)
        if (
          t > i.weeks ||
          (t === 0 && e < i.fweek) ||
          (t === i.weeks && e > i.lweek)
        )
          return null
        var a = (t - 1) * 7 - i.fweek + e,
          o = new Date(i.start.time)
        return o.setDate(+i.start.d + a), this.getDateInfo(o)
      }),
      (r.create = function (t, e) {
        var n = []
        return (
          t.eachComponent('calendar', function (i) {
            var a = new r(i)
            n.push(a), (i.coordinateSystem = a)
          }),
          t.eachSeries(function (i) {
            i.get('coordinateSystem') === 'calendar' &&
              (i.coordinateSystem = n[i.get('calendarIndex') || 0])
          }),
          n
        )
      }),
      (r.dimensions = ['time', 'value']),
      r
    )
  })()
function a3(r) {
  var t = r.calendarModel,
    e = r.seriesModel,
    n = t ? t.coordinateSystem : e ? e.coordinateSystem : null
  return n
}
const e0t = t0t
function n0t(r) {
  r.registerComponentModel(jyt),
    r.registerComponentView(Qyt),
    r.registerCoordinateSystem('calendar', e0t)
}
function r0t(r, t) {
  var e = r.existing
  if (
    ((t.id = r.keyInfo.id),
    !t.type && e && (t.type = e.type),
    t.parentId == null)
  ) {
    var n = t.parentOption
    n ? (t.parentId = n.id) : e && (t.parentId = e.parentId)
  }
  t.parentOption = null
}
function o3(r, t) {
  var e
  return (
    R(t, function (n) {
      r[n] != null && r[n] !== 'auto' && (e = !0)
    }),
    e
  )
}
function i0t(r, t, e) {
  var n = Q({}, e),
    i = r[t],
    a = e.$action || 'merge'
  a === 'merge'
    ? i
      ? (te(i, n, !0),
        ol(i, n, {
          ignoreSize: !0,
        }),
        o5(e, i),
        wm(e, i),
        wm(e, i, 'shape'),
        wm(e, i, 'style'),
        wm(e, i, 'extra'),
        (e.clipPath = i.clipPath))
      : (r[t] = n)
    : a === 'replace'
    ? (r[t] = n)
    : a === 'remove' && i && (r[t] = null)
}
var MH = ['transition', 'enterFrom', 'leaveTo'],
  a0t = MH.concat(['enterAnimation', 'updateAnimation', 'leaveAnimation'])
function wm(r, t, e) {
  if (
    (e && (!r[e] && t[e] && (r[e] = {}), (r = r[e]), (t = t[e])), !(!r || !t))
  )
    for (var n = e ? MH : a0t, i = 0; i < n.length; i++) {
      var a = n[i]
      r[a] == null && t[a] != null && (r[a] = t[a])
    }
}
function o0t(r, t) {
  if (
    r &&
    ((r.hv = t.hv = [o3(t, ['left', 'right']), o3(t, ['top', 'bottom'])]),
    r.type === 'group')
  ) {
    var e = r,
      n = t
    e.width == null && (e.width = n.width = 0),
      e.height == null && (e.height = n.height = 0)
  }
}
var s0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.preventAutoZ = !0), e
    }
    return (
      (t.prototype.mergeOption = function (e, n) {
        var i = this.option.elements
        ;(this.option.elements = null),
          r.prototype.mergeOption.call(this, e, n),
          (this.option.elements = i)
      }),
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option,
          a = (n ? i : e).elements,
          o = (i.elements = n ? [] : i.elements),
          s = []
        this._flatten(a, s, null)
        var l = Hz(o, s, 'normalMerge'),
          u = (this._elOptionsToUpdate = [])
        R(
          l,
          function (c, h) {
            var f = c.newOption
            f && (u.push(f), r0t(c, f), i0t(o, h, f), o0t(o[h], f))
          },
          this,
        ),
          (i.elements = Ne(o, function (c) {
            return c && delete c.$action, c != null
          }))
      }),
      (t.prototype._flatten = function (e, n, i) {
        R(
          e,
          function (a) {
            if (a) {
              i && (a.parentOption = i), n.push(a)
              var o = a.children
              o && o.length && this._flatten(o, n, a), delete a.children
            }
          },
          this,
        )
      }),
      (t.prototype.useElOptionsToUpdate = function () {
        var e = this._elOptionsToUpdate
        return (this._elOptionsToUpdate = null), e
      }),
      (t.type = 'graphic'),
      (t.defaultOption = {
        elements: [],
      }),
      t
    )
  })(xe),
  s3 = {
    path: null,
    compoundPath: null,
    group: Ht,
    image: yr,
    text: Ae,
  },
  Vi = ve(),
  l0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function () {
        this._elMap = Pt()
      }),
      (t.prototype.render = function (e, n, i) {
        e !== this._lastGraphicModel && this._clear(),
          (this._lastGraphicModel = e),
          this._updateElements(e),
          this._relocate(e, i)
      }),
      (t.prototype._updateElements = function (e) {
        var n = e.useElOptionsToUpdate()
        if (n) {
          var i = this._elMap,
            a = this.group,
            o = e.get('z'),
            s = e.get('zlevel')
          R(n, function (l) {
            var u = Un(l.id, null),
              c = u != null ? i.get(u) : null,
              h = Un(l.parentId, null),
              f = h != null ? i.get(h) : a,
              d = l.type,
              p = l.style
            d === 'text' &&
              p &&
              l.hv &&
              l.hv[1] &&
              (p.textVerticalAlign =
                p.textBaseline =
                p.verticalAlign =
                p.align =
                  null)
            var g = l.textContent,
              v = l.textConfig
            if (p && iH(p, d, !!v, !!g)) {
              var m = aH(p, d, !0)
              !v && m.textConfig && (v = l.textConfig = m.textConfig),
                !g && m.textContent && (g = m.textContent)
            }
            var y = u0t(l),
              _ = l.$action || 'merge',
              x = _ === 'merge',
              A = _ === 'replace'
            if (x) {
              var S = !c,
                b = c
              S ? (b = l3(u, f, l.type, i)) : (b && (Vi(b).isNew = !1), uH(b)),
                b &&
                  (sy(b, y, e, {
                    isInit: S,
                  }),
                  u3(b, l, o, s))
            } else if (A) {
              uy(c, l, i, e)
              var T = l3(u, f, l.type, i)
              T &&
                (sy(T, y, e, {
                  isInit: !0,
                }),
                u3(T, l, o, s))
            } else _ === 'remove' && (sH(c, l), uy(c, l, i, e))
            var w = i.get(u)
            if (w && g)
              if (x) {
                var M = w.getTextContent()
                M ? M.attr(g) : w.setTextContent(new Ae(g))
              } else A && w.setTextContent(new Ae(g))
            if (w) {
              var C = l.clipPath
              if (C) {
                var E = C.type,
                  D = void 0,
                  S = !1
                if (x) {
                  var P = w.getClipPath()
                  ;(S = !P || Vi(P).type !== E), (D = S ? tM(E) : P)
                } else A && ((S = !0), (D = tM(E)))
                w.setClipPath(D),
                  sy(D, C, e, {
                    isInit: S,
                  }),
                  _0(D, C.keyframeAnimation, e)
              }
              var L = Vi(w)
              w.setTextConfig(v),
                (L.option = l),
                c0t(w, e, l),
                Sf({
                  el: w,
                  componentModel: e,
                  itemName: w.name,
                  itemTooltipOption: l.tooltip,
                }),
                _0(w, l.keyframeAnimation, e)
            }
          })
        }
      }),
      (t.prototype._relocate = function (e, n) {
        for (
          var i = e.option.elements,
            a = this.group,
            o = this._elMap,
            s = n.getWidth(),
            l = n.getHeight(),
            u = ['x', 'y'],
            c = 0;
          c < i.length;
          c++
        ) {
          var h = i[c],
            f = Un(h.id, null),
            d = f != null ? o.get(f) : null
          if (!(!d || !d.isGroup)) {
            var p = d.parent,
              g = p === a,
              v = Vi(d),
              m = Vi(p)
            ;(v.width = _t(v.option.width, g ? s : m.width) || 0),
              (v.height = _t(v.option.height, g ? l : m.height) || 0)
          }
        }
        for (var c = i.length - 1; c >= 0; c--) {
          var h = i[c],
            f = Un(h.id, null),
            d = f != null ? o.get(f) : null
          if (d) {
            var p = d.parent,
              m = Vi(p),
              y =
                p === a
                  ? {
                      width: s,
                      height: l,
                    }
                  : {
                      width: m.width,
                      height: m.height,
                    },
              _ = {},
              x = p_(
                d,
                h,
                y,
                null,
                {
                  hv: h.hv,
                  boundingMode: h.bounding,
                },
                _,
              )
            if (!Vi(d).isNew && x) {
              for (var A = h.transition, S = {}, b = 0; b < u.length; b++) {
                var T = u[b],
                  w = _[T]
                A && (zu(A) || re(A, T) >= 0) ? (S[T] = w) : (d[T] = w)
              }
              we(d, S, e, 0)
            } else d.attr(_)
          }
        }
      }),
      (t.prototype._clear = function () {
        var e = this,
          n = this._elMap
        n.each(function (i) {
          uy(i, Vi(i).option, n, e._lastGraphicModel)
        }),
          (this._elMap = Pt())
      }),
      (t.prototype.dispose = function () {
        this._clear()
      }),
      (t.type = 'graphic'),
      t
    )
  })(dn)
function tM(r) {
  var t = Et(s3, r) ? s3[r] : tC(r),
    e = new t({})
  return (Vi(e).type = r), e
}
function l3(r, t, e, n) {
  var i = tM(e)
  return t.add(i), n.set(r, i), (Vi(i).id = r), (Vi(i).isNew = !0), i
}
function uy(r, t, e, n) {
  var i = r && r.parent
  i &&
    (r.type === 'group' &&
      r.traverse(function (a) {
        uy(a, t, e, n)
      }),
    P_(r, t, n),
    e.removeKey(Vi(r).id))
}
function u3(r, t, e, n) {
  r.isGroup ||
    R(
      [
        ['cursor', ea.prototype.cursor],
        ['zlevel', n || 0],
        ['z', e || 0],
        ['z2', 0],
      ],
      function (i) {
        var a = i[0]
        Et(t, a) ? (r[a] = $t(t[a], i[1])) : r[a] == null && (r[a] = i[1])
      },
    ),
    R(pe(t), function (i) {
      if (i.indexOf('on') === 0) {
        var a = t[i]
        r[i] = Nt(a) ? a : null
      }
    }),
    Et(t, 'draggable') && (r.draggable = t.draggable),
    t.name != null && (r.name = t.name),
    t.id != null && (r.id = t.id)
}
function u0t(r) {
  return (
    (r = Q({}, r)),
    R(
      [
        'id',
        'parentId',
        '$action',
        'hv',
        'bounding',
        'textContent',
        'clipPath',
      ].concat(a5),
      function (t) {
        delete r[t]
      },
    ),
    r
  )
}
function c0t(r, t, e) {
  var n = Wt(r).eventData
  !r.silent &&
    !r.ignore &&
    !n &&
    (n = Wt(r).eventData =
      {
        componentType: 'graphic',
        componentIndex: t.componentIndex,
        name: r.name,
      }),
    n && (n.info = e.info)
}
function h0t(r) {
  r.registerComponentModel(s0t),
    r.registerComponentView(l0t),
    r.registerPreprocessor(function (t) {
      var e = t.graphic
      at(e)
        ? !e[0] || !e[0].elements
          ? (t.graphic = [
              {
                elements: e,
              },
            ])
          : (t.graphic = [t.graphic[0]])
        : e &&
          !e.elements &&
          (t.graphic = [
            {
              elements: [e],
            },
          ])
    })
}
var c3 = ['x', 'y', 'radius', 'angle', 'single'],
  f0t = ['cartesian2d', 'polar', 'singleAxis']
function d0t(r) {
  var t = r.get('coordinateSystem')
  return re(f0t, t) >= 0
}
function Ws(r) {
  return r + 'Axis'
}
function p0t(r, t) {
  var e = Pt(),
    n = [],
    i = Pt()
  r.eachComponent(
    {
      mainType: 'dataZoom',
      query: t,
    },
    function (c) {
      i.get(c.uid) || s(c)
    },
  )
  var a
  do (a = !1), r.eachComponent('dataZoom', o)
  while (a)
  function o(c) {
    !i.get(c.uid) && l(c) && (s(c), (a = !0))
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c)
  }
  function l(c) {
    var h = !1
    return (
      c.eachTargetAxis(function (f, d) {
        var p = e.get(f)
        p && p[d] && (h = !0)
      }),
      h
    )
  }
  function u(c) {
    c.eachTargetAxis(function (h, f) {
      ;(e.get(h) || e.set(h, []))[f] = !0
    })
  }
  return n
}
function TH(r) {
  var t = r.ecModel,
    e = {
      infoList: [],
      infoMap: Pt(),
    }
  return (
    r.eachTargetAxis(function (n, i) {
      var a = t.getComponent(Ws(n), i)
      if (a) {
        var o = a.getCoordSysModel()
        if (o) {
          var s = o.uid,
            l = e.infoMap.get(s)
          l ||
            ((l = {
              model: o,
              axisModels: [],
            }),
            e.infoList.push(l),
            e.infoMap.set(s, l)),
            l.axisModels.push(a)
        }
      }
    }),
    e
  )
}
var qS = (function () {
    function r() {
      ;(this.indexList = []), (this.indexMap = [])
    }
    return (
      (r.prototype.add = function (t) {
        this.indexMap[t] || (this.indexList.push(t), (this.indexMap[t] = !0))
      }),
      r
    )
  })(),
  v0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e._autoThrottle = !0),
        (e._noTarget = !0),
        (e._rangePropMode = ['percent', 'percent']),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        var a = h3(e)
        ;(this.settledOption = a),
          this.mergeDefaultAndTheme(e, i),
          this._doInit(a)
      }),
      (t.prototype.mergeOption = function (e) {
        var n = h3(e)
        te(this.option, e, !0), te(this.settledOption, n, !0), this._doInit(n)
      }),
      (t.prototype._doInit = function (e) {
        var n = this.option
        this._setDefaultThrottle(e), this._updateRangeUse(e)
        var i = this.settledOption
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a, o) {
            this._rangePropMode[o] === 'value' && (n[a[0]] = i[a[0]] = null)
          },
          this,
        ),
          this._resetTarget()
      }),
      (t.prototype._resetTarget = function () {
        var e = this.get('orient', !0),
          n = (this._targetAxisInfoMap = Pt()),
          i = this._fillSpecifiedTargetAxis(n)
        i
          ? (this._orient = e || this._makeAutoOrientByTargetAxis())
          : ((this._orient = e || 'horizontal'),
            this._fillAutoTargetAxisByOrient(n, this._orient)),
          (this._noTarget = !0),
          n.each(function (a) {
            a.indexList.length && (this._noTarget = !1)
          }, this)
      }),
      (t.prototype._fillSpecifiedTargetAxis = function (e) {
        var n = !1
        return (
          R(
            c3,
            function (i) {
              var a = this.getReferringComponents(Ws(i), Ltt)
              if (a.specified) {
                n = !0
                var o = new qS()
                R(a.models, function (s) {
                  o.add(s.componentIndex)
                }),
                  e.set(i, o)
              }
            },
            this,
          ),
          n
        )
      }),
      (t.prototype._fillAutoTargetAxisByOrient = function (e, n) {
        var i = this.ecModel,
          a = !0
        if (a) {
          var o = n === 'vertical' ? 'y' : 'x',
            s = i.findComponents({
              mainType: o + 'Axis',
            })
          l(s, o)
        }
        if (a) {
          var s = i.findComponents({
            mainType: 'singleAxis',
            filter: function (c) {
              return c.get('orient', !0) === n
            },
          })
          l(s, 'single')
        }
        function l(u, c) {
          var h = u[0]
          if (h) {
            var f = new qS()
            if (
              (f.add(h.componentIndex),
              e.set(c, f),
              (a = !1),
              c === 'x' || c === 'y')
            ) {
              var d = h.getReferringComponents('grid', Pn).models[0]
              d &&
                R(u, function (p) {
                  h.componentIndex !== p.componentIndex &&
                    d === p.getReferringComponents('grid', Pn).models[0] &&
                    f.add(p.componentIndex)
                })
            }
          }
        }
        a &&
          R(
            c3,
            function (u) {
              if (a) {
                var c = i.findComponents({
                  mainType: Ws(u),
                  filter: function (f) {
                    return f.get('type', !0) === 'category'
                  },
                })
                if (c[0]) {
                  var h = new qS()
                  h.add(c[0].componentIndex), e.set(u, h), (a = !1)
                }
              }
            },
            this,
          )
      }),
      (t.prototype._makeAutoOrientByTargetAxis = function () {
        var e
        return (
          this.eachTargetAxis(function (n) {
            !e && (e = n)
          }, this),
          e === 'y' ? 'vertical' : 'horizontal'
        )
      }),
      (t.prototype._setDefaultThrottle = function (e) {
        if (
          (e.hasOwnProperty('throttle') && (this._autoThrottle = !1),
          this._autoThrottle)
        ) {
          var n = this.ecModel.option
          this.option.throttle =
            n.animation && n.animationDurationUpdate > 0 ? 100 : 20
        }
      }),
      (t.prototype._updateRangeUse = function (e) {
        var n = this._rangePropMode,
          i = this.get('rangeMode')
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a, o) {
            var s = e[a[0]] != null,
              l = e[a[1]] != null
            s && !l
              ? (n[o] = 'percent')
              : !s && l
              ? (n[o] = 'value')
              : i
              ? (n[o] = i[o])
              : s && (n[o] = 'percent')
          },
        )
      }),
      (t.prototype.noTarget = function () {
        return this._noTarget
      }),
      (t.prototype.getFirstTargetAxisModel = function () {
        var e
        return (
          this.eachTargetAxis(function (n, i) {
            e == null && (e = this.ecModel.getComponent(Ws(n), i))
          }, this),
          e
        )
      }),
      (t.prototype.eachTargetAxis = function (e, n) {
        this._targetAxisInfoMap.each(function (i, a) {
          R(i.indexList, function (o) {
            e.call(n, a, o)
          })
        })
      }),
      (t.prototype.getAxisProxy = function (e, n) {
        var i = this.getAxisModel(e, n)
        if (i) return i.__dzAxisProxy
      }),
      (t.prototype.getAxisModel = function (e, n) {
        var i = this._targetAxisInfoMap.get(e)
        if (i && i.indexMap[n]) return this.ecModel.getComponent(Ws(e), n)
      }),
      (t.prototype.setRawRange = function (e) {
        var n = this.option,
          i = this.settledOption
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a) {
            ;(e[a[0]] != null || e[a[1]] != null) &&
              ((n[a[0]] = i[a[0]] = e[a[0]]), (n[a[1]] = i[a[1]] = e[a[1]]))
          },
          this,
        ),
          this._updateRangeUse(e)
      }),
      (t.prototype.setCalculatedRange = function (e) {
        var n = this.option
        R(['start', 'startValue', 'end', 'endValue'], function (i) {
          n[i] = e[i]
        })
      }),
      (t.prototype.getPercentRange = function () {
        var e = this.findRepresentativeAxisProxy()
        if (e) return e.getDataPercentWindow()
      }),
      (t.prototype.getValueRange = function (e, n) {
        if (e == null && n == null) {
          var i = this.findRepresentativeAxisProxy()
          if (i) return i.getDataValueWindow()
        } else return this.getAxisProxy(e, n).getDataValueWindow()
      }),
      (t.prototype.findRepresentativeAxisProxy = function (e) {
        if (e) return e.__dzAxisProxy
        for (
          var n, i = this._targetAxisInfoMap.keys(), a = 0;
          a < i.length;
          a++
        )
          for (
            var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0;
            l < s.indexList.length;
            l++
          ) {
            var u = this.getAxisProxy(o, s.indexList[l])
            if (u.hostedBy(this)) return u
            n || (n = u)
          }
        return n
      }),
      (t.prototype.getRangePropMode = function () {
        return this._rangePropMode.slice()
      }),
      (t.prototype.getOrient = function () {
        return this._orient
      }),
      (t.type = 'dataZoom'),
      (t.dependencies = [
        'xAxis',
        'yAxis',
        'radiusAxis',
        'angleAxis',
        'singleAxis',
        'series',
        'toolbox',
      ]),
      (t.defaultOption = {
        z: 4,
        filterMode: 'filter',
        start: 0,
        end: 100,
      }),
      t
    )
  })(xe)
function h3(r) {
  var t = {}
  return (
    R(['start', 'end', 'startValue', 'endValue', 'throttle'], function (e) {
      r.hasOwnProperty(e) && (t[e] = r[e])
    }),
    t
  )
}
const sv = v0t
var g0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'dataZoom.select'), t
})(sv)
const m0t = g0t
var y0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      ;(this.dataZoomModel = e), (this.ecModel = n), (this.api = i)
    }),
    (t.type = 'dataZoom'),
    t
  )
})(dn)
const AE = y0t
var _0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'dataZoom.select'), t
})(AE)
const x0t = _0t
var uh = R,
  f3 = Zi,
  S0t = (function () {
    function r(t, e, n, i) {
      ;(this._dimName = t),
        (this._axisIndex = e),
        (this.ecModel = i),
        (this._dataZoomModel = n)
    }
    return (
      (r.prototype.hostedBy = function (t) {
        return this._dataZoomModel === t
      }),
      (r.prototype.getDataValueWindow = function () {
        return this._valueWindow.slice()
      }),
      (r.prototype.getDataPercentWindow = function () {
        return this._percentWindow.slice()
      }),
      (r.prototype.getTargetSeriesModels = function () {
        var t = []
        return (
          this.ecModel.eachSeries(function (e) {
            if (d0t(e)) {
              var n = Ws(this._dimName),
                i = e.getReferringComponents(n, Pn).models[0]
              i && this._axisIndex === i.componentIndex && t.push(e)
            }
          }, this),
          t
        )
      }),
      (r.prototype.getAxisModel = function () {
        return this.ecModel.getComponent(
          this._dimName + 'Axis',
          this._axisIndex,
        )
      }),
      (r.prototype.getMinMaxSpan = function () {
        return Vt(this._minMaxSpan)
      }),
      (r.prototype.calculateDataWindow = function (t) {
        var e = this._dataExtent,
          n = this.getAxisModel(),
          i = n.axis.scale,
          a = this._dataZoomModel.getRangePropMode(),
          o = [0, 100],
          s = [],
          l = [],
          u
        uh(['start', 'end'], function (f, d) {
          var p = t[f],
            g = t[f + 'Value']
          a[d] === 'percent'
            ? (p == null && (p = o[d]), (g = i.parse(Re(p, o, e))))
            : ((u = !0),
              (g = g == null ? e[d] : i.parse(g)),
              (p = Re(g, e, o))),
            (l[d] = g == null || isNaN(g) ? e[d] : g),
            (s[d] = p == null || isNaN(p) ? o[d] : p)
        }),
          f3(l),
          f3(s)
        var c = this._minMaxSpan
        u ? h(l, s, e, o, !1) : h(s, l, o, e, !0)
        function h(f, d, p, g, v) {
          var m = v ? 'Span' : 'ValueSpan'
          lc(0, f, p, 'all', c['min' + m], c['max' + m])
          for (var y = 0; y < 2; y++)
            (d[y] = Re(f[y], p, g, !0)), v && (d[y] = i.parse(d[y]))
        }
        return {
          valueWindow: l,
          percentWindow: s,
        }
      }),
      (r.prototype.reset = function (t) {
        if (t === this._dataZoomModel) {
          var e = this.getTargetSeriesModels()
          ;(this._dataExtent = A0t(this, this._dimName, e)),
            this._updateMinMaxSpan()
          var n = this.calculateDataWindow(t.settledOption)
          ;(this._valueWindow = n.valueWindow),
            (this._percentWindow = n.percentWindow),
            this._setAxisModel()
        }
      }),
      (r.prototype.filterData = function (t, e) {
        if (t !== this._dataZoomModel) return
        var n = this._dimName,
          i = this.getTargetSeriesModels(),
          a = t.get('filterMode'),
          o = this._valueWindow
        if (a === 'none') return
        uh(i, function (l) {
          var u = l.getData(),
            c = u.mapDimensionsAll(n)
          if (c.length) {
            if (a === 'weakFilter') {
              var h = u.getStore(),
                f = st(
                  c,
                  function (d) {
                    return u.getDimensionIndex(d)
                  },
                  u,
                )
              u.filterSelf(function (d) {
                for (var p, g, v, m = 0; m < c.length; m++) {
                  var y = h.get(f[m], d),
                    _ = !isNaN(y),
                    x = y < o[0],
                    A = y > o[1]
                  if (_ && !x && !A) return !0
                  _ && (v = !0), x && (p = !0), A && (g = !0)
                }
                return v && p && g
              })
            } else
              uh(c, function (d) {
                if (a === 'empty')
                  l.setData(
                    (u = u.map(d, function (g) {
                      return s(g) ? g : NaN
                    })),
                  )
                else {
                  var p = {}
                  ;(p[d] = o), u.selectRange(p)
                }
              })
            uh(c, function (d) {
              u.setApproximateExtent(o, d)
            })
          }
        })
        function s(l) {
          return l >= o[0] && l <= o[1]
        }
      }),
      (r.prototype._updateMinMaxSpan = function () {
        var t = (this._minMaxSpan = {}),
          e = this._dataZoomModel,
          n = this._dataExtent
        uh(
          ['min', 'max'],
          function (i) {
            var a = e.get(i + 'Span'),
              o = e.get(i + 'ValueSpan')
            o != null && (o = this.getAxisModel().axis.scale.parse(o)),
              o != null
                ? (a = Re(n[0] + o, n, [0, 100], !0))
                : a != null && (o = Re(a, [0, 100], n, !0) - n[0]),
              (t[i + 'Span'] = a),
              (t[i + 'ValueSpan'] = o)
          },
          this,
        )
      }),
      (r.prototype._setAxisModel = function () {
        var t = this.getAxisModel(),
          e = this._percentWindow,
          n = this._valueWindow
        if (e) {
          var i = Nz(n, [0, 500])
          i = Math.min(i, 20)
          var a = t.axis.scale.rawExtentInfo
          e[0] !== 0 && a.setDeterminedMinMax('min', +n[0].toFixed(i)),
            e[1] !== 100 && a.setDeterminedMinMax('max', +n[1].toFixed(i)),
            a.freeze()
        }
      }),
      r
    )
  })()
function A0t(r, t, e) {
  var n = [1 / 0, -1 / 0]
  uh(e, function (o) {
    Wot(n, o.getData(), t)
  })
  var i = r.getAxisModel(),
    a = UV(i.axis.scale, i, n).calculate()
  return [a.min, a.max]
}
const b0t = S0t
var w0t = {
  getTargetSeries: function (r) {
    function t(i) {
      r.eachComponent('dataZoom', function (a) {
        a.eachTargetAxis(function (o, s) {
          var l = r.getComponent(Ws(o), s)
          i(o, s, l, a)
        })
      })
    }
    t(function (i, a, o, s) {
      o.__dzAxisProxy = null
    })
    var e = []
    t(function (i, a, o, s) {
      o.__dzAxisProxy ||
        ((o.__dzAxisProxy = new b0t(i, a, s, r)), e.push(o.__dzAxisProxy))
    })
    var n = Pt()
    return (
      R(e, function (i) {
        R(i.getTargetSeriesModels(), function (a) {
          n.set(a.uid, a)
        })
      }),
      n
    )
  },
  overallReset: function (r, t) {
    r.eachComponent('dataZoom', function (e) {
      e.eachTargetAxis(function (n, i) {
        e.getAxisProxy(n, i).reset(e)
      }),
        e.eachTargetAxis(function (n, i) {
          e.getAxisProxy(n, i).filterData(e, t)
        })
    }),
      r.eachComponent('dataZoom', function (e) {
        var n = e.findRepresentativeAxisProxy()
        if (n) {
          var i = n.getDataPercentWindow(),
            a = n.getDataValueWindow()
          e.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1],
          })
        }
      })
  },
}
const M0t = w0t
function T0t(r) {
  r.registerAction('dataZoom', function (t, e) {
    var n = p0t(e, t)
    R(n, function (i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue,
      })
    })
  })
}
var d3 = !1
function bE(r) {
  d3 ||
    ((d3 = !0),
    r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, M0t),
    T0t(r),
    r.registerSubTypeDefaulter('dataZoom', function () {
      return 'slider'
    }))
}
function C0t(r) {
  r.registerComponentModel(m0t), r.registerComponentView(x0t), bE(r)
}
var Hi = (function () {
    function r() {}
    return r
  })(),
  CH = {}
function ch(r, t) {
  CH[r] = t
}
function EH(r) {
  return CH[r]
}
var E0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.optionUpdated = function () {
      r.prototype.optionUpdated.apply(this, arguments)
      var e = this.ecModel
      R(this.option.feature, function (n, i) {
        var a = EH(i)
        a &&
          (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)),
          te(n, a.defaultOption))
      })
    }),
    (t.type = 'toolbox'),
    (t.layoutMode = {
      type: 'box',
      ignoreSize: !0,
    }),
    (t.defaultOption = {
      show: !0,
      z: 6,
      orient: 'horizontal',
      left: 'right',
      top: 'top',
      backgroundColor: 'transparent',
      borderColor: '#ccc',
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: '#666',
        color: 'none',
      },
      emphasis: {
        iconStyle: {
          borderColor: '#3E98C5',
        },
      },
      tooltip: {
        show: !1,
        position: 'bottom',
      },
    }),
    t
  )
})(xe)
const D0t = E0t
function L0t(r, t, e) {
  var n = t.getBoxLayoutParams(),
    i = t.get('padding'),
    a = {
      width: e.getWidth(),
      height: e.getHeight(),
    },
    o = Vn(n, a, i)
  ku(t.get('orient'), r, t.get('itemGap'), o.width, o.height), p_(r, n, a, i)
}
function DH(r, t) {
  var e = wf(t.get('padding')),
    n = t.getItemStyle(['color', 'opacity'])
  return (
    (n.fill = t.get('backgroundColor')),
    (r = new ge({
      shape: {
        x: r.x - e[3],
        y: r.y - e[0],
        width: r.width + e[1] + e[3],
        height: r.height + e[0] + e[2],
        r: t.get('borderRadius'),
      },
      style: n,
      silent: !0,
      z2: -1,
    })),
    r
  )
}
var P0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      var o = this.group
      if ((o.removeAll(), !e.get('show'))) return
      var s = +e.get('itemSize'),
        l = e.get('orient') === 'vertical',
        u = e.get('feature') || {},
        c = this._features || (this._features = {}),
        h = []
      R(u, function (p, g) {
        h.push(g)
      }),
        new es(this._featureNames || [], h)
          .add(f)
          .update(f)
          .remove(Zt(f, null))
          .execute(),
        (this._featureNames = h)
      function f(p, g) {
        var v = h[p],
          m = h[g],
          y = u[v],
          _ = new qe(y, e, e.ecModel),
          x
        if (
          (a &&
            a.newTitle != null &&
            a.featureName === v &&
            (y.title = a.newTitle),
          v && !m)
        ) {
          if (R0t(v))
            x = {
              onclick: _.option.onclick,
              featureName: v,
            }
          else {
            var A = EH(v)
            if (!A) return
            x = new A()
          }
          c[v] = x
        } else if (((x = c[m]), !x)) return
        ;(x.uid = bf('toolbox-feature')),
          (x.model = _),
          (x.ecModel = n),
          (x.api = i)
        var S = x instanceof Hi
        if (!v && m) {
          S && x.dispose && x.dispose(n, i)
          return
        }
        if (!_.get('show') || (S && x.unusable)) {
          S && x.remove && x.remove(n, i)
          return
        }
        d(_, x, v),
          (_.setIconStatus = function (b, T) {
            var w = this.option,
              M = this.iconPaths
            ;(w.iconStatus = w.iconStatus || {}),
              (w.iconStatus[b] = T),
              M[b] && (T === 'emphasis' ? Qo : ts)(M[b])
          }),
          x instanceof Hi && x.render && x.render(_, n, i, a)
      }
      function d(p, g, v) {
        var m = p.getModel('iconStyle'),
          y = p.getModel(['emphasis', 'iconStyle']),
          _ = g instanceof Hi && g.getIcons ? g.getIcons() : p.get('icon'),
          x = p.get('title') || {},
          A,
          S
        bt(_) ? ((A = {}), (A[v] = _)) : (A = _),
          bt(x) ? ((S = {}), (S[v] = x)) : (S = x)
        var b = (p.iconPaths = {})
        R(A, function (T, w) {
          var M = Sv(
            T,
            {},
            {
              x: -s / 2,
              y: -s / 2,
              width: s,
              height: s,
            },
          )
          M.setStyle(m.getItemStyle())
          var C = M.ensureState('emphasis')
          C.style = y.getItemStyle()
          var E = new Ae({
            style: {
              text: S[w],
              align: y.get('textAlign'),
              borderRadius: y.get('textBorderRadius'),
              padding: y.get('textPadding'),
              fill: null,
              font: eC(
                {
                  fontStyle: y.get('textFontStyle'),
                  fontFamily: y.get('textFontFamily'),
                  fontSize: y.get('textFontSize'),
                  fontWeight: y.get('textFontWeight'),
                },
                n,
              ),
            },
            ignore: !0,
          })
          M.setTextContent(E),
            Sf({
              el: M,
              componentModel: e,
              itemName: w,
              formatterParamsExtra: {
                title: S[w],
              },
            }),
            (M.__title = S[w]),
            M.on('mouseover', function () {
              var D = y.getItemStyle(),
                P = l
                  ? e.get('right') == null && e.get('left') !== 'right'
                    ? 'right'
                    : 'left'
                  : e.get('bottom') == null && e.get('top') !== 'bottom'
                  ? 'bottom'
                  : 'top'
              E.setStyle({
                fill: y.get('textFill') || D.fill || D.stroke || '#000',
                backgroundColor: y.get('textBackgroundColor'),
              }),
                M.setTextConfig({
                  position: y.get('textPosition') || P,
                }),
                (E.ignore = !e.get('showTitle')),
                i.enterEmphasis(this)
            }).on('mouseout', function () {
              p.get(['iconStatus', w]) !== 'emphasis' && i.leaveEmphasis(this),
                E.hide()
            }),
            (p.get(['iconStatus', w]) === 'emphasis' ? Qo : ts)(M),
            o.add(M),
            M.on('click', Tt(g.onclick, g, n, i, w)),
            (b[w] = M)
        })
      }
      L0t(o, e, i),
        o.add(DH(o.getBoundingRect(), e)),
        l ||
          o.eachChild(function (p) {
            var g = p.__title,
              v = p.ensureState('emphasis'),
              m = v.textConfig || (v.textConfig = {}),
              y = p.getTextContent(),
              _ = y && y.ensureState('emphasis')
            if (_ && !Nt(_) && g) {
              var x = _.style || (_.style = {}),
                A = mv(g, Ae.makeFont(x)),
                S = p.x + o.x,
                b = p.y + o.y + s,
                T = !1
              b + A.height > i.getHeight() && ((m.position = 'top'), (T = !0))
              var w = T ? -5 - A.height : s + 10
              S + A.width / 2 > i.getWidth()
                ? ((m.position = ['100%', w]), (x.align = 'right'))
                : S - A.width / 2 < 0 &&
                  ((m.position = [0, w]), (x.align = 'left'))
            }
          })
    }),
    (t.prototype.updateView = function (e, n, i, a) {
      R(this._features, function (o) {
        o instanceof Hi && o.updateView && o.updateView(o.model, n, i, a)
      })
    }),
    (t.prototype.remove = function (e, n) {
      R(this._features, function (i) {
        i instanceof Hi && i.remove && i.remove(e, n)
      }),
        this.group.removeAll()
    }),
    (t.prototype.dispose = function (e, n) {
      R(this._features, function (i) {
        i instanceof Hi && i.dispose && i.dispose(e, n)
      })
    }),
    (t.type = 'toolbox'),
    t
  )
})(dn)
function R0t(r) {
  return r.indexOf('my') === 0
}
const I0t = P0t
var O0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      var i = this.model,
        a = i.get('name') || e.get('title.0.text') || 'echarts',
        o = n.getZr().painter.getType() === 'svg',
        s = o ? 'svg' : i.get('type', !0) || 'png',
        l = n.getConnectedDataURL({
          type: s,
          backgroundColor:
            i.get('backgroundColor', !0) || e.get('backgroundColor') || '#fff',
          connectedBackgroundColor: i.get('connectedBackgroundColor'),
          excludeComponents: i.get('excludeComponents'),
          pixelRatio: i.get('pixelRatio'),
        }),
        u = Se.browser
      if (
        typeof MouseEvent == 'function' &&
        (u.newEdge || (!u.ie && !u.edge))
      ) {
        var c = document.createElement('a')
        ;(c.download = a + '.' + s), (c.target = '_blank'), (c.href = l)
        var h = new MouseEvent('click', {
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1,
        })
        c.dispatchEvent(h)
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(','),
          d = f[0].indexOf('base64') > -1,
          p = o ? decodeURIComponent(f[1]) : f[1]
        d && (p = window.atob(p))
        var g = a + '.' + s
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v)
          var y = new Blob([m])
          window.navigator.msSaveOrOpenBlob(y, g)
        } else {
          var _ = document.createElement('iframe')
          document.body.appendChild(_)
          var x = _.contentWindow,
            A = x.document
          A.open('image/svg+xml', 'replace'),
            A.write(p),
            A.close(),
            x.focus(),
            A.execCommand('SaveAs', !0, g),
            document.body.removeChild(_)
        }
      } else {
        var S = i.get('lang'),
          b =
            '<body style="margin:0;"><img src="' +
            l +
            '" style="max-width:100%;" title="' +
            ((S && S[0]) || '') +
            '" /></body>',
          T = window.open()
        T.document.write(b), (T.document.title = a)
      }
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
        title: e.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']),
        type: 'png',
        connectedBackgroundColor: '#fff',
        name: '',
        excludeComponents: ['toolbox'],
        lang: e.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang']),
      }
      return n
    }),
    t
  )
})(Hi)
const N0t = O0t
var p3 = '__ec_magicType_stack__',
  k0t = [['line', 'bar'], ['stack']],
  B0t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.getIcons = function () {
        var e = this.model,
          n = e.get('icon'),
          i = {}
        return (
          R(e.get('type'), function (a) {
            n[a] && (i[a] = n[a])
          }),
          i
        )
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          type: [],
          icon: {
            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
            stack:
              'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
          },
          title: e.getLocaleModel().get(['toolbox', 'magicType', 'title']),
          option: {},
          seriesIndex: {},
        }
        return n
      }),
      (t.prototype.onclick = function (e, n, i) {
        var a = this.model,
          o = a.get(['seriesIndex', i])
        if (v3[i]) {
          var s = {
              series: [],
            },
            l = function (h) {
              var f = h.subType,
                d = h.id,
                p = v3[i](f, d, h, a)
              p && (zt(p, h.option), s.series.push(p))
              var g = h.coordinateSystem
              if (
                g &&
                g.type === 'cartesian2d' &&
                (i === 'line' || i === 'bar')
              ) {
                var v = g.getAxesByScale('ordinal')[0]
                if (v) {
                  var m = v.dim,
                    y = m + 'Axis',
                    _ = h.getReferringComponents(y, Pn).models[0],
                    x = _.componentIndex
                  s[y] = s[y] || []
                  for (var A = 0; A <= x; A++) s[y][x] = s[y][x] || {}
                  s[y][x].boundaryGap = i === 'bar'
                }
              }
            }
          R(k0t, function (h) {
            re(h, i) >= 0 &&
              R(h, function (f) {
                a.setIconStatus(f, 'normal')
              })
          }),
            a.setIconStatus(i, 'emphasis'),
            e.eachComponent(
              {
                mainType: 'series',
                query:
                  o == null
                    ? null
                    : {
                        seriesIndex: o,
                      },
              },
              l,
            )
          var u,
            c = i
          i === 'stack' &&
            ((u = te(
              {
                stack: a.option.title.tiled,
                tiled: a.option.title.stack,
              },
              a.option.title,
            )),
            a.get(['iconStatus', i]) !== 'emphasis' && (c = 'tiled')),
            n.dispatchAction({
              type: 'changeMagicType',
              currentType: c,
              newOption: s,
              newTitle: u,
              featureName: 'magicType',
            })
        }
      }),
      t
    )
  })(Hi),
  v3 = {
    line: function (r, t, e, n) {
      if (r === 'bar')
        return te(
          {
            id: t,
            type: 'line',
            data: e.get('data'),
            stack: e.get('stack'),
            markPoint: e.get('markPoint'),
            markLine: e.get('markLine'),
          },
          n.get(['option', 'line']) || {},
          !0,
        )
    },
    bar: function (r, t, e, n) {
      if (r === 'line')
        return te(
          {
            id: t,
            type: 'bar',
            data: e.get('data'),
            stack: e.get('stack'),
            markPoint: e.get('markPoint'),
            markLine: e.get('markLine'),
          },
          n.get(['option', 'bar']) || {},
          !0,
        )
    },
    stack: function (r, t, e, n) {
      var i = e.get('stack') === p3
      if (r === 'line' || r === 'bar')
        return (
          n.setIconStatus('stack', i ? 'normal' : 'emphasis'),
          te(
            {
              id: t,
              stack: i ? '' : p3,
            },
            n.get(['option', 'stack']) || {},
            !0,
          )
        )
    },
  }
xo(
  {
    type: 'changeMagicType',
    event: 'magicTypeChanged',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    t.mergeOption(r.newOption)
  },
)
const F0t = B0t
var R_ = new Array(60).join('-'),
  cf = '	'
function z0t(r) {
  var t = {},
    e = [],
    n = []
  return (
    r.eachRawSeries(function (i) {
      var a = i.coordinateSystem
      if (a && (a.type === 'cartesian2d' || a.type === 'polar')) {
        var o = a.getBaseAxis()
        if (o.type === 'category') {
          var s = o.dim + '_' + o.index
          t[s] ||
            ((t[s] = {
              categoryAxis: o,
              valueAxis: a.getOtherAxis(o),
              series: [],
            }),
            n.push({
              axisDim: o.dim,
              axisIndex: o.index,
            })),
            t[s].series.push(i)
        } else e.push(i)
      } else e.push(i)
    }),
    {
      seriesGroupByCategoryAxis: t,
      other: e,
      meta: n,
    }
  )
}
function U0t(r) {
  var t = []
  return (
    R(r, function (e, n) {
      var i = e.categoryAxis,
        a = e.valueAxis,
        o = a.dim,
        s = [' '].concat(
          st(e.series, function (d) {
            return d.name
          }),
        ),
        l = [i.model.getCategories()]
      R(e.series, function (d) {
        var p = d.getRawData()
        l.push(
          d.getRawData().mapArray(p.mapDimension(o), function (g) {
            return g
          }),
        )
      })
      for (var u = [s.join(cf)], c = 0; c < l[0].length; c++) {
        for (var h = [], f = 0; f < l.length; f++) h.push(l[f][c])
        u.push(h.join(cf))
      }
      t.push(
        u.join(`
`),
      )
    }),
    t.join(
      `

` +
        R_ +
        `

`,
    )
  )
}
function V0t(r) {
  return st(r, function (t) {
    var e = t.getRawData(),
      n = [t.name],
      i = []
    return (
      e.each(e.dimensions, function () {
        for (
          var a = arguments.length,
            o = arguments[a - 1],
            s = e.getName(o),
            l = 0;
          l < a - 1;
          l++
        )
          i[l] = arguments[l]
        n.push((s ? s + cf : '') + i.join(cf))
      }),
      n.join(`
`)
    )
  }).join(
    `

` +
      R_ +
      `

`,
  )
}
function G0t(r) {
  var t = z0t(r)
  return {
    value: Ne([U0t(t.seriesGroupByCategoryAxis), V0t(t.other)], function (e) {
      return !!e.replace(/[\n\t\s]/g, '')
    }).join(
      `

` +
        R_ +
        `

`,
    ),
    meta: t.meta,
  }
}
function A0(r) {
  return r.replace(/^\s\s*/, '').replace(/\s\s*$/, '')
}
function H0t(r) {
  var t = r.slice(
    0,
    r.indexOf(`
`),
  )
  if (t.indexOf(cf) >= 0) return !0
}
var eM = new RegExp('[' + cf + ']+', 'g')
function W0t(r) {
  for (
    var t = r.split(/\n+/g),
      e = A0(t.shift()).split(eM),
      n = [],
      i = st(e, function (l) {
        return {
          name: l,
          data: [],
        }
      }),
      a = 0;
    a < t.length;
    a++
  ) {
    var o = A0(t[a]).split(eM)
    n.push(o.shift())
    for (var s = 0; s < o.length; s++) i[s] && (i[s].data[a] = o[s])
  }
  return {
    series: i,
    categories: n,
  }
}
function X0t(r) {
  for (
    var t = r.split(/\n+/g), e = A0(t.shift()), n = [], i = 0;
    i < t.length;
    i++
  ) {
    var a = A0(t[i])
    if (a) {
      var o = a.split(eM),
        s = '',
        l = void 0,
        u = !1
      isNaN(o[0])
        ? ((u = !0),
          (s = o[0]),
          (o = o.slice(1)),
          (n[i] = {
            name: s,
            value: [],
          }),
          (l = n[i].value))
        : (l = n[i] = [])
      for (var c = 0; c < o.length; c++) l.push(+o[c])
      l.length === 1 && (u ? (n[i].value = l[0]) : (n[i] = l[0]))
    }
  }
  return {
    name: e,
    data: n,
  }
}
function Y0t(r, t) {
  var e = r.split(
      new RegExp(
        `
*` +
          R_ +
          `
*`,
        'g',
      ),
    ),
    n = {
      series: [],
    }
  return (
    R(e, function (i, a) {
      if (H0t(i)) {
        var o = W0t(i),
          s = t[a],
          l = s.axisDim + 'Axis'
        s &&
          ((n[l] = n[l] || []),
          (n[l][s.axisIndex] = {
            data: o.categories,
          }),
          (n.series = n.series.concat(o.series)))
      } else {
        var o = X0t(i)
        n.series.push(o)
      }
    }),
    n
  )
}
var $0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      setTimeout(function () {
        n.dispatchAction({
          type: 'hideTip',
        })
      })
      var i = n.getDom(),
        a = this.model
      this._dom && i.removeChild(this._dom)
      var o = document.createElement('div')
      ;(o.style.cssText =
        'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px'),
        (o.style.backgroundColor = a.get('backgroundColor') || '#fff')
      var s = document.createElement('h4'),
        l = a.get('lang') || []
      ;(s.innerHTML = l[0] || a.get('title')),
        (s.style.cssText = 'margin:10px 20px'),
        (s.style.color = a.get('textColor'))
      var u = document.createElement('div'),
        c = document.createElement('textarea')
      u.style.cssText = 'overflow:auto'
      var h = a.get('optionToContent'),
        f = a.get('contentToOption'),
        d = G0t(e)
      if (Nt(h)) {
        var p = h(n.getOption())
        bt(p) ? (u.innerHTML = p) : tf(p) && u.appendChild(p)
      } else {
        c.readOnly = a.get('readOnly')
        var g = c.style
        ;(g.cssText =
          'display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none'),
          (g.color = a.get('textColor')),
          (g.borderColor = a.get('textareaBorderColor')),
          (g.backgroundColor = a.get('textareaColor')),
          (c.value = d.value),
          u.appendChild(c)
      }
      var v = d.meta,
        m = document.createElement('div')
      m.style.cssText = 'position:absolute;bottom:5px;left:0;right:0'
      var y =
          'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px',
        _ = document.createElement('div'),
        x = document.createElement('div')
      ;(y += ';background-color:' + a.get('buttonColor')),
        (y += ';color:' + a.get('buttonTextColor'))
      var A = this
      function S() {
        i.removeChild(o), (A._dom = null)
      }
      Ob(_, 'click', S),
        Ob(x, 'click', function () {
          if ((f == null && h != null) || (f != null && h == null)) {
            S()
            return
          }
          var b
          try {
            Nt(f) ? (b = f(u, n.getOption())) : (b = Y0t(c.value, v))
          } catch (T) {
            throw (S(), new Error('Data view format error ' + T))
          }
          b &&
            n.dispatchAction({
              type: 'changeDataView',
              newOption: b,
            }),
            S()
        }),
        (_.innerHTML = l[1]),
        (x.innerHTML = l[2]),
        (x.style.cssText = _.style.cssText = y),
        !a.get('readOnly') && m.appendChild(x),
        m.appendChild(_),
        o.appendChild(s),
        o.appendChild(u),
        o.appendChild(m),
        (u.style.height = i.clientHeight - 80 + 'px'),
        i.appendChild(o),
        (this._dom = o)
    }),
    (t.prototype.remove = function (e, n) {
      this._dom && n.getDom().removeChild(this._dom)
    }),
    (t.prototype.dispose = function (e, n) {
      this.remove(e, n)
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
        title: e.getLocaleModel().get(['toolbox', 'dataView', 'title']),
        lang: e.getLocaleModel().get(['toolbox', 'dataView', 'lang']),
        backgroundColor: '#fff',
        textColor: '#000',
        textareaColor: '#fff',
        textareaBorderColor: '#333',
        buttonColor: '#c23531',
        buttonTextColor: '#fff',
      }
      return n
    }),
    t
  )
})(Hi)
function q0t(r, t) {
  return st(r, function (e, n) {
    var i = t && t[n]
    if (Ut(i) && !at(i)) {
      var a = Ut(e) && !at(e)
      a ||
        (e = {
          value: e,
        })
      var o = i.name != null && e.name == null
      return (e = zt(e, i)), o && delete e.name, e
    } else return e
  })
}
xo(
  {
    type: 'changeDataView',
    event: 'dataViewChanged',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    var e = []
    R(r.newOption.series, function (n) {
      var i = t.getSeriesByName(n.name)[0]
      if (!i)
        e.push(
          Q(
            {
              type: 'scatter',
            },
            n,
          ),
        )
      else {
        var a = i.get('data')
        e.push({
          name: n.name,
          data: q0t(n.data, a),
        })
      }
    }),
      t.mergeOption(
        zt(
          {
            series: e,
          },
          r.newOption,
        ),
      )
  },
)
const Z0t = $0t
var LH = R,
  PH = ve()
function K0t(r, t) {
  var e = wE(r)
  LH(t, function (n, i) {
    for (var a = e.length - 1; a >= 0; a--) {
      var o = e[a]
      if (o[i]) break
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: i,
      })[0]
      if (s) {
        var l = s.getPercentRange()
        e[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1],
        }
      }
    }
  }),
    e.push(t)
}
function j0t(r) {
  var t = wE(r),
    e = t[t.length - 1]
  t.length > 1 && t.pop()
  var n = {}
  return (
    LH(e, function (i, a) {
      for (var o = t.length - 1; o >= 0; o--)
        if (((i = t[o][a]), i)) {
          n[a] = i
          break
        }
    }),
    n
  )
}
function J0t(r) {
  PH(r).snapshots = null
}
function Q0t(r) {
  return wE(r).length
}
function wE(r) {
  var t = PH(r)
  return t.snapshots || (t.snapshots = [{}]), t.snapshots
}
var t_t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      J0t(e),
        n.dispatchAction({
          type: 'restore',
          from: this.uid,
        })
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
        title: e.getLocaleModel().get(['toolbox', 'restore', 'title']),
      }
      return n
    }),
    t
  )
})(Hi)
xo(
  {
    type: 'restore',
    event: 'restore',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    t.resetOption('recreate')
  },
)
const e_t = t_t
var n_t = [
    'grid',
    'xAxis',
    'yAxis',
    'geo',
    'graph',
    'polar',
    'radiusAxis',
    'angleAxis',
    'bmap',
  ],
  r_t = (function () {
    function r(t, e, n) {
      var i = this
      this._targetInfoList = []
      var a = g3(e, t)
      R(i_t, function (o, s) {
        ;(!n || !n.include || re(n.include, s) >= 0) && o(a, i._targetInfoList)
      })
    }
    return (
      (r.prototype.setOutputRanges = function (t, e) {
        return (
          this.matchOutputRanges(t, e, function (n, i, a) {
            if (
              ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange)
            ) {
              n.coordRange = i
              var o = ZS[n.brushType](0, a, i)
              n.__rangeOffset = {
                offset: x3[n.brushType](o.values, n.range, [1, 1]),
                xyMinMax: o.xyMinMax,
              }
            }
          }),
          t
        )
      }),
      (r.prototype.matchOutputRanges = function (t, e, n) {
        R(
          t,
          function (i) {
            var a = this.findTargetInfo(i, e)
            a &&
              a !== !0 &&
              R(a.coordSyses, function (o) {
                var s = ZS[i.brushType](1, o, i.range, !0)
                n(i, s.values, o, e)
              })
          },
          this,
        )
      }),
      (r.prototype.setInputRanges = function (t, e) {
        R(
          t,
          function (n) {
            var i = this.findTargetInfo(n, e)
            if (((n.range = n.range || []), i && i !== !0)) {
              n.panelId = i.panelId
              var a = ZS[n.brushType](0, i.coordSys, n.coordRange),
                o = n.__rangeOffset
              n.range = o
                ? x3[n.brushType](
                    a.values,
                    o.offset,
                    a_t(a.xyMinMax, o.xyMinMax),
                  )
                : a.values
            }
          },
          this,
        )
      }),
      (r.prototype.makePanelOpts = function (t, e) {
        return st(this._targetInfoList, function (n) {
          var i = n.getPanelRect()
          return {
            panelId: n.panelId,
            defaultBrushType: e ? e(n) : null,
            clipPath: F4(i),
            isTargetByCursor: U4(i, t, n.coordSysModel),
            getLinearBrushOtherExtent: z4(i),
          }
        })
      }),
      (r.prototype.controlSeries = function (t, e, n) {
        var i = this.findTargetInfo(t, n)
        return i === !0 || (i && re(i.coordSyses, e.coordinateSystem) >= 0)
      }),
      (r.prototype.findTargetInfo = function (t, e) {
        for (
          var n = this._targetInfoList, i = g3(e, t), a = 0;
          a < n.length;
          a++
        ) {
          var o = n[a],
            s = t.panelId
          if (s) {
            if (o.panelId === s) return o
          } else for (var l = 0; l < m3.length; l++) if (m3[l](i, o)) return o
        }
        return !0
      }),
      r
    )
  })()
function nM(r) {
  return r[0] > r[1] && r.reverse(), r
}
function g3(r, t) {
  return ip(r, t, {
    includeMainTypes: n_t,
  })
}
var i_t = {
    grid: function (r, t) {
      var e = r.xAxisModels,
        n = r.yAxisModels,
        i = r.gridModels,
        a = Pt(),
        o = {},
        s = {}
      ;(!e && !n && !i) ||
        (R(e, function (l) {
          var u = l.axis.grid.model
          a.set(u.id, u), (o[u.id] = !0)
        }),
        R(n, function (l) {
          var u = l.axis.grid.model
          a.set(u.id, u), (s[u.id] = !0)
        }),
        R(i, function (l) {
          a.set(l.id, l), (o[l.id] = !0), (s[l.id] = !0)
        }),
        a.each(function (l) {
          var u = l.coordinateSystem,
            c = []
          R(u.getCartesians(), function (h, f) {
            ;(re(e, h.getAxis('x').model) >= 0 ||
              re(n, h.getAxis('y').model) >= 0) &&
              c.push(h)
          }),
            t.push({
              panelId: 'grid--' + l.id,
              gridModel: l,
              coordSysModel: l,
              coordSys: c[0],
              coordSyses: c,
              getPanelRect: y3.grid,
              xAxisDeclared: o[l.id],
              yAxisDeclared: s[l.id],
            })
        }))
    },
    geo: function (r, t) {
      R(r.geoModels, function (e) {
        var n = e.coordinateSystem
        t.push({
          panelId: 'geo--' + e.id,
          geoModel: e,
          coordSysModel: e,
          coordSys: n,
          coordSyses: [n],
          getPanelRect: y3.geo,
        })
      })
    },
  },
  m3 = [
    function (r, t) {
      var e = r.xAxisModel,
        n = r.yAxisModel,
        i = r.gridModel
      return (
        !i && e && (i = e.axis.grid.model),
        !i && n && (i = n.axis.grid.model),
        i && i === t.gridModel
      )
    },
    function (r, t) {
      var e = r.geoModel
      return e && e === t.geoModel
    },
  ],
  y3 = {
    grid: function () {
      return this.coordSys.master.getRect().clone()
    },
    geo: function () {
      var r = this.coordSys,
        t = r.getBoundingRect().clone()
      return t.applyTransform(Nu(r)), t
    },
  },
  ZS = {
    lineX: Zt(_3, 0),
    lineY: Zt(_3, 1),
    rect: function (r, t, e, n) {
      var i = r
          ? t.pointToData([e[0][0], e[1][0]], n)
          : t.dataToPoint([e[0][0], e[1][0]], n),
        a = r
          ? t.pointToData([e[0][1], e[1][1]], n)
          : t.dataToPoint([e[0][1], e[1][1]], n),
        o = [nM([i[0], a[0]]), nM([i[1], a[1]])]
      return {
        values: o,
        xyMinMax: o,
      }
    },
    polygon: function (r, t, e, n) {
      var i = [
          [1 / 0, -1 / 0],
          [1 / 0, -1 / 0],
        ],
        a = st(e, function (o) {
          var s = r ? t.pointToData(o, n) : t.dataToPoint(o, n)
          return (
            (i[0][0] = Math.min(i[0][0], s[0])),
            (i[1][0] = Math.min(i[1][0], s[1])),
            (i[0][1] = Math.max(i[0][1], s[0])),
            (i[1][1] = Math.max(i[1][1], s[1])),
            s
          )
        })
      return {
        values: a,
        xyMinMax: i,
      }
    },
  }
function _3(r, t, e, n) {
  var i = e.getAxis(['x', 'y'][r]),
    a = nM(
      st([0, 1], function (s) {
        return t
          ? i.coordToData(i.toLocalCoord(n[s]), !0)
          : i.toGlobalCoord(i.dataToCoord(n[s]))
      }),
    ),
    o = []
  return (
    (o[r] = a),
    (o[1 - r] = [NaN, NaN]),
    {
      values: a,
      xyMinMax: o,
    }
  )
}
var x3 = {
  lineX: Zt(S3, 0),
  lineY: Zt(S3, 1),
  rect: function (r, t, e) {
    return [
      [r[0][0] - e[0] * t[0][0], r[0][1] - e[0] * t[0][1]],
      [r[1][0] - e[1] * t[1][0], r[1][1] - e[1] * t[1][1]],
    ]
  },
  polygon: function (r, t, e) {
    return st(r, function (n, i) {
      return [n[0] - e[0] * t[i][0], n[1] - e[1] * t[i][1]]
    })
  },
}
function S3(r, t, e, n) {
  return [t[0] - n[r] * e[0], t[1] - n[r] * e[1]]
}
function a_t(r, t) {
  var e = A3(r),
    n = A3(t),
    i = [e[0] / n[0], e[1] / n[1]]
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i
}
function A3(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN]
}
const ME = r_t
var rM = R,
  o_t = Mtt('toolbox-dataZoom_'),
  s_t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this._brushController ||
          ((this._brushController = new aE(i.getZr())),
          this._brushController.on('brush', Tt(this._onBrush, this)).mount()),
          c_t(e, n, this, a, i),
          u_t(e, n)
      }),
      (t.prototype.onclick = function (e, n, i) {
        l_t[i].call(this)
      }),
      (t.prototype.remove = function (e, n) {
        this._brushController && this._brushController.unmount()
      }),
      (t.prototype.dispose = function (e, n) {
        this._brushController && this._brushController.dispose()
      }),
      (t.prototype._onBrush = function (e) {
        var n = e.areas
        if (!e.isEnd || !n.length) return
        var i = {},
          a = this.ecModel
        this._brushController.updateCovers([])
        var o = new ME(TE(this.model), a, {
          include: ['grid'],
        })
        o.matchOutputRanges(n, a, function (u, c, h) {
          if (h.type === 'cartesian2d') {
            var f = u.brushType
            f === 'rect'
              ? (s('x', h, c[0]), s('y', h, c[1]))
              : s(
                  {
                    lineX: 'x',
                    lineY: 'y',
                  }[f],
                  h,
                  c,
                )
          }
        }),
          K0t(a, i),
          this._dispatchZoomAction(i)
        function s(u, c, h) {
          var f = c.getAxis(u),
            d = f.model,
            p = l(u, d, a),
            g = p.findRepresentativeAxisProxy(d).getMinMaxSpan()
          ;(g.minValueSpan != null || g.maxValueSpan != null) &&
            (h = lc(
              0,
              h.slice(),
              f.scale.getExtent(),
              0,
              g.minValueSpan,
              g.maxValueSpan,
            )),
            p &&
              (i[p.id] = {
                dataZoomId: p.id,
                startValue: h[0],
                endValue: h[1],
              })
        }
        function l(u, c, h) {
          var f
          return (
            h.eachComponent(
              {
                mainType: 'dataZoom',
                subType: 'select',
              },
              function (d) {
                var p = d.getAxisModel(u, c.componentIndex)
                p && (f = d)
              },
            ),
            f
          )
        }
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var n = []
        rM(e, function (i, a) {
          n.push(Vt(i))
        }),
          n.length &&
            this.api.dispatchAction({
              type: 'dataZoom',
              from: this.uid,
              batch: n,
            })
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          filterMode: 'filter',
          icon: {
            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26',
          },
          title: e.getLocaleModel().get(['toolbox', 'dataZoom', 'title']),
          brushStyle: {
            borderWidth: 0,
            color: 'rgba(210,219,238,0.2)',
          },
        }
        return n
      }),
      t
    )
  })(Hi),
  l_t = {
    zoom: function () {
      var r = !this._isZoomActive
      this.api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'dataZoomSelect',
        dataZoomSelectActive: r,
      })
    },
    back: function () {
      this._dispatchZoomAction(j0t(this.ecModel))
    },
  }
function TE(r) {
  var t = {
    xAxisIndex: r.get('xAxisIndex', !0),
    yAxisIndex: r.get('yAxisIndex', !0),
    xAxisId: r.get('xAxisId', !0),
    yAxisId: r.get('yAxisId', !0),
  }
  return (
    t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = 'all'),
    t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = 'all'),
    t
  )
}
function u_t(r, t) {
  r.setIconStatus('back', Q0t(t) > 1 ? 'emphasis' : 'normal')
}
function c_t(r, t, e, n, i) {
  var a = e._isZoomActive
  n &&
    n.type === 'takeGlobalCursor' &&
    (a = n.key === 'dataZoomSelect' ? n.dataZoomSelectActive : !1),
    (e._isZoomActive = a),
    r.setIconStatus('zoom', a ? 'emphasis' : 'normal')
  var o = new ME(TE(r), t, {
      include: ['grid'],
    }),
    s = o.makePanelOpts(i, function (l) {
      return l.xAxisDeclared && !l.yAxisDeclared
        ? 'lineX'
        : !l.xAxisDeclared && l.yAxisDeclared
        ? 'lineY'
        : 'rect'
    })
  e._brushController.setPanels(s).enableBrush(
    a && s.length
      ? {
          brushType: 'auto',
          brushStyle: r.getModel('brushStyle').getItemStyle(),
        }
      : !1,
  )
}
srt('dataZoom', function (r) {
  var t = r.getComponent('toolbox', 0),
    e = ['feature', 'dataZoom']
  if (!t || t.get(e) == null) return
  var n = t.getModel(e),
    i = [],
    a = TE(n),
    o = ip(r, a)
  rM(o.xAxisModels, function (l) {
    return s(l, 'xAxis', 'xAxisIndex')
  }),
    rM(o.yAxisModels, function (l) {
      return s(l, 'yAxis', 'yAxisIndex')
    })
  function s(l, u, c) {
    var h = l.componentIndex,
      f = {
        type: 'select',
        $fromToolbox: !0,
        filterMode: n.get('filterMode', !0) || 'filter',
        id: o_t + u + h,
      }
    ;(f[c] = h), i.push(f)
  }
  return i
})
const h_t = s_t
function f_t(r) {
  r.registerComponentModel(D0t),
    r.registerComponentView(I0t),
    ch('saveAsImage', N0t),
    ch('magicType', F0t),
    ch('dataView', Z0t),
    ch('dataZoom', h_t),
    ch('restore', e_t),
    ie(C0t)
}
var d_t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'tooltip'),
    (t.dependencies = ['axisPointer']),
    (t.defaultOption = {
      z: 60,
      show: !0,
      showContent: !0,
      trigger: 'item',
      triggerOn: 'mousemove|click',
      alwaysShowContent: !1,
      displayMode: 'single',
      renderMode: 'auto',
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: '#fff',
      shadowBlur: 10,
      shadowColor: 'rgba(0, 0, 0, .2)',
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: '',
      axisPointer: {
        type: 'line',
        axis: 'auto',
        animation: 'auto',
        animationDurationUpdate: 200,
        animationEasingUpdate: 'exponentialOut',
        crossStyle: {
          color: '#999',
          width: 1,
          type: 'dashed',
          textStyle: {},
        },
      },
      textStyle: {
        color: '#666',
        fontSize: 14,
      },
    }),
    t
  )
})(xe)
const p_t = d_t
function RH(r) {
  var t = r.get('confine')
  return t != null ? !!t : r.get('renderMode') === 'richText'
}
function IH(r) {
  if (Se.domSupported) {
    for (
      var t = document.documentElement.style, e = 0, n = r.length;
      e < n;
      e++
    )
      if (r[e] in t) return r[e]
  }
}
var OH = IH([
    'transform',
    'webkitTransform',
    'OTransform',
    'MozTransform',
    'msTransform',
  ]),
  v_t = IH([
    'webkitTransition',
    'transition',
    'OTransition',
    'MozTransition',
    'msTransition',
  ])
function NH(r, t) {
  if (!r) return t
  t = r5(t, !0)
  var e = r.indexOf(t)
  return (r = e === -1 ? t : '-' + r.slice(0, e) + '-' + t), r.toLowerCase()
}
function g_t(r, t) {
  var e =
    r.currentStyle ||
    (document.defaultView && document.defaultView.getComputedStyle(r))
  return e ? (t ? e[t] : e) : null
}
var m_t = NH(v_t, 'transition'),
  CE = NH(OH, 'transform'),
  y_t =
    'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;' +
    (Se.transform3dSupported ? 'will-change:transform;' : '')
function __t(r) {
  return (
    (r =
      r === 'left'
        ? 'right'
        : r === 'right'
        ? 'left'
        : r === 'top'
        ? 'bottom'
        : 'top'),
    r
  )
}
function x_t(r, t, e) {
  if (!bt(e) || e === 'inside') return ''
  var n = r.get('backgroundColor'),
    i = r.get('borderWidth')
  t = Zu(t)
  var a = __t(e),
    o = Math.max(Math.round(i) * 1.5, 6),
    s = '',
    l = CE + ':',
    u
  re(['left', 'right'], a) > -1
    ? ((s += 'top:50%'),
      (l +=
        'translateY(-50%) rotate(' + (u = a === 'left' ? -225 : -45) + 'deg)'))
    : ((s += 'left:50%'),
      (l += 'translateX(-50%) rotate(' + (u = a === 'top' ? 225 : 45) + 'deg)'))
  var c = (u * Math.PI) / 180,
    h = o + i,
    f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)),
    d =
      Math.round(
        ((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100,
      ) / 100
  s += ';' + a + ':-' + d + 'px'
  var p = t + ' solid ' + i + 'px;',
    g = [
      'position:absolute;width:' + o + 'px;height:' + o + 'px;z-index:-1;',
      s + ';' + l + ';',
      'border-bottom:' + p,
      'border-right:' + p,
      'background-color:' + n + ';',
    ]
  return '<div style="' + g.join('') + '"></div>'
}
function S_t(r, t) {
  var e = 'cubic-bezier(0.23,1,0.32,1)',
    n = ' ' + r / 2 + 's ' + e,
    i = 'opacity' + n + ',visibility' + n
  return (
    t ||
      ((n = ' ' + r + 's ' + e),
      (i += Se.transformSupported ? ',' + CE + n : ',left' + n + ',top' + n)),
    m_t + ':' + i
  )
}
function b3(r, t, e) {
  var n = r.toFixed(0) + 'px',
    i = t.toFixed(0) + 'px'
  if (!Se.transformSupported)
    return e
      ? 'top:' + i + ';left:' + n + ';'
      : [
          ['top', i],
          ['left', n],
        ]
  var a = Se.transform3dSupported,
    o =
      'translate' + (a ? '3d' : '') + '(' + n + ',' + i + (a ? ',0' : '') + ')'
  return e
    ? 'top:0;left:0;' + CE + ':' + o + ';'
    : [
        ['top', 0],
        ['left', 0],
        [OH, o],
      ]
}
function A_t(r) {
  var t = [],
    e = r.get('fontSize'),
    n = r.getTextColor()
  n && t.push('color:' + n),
    t.push('font:' + r.getFont()),
    e && t.push('line-height:' + Math.round((e * 3) / 2) + 'px')
  var i = r.get('textShadowColor'),
    a = r.get('textShadowBlur') || 0,
    o = r.get('textShadowOffsetX') || 0,
    s = r.get('textShadowOffsetY') || 0
  return (
    i && a && t.push('text-shadow:' + o + 'px ' + s + 'px ' + a + 'px ' + i),
    R(['decoration', 'align'], function (l) {
      var u = r.get(l)
      u && t.push('text-' + l + ':' + u)
    }),
    t.join(';')
  )
}
function b_t(r, t, e) {
  var n = [],
    i = r.get('transitionDuration'),
    a = r.get('backgroundColor'),
    o = r.get('shadowBlur'),
    s = r.get('shadowColor'),
    l = r.get('shadowOffsetX'),
    u = r.get('shadowOffsetY'),
    c = r.getModel('textStyle'),
    h = z5(r, 'html'),
    f = l + 'px ' + u + 'px ' + o + 'px ' + s
  return (
    n.push('box-shadow:' + f),
    t && i && n.push(S_t(i, e)),
    a && n.push('background-color:' + a),
    R(['width', 'color', 'radius'], function (d) {
      var p = 'border-' + d,
        g = r5(p),
        v = r.get(g)
      v != null && n.push(p + ':' + v + (d === 'color' ? '' : 'px'))
    }),
    n.push(A_t(c)),
    h != null && n.push('padding:' + wf(h).join('px ') + 'px'),
    n.join(';') + ';'
  )
}
function w3(r, t, e, n, i) {
  var a = t && t.painter
  if (e) {
    var o = a && a.getViewportRoot()
    o && qJ(r, o, e, n, i)
  } else {
    ;(r[0] = n), (r[1] = i)
    var s = a && a.getViewportRootOffset()
    s && ((r[0] += s.offsetLeft), (r[1] += s.offsetTop))
  }
  ;(r[2] = r[0] / t.getWidth()), (r[3] = r[1] / t.getHeight())
}
var w_t = (function () {
  function r(t, e) {
    if (
      ((this._show = !1),
      (this._styleCoord = [0, 0, 0, 0]),
      (this._enterable = !0),
      (this._alwaysShowContent = !1),
      (this._firstShow = !0),
      (this._longHide = !0),
      Se.wxa)
    )
      return null
    var n = document.createElement('div')
    ;(n.domBelongToZr = !0), (this.el = n)
    var i = (this._zr = t.getZr()),
      a = e.appendTo,
      o =
        a &&
        (bt(a) ? document.querySelector(a) : tf(a) ? a : Nt(a) && a(t.getDom()))
    w3(this._styleCoord, i, o, t.getWidth() / 2, t.getHeight() / 2),
      (o || t.getDom()).appendChild(n),
      (this._api = t),
      (this._container = o)
    var s = this
    ;(n.onmouseenter = function () {
      s._enterable && (clearTimeout(s._hideTimeout), (s._show = !0)),
        (s._inContent = !0)
    }),
      (n.onmousemove = function (l) {
        if (((l = l || window.event), !s._enterable)) {
          var u = i.handler,
            c = i.painter.getViewportRoot()
          Fi(c, l, !0), u.dispatch('mousemove', l)
        }
      }),
      (n.onmouseleave = function () {
        ;(s._inContent = !1),
          s._enterable && s._show && s.hideLater(s._hideDelay)
      })
  }
  return (
    (r.prototype.update = function (t) {
      if (!this._container) {
        var e = this._api.getDom(),
          n = g_t(e, 'position'),
          i = e.style
        i.position !== 'absolute' &&
          n !== 'absolute' &&
          (i.position = 'relative')
      }
      var a = t.get('alwaysShowContent')
      a && this._moveIfResized(),
        (this._alwaysShowContent = a),
        (this.el.className = t.get('className') || '')
    }),
    (r.prototype.show = function (t, e) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout)
      var n = this.el,
        i = n.style,
        a = this._styleCoord
      n.innerHTML
        ? (i.cssText =
            y_t +
            b_t(t, !this._firstShow, this._longHide) +
            b3(a[0], a[1], !0) +
            ('border-color:' + Zu(e) + ';') +
            (t.get('extraCssText') || '') +
            (';pointer-events:' + (this._enterable ? 'auto' : 'none')))
        : (i.display = 'none'),
        (this._show = !0),
        (this._firstShow = !1),
        (this._longHide = !1)
    }),
    (r.prototype.setContent = function (t, e, n, i, a) {
      var o = this.el
      if (t == null) {
        o.innerHTML = ''
        return
      }
      var s = ''
      if (
        (bt(a) && n.get('trigger') === 'item' && !RH(n) && (s = x_t(n, i, a)),
        bt(t))
      )
        o.innerHTML = t + s
      else if (t) {
        ;(o.innerHTML = ''), at(t) || (t = [t])
        for (var l = 0; l < t.length; l++)
          tf(t[l]) && t[l].parentNode !== o && o.appendChild(t[l])
        if (s && o.childNodes.length) {
          var u = document.createElement('div')
          ;(u.innerHTML = s), o.appendChild(u)
        }
      }
    }),
    (r.prototype.setEnterable = function (t) {
      this._enterable = t
    }),
    (r.prototype.getSize = function () {
      var t = this.el
      return [t.offsetWidth, t.offsetHeight]
    }),
    (r.prototype.moveTo = function (t, e) {
      var n = this._styleCoord
      if (
        (w3(n, this._zr, this._container, t, e), n[0] != null && n[1] != null)
      ) {
        var i = this.el.style,
          a = b3(n[0], n[1])
        R(a, function (o) {
          i[o[0]] = o[1]
        })
      }
    }),
    (r.prototype._moveIfResized = function () {
      var t = this._styleCoord[2],
        e = this._styleCoord[3]
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
    }),
    (r.prototype.hide = function () {
      var t = this,
        e = this.el.style
      ;(e.visibility = 'hidden'),
        (e.opacity = '0'),
        Se.transform3dSupported && (e.willChange = ''),
        (this._show = !1),
        (this._longHideTimeout = setTimeout(function () {
          return (t._longHide = !0)
        }, 500))
    }),
    (r.prototype.hideLater = function (t) {
      this._show &&
        !(this._inContent && this._enterable) &&
        !this._alwaysShowContent &&
        (t
          ? ((this._hideDelay = t),
            (this._show = !1),
            (this._hideTimeout = setTimeout(Tt(this.hide, this), t)))
          : this.hide())
    }),
    (r.prototype.isShow = function () {
      return this._show
    }),
    (r.prototype.dispose = function () {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout)
      var t = this.el.parentNode
      t && t.removeChild(this.el), (this.el = this._container = null)
    }),
    r
  )
})()
const M_t = w_t
var T_t = (function () {
  function r(t) {
    ;(this._show = !1),
      (this._styleCoord = [0, 0, 0, 0]),
      (this._alwaysShowContent = !1),
      (this._enterable = !0),
      (this._zr = t.getZr()),
      T3(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2)
  }
  return (
    (r.prototype.update = function (t) {
      var e = t.get('alwaysShowContent')
      e && this._moveIfResized(), (this._alwaysShowContent = e)
    }),
    (r.prototype.show = function () {
      this._hideTimeout && clearTimeout(this._hideTimeout),
        this.el.show(),
        (this._show = !0)
    }),
    (r.prototype.setContent = function (t, e, n, i, a) {
      var o = this
      Ut(t) && Ce(''), this.el && this._zr.remove(this.el)
      var s = n.getModel('textStyle')
      ;(this.el = new Ae({
        style: {
          rich: e.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get('textShadowColor'),
          fill: n.get(['textStyle', 'color']),
          padding: z5(n, 'richText'),
          verticalAlign: 'top',
          align: 'left',
        },
        z: n.get('z'),
      })),
        R(
          [
            'backgroundColor',
            'borderRadius',
            'shadowColor',
            'shadowBlur',
            'shadowOffsetX',
            'shadowOffsetY',
          ],
          function (u) {
            o.el.style[u] = n.get(u)
          },
        ),
        R(
          ['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'],
          function (u) {
            o.el.style[u] = s.get(u) || 0
          },
        ),
        this._zr.add(this.el)
      var l = this
      this.el.on('mouseover', function () {
        l._enterable && (clearTimeout(l._hideTimeout), (l._show = !0)),
          (l._inContent = !0)
      }),
        this.el.on('mouseout', function () {
          l._enterable && l._show && l.hideLater(l._hideDelay),
            (l._inContent = !1)
        })
    }),
    (r.prototype.setEnterable = function (t) {
      this._enterable = t
    }),
    (r.prototype.getSize = function () {
      var t = this.el,
        e = this.el.getBoundingRect(),
        n = M3(t.style)
      return [e.width + n.left + n.right, e.height + n.top + n.bottom]
    }),
    (r.prototype.moveTo = function (t, e) {
      var n = this.el
      if (n) {
        var i = this._styleCoord
        T3(i, this._zr, t, e), (t = i[0]), (e = i[1])
        var a = n.style,
          o = Ts(a.borderWidth || 0),
          s = M3(a)
        ;(n.x = t + o + s.left), (n.y = e + o + s.top), n.markRedraw()
      }
    }),
    (r.prototype._moveIfResized = function () {
      var t = this._styleCoord[2],
        e = this._styleCoord[3]
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
    }),
    (r.prototype.hide = function () {
      this.el && this.el.hide(), (this._show = !1)
    }),
    (r.prototype.hideLater = function (t) {
      this._show &&
        !(this._inContent && this._enterable) &&
        !this._alwaysShowContent &&
        (t
          ? ((this._hideDelay = t),
            (this._show = !1),
            (this._hideTimeout = setTimeout(Tt(this.hide, this), t)))
          : this.hide())
    }),
    (r.prototype.isShow = function () {
      return this._show
    }),
    (r.prototype.dispose = function () {
      this._zr.remove(this.el)
    }),
    r
  )
})()
function Ts(r) {
  return Math.max(0, r)
}
function M3(r) {
  var t = Ts(r.shadowBlur || 0),
    e = Ts(r.shadowOffsetX || 0),
    n = Ts(r.shadowOffsetY || 0)
  return {
    left: Ts(t - e),
    right: Ts(t + e),
    top: Ts(t - n),
    bottom: Ts(t + n),
  }
}
function T3(r, t, e, n) {
  ;(r[0] = e),
    (r[1] = n),
    (r[2] = r[0] / t.getWidth()),
    (r[3] = r[1] / t.getHeight())
}
const C_t = T_t
var E_t = new ge({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2,
    },
  }),
  D_t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        if (!(Se.node || !n.getDom())) {
          var i = e.getComponent('tooltip'),
            a = (this._renderMode = Rtt(i.get('renderMode')))
          this._tooltipContent =
            a === 'richText'
              ? new C_t(n)
              : new M_t(n, {
                  appendTo: i.get('appendToBody', !0)
                    ? 'body'
                    : i.get('appendTo', !0),
                })
        }
      }),
      (t.prototype.render = function (e, n, i) {
        if (!(Se.node || !i.getDom())) {
          this.group.removeAll(),
            (this._tooltipModel = e),
            (this._ecModel = n),
            (this._api = i)
          var a = this._tooltipContent
          a.update(e),
            a.setEnterable(e.get('enterable')),
            this._initGlobalListener(),
            this._keepShow(),
            this._renderMode !== 'richText' && e.get('transitionDuration')
              ? Df(this, '_updatePosition', 50, 'fixRate')
              : Zp(this, '_updatePosition')
        }
      }),
      (t.prototype._initGlobalListener = function () {
        var e = this._tooltipModel,
          n = e.get('triggerOn')
        yH(
          'itemTooltip',
          this._api,
          Tt(function (i, a, o) {
            n !== 'none' &&
              (n.indexOf(i) >= 0
                ? this._tryShow(a, o)
                : i === 'leave' && this._hide(o))
          }, this),
        )
      }),
      (t.prototype._keepShow = function () {
        var e = this._tooltipModel,
          n = this._ecModel,
          i = this._api,
          a = e.get('triggerOn')
        if (
          this._lastX != null &&
          this._lastY != null &&
          a !== 'none' &&
          a !== 'click'
        ) {
          var o = this
          clearTimeout(this._refreshUpdateTimeout),
            (this._refreshUpdateTimeout = setTimeout(function () {
              !i.isDisposed() &&
                o.manuallyShowTip(e, n, i, {
                  x: o._lastX,
                  y: o._lastY,
                  dataByCoordSys: o._lastDataByCoordSys,
                })
            }))
        }
      }),
      (t.prototype.manuallyShowTip = function (e, n, i, a) {
        if (!(a.from === this.uid || Se.node || !i.getDom())) {
          var o = C3(a, i)
          this._ticket = ''
          var s = a.dataByCoordSys,
            l = I_t(a, n, i)
          if (l) {
            var u = l.el.getBoundingRect().clone()
            u.applyTransform(l.el.transform),
              this._tryShow(
                {
                  offsetX: u.x + u.width / 2,
                  offsetY: u.y + u.height / 2,
                  target: l.el,
                  position: a.position,
                  positionDefault: 'bottom',
                },
                o,
              )
          } else if (a.tooltip && a.x != null && a.y != null) {
            var c = E_t
            ;(c.x = a.x),
              (c.y = a.y),
              c.update(),
              (Wt(c).tooltipConfig = {
                name: null,
                option: a.tooltip,
              }),
              this._tryShow(
                {
                  offsetX: a.x,
                  offsetY: a.y,
                  target: c,
                },
                o,
              )
          } else if (s)
            this._tryShow(
              {
                offsetX: a.x,
                offsetY: a.y,
                position: a.position,
                dataByCoordSys: s,
                tooltipOption: a.tooltipOption,
              },
              o,
            )
          else if (a.seriesIndex != null) {
            if (this._manuallyAxisShowTip(e, n, i, a)) return
            var h = _H(a, n),
              f = h.point[0],
              d = h.point[1]
            f != null &&
              d != null &&
              this._tryShow(
                {
                  offsetX: f,
                  offsetY: d,
                  target: h.el,
                  position: a.position,
                  positionDefault: 'bottom',
                },
                o,
              )
          } else
            a.x != null &&
              a.y != null &&
              (i.dispatchAction({
                type: 'updateAxisPointer',
                x: a.x,
                y: a.y,
              }),
              this._tryShow(
                {
                  offsetX: a.x,
                  offsetY: a.y,
                  position: a.position,
                  target: i.getZr().findHover(a.x, a.y).target,
                },
                o,
              ))
        }
      }),
      (t.prototype.manuallyHideTip = function (e, n, i, a) {
        var o = this._tooltipContent
        this._tooltipModel && o.hideLater(this._tooltipModel.get('hideDelay')),
          (this._lastX = this._lastY = this._lastDataByCoordSys = null),
          a.from !== this.uid && this._hide(C3(a, i))
      }),
      (t.prototype._manuallyAxisShowTip = function (e, n, i, a) {
        var o = a.seriesIndex,
          s = a.dataIndex,
          l = n.getComponent('axisPointer').coordSysAxesInfo
        if (!(o == null || s == null || l == null)) {
          var u = n.getSeriesByIndex(o)
          if (u) {
            var c = u.getData(),
              h = _d(
                [c.getItemModel(s), u, (u.coordinateSystem || {}).model],
                this._tooltipModel,
              )
            if (h.get('trigger') === 'axis')
              return (
                i.dispatchAction({
                  type: 'updateAxisPointer',
                  seriesIndex: o,
                  dataIndex: s,
                  position: a.position,
                }),
                !0
              )
          }
        }
      }),
      (t.prototype._tryShow = function (e, n) {
        var i = e.target,
          a = this._tooltipModel
        if (a) {
          ;(this._lastX = e.offsetX), (this._lastY = e.offsetY)
          var o = e.dataByCoordSys
          if (o && o.length) this._showAxisTooltip(o, e)
          else if (i) {
            var s = Wt(i)
            if (s.ssrType === 'legend') return
            this._lastDataByCoordSys = null
            var l, u
            xu(
              i,
              function (c) {
                if (Wt(c).dataIndex != null) return (l = c), !0
                if (Wt(c).tooltipConfig != null) return (u = c), !0
              },
              !0,
            ),
              l
                ? this._showSeriesItemTooltip(e, l, n)
                : u
                ? this._showComponentItemTooltip(e, u, n)
                : this._hide(n)
          } else (this._lastDataByCoordSys = null), this._hide(n)
        }
      }),
      (t.prototype._showOrMove = function (e, n) {
        var i = e.get('showDelay')
        ;(n = Tt(n, this)),
          clearTimeout(this._showTimout),
          i > 0 ? (this._showTimout = setTimeout(n, i)) : n()
      }),
      (t.prototype._showAxisTooltip = function (e, n) {
        var i = this._ecModel,
          a = this._tooltipModel,
          o = [n.offsetX, n.offsetY],
          s = _d([n.tooltipOption], a),
          l = this._renderMode,
          u = [],
          c = Kn('section', {
            blocks: [],
            noHeader: !0,
          }),
          h = [],
          f = new I1()
        R(e, function (y) {
          R(y.dataByAxis, function (_) {
            var x = i.getComponent(_.axisDim + 'Axis', _.axisIndex),
              A = _.value
            if (!(!x || A == null)) {
              var S = vH(A, x.axis, i, _.seriesDataIndices, _.valueLabelOpt),
                b = Kn('section', {
                  header: S,
                  noHeader: !xa(S),
                  sortBlocks: !0,
                  blocks: [],
                })
              c.blocks.push(b),
                R(_.seriesDataIndices, function (T) {
                  var w = i.getSeriesByIndex(T.seriesIndex),
                    M = T.dataIndexInside,
                    C = w.getDataParams(M)
                  if (!(C.dataIndex < 0)) {
                    ;(C.axisDim = _.axisDim),
                      (C.axisIndex = _.axisIndex),
                      (C.axisType = _.axisType),
                      (C.axisId = _.axisId),
                      (C.axisValue = EC(x.axis, {
                        value: A,
                      })),
                      (C.axisValueLabel = S),
                      (C.marker = f.makeTooltipMarker('item', Zu(C.color), l))
                    var E = hR(w.formatTooltip(M, !0, null)),
                      D = E.frag
                    if (D) {
                      var P = _d([w], a).get('valueFormatter')
                      b.blocks.push(
                        P
                          ? Q(
                              {
                                valueFormatter: P,
                              },
                              D,
                            )
                          : D,
                      )
                    }
                    E.text && h.push(E.text), u.push(C)
                  }
                })
            }
          })
        }),
          c.blocks.reverse(),
          h.reverse()
        var d = n.position,
          p = s.get('order'),
          g = mR(c, f, l, p, i.get('useUTC'), s.get('textStyle'))
        g && h.unshift(g)
        var v =
            l === 'richText'
              ? `

`
              : '<br/>',
          m = h.join(v)
        this._showOrMove(s, function () {
          this._updateContentNotChangedOnAxis(e, u)
            ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u)
            : this._showTooltipContent(
                s,
                m,
                u,
                Math.random() + '',
                o[0],
                o[1],
                d,
                null,
                f,
              )
        })
      }),
      (t.prototype._showSeriesItemTooltip = function (e, n, i) {
        var a = this._ecModel,
          o = Wt(n),
          s = o.seriesIndex,
          l = a.getSeriesByIndex(s),
          u = o.dataModel || l,
          c = o.dataIndex,
          h = o.dataType,
          f = u.getData(h),
          d = this._renderMode,
          p = e.positionDefault,
          g = _d(
            [f.getItemModel(c), u, l && (l.coordinateSystem || {}).model],
            this._tooltipModel,
            p
              ? {
                  position: p,
                }
              : null,
          ),
          v = g.get('trigger')
        if (!(v != null && v !== 'item')) {
          var m = u.getDataParams(c, h),
            y = new I1()
          m.marker = y.makeTooltipMarker('item', Zu(m.color), d)
          var _ = hR(u.formatTooltip(c, !1, h)),
            x = g.get('order'),
            A = g.get('valueFormatter'),
            S = _.frag,
            b = S
              ? mR(
                  A
                    ? Q(
                        {
                          valueFormatter: A,
                        },
                        S,
                      )
                    : S,
                  y,
                  d,
                  x,
                  a.get('useUTC'),
                  g.get('textStyle'),
                )
              : _.text,
            T = 'item_' + u.name + '_' + c
          this._showOrMove(g, function () {
            this._showTooltipContent(
              g,
              b,
              m,
              T,
              e.offsetX,
              e.offsetY,
              e.position,
              e.target,
              y,
            )
          }),
            i({
              type: 'showTip',
              dataIndexInside: c,
              dataIndex: f.getRawIndex(c),
              seriesIndex: s,
              from: this.uid,
            })
        }
      }),
      (t.prototype._showComponentItemTooltip = function (e, n, i) {
        var a = this._renderMode === 'html',
          o = Wt(n),
          s = o.tooltipConfig,
          l = s.option || {},
          u = l.encodeHTMLContent
        if (bt(l)) {
          var c = l
          ;(l = {
            content: c,
            formatter: c,
          }),
            (u = !0)
        }
        u && a && l.content && ((l = Vt(l)), (l.content = Fr(l.content)))
        var h = [l],
          f = this._ecModel.getComponent(o.componentMainType, o.componentIndex)
        f && h.push(f),
          h.push({
            formatter: l.content,
          })
        var d = e.positionDefault,
          p = _d(
            h,
            this._tooltipModel,
            d
              ? {
                  position: d,
                }
              : null,
          ),
          g = p.get('content'),
          v = Math.random() + '',
          m = new I1()
        this._showOrMove(p, function () {
          var y = Vt(p.get('formatterParams') || {})
          this._showTooltipContent(
            p,
            g,
            y,
            v,
            e.offsetX,
            e.offsetY,
            e.position,
            n,
            m,
          )
        }),
          i({
            type: 'showTip',
            from: this.uid,
          })
      }),
      (t.prototype._showTooltipContent = function (e, n, i, a, o, s, l, u, c) {
        if (((this._ticket = ''), !(!e.get('showContent') || !e.get('show')))) {
          var h = this._tooltipContent
          h.setEnterable(e.get('enterable'))
          var f = e.get('formatter')
          l = l || e.get('position')
          var d = n,
            p = this._getNearestPoint(
              [o, s],
              i,
              e.get('trigger'),
              e.get('borderColor'),
            ),
            g = p.color
          if (f)
            if (bt(f)) {
              var v = e.ecModel.get('useUTC'),
                m = at(i) ? i[0] : i,
                y = m && m.axisType && m.axisType.indexOf('time') >= 0
              ;(d = f), y && (d = u_(m.axisValue, d, v)), (d = i5(d, i, !0))
            } else if (Nt(f)) {
              var _ = Tt(function (x, A) {
                x === this._ticket &&
                  (h.setContent(A, c, e, g, l),
                  this._updatePosition(e, l, o, s, h, i, u))
              }, this)
              ;(this._ticket = a), (d = f(i, a, _))
            } else d = f
          h.setContent(d, c, e, g, l),
            h.show(e, g),
            this._updatePosition(e, l, o, s, h, i, u)
        }
      }),
      (t.prototype._getNearestPoint = function (e, n, i, a) {
        if (i === 'axis' || at(n))
          return {
            color: a || (this._renderMode === 'html' ? '#fff' : 'none'),
          }
        if (!at(n))
          return {
            color: a || n.color || n.borderColor,
          }
      }),
      (t.prototype._updatePosition = function (e, n, i, a, o, s, l) {
        var u = this._api.getWidth(),
          c = this._api.getHeight()
        n = n || e.get('position')
        var h = o.getSize(),
          f = e.get('align'),
          d = e.get('verticalAlign'),
          p = l && l.getBoundingRect().clone()
        if (
          (l && p.applyTransform(l.transform),
          Nt(n) &&
            (n = n([i, a], s, o.el, p, {
              viewSize: [u, c],
              contentSize: h.slice(),
            })),
          at(n))
        )
          (i = _t(n[0], u)), (a = _t(n[1], c))
        else if (Ut(n)) {
          var g = n
          ;(g.width = h[0]), (g.height = h[1])
          var v = Vn(g, {
            width: u,
            height: c,
          })
          ;(i = v.x), (a = v.y), (f = null), (d = null)
        } else if (bt(n) && l) {
          var m = R_t(n, p, h, e.get('borderWidth'))
          ;(i = m[0]), (a = m[1])
        } else {
          var m = L_t(i, a, o, u, c, f ? null : 20, d ? null : 20)
          ;(i = m[0]), (a = m[1])
        }
        if (
          (f && (i -= E3(f) ? h[0] / 2 : f === 'right' ? h[0] : 0),
          d && (a -= E3(d) ? h[1] / 2 : d === 'bottom' ? h[1] : 0),
          RH(e))
        ) {
          var m = P_t(i, a, o, u, c)
          ;(i = m[0]), (a = m[1])
        }
        o.moveTo(i, a)
      }),
      (t.prototype._updateContentNotChangedOnAxis = function (e, n) {
        var i = this._lastDataByCoordSys,
          a = this._cbParamsList,
          o = !!i && i.length === e.length
        return (
          o &&
            R(i, function (s, l) {
              var u = s.dataByAxis || [],
                c = e[l] || {},
                h = c.dataByAxis || []
              ;(o = o && u.length === h.length),
                o &&
                  R(u, function (f, d) {
                    var p = h[d] || {},
                      g = f.seriesDataIndices || [],
                      v = p.seriesDataIndices || []
                    ;(o =
                      o &&
                      f.value === p.value &&
                      f.axisType === p.axisType &&
                      f.axisId === p.axisId &&
                      g.length === v.length),
                      o &&
                        R(g, function (m, y) {
                          var _ = v[y]
                          o =
                            o &&
                            m.seriesIndex === _.seriesIndex &&
                            m.dataIndex === _.dataIndex
                        }),
                      a &&
                        R(f.seriesDataIndices, function (m) {
                          var y = m.seriesIndex,
                            _ = n[y],
                            x = a[y]
                          _ && x && x.data !== _.data && (o = !1)
                        })
                  })
            }),
          (this._lastDataByCoordSys = e),
          (this._cbParamsList = n),
          !!o
        )
      }),
      (t.prototype._hide = function (e) {
        ;(this._lastDataByCoordSys = null),
          e({
            type: 'hideTip',
            from: this.uid,
          })
      }),
      (t.prototype.dispose = function (e, n) {
        Se.node ||
          !n.getDom() ||
          (Zp(this, '_updatePosition'),
          this._tooltipContent.dispose(),
          Jw('itemTooltip', n))
      }),
      (t.type = 'tooltip'),
      t
    )
  })(dn)
function _d(r, t, e) {
  var n = t.ecModel,
    i
  e ? ((i = new qe(e, n, n)), (i = new qe(t.option, i, n))) : (i = t)
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a]
    o &&
      (o instanceof qe && (o = o.get('tooltip', !0)),
      bt(o) &&
        (o = {
          formatter: o,
        }),
      o && (i = new qe(o, i, n)))
  }
  return i
}
function C3(r, t) {
  return r.dispatchAction || Tt(t.dispatchAction, t)
}
function L_t(r, t, e, n, i, a, o) {
  var s = e.getSize(),
    l = s[0],
    u = s[1]
  return (
    a != null && (r + l + a + 2 > n ? (r -= l + a) : (r += a)),
    o != null && (t + u + o > i ? (t -= u + o) : (t += o)),
    [r, t]
  )
}
function P_t(r, t, e, n, i) {
  var a = e.getSize(),
    o = a[0],
    s = a[1]
  return (
    (r = Math.min(r + o, n) - o),
    (t = Math.min(t + s, i) - s),
    (r = Math.max(r, 0)),
    (t = Math.max(t, 0)),
    [r, t]
  )
}
function R_t(r, t, e, n) {
  var i = e[0],
    a = e[1],
    o = Math.ceil(Math.SQRT2 * n) + 8,
    s = 0,
    l = 0,
    u = t.width,
    c = t.height
  switch (r) {
    case 'inside':
      ;(s = t.x + u / 2 - i / 2), (l = t.y + c / 2 - a / 2)
      break
    case 'top':
      ;(s = t.x + u / 2 - i / 2), (l = t.y - a - o)
      break
    case 'bottom':
      ;(s = t.x + u / 2 - i / 2), (l = t.y + c + o)
      break
    case 'left':
      ;(s = t.x - i - o), (l = t.y + c / 2 - a / 2)
      break
    case 'right':
      ;(s = t.x + u + o), (l = t.y + c / 2 - a / 2)
  }
  return [s, l]
}
function E3(r) {
  return r === 'center' || r === 'middle'
}
function I_t(r, t, e) {
  var n = UT(r).queryOptionMap,
    i = n.keys()[0]
  if (!(!i || i === 'series')) {
    var a = yv(t, i, n.get(i), {
        useDefault: !1,
        enableAll: !1,
        enableNone: !1,
      }),
      o = a.models[0]
    if (o) {
      var s = e.getViewOfComponentModel(o),
        l
      if (
        (s.group.traverse(function (u) {
          var c = Wt(u).tooltipConfig
          if (c && c.name === r.name) return (l = u), !0
        }),
        l)
      )
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l,
        }
    }
  }
}
const O_t = D_t
function N_t(r) {
  ie(Ov),
    r.registerComponentModel(p_t),
    r.registerComponentView(O_t),
    r.registerAction(
      {
        type: 'showTip',
        event: 'showTip',
        update: 'tooltip:manuallyShowTip',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'hideTip',
        event: 'hideTip',
        update: 'tooltip:manuallyHideTip',
      },
      wn,
    )
}
var k_t = ['rect', 'polygon', 'keep', 'clear']
function B_t(r, t) {
  var e = ke(r ? r.brush : [])
  if (e.length) {
    var n = []
    R(e, function (l) {
      var u = l.hasOwnProperty('toolbox') ? l.toolbox : []
      u instanceof Array && (n = n.concat(u))
    })
    var i = r && r.toolbox
    at(i) && (i = i[0]),
      i ||
        ((i = {
          feature: {},
        }),
        (r.toolbox = [i]))
    var a = i.feature || (i.feature = {}),
      o = a.brush || (a.brush = {}),
      s = o.type || (o.type = [])
    s.push.apply(s, n), F_t(s), t && !s.length && s.push.apply(s, k_t)
  }
}
function F_t(r) {
  var t = {}
  R(r, function (e) {
    t[e] = 1
  }),
    (r.length = 0),
    R(t, function (e, n) {
      r.push(n)
    })
}
var D3 = R
function L3(r) {
  if (r) {
    for (var t in r) if (r.hasOwnProperty(t)) return !0
  }
}
function iM(r, t, e) {
  var n = {}
  return (
    D3(t, function (a) {
      var o = (n[a] = i())
      D3(r[a], function (s, l) {
        if (vr.isValidType(l)) {
          var u = {
            type: l,
            visual: s,
          }
          e && e(u, a),
            (o[l] = new vr(u)),
            l === 'opacity' &&
              ((u = Vt(u)),
              (u.type = 'colorAlpha'),
              (o.__hidden.__alphaForOpacity = new vr(u)))
        }
      })
    }),
    n
  )
  function i() {
    var a = function () {}
    a.prototype.__hidden = a.prototype
    var o = new a()
    return o
  }
}
function kH(r, t, e) {
  var n
  R(e, function (i) {
    t.hasOwnProperty(i) && L3(t[i]) && (n = !0)
  }),
    n &&
      R(e, function (i) {
        t.hasOwnProperty(i) && L3(t[i]) ? (r[i] = Vt(t[i])) : delete r[i]
      })
}
function z_t(r, t, e, n, i, a) {
  var o = {}
  R(r, function (h) {
    var f = vr.prepareVisualTypes(t[h])
    o[h] = f
  })
  var s
  function l(h) {
    return mC(e, s, h)
  }
  function u(h, f) {
    Z5(e, s, h, f)
  }
  a == null ? e.each(c) : e.each([a], c)
  function c(h, f) {
    s = a == null ? h : f
    var d = e.getRawDataItem(s)
    if (!(d && d.visualMap === !1))
      for (
        var p = n.call(i, h), g = t[p], v = o[p], m = 0, y = v.length;
        m < y;
        m++
      ) {
        var _ = v[m]
        g[_] && g[_].applyVisual(h, l, u)
      }
  }
}
function U_t(r, t, e, n) {
  var i = {}
  return (
    R(r, function (a) {
      var o = vr.prepareVisualTypes(t[a])
      i[a] = o
    }),
    {
      progress: function (o, s) {
        var l
        n != null && (l = s.getDimensionIndex(n))
        function u(A) {
          return mC(s, h, A)
        }
        function c(A, S) {
          Z5(s, h, A, S)
        }
        for (var h, f = s.getStore(); (h = o.next()) != null; ) {
          var d = s.getRawDataItem(h)
          if (!(d && d.visualMap === !1))
            for (
              var p = n != null ? f.get(l, h) : h,
                g = e(p),
                v = t[g],
                m = i[g],
                y = 0,
                _ = m.length;
              y < _;
              y++
            ) {
              var x = m[y]
              v[x] && v[x].applyVisual(p, u, c)
            }
        }
      },
    }
  )
}
function V_t(r) {
  var t = r.brushType,
    e = {
      point: function (n) {
        return P3[t].point(n, e, r)
      },
      rect: function (n) {
        return P3[t].rect(n, e, r)
      },
    }
  return e
}
var P3 = {
  lineX: R3(0),
  lineY: R3(1),
  rect: {
    point: function (r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1])
    },
    rect: function (r, t, e) {
      return r && e.boundingRect.intersect(r)
    },
  },
  polygon: {
    point: function (r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]) && hu(e.range, r[0], r[1])
    },
    rect: function (r, t, e) {
      var n = e.range
      if (!r || n.length <= 1) return !1
      var i = r.x,
        a = r.y,
        o = r.width,
        s = r.height,
        l = n[0]
      if (
        hu(n, i, a) ||
        hu(n, i + o, a) ||
        hu(n, i, a + s) ||
        hu(n, i + o, a + s) ||
        ee.create(r).contain(l[0], l[1]) ||
        Fd(i, a, i + o, a, n) ||
        Fd(i, a, i, a + s, n) ||
        Fd(i + o, a, i + o, a + s, n) ||
        Fd(i, a + s, i + o, a + s, n)
      )
        return !0
    },
  },
}
function R3(r) {
  var t = ['x', 'y'],
    e = ['width', 'height']
  return {
    point: function (n, i, a) {
      if (n) {
        var o = a.range,
          s = n[r]
        return xd(s, o)
      }
    },
    rect: function (n, i, a) {
      if (n) {
        var o = a.range,
          s = [n[t[r]], n[t[r]] + n[e[r]]]
        return (
          s[1] < s[0] && s.reverse(),
          xd(s[0], o) || xd(s[1], o) || xd(o[0], s) || xd(o[1], s)
        )
      }
    },
  }
}
function xd(r, t) {
  return t[0] <= r && r <= t[1]
}
var I3 = ['inBrush', 'outOfBrush'],
  KS = '__ecBrushSelect',
  aM = '__ecInBrushSelectEvent'
function BH(r) {
  r.eachComponent(
    {
      mainType: 'brush',
    },
    function (t) {
      var e = (t.brushTargetManager = new ME(t.option, r))
      e.setInputRanges(t.areas, r)
    },
  )
}
function G_t(r, t, e) {
  var n = [],
    i,
    a
  r.eachComponent(
    {
      mainType: 'brush',
    },
    function (o) {
      e &&
        e.type === 'takeGlobalCursor' &&
        o.setBrushOption(
          e.key === 'brush'
            ? e.brushOption
            : {
                brushType: !1,
              },
        )
    },
  ),
    BH(r),
    r.eachComponent(
      {
        mainType: 'brush',
      },
      function (o, s) {
        var l = {
          brushId: o.id,
          brushIndex: s,
          brushName: o.name,
          areas: Vt(o.areas),
          selected: [],
        }
        n.push(l)
        var u = o.option,
          c = u.brushLink,
          h = [],
          f = [],
          d = [],
          p = !1
        s || ((i = u.throttleType), (a = u.throttleDelay))
        var g = st(o.areas, function (A) {
            var S = Y_t[A.brushType],
              b = zt(
                {
                  boundingRect: S ? S(A) : void 0,
                },
                A,
              )
            return (b.selectors = V_t(b)), b
          }),
          v = iM(o.option, I3, function (A) {
            A.mappingMethod = 'fixed'
          })
        at(c) &&
          R(c, function (A) {
            h[A] = 1
          })
        function m(A) {
          return c === 'all' || !!h[A]
        }
        function y(A) {
          return !!A.length
        }
        r.eachSeries(function (A, S) {
          var b = (d[S] = [])
          A.subType === 'parallel' ? _(A, S) : x(A, S, b)
        })
        function _(A, S) {
          var b = A.coordinateSystem
          ;(p = p || b.hasAxisBrushed()),
            m(S) &&
              b.eachActiveState(A.getData(), function (T, w) {
                T === 'active' && (f[w] = 1)
              })
        }
        function x(A, S, b) {
          if (
            !(!A.brushSelector || X_t(o, S)) &&
            (R(g, function (w) {
              o.brushTargetManager.controlSeries(w, A, r) && b.push(w),
                (p = p || y(b))
            }),
            m(S) && y(b))
          ) {
            var T = A.getData()
            T.each(function (w) {
              O3(A, b, T, w) && (f[w] = 1)
            })
          }
        }
        r.eachSeries(function (A, S) {
          var b = {
            seriesId: A.id,
            seriesIndex: S,
            seriesName: A.name,
            dataIndex: [],
          }
          l.selected.push(b)
          var T = d[S],
            w = A.getData(),
            M = m(S)
              ? function (C) {
                  return f[C]
                    ? (b.dataIndex.push(w.getRawIndex(C)), 'inBrush')
                    : 'outOfBrush'
                }
              : function (C) {
                  return O3(A, T, w, C)
                    ? (b.dataIndex.push(w.getRawIndex(C)), 'inBrush')
                    : 'outOfBrush'
                }
          ;(m(S) ? p : y(T)) && z_t(I3, v, w, M)
        })
      },
    ),
    H_t(t, i, a, n, e)
}
function H_t(r, t, e, n, i) {
  if (i) {
    var a = r.getZr()
    if (!a[aM]) {
      a[KS] || (a[KS] = W_t)
      var o = Df(a, KS, e, t)
      o(r, n)
    }
  }
}
function W_t(r, t) {
  if (!r.isDisposed()) {
    var e = r.getZr()
    ;(e[aM] = !0),
      r.dispatchAction({
        type: 'brushSelect',
        batch: t,
      }),
      (e[aM] = !1)
  }
}
function O3(r, t, e, n) {
  for (var i = 0, a = t.length; i < a; i++) {
    var o = t[i]
    if (r.brushSelector(n, e, o.selectors, o)) return !0
  }
}
function X_t(r, t) {
  var e = r.option.seriesIndex
  return e != null && e !== 'all' && (at(e) ? re(e, t) < 0 : t !== e)
}
var Y_t = {
  rect: function (r) {
    return N3(r.range)
  },
  polygon: function (r) {
    for (var t, e = r.range, n = 0, i = e.length; n < i; n++) {
      t = t || [
        [1 / 0, -1 / 0],
        [1 / 0, -1 / 0],
      ]
      var a = e[n]
      a[0] < t[0][0] && (t[0][0] = a[0]),
        a[0] > t[0][1] && (t[0][1] = a[0]),
        a[1] < t[1][0] && (t[1][0] = a[1]),
        a[1] > t[1][1] && (t[1][1] = a[1])
    }
    return t && N3(t)
  },
}
function N3(r) {
  return new ee(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0])
}
var $_t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n) {
      ;(this.ecModel = e),
        (this.api = n),
        this.model,
        (this._brushController = new aE(n.getZr()))
          .on('brush', Tt(this._onBrush, this))
          .mount()
    }),
    (t.prototype.render = function (e, n, i, a) {
      ;(this.model = e), this._updateController(e, n, i, a)
    }),
    (t.prototype.updateTransform = function (e, n, i, a) {
      BH(n), this._updateController(e, n, i, a)
    }),
    (t.prototype.updateVisual = function (e, n, i, a) {
      this.updateTransform(e, n, i, a)
    }),
    (t.prototype.updateView = function (e, n, i, a) {
      this._updateController(e, n, i, a)
    }),
    (t.prototype._updateController = function (e, n, i, a) {
      ;(!a || a.$from !== e.id) &&
        this._brushController
          .setPanels(e.brushTargetManager.makePanelOpts(i))
          .enableBrush(e.brushOption)
          .updateCovers(e.areas.slice())
    }),
    (t.prototype.dispose = function () {
      this._brushController.dispose()
    }),
    (t.prototype._onBrush = function (e) {
      var n = this.model.id,
        i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel)
      ;(!e.isEnd || e.removeOnClick) &&
        this.api.dispatchAction({
          type: 'brush',
          brushId: n,
          areas: Vt(i),
          $from: n,
        }),
        e.isEnd &&
          this.api.dispatchAction({
            type: 'brushEnd',
            brushId: n,
            areas: Vt(i),
            $from: n,
          })
    }),
    (t.type = 'brush'),
    t
  )
})(dn)
const q_t = $_t
var Z_t = '#ddd',
  K_t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.areas = []), (e.brushOption = {}), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option
        !n && kH(i, e, ['inBrush', 'outOfBrush'])
        var a = (i.inBrush = i.inBrush || {})
        ;(i.outOfBrush = i.outOfBrush || {
          color: Z_t,
        }),
          a.hasOwnProperty('liftZ') || (a.liftZ = 5)
      }),
      (t.prototype.setAreas = function (e) {
        e &&
          (this.areas = st(
            e,
            function (n) {
              return k3(this.option, n)
            },
            this,
          ))
      }),
      (t.prototype.setBrushOption = function (e) {
        ;(this.brushOption = k3(this.option, e)),
          (this.brushType = this.brushOption.brushType)
      }),
      (t.type = 'brush'),
      (t.dependencies = [
        'geo',
        'grid',
        'xAxis',
        'yAxis',
        'parallel',
        'series',
      ]),
      (t.defaultOption = {
        seriesIndex: 'all',
        brushType: 'rect',
        brushMode: 'single',
        transformable: !0,
        brushStyle: {
          borderWidth: 1,
          color: 'rgba(210,219,238,0.3)',
          borderColor: '#D2DBEE',
        },
        throttleType: 'fixRate',
        throttleDelay: 0,
        removeOnClick: !0,
        z: 1e4,
      }),
      t
    )
  })(xe)
function k3(r, t) {
  return te(
    {
      brushType: r.brushType,
      brushMode: r.brushMode,
      transformable: r.transformable,
      brushStyle: new qe(r.brushStyle).getItemStyle(),
      removeOnClick: r.removeOnClick,
      z: r.z,
    },
    t,
    !0,
  )
}
const j_t = K_t
var J_t = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
  Q_t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a, o, s
        n.eachComponent(
          {
            mainType: 'brush',
          },
          function (l) {
            ;(a = l.brushType),
              (o = l.brushOption.brushMode || 'single'),
              (s = s || !!l.areas.length)
          },
        ),
          (this._brushType = a),
          (this._brushMode = o),
          R(e.get('type', !0), function (l) {
            e.setIconStatus(
              l,
              (l === 'keep' ? o === 'multiple' : l === 'clear' ? s : l === a)
                ? 'emphasis'
                : 'normal',
            )
          })
      }),
      (t.prototype.updateView = function (e, n, i) {
        this.render(e, n, i)
      }),
      (t.prototype.getIcons = function () {
        var e = this.model,
          n = e.get('icon', !0),
          i = {}
        return (
          R(e.get('type', !0), function (a) {
            n[a] && (i[a] = n[a])
          }),
          i
        )
      }),
      (t.prototype.onclick = function (e, n, i) {
        var a = this._brushType,
          o = this._brushMode
        i === 'clear'
          ? (n.dispatchAction({
              type: 'axisAreaSelect',
              intervals: [],
            }),
            n.dispatchAction({
              type: 'brush',
              command: 'clear',
              areas: [],
            }))
          : n.dispatchAction({
              type: 'takeGlobalCursor',
              key: 'brush',
              brushOption: {
                brushType: i === 'keep' ? a : a === i ? !1 : i,
                brushMode:
                  i === 'keep' ? (o === 'multiple' ? 'single' : 'multiple') : o,
              },
            })
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          type: J_t.slice(),
          icon: {
            rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
            polygon:
              'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
            lineX:
              'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
            lineY:
              'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
            keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
            clear:
              'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2',
          },
          title: e.getLocaleModel().get(['toolbox', 'brush', 'title']),
        }
        return n
      }),
      t
    )
  })(Hi)
const txt = Q_t
function ext(r) {
  r.registerComponentView(q_t),
    r.registerComponentModel(j_t),
    r.registerPreprocessor(B_t),
    r.registerVisual(r.PRIORITY.VISUAL.BRUSH, G_t),
    r.registerAction(
      {
        type: 'brush',
        event: 'brush',
        update: 'updateVisual',
      },
      function (t, e) {
        e.eachComponent(
          {
            mainType: 'brush',
            query: t,
          },
          function (n) {
            n.setAreas(t.areas)
          },
        )
      },
    ),
    r.registerAction(
      {
        type: 'brushSelect',
        event: 'brushSelected',
        update: 'none',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'brushEnd',
        event: 'brushEnd',
        update: 'none',
      },
      wn,
    ),
    ch('brush', txt)
}
var nxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        e
      )
    }
    return (
      (t.type = 'title'),
      (t.defaultOption = {
        z: 6,
        show: !0,
        text: '',
        target: 'blank',
        subtext: '',
        subtarget: 'blank',
        left: 0,
        top: 0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: 'bold',
          color: '#464646',
        },
        subtextStyle: {
          fontSize: 12,
          color: '#6E7079',
        },
      }),
      t
    )
  })(xe),
  rxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var a = this.group,
            o = e.getModel('textStyle'),
            s = e.getModel('subtextStyle'),
            l = e.get('textAlign'),
            u = $t(e.get('textBaseline'), e.get('textVerticalAlign')),
            c = new Ae({
              style: $e(
                o,
                {
                  text: e.get('text'),
                  fill: o.getTextColor(),
                },
                {
                  disableBox: !0,
                },
              ),
              z2: 10,
            }),
            h = c.getBoundingRect(),
            f = e.get('subtext'),
            d = new Ae({
              style: $e(
                s,
                {
                  text: f,
                  fill: s.getTextColor(),
                  y: h.height + e.get('itemGap'),
                  verticalAlign: 'top',
                },
                {
                  disableBox: !0,
                },
              ),
              z2: 10,
            }),
            p = e.get('link'),
            g = e.get('sublink'),
            v = e.get('triggerEvent', !0)
          ;(c.silent = !p && !v),
            (d.silent = !g && !v),
            p &&
              c.on('click', function () {
                jy(p, '_' + e.get('target'))
              }),
            g &&
              d.on('click', function () {
                jy(g, '_' + e.get('subtarget'))
              }),
            (Wt(c).eventData = Wt(d).eventData =
              v
                ? {
                    componentType: 'title',
                    componentIndex: e.componentIndex,
                  }
                : null),
            a.add(c),
            f && a.add(d)
          var m = a.getBoundingRect(),
            y = e.getBoxLayoutParams()
          ;(y.width = m.width), (y.height = m.height)
          var _ = Vn(
            y,
            {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            e.get('padding'),
          )
          l ||
            ((l = e.get('left') || e.get('right')),
            l === 'middle' && (l = 'center'),
            l === 'right'
              ? (_.x += _.width)
              : l === 'center' && (_.x += _.width / 2)),
            u ||
              ((u = e.get('top') || e.get('bottom')),
              u === 'center' && (u = 'middle'),
              u === 'bottom'
                ? (_.y += _.height)
                : u === 'middle' && (_.y += _.height / 2),
              (u = u || 'top')),
            (a.x = _.x),
            (a.y = _.y),
            a.markRedraw()
          var x = {
            align: l,
            verticalAlign: u,
          }
          c.setStyle(x), d.setStyle(x), (m = a.getBoundingRect())
          var A = _.margin,
            S = e.getItemStyle(['color', 'opacity'])
          S.fill = e.get('backgroundColor')
          var b = new ge({
            shape: {
              x: m.x - A[3],
              y: m.y - A[0],
              width: m.width + A[1] + A[3],
              height: m.height + A[0] + A[2],
              r: e.get('borderRadius'),
            },
            style: S,
            subPixelOptimize: !0,
            silent: !0,
          })
          a.add(b)
        }
      }),
      (t.type = 'title'),
      t
    )
  })(dn)
function ixt(r) {
  r.registerComponentModel(nxt), r.registerComponentView(rxt)
}
var axt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.layoutMode = 'box'), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      this.mergeDefaultAndTheme(e, i), this._initData()
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments), this._initData()
    }),
    (t.prototype.setCurrentIndex = function (e) {
      e == null && (e = this.option.currentIndex)
      var n = this._data.count()
      this.option.loop
        ? (e = ((e % n) + n) % n)
        : (e >= n && (e = n - 1), e < 0 && (e = 0)),
        (this.option.currentIndex = e)
    }),
    (t.prototype.getCurrentIndex = function () {
      return this.option.currentIndex
    }),
    (t.prototype.isIndexMax = function () {
      return this.getCurrentIndex() >= this._data.count() - 1
    }),
    (t.prototype.setPlayState = function (e) {
      this.option.autoPlay = !!e
    }),
    (t.prototype.getPlayState = function () {
      return !!this.option.autoPlay
    }),
    (t.prototype._initData = function () {
      var e = this.option,
        n = e.data || [],
        i = e.axisType,
        a = (this._names = []),
        o
      i === 'category'
        ? ((o = []),
          R(n, function (u, c) {
            var h = Un(yf(u), ''),
              f
            Ut(u) ? ((f = Vt(u)), (f.value = c)) : (f = c), o.push(f), a.push(h)
          }))
        : (o = n)
      var s =
          {
            category: 'ordinal',
            time: 'time',
            value: 'number',
          }[i] || 'number',
        l = (this._data = new Vr(
          [
            {
              name: 'value',
              type: s,
            },
          ],
          this,
        ))
      l.initData(o, a)
    }),
    (t.prototype.getData = function () {
      return this._data
    }),
    (t.prototype.getCategories = function () {
      if (this.get('axisType') === 'category') return this._names.slice()
    }),
    (t.type = 'timeline'),
    (t.defaultOption = {
      z: 4,
      show: !0,
      axisType: 'time',
      realtime: !0,
      left: '20%',
      top: null,
      right: '20%',
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: 'left',
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: '#000',
      },
      data: [],
    }),
    t
  )
})(xe)
const B3 = axt
var FH = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'timeline.slider'),
    (t.defaultOption = gl(B3.defaultOption, {
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      borderWidth: 0,
      orient: 'horizontal',
      inverse: !1,
      tooltip: {
        trigger: 'item',
      },
      symbol: 'circle',
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: '#DAE1F5',
      },
      label: {
        position: 'auto',
        show: !0,
        interval: 'auto',
        rotate: 0,
        color: '#A4B1D7',
      },
      itemStyle: {
        color: '#A4B1D7',
        borderWidth: 1,
      },
      checkpointStyle: {
        symbol: 'circle',
        symbolSize: 15,
        color: '#316bf3',
        borderColor: '#fff',
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        animation: !0,
        animationDuration: 300,
        animationEasing: 'quinticInOut',
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: 'left',
        playIcon:
          'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
        stopIcon:
          'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
        nextIcon:
          'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',
        prevIcon:
          'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: '#A4B1D7',
        borderColor: '#A4B1D7',
        borderWidth: 1,
      },
      emphasis: {
        label: {
          show: !0,
          color: '#6f778d',
        },
        itemStyle: {
          color: '#316BF3',
        },
        controlStyle: {
          color: '#316BF3',
          borderColor: '#316BF3',
          borderWidth: 2,
        },
      },
      progress: {
        lineStyle: {
          color: '#316BF3',
        },
        itemStyle: {
          color: '#316BF3',
        },
        label: {
          color: '#6f778d',
        },
      },
      data: [],
    })),
    t
  )
})(B3)
In(FH, g_.prototype)
const oxt = FH
var sxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'timeline'), t
})(dn)
const lxt = sxt
var uxt = (function (r) {
  X(t, r)
  function t(e, n, i, a) {
    var o = r.call(this, e, n, i) || this
    return (o.type = a || 'value'), o
  }
  return (
    (t.prototype.getLabelModel = function () {
      return this.model.getModel('label')
    }),
    (t.prototype.isHorizontal = function () {
      return this.model.get('orient') === 'horizontal'
    }),
    t
  )
})(Ra)
const cxt = uxt
var jS = Math.PI,
  F3 = ve(),
  hxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        this.api = n
      }),
      (t.prototype.render = function (e, n, i) {
        if (
          ((this.model = e),
          (this.api = i),
          (this.ecModel = n),
          this.group.removeAll(),
          e.get('show', !0))
        ) {
          var a = this._layout(e, i),
            o = this._createGroup('_mainGroup'),
            s = this._createGroup('_labelGroup'),
            l = (this._axis = this._createAxis(a, e))
          ;(e.formatTooltip = function (u) {
            var c = l.scale.getLabel({
              value: u,
            })
            return Kn('nameValue', {
              noName: !0,
              value: c,
            })
          }),
            R(
              ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'],
              function (u) {
                this['_render' + u](a, o, l, e)
              },
              this,
            ),
            this._renderAxisLabel(a, s, l, e),
            this._position(a, e)
        }
        this._doPlayStop(), this._updateTicksStatus()
      }),
      (t.prototype.remove = function () {
        this._clearTimer(), this.group.removeAll()
      }),
      (t.prototype.dispose = function () {
        this._clearTimer()
      }),
      (t.prototype._layout = function (e, n) {
        var i = e.get(['label', 'position']),
          a = e.get('orient'),
          o = dxt(e, n),
          s
        i == null || i === 'auto'
          ? (s =
              a === 'horizontal'
                ? o.y + o.height / 2 < n.getHeight() / 2
                  ? '-'
                  : '+'
                : o.x + o.width / 2 < n.getWidth() / 2
                ? '+'
                : '-')
          : bt(i)
          ? (s = {
              horizontal: {
                top: '-',
                bottom: '+',
              },
              vertical: {
                left: '-',
                right: '+',
              },
            }[a][i])
          : (s = i)
        var l = {
            horizontal: 'center',
            vertical: s >= 0 || s === '+' ? 'left' : 'right',
          },
          u = {
            horizontal: s >= 0 || s === '+' ? 'top' : 'bottom',
            vertical: 'middle',
          },
          c = {
            horizontal: 0,
            vertical: jS / 2,
          },
          h = a === 'vertical' ? o.height : o.width,
          f = e.getModel('controlStyle'),
          d = f.get('show', !0),
          p = d ? f.get('itemSize') : 0,
          g = d ? f.get('itemGap') : 0,
          v = p + g,
          m = e.get(['label', 'rotate']) || 0
        m = (m * jS) / 180
        var y,
          _,
          x,
          A = f.get('position', !0),
          S = d && f.get('showPlayBtn', !0),
          b = d && f.get('showPrevBtn', !0),
          T = d && f.get('showNextBtn', !0),
          w = 0,
          M = h
        A === 'left' || A === 'bottom'
          ? (S && ((y = [0, 0]), (w += v)),
            b && ((_ = [w, 0]), (w += v)),
            T && ((x = [M - p, 0]), (M -= v)))
          : (S && ((y = [M - p, 0]), (M -= v)),
            b && ((_ = [0, 0]), (w += v)),
            T && ((x = [M - p, 0]), (M -= v)))
        var C = [w, M]
        return (
          e.get('inverse') && C.reverse(),
          {
            viewRect: o,
            mainLength: h,
            orient: a,
            rotation: c[a],
            labelRotation: m,
            labelPosOpt: s,
            labelAlign: e.get(['label', 'align']) || l[a],
            labelBaseline:
              e.get(['label', 'verticalAlign']) ||
              e.get(['label', 'baseline']) ||
              u[a],
            playPosition: y,
            prevBtnPosition: _,
            nextBtnPosition: x,
            axisExtent: C,
            controlSize: p,
            controlGap: g,
          }
        )
      }),
      (t.prototype._position = function (e, n) {
        var i = this._mainGroup,
          a = this._labelGroup,
          o = e.viewRect
        if (e.orient === 'vertical') {
          var s = bi(),
            l = o.x,
            u = o.y + o.height
          ho(s, s, [-l, -u]),
            ec(s, s, -jS / 2),
            ho(s, s, [l, u]),
            (o = o.clone()),
            o.applyTransform(s)
        }
        var c = y(o),
          h = y(i.getBoundingRect()),
          f = y(a.getBoundingRect()),
          d = [i.x, i.y],
          p = [a.x, a.y]
        p[0] = d[0] = c[0][0]
        var g = e.labelPosOpt
        if (g == null || bt(g)) {
          var v = g === '+' ? 0 : 1
          _(d, h, c, 1, v), _(p, f, c, 1, 1 - v)
        } else {
          var v = g >= 0 ? 0 : 1
          _(d, h, c, 1, v), (p[1] = d[1] + g)
        }
        i.setPosition(d),
          a.setPosition(p),
          (i.rotation = a.rotation = e.rotation),
          m(i),
          m(a)
        function m(x) {
          ;(x.originX = c[0][0] - x.x), (x.originY = c[1][0] - x.y)
        }
        function y(x) {
          return [
            [x.x, x.x + x.width],
            [x.y, x.y + x.height],
          ]
        }
        function _(x, A, S, b, T) {
          x[b] += S[b][T] - A[b][T]
        }
      }),
      (t.prototype._createAxis = function (e, n) {
        var i = n.getData(),
          a = n.get('axisType'),
          o = fxt(n, a)
        o.getTicks = function () {
          return i.mapArray(['value'], function (u) {
            return {
              value: u,
            }
          })
        }
        var s = i.getDataExtent('value')
        o.setExtent(s[0], s[1]), o.calcNiceTicks()
        var l = new cxt('value', o, e.axisExtent, a)
        return (l.model = n), l
      }),
      (t.prototype._createGroup = function (e) {
        var n = (this[e] = new Ht())
        return this.group.add(n), n
      }),
      (t.prototype._renderAxisLine = function (e, n, i, a) {
        var o = i.getExtent()
        if (a.get(['lineStyle', 'show'])) {
          var s = new rr({
            shape: {
              x1: o[0],
              y1: 0,
              x2: o[1],
              y2: 0,
            },
            style: Q(
              {
                lineCap: 'round',
              },
              a.getModel('lineStyle').getLineStyle(),
            ),
            silent: !0,
            z2: 1,
          })
          n.add(s)
          var l = (this._progressLine = new rr({
            shape: {
              x1: o[0],
              x2: this._currentPointer ? this._currentPointer.x : o[0],
              y1: 0,
              y2: 0,
            },
            style: zt(
              {
                lineCap: 'round',
                lineWidth: s.style.lineWidth,
              },
              a.getModel(['progress', 'lineStyle']).getLineStyle(),
            ),
            silent: !0,
            z2: 1,
          }))
          n.add(l)
        }
      }),
      (t.prototype._renderAxisTick = function (e, n, i, a) {
        var o = this,
          s = a.getData(),
          l = i.scale.getTicks()
        ;(this._tickSymbols = []),
          R(l, function (u) {
            var c = i.dataToCoord(u.value),
              h = s.getItemModel(u.value),
              f = h.getModel('itemStyle'),
              d = h.getModel(['emphasis', 'itemStyle']),
              p = h.getModel(['progress', 'itemStyle']),
              g = {
                x: c,
                y: 0,
                onclick: Tt(o._changeTimeline, o, u.value),
              },
              v = z3(h, f, n, g)
            ;(v.ensureState('emphasis').style = d.getItemStyle()),
              (v.ensureState('progress').style = p.getItemStyle()),
              Ou(v)
            var m = Wt(v)
            h.get('tooltip')
              ? ((m.dataIndex = u.value), (m.dataModel = a))
              : (m.dataIndex = m.dataModel = null),
              o._tickSymbols.push(v)
          })
      }),
      (t.prototype._renderAxisLabel = function (e, n, i, a) {
        var o = this,
          s = i.getLabelModel()
        if (s.get('show')) {
          var l = a.getData(),
            u = i.getViewLabels()
          ;(this._tickLabels = []),
            R(u, function (c) {
              var h = c.tickValue,
                f = l.getItemModel(h),
                d = f.getModel('label'),
                p = f.getModel(['emphasis', 'label']),
                g = f.getModel(['progress', 'label']),
                v = i.dataToCoord(c.tickValue),
                m = new Ae({
                  x: v,
                  y: 0,
                  rotation: e.labelRotation - e.rotation,
                  onclick: Tt(o._changeTimeline, o, h),
                  silent: !1,
                  style: $e(d, {
                    text: c.formattedLabel,
                    align: e.labelAlign,
                    verticalAlign: e.labelBaseline,
                  }),
                })
              ;(m.ensureState('emphasis').style = $e(p)),
                (m.ensureState('progress').style = $e(g)),
                n.add(m),
                Ou(m),
                (F3(m).dataIndex = h),
                o._tickLabels.push(m)
            })
        }
      }),
      (t.prototype._renderControl = function (e, n, i, a) {
        var o = e.controlSize,
          s = e.rotation,
          l = a.getModel('controlStyle').getItemStyle(),
          u = a.getModel(['emphasis', 'controlStyle']).getItemStyle(),
          c = a.getPlayState(),
          h = a.get('inverse', !0)
        f(
          e.nextBtnPosition,
          'next',
          Tt(this._changeTimeline, this, h ? '-' : '+'),
        ),
          f(
            e.prevBtnPosition,
            'prev',
            Tt(this._changeTimeline, this, h ? '+' : '-'),
          ),
          f(
            e.playPosition,
            c ? 'stop' : 'play',
            Tt(this._handlePlayClick, this, !c),
            !0,
          )
        function f(d, p, g, v) {
          if (d) {
            var m = Ta($t(a.get(['controlStyle', p + 'BtnSize']), o), o),
              y = [0, -m / 2, m, m],
              _ = pxt(a, p + 'Icon', y, {
                x: d[0],
                y: d[1],
                originX: o / 2,
                originY: 0,
                rotation: v ? -s : 0,
                rectHover: !0,
                style: l,
                onclick: g,
              })
            ;(_.ensureState('emphasis').style = u), n.add(_), Ou(_)
          }
        }
      }),
      (t.prototype._renderCurrentPointer = function (e, n, i, a) {
        var o = a.getData(),
          s = a.getCurrentIndex(),
          l = o.getItemModel(s).getModel('checkpointStyle'),
          u = this,
          c = {
            onCreate: function (h) {
              ;(h.draggable = !0),
                (h.drift = Tt(u._handlePointerDrag, u)),
                (h.ondragend = Tt(u._handlePointerDragend, u)),
                U3(h, u._progressLine, s, i, a, !0)
            },
            onUpdate: function (h) {
              U3(h, u._progressLine, s, i, a)
            },
          }
        this._currentPointer = z3(
          l,
          l,
          this._mainGroup,
          {},
          this._currentPointer,
          c,
        )
      }),
      (t.prototype._handlePlayClick = function (e) {
        this._clearTimer(),
          this.api.dispatchAction({
            type: 'timelinePlayChange',
            playState: e,
            from: this.uid,
          })
      }),
      (t.prototype._handlePointerDrag = function (e, n, i) {
        this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
      }),
      (t.prototype._handlePointerDragend = function (e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], !0)
      }),
      (t.prototype._pointerChangeTimeline = function (e, n) {
        var i = this._toAxisCoord(e)[0],
          a = this._axis,
          o = Zi(a.getExtent().slice())
        i > o[1] && (i = o[1]),
          i < o[0] && (i = o[0]),
          (this._currentPointer.x = i),
          this._currentPointer.markRedraw()
        var s = this._progressLine
        s && ((s.shape.x2 = i), s.dirty())
        var l = this._findNearestTick(i),
          u = this.model
        ;(n || (l !== u.getCurrentIndex() && u.get('realtime'))) &&
          this._changeTimeline(l)
      }),
      (t.prototype._doPlayStop = function () {
        var e = this
        this._clearTimer(),
          this.model.getPlayState() &&
            (this._timer = setTimeout(function () {
              var n = e.model
              e._changeTimeline(
                n.getCurrentIndex() + (n.get('rewind', !0) ? -1 : 1),
              )
            }, this.model.get('playInterval')))
      }),
      (t.prototype._toAxisCoord = function (e) {
        var n = this._mainGroup.getLocalTransform()
        return ba(e, n, !0)
      }),
      (t.prototype._findNearestTick = function (e) {
        var n = this.model.getData(),
          i = 1 / 0,
          a,
          o = this._axis
        return (
          n.each(['value'], function (s, l) {
            var u = o.dataToCoord(s),
              c = Math.abs(u - e)
            c < i && ((i = c), (a = l))
          }),
          a
        )
      }),
      (t.prototype._clearTimer = function () {
        this._timer && (clearTimeout(this._timer), (this._timer = null))
      }),
      (t.prototype._changeTimeline = function (e) {
        var n = this.model.getCurrentIndex()
        e === '+' ? (e = n + 1) : e === '-' && (e = n - 1),
          this.api.dispatchAction({
            type: 'timelineChange',
            currentIndex: e,
            from: this.uid,
          })
      }),
      (t.prototype._updateTicksStatus = function () {
        var e = this.model.getCurrentIndex(),
          n = this._tickSymbols,
          i = this._tickLabels
        if (n)
          for (var a = 0; a < n.length; a++)
            n && n[a] && n[a].toggleState('progress', a < e)
        if (i)
          for (var a = 0; a < i.length; a++)
            i && i[a] && i[a].toggleState('progress', F3(i[a]).dataIndex <= e)
      }),
      (t.type = 'timeline.slider'),
      t
    )
  })(lxt)
function fxt(r, t) {
  if (((t = t || r.get('type')), t))
    switch (t) {
      case 'category':
        return new wC({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0],
        })
      case 'time':
        return new FV({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get('useUTC'),
        })
      default:
        return new ll()
    }
}
function dxt(r, t) {
  return Vn(
    r.getBoxLayoutParams(),
    {
      width: t.getWidth(),
      height: t.getHeight(),
    },
    r.get('padding'),
  )
}
function pxt(r, t, e, n) {
  var i = n.style,
    a = Sv(r.get(['controlStyle', t]), n || {}, new ee(e[0], e[1], e[2], e[3]))
  return i && a.setStyle(i), a
}
function z3(r, t, e, n, i, a) {
  var o = t.get('color')
  if (i) i.setColor(o), e.add(i), a && a.onUpdate(i)
  else {
    var s = r.get('symbol')
    ;(i = Rn(s, -1, -1, 2, 2, o)),
      i.setStyle('strokeNoScale', !0),
      e.add(i),
      a && a.onCreate(i)
  }
  var l = t.getItemStyle(['color'])
  i.setStyle(l),
    (n = te(
      {
        rectHover: !0,
        z2: 100,
      },
      n,
      !0,
    ))
  var u = Lf(r.get('symbolSize'))
  ;(n.scaleX = u[0] / 2), (n.scaleY = u[1] / 2)
  var c = ic(r.get('symbolOffset'), u)
  c && ((n.x = (n.x || 0) + c[0]), (n.y = (n.y || 0) + c[1]))
  var h = r.get('symbolRotate')
  return (
    (n.rotation = ((h || 0) * Math.PI) / 180 || 0),
    i.attr(n),
    i.updateTransform(),
    i
  )
}
function U3(r, t, e, n, i, a) {
  if (!r.dragging) {
    var o = i.getModel('checkpointStyle'),
      s = n.dataToCoord(i.getData().get('value', e))
    if (a || !o.get('animation', !0))
      r.attr({
        x: s,
        y: 0,
      }),
        t &&
          t.attr({
            shape: {
              x2: s,
            },
          })
    else {
      var l = {
        duration: o.get('animationDuration', !0),
        easing: o.get('animationEasing', !0),
      }
      r.stopAnimation(null, !0),
        r.animateTo(
          {
            x: s,
            y: 0,
          },
          l,
        ),
        t &&
          t.animateTo(
            {
              shape: {
                x2: s,
              },
            },
            l,
          )
    }
  }
}
const vxt = hxt
function gxt(r) {
  r.registerAction(
    {
      type: 'timelineChange',
      event: 'timelineChanged',
      update: 'prepareAndUpdate',
    },
    function (t, e, n) {
      var i = e.getComponent('timeline')
      return (
        i &&
          t.currentIndex != null &&
          (i.setCurrentIndex(t.currentIndex),
          !i.get('loop', !0) &&
            i.isIndexMax() &&
            i.getPlayState() &&
            (i.setPlayState(!1),
            n.dispatchAction({
              type: 'timelinePlayChange',
              playState: !1,
              from: t.from,
            }))),
        e.resetOption('timeline', {
          replaceMerge: i.get('replaceMerge', !0),
        }),
        zt(
          {
            currentIndex: i.option.currentIndex,
          },
          t,
        )
      )
    },
  ),
    r.registerAction(
      {
        type: 'timelinePlayChange',
        event: 'timelinePlayChanged',
        update: 'update',
      },
      function (t, e) {
        var n = e.getComponent('timeline')
        n && t.playState != null && n.setPlayState(t.playState)
      },
    )
}
function mxt(r) {
  var t = r && r.timeline
  at(t) || (t = t ? [t] : []),
    R(t, function (e) {
      e && yxt(e)
    })
}
function yxt(r) {
  var t = r.type,
    e = {
      number: 'value',
      time: 'time',
    }
  if (
    (e[t] && ((r.axisType = e[t]), delete r.type),
    V3(r),
    pu(r, 'controlPosition'))
  ) {
    var n = r.controlStyle || (r.controlStyle = {})
    pu(n, 'position') || (n.position = r.controlPosition),
      n.position === 'none' &&
        !pu(n, 'show') &&
        ((n.show = !1), delete n.position),
      delete r.controlPosition
  }
  R(r.data || [], function (i) {
    Ut(i) &&
      !at(i) &&
      (!pu(i, 'value') && pu(i, 'name') && (i.value = i.name), V3(i))
  })
}
function V3(r) {
  var t = r.itemStyle || (r.itemStyle = {}),
    e = t.emphasis || (t.emphasis = {}),
    n = r.label || r.label || {},
    i = n.normal || (n.normal = {}),
    a = {
      normal: 1,
      emphasis: 1,
    }
  R(n, function (o, s) {
    !a[s] && !pu(i, s) && (i[s] = o)
  }),
    e.label && !pu(n, 'emphasis') && ((n.emphasis = e.label), delete e.label)
}
function pu(r, t) {
  return r.hasOwnProperty(t)
}
function _xt(r) {
  r.registerComponentModel(oxt),
    r.registerComponentView(vxt),
    r.registerSubTypeDefaulter('timeline', function () {
      return 'slider'
    }),
    gxt(r),
    r.registerPreprocessor(mxt)
}
function EE(r, t) {
  if (!r) return !1
  for (var e = at(r) ? r : [r], n = 0; n < e.length; n++)
    if (e[n] && e[n][t]) return !0
  return !1
}
function Mm(r) {
  Xu(r, 'label', ['show'])
}
var Tm = ve(),
  zH = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.createdBySelf = !1), e
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, !1, !0)
      }),
      (t.prototype.isAnimationEnabled = function () {
        if (Se.node) return !1
        var e = this.__hostSeries
        return this.getShallow('animation') && e && e.isAnimationEnabled()
      }),
      (t.prototype.mergeOption = function (e, n) {
        this._mergeOption(e, n, !1, !1)
      }),
      (t.prototype._mergeOption = function (e, n, i, a) {
        var o = this.mainType
        i ||
          n.eachSeries(function (s) {
            var l = s.get(this.mainType, !0),
              u = Tm(s)[o]
            if (!l || !l.data) {
              Tm(s)[o] = null
              return
            }
            u
              ? u._mergeOption(l, n, !0)
              : (a && Mm(l),
                R(l.data, function (c) {
                  c instanceof Array ? (Mm(c[0]), Mm(c[1])) : Mm(c)
                }),
                (u = this.createMarkerModelFromSeries(l, this, n)),
                Q(u, {
                  mainType: this.mainType,
                  seriesIndex: s.seriesIndex,
                  name: s.name,
                  createdBySelf: !0,
                }),
                (u.__hostSeries = s)),
              (Tm(s)[o] = u)
          }, this)
      }),
      (t.prototype.formatTooltip = function (e, n, i) {
        var a = this.getData(),
          o = this.getRawValue(e),
          s = a.getName(e)
        return Kn('section', {
          header: this.name,
          blocks: [
            Kn('nameValue', {
              name: s,
              value: o,
              noName: !s,
              noValue: o == null,
            }),
          ],
        })
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.setData = function (e) {
        this._data = e
      }),
      (t.prototype.getDataParams = function (e, n) {
        var i = g_.prototype.getDataParams.call(this, e, n),
          a = this.__hostSeries
        return (
          a &&
            ((i.seriesId = a.id),
            (i.seriesName = a.name),
            (i.seriesType = a.subType)),
          i
        )
      }),
      (t.getMarkerModelFromSeries = function (e, n) {
        return Tm(e)[n]
      }),
      (t.type = 'marker'),
      (t.dependencies = ['series', 'grid', 'polar', 'geo']),
      t
    )
  })(xe)
In(zH, g_.prototype)
const hl = zH
var xxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markPoint'),
    (t.defaultOption = {
      z: 5,
      symbol: 'pin',
      symbolSize: 50,
      tooltip: {
        trigger: 'item',
      },
      label: {
        show: !0,
        position: 'inside',
      },
      itemStyle: {
        borderWidth: 2,
      },
      emphasis: {
        label: {
          show: !0,
        },
      },
    }),
    t
  )
})(hl)
const Sxt = xxt
function oM(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)))
}
function Axt(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y))
}
function Cm(r, t, e, n, i, a) {
  var o = [],
    s = sl(t, n),
    l = s ? t.getCalculationInfo('stackResultDimension') : n,
    u = DE(t, l, r),
    c = t.indicesOfNearest(l, u)[0]
  ;(o[i] = t.get(e, c)), (o[a] = t.get(l, c))
  var h = t.get(n, c),
    f = Qa(t.get(n, c))
  return (f = Math.min(f, 20)), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, h]
}
var JS = {
  min: Zt(Cm, 'min'),
  max: Zt(Cm, 'max'),
  average: Zt(Cm, 'average'),
  median: Zt(Cm, 'median'),
}
function lv(r, t) {
  if (t) {
    var e = r.getData(),
      n = r.coordinateSystem,
      i = n && n.dimensions
    if (!Axt(t) && !at(t.coord) && at(i)) {
      var a = UH(t, e, n, r)
      if (((t = Vt(t)), t.type && JS[t.type] && a.baseAxis && a.valueAxis)) {
        var o = re(i, a.baseAxis.dim),
          s = re(i, a.valueAxis.dim),
          l = JS[t.type](e, a.baseDataDim, a.valueDataDim, o, s)
        ;(t.coord = l[0]), (t.value = l[1])
      } else
        t.coord = [
          t.xAxis != null ? t.xAxis : t.radiusAxis,
          t.yAxis != null ? t.yAxis : t.angleAxis,
        ]
    }
    if (t.coord == null || !at(i)) t.coord = []
    else
      for (var u = t.coord, c = 0; c < 2; c++)
        JS[u[c]] && (u[c] = DE(e, e.mapDimension(i[c]), u[c]))
    return t
  }
}
function UH(r, t, e, n) {
  var i = {}
  return (
    r.valueIndex != null || r.valueDim != null
      ? ((i.valueDataDim =
          r.valueIndex != null ? t.getDimension(r.valueIndex) : r.valueDim),
        (i.valueAxis = e.getAxis(bxt(n, i.valueDataDim))),
        (i.baseAxis = e.getOtherAxis(i.valueAxis)),
        (i.baseDataDim = t.mapDimension(i.baseAxis.dim)))
      : ((i.baseAxis = n.getBaseAxis()),
        (i.valueAxis = e.getOtherAxis(i.baseAxis)),
        (i.baseDataDim = t.mapDimension(i.baseAxis.dim)),
        (i.valueDataDim = t.mapDimension(i.valueAxis.dim))),
    i
  )
}
function bxt(r, t) {
  var e = r.getData().getDimensionInfo(t)
  return e && e.coordDim
}
function uv(r, t) {
  return r && r.containData && t.coord && !oM(t) ? r.containData(t.coord) : !0
}
function wxt(r, t, e) {
  return r && r.containZone && t.coord && e.coord && !oM(t) && !oM(e)
    ? r.containZone(t.coord, e.coord)
    : !0
}
function VH(r, t) {
  return r
    ? function (e, n, i, a) {
        var o = a < 2 ? e.coord && e.coord[a] : e.value
        return Js(o, t[a])
      }
    : function (e, n, i, a) {
        return Js(e.value, t[a])
      }
}
function DE(r, t, e) {
  if (e === 'average') {
    var n = 0,
      i = 0
    return (
      r.each(t, function (a, o) {
        isNaN(a) || ((n += a), i++)
      }),
      n / i
    )
  } else
    return e === 'median'
      ? r.getMedian(t)
      : r.getDataExtent(t)[e === 'max' ? 1 : 0]
}
var QS = ve(),
  Mxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function () {
        this.markerGroupMap = Pt()
      }),
      (t.prototype.render = function (e, n, i) {
        var a = this,
          o = this.markerGroupMap
        o.each(function (s) {
          QS(s).keep = !1
        }),
          n.eachSeries(function (s) {
            var l = hl.getMarkerModelFromSeries(s, a.type)
            l && a.renderSeries(s, l, n, i)
          }),
          o.each(function (s) {
            !QS(s).keep && a.group.remove(s.group)
          })
      }),
      (t.prototype.markKeep = function (e) {
        QS(e).keep = !0
      }),
      (t.prototype.toggleBlurSeries = function (e, n) {
        var i = this
        R(e, function (a) {
          var o = hl.getMarkerModelFromSeries(a, i.type)
          if (o) {
            var s = o.getData()
            s.eachItemGraphicEl(function (l) {
              l && (n ? fU(l) : $T(l))
            })
          }
        })
      }),
      (t.type = 'marker'),
      t
    )
  })(dn)
const LE = Mxt
function G3(r, t, e) {
  var n = t.coordinateSystem
  r.each(function (i) {
    var a = r.getItemModel(i),
      o,
      s = _t(a.get('x'), e.getWidth()),
      l = _t(a.get('y'), e.getHeight())
    if (!isNaN(s) && !isNaN(l)) o = [s, l]
    else if (t.getMarkerPosition)
      o = t.getMarkerPosition(r.getValues(r.dimensions, i))
    else if (n) {
      var u = r.get(n.dimensions[0], i),
        c = r.get(n.dimensions[1], i)
      o = n.dataToPoint([u, c])
    }
    isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), r.setItemLayout(i, o)
  })
}
var Txt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.updateTransform = function (e, n, i) {
      n.eachSeries(function (a) {
        var o = hl.getMarkerModelFromSeries(a, 'markPoint')
        o &&
          (G3(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout())
      }, this)
    }),
    (t.prototype.renderSeries = function (e, n, i, a) {
      var o = e.coordinateSystem,
        s = e.id,
        l = e.getData(),
        u = this.markerGroupMap,
        c = u.get(s) || u.set(s, new Cv()),
        h = Cxt(o, e, n)
      n.setData(h),
        G3(n.getData(), e, a),
        h.each(function (f) {
          var d = h.getItemModel(f),
            p = d.getShallow('symbol'),
            g = d.getShallow('symbolSize'),
            v = d.getShallow('symbolRotate'),
            m = d.getShallow('symbolOffset'),
            y = d.getShallow('symbolKeepAspect')
          if (Nt(p) || Nt(g) || Nt(v) || Nt(m)) {
            var _ = n.getRawValue(f),
              x = n.getDataParams(f)
            Nt(p) && (p = p(_, x)),
              Nt(g) && (g = g(_, x)),
              Nt(v) && (v = v(_, x)),
              Nt(m) && (m = m(_, x))
          }
          var A = d.getModel('itemStyle').getItemStyle(),
            S = bv(l, 'color')
          A.fill || (A.fill = S),
            h.setItemVisual(f, {
              symbol: p,
              symbolSize: g,
              symbolRotate: v,
              symbolOffset: m,
              symbolKeepAspect: y,
              style: A,
            })
        }),
        c.updateData(h),
        this.group.add(c.group),
        h.eachItemGraphicEl(function (f) {
          f.traverse(function (d) {
            Wt(d).dataModel = n
          })
        }),
        this.markKeep(c),
        (c.group.silent = n.get('silent') || e.get('silent'))
    }),
    (t.type = 'markPoint'),
    t
  )
})(LE)
function Cxt(r, t, e) {
  var n
  r
    ? (n = st(r && r.dimensions, function (s) {
        var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {}
        return Q(Q({}, l), {
          name: s,
          ordinalMeta: null,
        })
      }))
    : (n = [
        {
          name: 'value',
          type: 'float',
        },
      ])
  var i = new Vr(n, e),
    a = st(e.get('data'), Zt(lv, t))
  r && (a = Ne(a, Zt(uv, r)))
  var o = VH(!!r, n)
  return i.initData(a, null, o), i
}
const Ext = Txt
function Dxt(r) {
  r.registerComponentModel(Sxt),
    r.registerComponentView(Ext),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markPoint') && (t.markPoint = t.markPoint || {})
    })
}
var Lxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markLine'),
    (t.defaultOption = {
      z: 5,
      symbol: ['circle', 'arrow'],
      symbolSize: [8, 16],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: 'item',
      },
      label: {
        show: !0,
        position: 'end',
        distance: 5,
      },
      lineStyle: {
        type: 'dashed',
      },
      emphasis: {
        label: {
          show: !0,
        },
        lineStyle: {
          width: 3,
        },
      },
      animationEasing: 'linear',
    }),
    t
  )
})(hl)
const Pxt = Lxt
var Em = ve(),
  Rxt = function (r, t, e, n) {
    var i = r.getData(),
      a
    if (at(n)) a = n
    else {
      var o = n.type
      if (
        o === 'min' ||
        o === 'max' ||
        o === 'average' ||
        o === 'median' ||
        n.xAxis != null ||
        n.yAxis != null
      ) {
        var s = void 0,
          l = void 0
        if (n.yAxis != null || n.xAxis != null)
          (s = t.getAxis(n.yAxis != null ? 'y' : 'x')),
            (l = nr(n.yAxis, n.xAxis))
        else {
          var u = UH(n, i, t, r)
          s = u.valueAxis
          var c = wV(i, u.valueDataDim)
          l = DE(i, c, o)
        }
        var h = s.dim === 'x' ? 0 : 1,
          f = 1 - h,
          d = Vt(n),
          p = {
            coord: [],
          }
        ;(d.type = null),
          (d.coord = []),
          (d.coord[f] = -1 / 0),
          (p.coord[f] = 1 / 0)
        var g = e.get('precision')
        g >= 0 && be(l) && (l = +l.toFixed(Math.min(g, 20))),
          (d.coord[h] = p.coord[h] = l),
          (a = [
            d,
            p,
            {
              type: o,
              valueIndex: n.valueIndex,
              value: l,
            },
          ])
      } else a = []
    }
    var v = [lv(r, a[0]), lv(r, a[1]), Q({}, a[2])]
    return (v[2].type = v[2].type || null), te(v[2], v[0]), te(v[2], v[1]), v
  }
function b0(r) {
  return !isNaN(r) && !isFinite(r)
}
function H3(r, t, e, n) {
  var i = 1 - r,
    a = n.dimensions[r]
  return b0(t[i]) && b0(e[i]) && t[r] === e[r] && n.getAxis(a).containData(t[r])
}
function Ixt(r, t) {
  if (r.type === 'cartesian2d') {
    var e = t[0].coord,
      n = t[1].coord
    if (e && n && (H3(1, e, n, r) || H3(0, e, n, r))) return !0
  }
  return uv(r, t[0]) && uv(r, t[1])
}
function tA(r, t, e, n, i) {
  var a = n.coordinateSystem,
    o = r.getItemModel(t),
    s,
    l = _t(o.get('x'), i.getWidth()),
    u = _t(o.get('y'), i.getHeight())
  if (!isNaN(l) && !isNaN(u)) s = [l, u]
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(r.getValues(r.dimensions, t))
    else {
      var c = a.dimensions,
        h = r.get(c[0], t),
        f = r.get(c[1], t)
      s = a.dataToPoint([h, f])
    }
    if (oc(a, 'cartesian2d')) {
      var d = a.getAxis('x'),
        p = a.getAxis('y'),
        c = a.dimensions
      b0(r.get(c[0], t))
        ? (s[0] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]))
        : b0(r.get(c[1], t)) &&
          (s[1] = p.toGlobalCoord(p.getExtent()[e ? 0 : 1]))
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
  }
  r.setItemLayout(t, s)
}
var Oxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.updateTransform = function (e, n, i) {
      n.eachSeries(function (a) {
        var o = hl.getMarkerModelFromSeries(a, 'markLine')
        if (o) {
          var s = o.getData(),
            l = Em(o).from,
            u = Em(o).to
          l.each(function (c) {
            tA(l, c, !0, a, i), tA(u, c, !1, a, i)
          }),
            s.each(function (c) {
              s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)])
            }),
            this.markerGroupMap.get(a.id).updateLayout()
        }
      }, this)
    }),
    (t.prototype.renderSeries = function (e, n, i, a) {
      var o = e.coordinateSystem,
        s = e.id,
        l = e.getData(),
        u = this.markerGroupMap,
        c = u.get(s) || u.set(s, new QC())
      this.group.add(c.group)
      var h = Nxt(o, e, n),
        f = h.from,
        d = h.to,
        p = h.line
      ;(Em(n).from = f), (Em(n).to = d), n.setData(p)
      var g = n.get('symbol'),
        v = n.get('symbolSize'),
        m = n.get('symbolRotate'),
        y = n.get('symbolOffset')
      at(g) || (g = [g, g]),
        at(v) || (v = [v, v]),
        at(m) || (m = [m, m]),
        at(y) || (y = [y, y]),
        h.from.each(function (x) {
          _(f, x, !0), _(d, x, !1)
        }),
        p.each(function (x) {
          var A = p.getItemModel(x).getModel('lineStyle').getLineStyle()
          p.setItemLayout(x, [f.getItemLayout(x), d.getItemLayout(x)]),
            A.stroke == null && (A.stroke = f.getItemVisual(x, 'style').fill),
            p.setItemVisual(x, {
              fromSymbolKeepAspect: f.getItemVisual(x, 'symbolKeepAspect'),
              fromSymbolOffset: f.getItemVisual(x, 'symbolOffset'),
              fromSymbolRotate: f.getItemVisual(x, 'symbolRotate'),
              fromSymbolSize: f.getItemVisual(x, 'symbolSize'),
              fromSymbol: f.getItemVisual(x, 'symbol'),
              toSymbolKeepAspect: d.getItemVisual(x, 'symbolKeepAspect'),
              toSymbolOffset: d.getItemVisual(x, 'symbolOffset'),
              toSymbolRotate: d.getItemVisual(x, 'symbolRotate'),
              toSymbolSize: d.getItemVisual(x, 'symbolSize'),
              toSymbol: d.getItemVisual(x, 'symbol'),
              style: A,
            })
        }),
        c.updateData(p),
        h.line.eachItemGraphicEl(function (x) {
          ;(Wt(x).dataModel = n),
            x.traverse(function (A) {
              Wt(A).dataModel = n
            })
        })
      function _(x, A, S) {
        var b = x.getItemModel(A)
        tA(x, A, S, e, a)
        var T = b.getModel('itemStyle').getItemStyle()
        T.fill == null && (T.fill = bv(l, 'color')),
          x.setItemVisual(A, {
            symbolKeepAspect: b.get('symbolKeepAspect'),
            symbolOffset: $t(b.get('symbolOffset', !0), y[S ? 0 : 1]),
            symbolRotate: $t(b.get('symbolRotate', !0), m[S ? 0 : 1]),
            symbolSize: $t(b.get('symbolSize'), v[S ? 0 : 1]),
            symbol: $t(b.get('symbol', !0), g[S ? 0 : 1]),
            style: T,
          })
      }
      this.markKeep(c), (c.group.silent = n.get('silent') || e.get('silent'))
    }),
    (t.type = 'markLine'),
    t
  )
})(LE)
function Nxt(r, t, e) {
  var n
  r
    ? (n = st(r && r.dimensions, function (u) {
        var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {}
        return Q(Q({}, c), {
          name: u,
          ordinalMeta: null,
        })
      }))
    : (n = [
        {
          name: 'value',
          type: 'float',
        },
      ])
  var i = new Vr(n, e),
    a = new Vr(n, e),
    o = new Vr([], e),
    s = st(e.get('data'), Zt(Rxt, t, r, e))
  r && (s = Ne(s, Zt(Ixt, r)))
  var l = VH(!!r, n)
  return (
    i.initData(
      st(s, function (u) {
        return u[0]
      }),
      null,
      l,
    ),
    a.initData(
      st(s, function (u) {
        return u[1]
      }),
      null,
      l,
    ),
    o.initData(
      st(s, function (u) {
        return u[2]
      }),
    ),
    (o.hasItemOption = !0),
    {
      from: i,
      to: a,
      line: o,
    }
  )
}
const kxt = Oxt
function Bxt(r) {
  r.registerComponentModel(Pxt),
    r.registerComponentView(kxt),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markLine') && (t.markLine = t.markLine || {})
    })
}
var Fxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markArea'),
    (t.defaultOption = {
      z: 1,
      tooltip: {
        trigger: 'item',
      },
      animation: !1,
      label: {
        show: !0,
        position: 'top',
      },
      itemStyle: {
        borderWidth: 0,
      },
      emphasis: {
        label: {
          show: !0,
          position: 'top',
        },
      },
    }),
    t
  )
})(hl)
const zxt = Fxt
var Dm = ve(),
  Uxt = function (r, t, e, n) {
    var i = n[0],
      a = n[1]
    if (!(!i || !a)) {
      var o = lv(r, i),
        s = lv(r, a),
        l = o.coord,
        u = s.coord
      ;(l[0] = nr(l[0], -1 / 0)),
        (l[1] = nr(l[1], -1 / 0)),
        (u[0] = nr(u[0], 1 / 0)),
        (u[1] = nr(u[1], 1 / 0))
      var c = ET([{}, o, s])
      return (
        (c.coord = [o.coord, s.coord]),
        (c.x0 = o.x),
        (c.y0 = o.y),
        (c.x1 = s.x),
        (c.y1 = s.y),
        c
      )
    }
  }
function w0(r) {
  return !isNaN(r) && !isFinite(r)
}
function W3(r, t, e, n) {
  var i = 1 - r
  return w0(t[i]) && w0(e[i])
}
function Vxt(r, t) {
  var e = t.coord[0],
    n = t.coord[1],
    i = {
      coord: e,
      x: t.x0,
      y: t.y0,
    },
    a = {
      coord: n,
      x: t.x1,
      y: t.y1,
    }
  return oc(r, 'cartesian2d')
    ? e && n && (W3(1, e, n) || W3(0, e, n))
      ? !0
      : wxt(r, i, a)
    : uv(r, i) || uv(r, a)
}
function X3(r, t, e, n, i) {
  var a = n.coordinateSystem,
    o = r.getItemModel(t),
    s,
    l = _t(o.get(e[0]), i.getWidth()),
    u = _t(o.get(e[1]), i.getHeight())
  if (!isNaN(l) && !isNaN(u)) s = [l, u]
  else {
    if (n.getMarkerPosition) {
      var c = r.getValues(['x0', 'y0'], t),
        h = r.getValues(['x1', 'y1'], t),
        f = a.clampData(c),
        d = a.clampData(h),
        p = []
      e[0] === 'x0'
        ? (p[0] = f[0] > d[0] ? h[0] : c[0])
        : (p[0] = f[0] > d[0] ? c[0] : h[0]),
        e[1] === 'y0'
          ? (p[1] = f[1] > d[1] ? h[1] : c[1])
          : (p[1] = f[1] > d[1] ? c[1] : h[1]),
        (s = n.getMarkerPosition(p, e, !0))
    } else {
      var g = r.get(e[0], t),
        v = r.get(e[1], t),
        m = [g, v]
      a.clampData && a.clampData(m, m), (s = a.dataToPoint(m, !0))
    }
    if (oc(a, 'cartesian2d')) {
      var y = a.getAxis('x'),
        _ = a.getAxis('y'),
        g = r.get(e[0], t),
        v = r.get(e[1], t)
      w0(g)
        ? (s[0] = y.toGlobalCoord(y.getExtent()[e[0] === 'x0' ? 0 : 1]))
        : w0(v) &&
          (s[1] = _.toGlobalCoord(_.getExtent()[e[1] === 'y0' ? 0 : 1]))
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
  }
  return s
}
var Y3 = [
    ['x0', 'y0'],
    ['x1', 'y0'],
    ['x1', 'y1'],
    ['x0', 'y1'],
  ],
  Gxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.updateTransform = function (e, n, i) {
        n.eachSeries(function (a) {
          var o = hl.getMarkerModelFromSeries(a, 'markArea')
          if (o) {
            var s = o.getData()
            s.each(function (l) {
              var u = st(Y3, function (h) {
                return X3(s, l, h, a, i)
              })
              s.setItemLayout(l, u)
              var c = s.getItemGraphicEl(l)
              c.setShape('points', u)
            })
          }
        }, this)
      }),
      (t.prototype.renderSeries = function (e, n, i, a) {
        var o = e.coordinateSystem,
          s = e.id,
          l = e.getData(),
          u = this.markerGroupMap,
          c =
            u.get(s) ||
            u.set(s, {
              group: new Ht(),
            })
        this.group.add(c.group), this.markKeep(c)
        var h = Hxt(o, e, n)
        n.setData(h),
          h.each(function (f) {
            var d = st(Y3, function (T) {
                return X3(h, f, T, e, a)
              }),
              p = o.getAxis('x').scale,
              g = o.getAxis('y').scale,
              v = p.getExtent(),
              m = g.getExtent(),
              y = [p.parse(h.get('x0', f)), p.parse(h.get('x1', f))],
              _ = [g.parse(h.get('y0', f)), g.parse(h.get('y1', f))]
            Zi(y), Zi(_)
            var x = !(v[0] > y[1] || v[1] < y[0] || m[0] > _[1] || m[1] < _[0]),
              A = !x
            h.setItemLayout(f, {
              points: d,
              allClipped: A,
            })
            var S = h.getItemModel(f).getModel('itemStyle').getItemStyle(),
              b = bv(l, 'color')
            S.fill || ((S.fill = b), bt(S.fill) && (S.fill = zy(S.fill, 0.4))),
              S.stroke || (S.stroke = b),
              h.setItemVisual(f, 'style', S)
          }),
          h
            .diff(Dm(c).data)
            .add(function (f) {
              var d = h.getItemLayout(f)
              if (!d.allClipped) {
                var p = new si({
                  shape: {
                    points: d.points,
                  },
                })
                h.setItemGraphicEl(f, p), c.group.add(p)
              }
            })
            .update(function (f, d) {
              var p = Dm(c).data.getItemGraphicEl(d),
                g = h.getItemLayout(f)
              g.allClipped
                ? p && c.group.remove(p)
                : (p
                    ? we(
                        p,
                        {
                          shape: {
                            points: g.points,
                          },
                        },
                        n,
                        f,
                      )
                    : (p = new si({
                        shape: {
                          points: g.points,
                        },
                      })),
                  h.setItemGraphicEl(f, p),
                  c.group.add(p))
            })
            .remove(function (f) {
              var d = Dm(c).data.getItemGraphicEl(f)
              c.group.remove(d)
            })
            .execute(),
          h.eachItemGraphicEl(function (f, d) {
            var p = h.getItemModel(d),
              g = h.getItemVisual(d, 'style')
            f.useStyle(h.getItemVisual(d, 'style')),
              mr(f, Zn(p), {
                labelFetcher: n,
                labelDataIndex: d,
                defaultText: h.getName(d) || '',
                inheritColor: bt(g.fill) ? zy(g.fill, 1) : '#000',
              }),
              gr(f, p),
              fn(f, null, null, p.get(['emphasis', 'disabled'])),
              (Wt(f).dataModel = n)
          }),
          (Dm(c).data = h),
          (c.group.silent = n.get('silent') || e.get('silent'))
      }),
      (t.type = 'markArea'),
      t
    )
  })(LE)
function Hxt(r, t, e) {
  var n,
    i,
    a = ['x0', 'y0', 'x1', 'y1']
  if (r) {
    var o = st(r && r.dimensions, function (u) {
      var c = t.getData(),
        h = c.getDimensionInfo(c.mapDimension(u)) || {}
      return Q(Q({}, h), {
        name: u,
        ordinalMeta: null,
      })
    })
    ;(i = st(a, function (u, c) {
      return {
        name: u,
        type: o[c % 2].type,
      }
    })),
      (n = new Vr(i, e))
  } else
    (i = [
      {
        name: 'value',
        type: 'float',
      },
    ]),
      (n = new Vr(i, e))
  var s = st(e.get('data'), Zt(Uxt, t, r, e))
  r && (s = Ne(s, Zt(Vxt, r)))
  var l = r
    ? function (u, c, h, f) {
        var d = u.coord[Math.floor(f / 2)][f % 2]
        return Js(d, i[f])
      }
    : function (u, c, h, f) {
        return Js(u.value, i[f])
      }
  return n.initData(s, null, l), (n.hasItemOption = !0), n
}
const Wxt = Gxt
function Xxt(r) {
  r.registerComponentModel(zxt),
    r.registerComponentView(Wxt),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markArea') && (t.markArea = t.markArea || {})
    })
}
var Yxt = function (r, t) {
    if (t === 'all')
      return {
        type: 'all',
        title: r.getLocaleModel().get(['legend', 'selector', 'all']),
      }
    if (t === 'inverse')
      return {
        type: 'inverse',
        title: r.getLocaleModel().get(['legend', 'selector', 'inverse']),
      }
  },
  $xt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i),
          (e.selected = e.selected || {}),
          this._updateSelector(e)
      }),
      (t.prototype.mergeOption = function (e, n) {
        r.prototype.mergeOption.call(this, e, n), this._updateSelector(e)
      }),
      (t.prototype._updateSelector = function (e) {
        var n = e.selector,
          i = this.ecModel
        n === !0 && (n = e.selector = ['all', 'inverse']),
          at(n) &&
            R(n, function (a, o) {
              bt(a) &&
                (a = {
                  type: a,
                }),
                (n[o] = te(a, Yxt(i, a.type)))
            })
      }),
      (t.prototype.optionUpdated = function () {
        this._updateData(this.ecModel)
        var e = this._data
        if (e[0] && this.get('selectedMode') === 'single') {
          for (var n = !1, i = 0; i < e.length; i++) {
            var a = e[i].get('name')
            if (this.isSelected(a)) {
              this.select(a), (n = !0)
              break
            }
          }
          !n && this.select(e[0].get('name'))
        }
      }),
      (t.prototype._updateData = function (e) {
        var n = [],
          i = []
        e.eachRawSeries(function (l) {
          var u = l.name
          i.push(u)
          var c
          if (l.legendVisualProvider) {
            var h = l.legendVisualProvider,
              f = h.getAllNames()
            e.isSeriesFiltered(l) || (i = i.concat(f)),
              f.length ? (n = n.concat(f)) : (c = !0)
          } else c = !0
          c && zT(l) && n.push(l.name)
        }),
          (this._availableNames = i)
        var a = this.get('data') || n,
          o = Pt(),
          s = st(
            a,
            function (l) {
              return (
                (bt(l) || be(l)) &&
                  (l = {
                    name: l,
                  }),
                o.get(l.name)
                  ? null
                  : (o.set(l.name, !0), new qe(l, this, this.ecModel))
              )
            },
            this,
          )
        this._data = Ne(s, function (l) {
          return !!l
        })
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.select = function (e) {
        var n = this.option.selected,
          i = this.get('selectedMode')
        if (i === 'single') {
          var a = this._data
          R(a, function (o) {
            n[o.get('name')] = !1
          })
        }
        n[e] = !0
      }),
      (t.prototype.unSelect = function (e) {
        this.get('selectedMode') !== 'single' && (this.option.selected[e] = !1)
      }),
      (t.prototype.toggleSelected = function (e) {
        var n = this.option.selected
        n.hasOwnProperty(e) || (n[e] = !0),
          this[n[e] ? 'unSelect' : 'select'](e)
      }),
      (t.prototype.allSelect = function () {
        var e = this._data,
          n = this.option.selected
        R(e, function (i) {
          n[i.get('name', !0)] = !0
        })
      }),
      (t.prototype.inverseSelect = function () {
        var e = this._data,
          n = this.option.selected
        R(e, function (i) {
          var a = i.get('name', !0)
          n.hasOwnProperty(a) || (n[a] = !0), (n[a] = !n[a])
        })
      }),
      (t.prototype.isSelected = function (e) {
        var n = this.option.selected
        return (
          !(n.hasOwnProperty(e) && !n[e]) && re(this._availableNames, e) >= 0
        )
      }),
      (t.prototype.getOrient = function () {
        return this.get('orient') === 'vertical'
          ? {
              index: 1,
              name: 'vertical',
            }
          : {
              index: 0,
              name: 'horizontal',
            }
      }),
      (t.type = 'legend.plain'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        z: 4,
        show: !0,
        orient: 'horizontal',
        left: 'center',
        top: 0,
        align: 'auto',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: 'inherit',
        symbolKeepAspect: !0,
        inactiveColor: '#ccc',
        inactiveBorderColor: '#ccc',
        inactiveBorderWidth: 'auto',
        itemStyle: {
          color: 'inherit',
          opacity: 'inherit',
          borderColor: 'inherit',
          borderWidth: 'auto',
          borderCap: 'inherit',
          borderJoin: 'inherit',
          borderDashOffset: 'inherit',
          borderMiterLimit: 'inherit',
        },
        lineStyle: {
          width: 'auto',
          color: 'inherit',
          inactiveColor: '#ccc',
          inactiveWidth: 2,
          opacity: 'inherit',
          type: 'inherit',
          cap: 'inherit',
          join: 'inherit',
          dashOffset: 'inherit',
          miterLimit: 'inherit',
        },
        textStyle: {
          color: '#333',
        },
        selectedMode: !0,
        selector: !1,
        selectorLabel: {
          show: !0,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: 'sans-serif',
          color: '#666',
          borderWidth: 1,
          borderColor: '#666',
        },
        emphasis: {
          selectorLabel: {
            show: !0,
            color: '#eee',
            backgroundColor: '#666',
          },
        },
        selectorPosition: 'auto',
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: !1,
        },
      }),
      t
    )
  })(xe)
const sM = $xt
var eh = Zt,
  lM = R,
  Lm = Ht,
  qxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.newlineDisabled = !1), e
    }
    return (
      (t.prototype.init = function () {
        this.group.add((this._contentGroup = new Lm())),
          this.group.add((this._selectorGroup = new Lm())),
          (this._isFirstRender = !0)
      }),
      (t.prototype.getContentGroup = function () {
        return this._contentGroup
      }),
      (t.prototype.getSelectorGroup = function () {
        return this._selectorGroup
      }),
      (t.prototype.render = function (e, n, i) {
        var a = this._isFirstRender
        if (
          ((this._isFirstRender = !1), this.resetInner(), !!e.get('show', !0))
        ) {
          var o = e.get('align'),
            s = e.get('orient')
          ;(!o || o === 'auto') &&
            (o =
              e.get('left') === 'right' && s === 'vertical' ? 'right' : 'left')
          var l = e.get('selector', !0),
            u = e.get('selectorPosition', !0)
          l &&
            (!u || u === 'auto') &&
            (u = s === 'horizontal' ? 'end' : 'start'),
            this.renderInner(o, e, n, i, l, s, u)
          var c = e.getBoxLayoutParams(),
            h = {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            f = e.get('padding'),
            d = Vn(c, h, f),
            p = this.layoutInner(e, o, d, a, l, u),
            g = Vn(
              zt(
                {
                  width: p.width,
                  height: p.height,
                },
                c,
              ),
              h,
              f,
            )
          ;(this.group.x = g.x - p.x),
            (this.group.y = g.y - p.y),
            this.group.markRedraw(),
            this.group.add((this._backgroundEl = DH(p, e)))
        }
      }),
      (t.prototype.resetInner = function () {
        this.getContentGroup().removeAll(),
          this._backgroundEl && this.group.remove(this._backgroundEl),
          this.getSelectorGroup().removeAll()
      }),
      (t.prototype.renderInner = function (e, n, i, a, o, s, l) {
        var u = this.getContentGroup(),
          c = Pt(),
          h = n.get('selectedMode'),
          f = []
        i.eachRawSeries(function (d) {
          !d.get('legendHoverLink') && f.push(d.id)
        }),
          lM(
            n.getData(),
            function (d, p) {
              var g = d.get('name')
              if (
                !this.newlineDisabled &&
                (g === '' ||
                  g ===
                    `
`)
              ) {
                var v = new Lm()
                ;(v.newline = !0), u.add(v)
                return
              }
              var m = i.getSeriesByName(g)[0]
              if (!c.get(g))
                if (m) {
                  var y = m.getData(),
                    _ = y.getVisual('legendLineStyle') || {},
                    x = y.getVisual('legendIcon'),
                    A = y.getVisual('style'),
                    S = this._createItem(m, g, p, d, n, e, _, A, x, h, a)
                  S.on('click', eh($3, g, null, a, f))
                    .on('mouseover', eh(uM, m.name, null, a, f))
                    .on('mouseout', eh(cM, m.name, null, a, f)),
                    i.ssr &&
                      S.eachChild(function (b) {
                        var T = Wt(b)
                        ;(T.seriesIndex = m.seriesIndex),
                          (T.dataIndex = p),
                          (T.ssrType = 'legend')
                      }),
                    c.set(g, !0)
                } else
                  i.eachRawSeries(function (b) {
                    if (!c.get(g) && b.legendVisualProvider) {
                      var T = b.legendVisualProvider
                      if (!T.containName(g)) return
                      var w = T.indexOfName(g),
                        M = T.getItemVisual(w, 'style'),
                        C = T.getItemVisual(w, 'legendIcon'),
                        E = wi(M.fill)
                      E &&
                        E[3] === 0 &&
                        ((E[3] = 0.2),
                        (M = Q(Q({}, M), {
                          fill: Wo(E, 'rgba'),
                        })))
                      var D = this._createItem(b, g, p, d, n, e, {}, M, C, h, a)
                      D.on('click', eh($3, null, g, a, f))
                        .on('mouseover', eh(uM, null, g, a, f))
                        .on('mouseout', eh(cM, null, g, a, f)),
                        i.ssr &&
                          D.eachChild(function (P) {
                            var L = Wt(P)
                            ;(L.seriesIndex = b.seriesIndex),
                              (L.dataIndex = p),
                              (L.ssrType = 'legend')
                          }),
                        c.set(g, !0)
                    }
                  }, this)
            },
            this,
          ),
          o && this._createSelector(o, n, a, s, l)
      }),
      (t.prototype._createSelector = function (e, n, i, a, o) {
        var s = this.getSelectorGroup()
        lM(e, function (u) {
          var c = u.type,
            h = new Ae({
              style: {
                x: 0,
                y: 0,
                align: 'center',
                verticalAlign: 'middle',
              },
              onclick: function () {
                i.dispatchAction({
                  type: c === 'all' ? 'legendAllSelect' : 'legendInverseSelect',
                })
              },
            })
          s.add(h)
          var f = n.getModel('selectorLabel'),
            d = n.getModel(['emphasis', 'selectorLabel'])
          mr(
            h,
            {
              normal: f,
              emphasis: d,
            },
            {
              defaultText: u.title,
            },
          ),
            Ou(h)
        })
      }),
      (t.prototype._createItem = function (e, n, i, a, o, s, l, u, c, h, f) {
        var d = e.visualDrawType,
          p = o.get('itemWidth'),
          g = o.get('itemHeight'),
          v = o.isSelected(n),
          m = a.get('symbolRotate'),
          y = a.get('symbolKeepAspect'),
          _ = a.get('icon')
        c = _ || c || 'roundRect'
        var x = Zxt(c, a, l, u, d, v, f),
          A = new Lm(),
          S = a.getModel('textStyle')
        if (Nt(e.getLegendIcon) && (!_ || _ === 'inherit'))
          A.add(
            e.getLegendIcon({
              itemWidth: p,
              itemHeight: g,
              icon: c,
              iconRotate: m,
              itemStyle: x.itemStyle,
              lineStyle: x.lineStyle,
              symbolKeepAspect: y,
            }),
          )
        else {
          var b =
            _ === 'inherit' && e.getData().getVisual('symbol')
              ? m === 'inherit'
                ? e.getData().getVisual('symbolRotate')
                : m
              : 0
          A.add(
            Kxt({
              itemWidth: p,
              itemHeight: g,
              icon: c,
              iconRotate: b,
              itemStyle: x.itemStyle,
              lineStyle: x.lineStyle,
              symbolKeepAspect: y,
            }),
          )
        }
        var T = s === 'left' ? p + 5 : -5,
          w = s,
          M = o.get('formatter'),
          C = n
        bt(M) && M ? (C = M.replace('{name}', n ?? '')) : Nt(M) && (C = M(n))
        var E = v ? S.getTextColor() : a.get('inactiveColor')
        A.add(
          new Ae({
            style: $e(
              S,
              {
                text: C,
                x: T,
                y: g / 2,
                fill: E,
                align: w,
                verticalAlign: 'middle',
              },
              {
                inheritColor: E,
              },
            ),
          }),
        )
        var D = new ge({
            shape: A.getBoundingRect(),
            style: {
              fill: 'transparent',
            },
          }),
          P = a.getModel('tooltip')
        return (
          P.get('show') &&
            Sf({
              el: D,
              componentModel: o,
              itemName: n,
              itemTooltipOption: P.option,
            }),
          A.add(D),
          A.eachChild(function (L) {
            L.silent = !0
          }),
          (D.silent = !h),
          this.getContentGroup().add(A),
          Ou(A),
          (A.__legendDataIndex = i),
          A
        )
      }),
      (t.prototype.layoutInner = function (e, n, i, a, o, s) {
        var l = this.getContentGroup(),
          u = this.getSelectorGroup()
        ku(e.get('orient'), l, e.get('itemGap'), i.width, i.height)
        var c = l.getBoundingRect(),
          h = [-c.x, -c.y]
        if ((u.markRedraw(), l.markRedraw(), o)) {
          ku('horizontal', u, e.get('selectorItemGap', !0))
          var f = u.getBoundingRect(),
            d = [-f.x, -f.y],
            p = e.get('selectorButtonGap', !0),
            g = e.getOrient().index,
            v = g === 0 ? 'width' : 'height',
            m = g === 0 ? 'height' : 'width',
            y = g === 0 ? 'y' : 'x'
          s === 'end' ? (d[g] += c[v] + p) : (h[g] += f[v] + p),
            (d[1 - g] += c[m] / 2 - f[m] / 2),
            (u.x = d[0]),
            (u.y = d[1]),
            (l.x = h[0]),
            (l.y = h[1])
          var _ = {
            x: 0,
            y: 0,
          }
          return (
            (_[v] = c[v] + p + f[v]),
            (_[m] = Math.max(c[m], f[m])),
            (_[y] = Math.min(0, f[y] + d[1 - g])),
            _
          )
        } else return (l.x = h[0]), (l.y = h[1]), this.group.getBoundingRect()
      }),
      (t.prototype.remove = function () {
        this.getContentGroup().removeAll(), (this._isFirstRender = !0)
      }),
      (t.type = 'legend.plain'),
      t
    )
  })(dn)
function Zxt(r, t, e, n, i, a, o) {
  function s(v, m) {
    v.lineWidth === 'auto' && (v.lineWidth = m.lineWidth > 0 ? 2 : 0),
      lM(v, function (y, _) {
        v[_] === 'inherit' && (v[_] = m[_])
      })
  }
  var l = t.getModel('itemStyle'),
    u = l.getItemStyle(),
    c = r.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke',
    h = l.getShallow('decal')
  ;(u.decal = !h || h === 'inherit' ? n.decal : rf(h, o)),
    u.fill === 'inherit' && (u.fill = n[i]),
    u.stroke === 'inherit' && (u.stroke = n[c]),
    u.opacity === 'inherit' && (u.opacity = (i === 'fill' ? n : e).opacity),
    s(u, n)
  var f = t.getModel('lineStyle'),
    d = f.getLineStyle()
  if (
    (s(d, e),
    u.fill === 'auto' && (u.fill = n.fill),
    u.stroke === 'auto' && (u.stroke = n.fill),
    d.stroke === 'auto' && (d.stroke = n.fill),
    !a)
  ) {
    var p = t.get('inactiveBorderWidth'),
      g = u[c]
    ;(u.lineWidth =
      p === 'auto' ? (n.lineWidth > 0 && g ? 2 : 0) : u.lineWidth),
      (u.fill = t.get('inactiveColor')),
      (u.stroke = t.get('inactiveBorderColor')),
      (d.stroke = f.get('inactiveColor')),
      (d.lineWidth = f.get('inactiveWidth'))
  }
  return {
    itemStyle: u,
    lineStyle: d,
  }
}
function Kxt(r) {
  var t = r.icon || 'roundRect',
    e = Rn(
      t,
      0,
      0,
      r.itemWidth,
      r.itemHeight,
      r.itemStyle.fill,
      r.symbolKeepAspect,
    )
  return (
    e.setStyle(r.itemStyle),
    (e.rotation = ((r.iconRotate || 0) * Math.PI) / 180),
    e.setOrigin([r.itemWidth / 2, r.itemHeight / 2]),
    t.indexOf('empty') > -1 &&
      ((e.style.stroke = e.style.fill),
      (e.style.fill = '#fff'),
      (e.style.lineWidth = 2)),
    e
  )
}
function $3(r, t, e, n) {
  cM(r, t, e, n),
    e.dispatchAction({
      type: 'legendToggleSelect',
      name: r ?? t,
    }),
    uM(r, t, e, n)
}
function GH(r) {
  for (
    var t = r.getZr().storage.getDisplayList(), e, n = 0, i = t.length;
    n < i && !(e = t[n].states.emphasis);

  )
    n++
  return e && e.hoverLayer
}
function uM(r, t, e, n) {
  GH(e) ||
    e.dispatchAction({
      type: 'highlight',
      seriesName: r,
      name: t,
      excludeSeriesId: n,
    })
}
function cM(r, t, e, n) {
  GH(e) ||
    e.dispatchAction({
      type: 'downplay',
      seriesName: r,
      name: t,
      excludeSeriesId: n,
    })
}
const HH = qxt
function jxt(r) {
  var t = r.findComponents({
    mainType: 'legend',
  })
  t &&
    t.length &&
    r.filterSeries(function (e) {
      for (var n = 0; n < t.length; n++) if (!t[n].isSelected(e.name)) return !1
      return !0
    })
}
function Sd(r, t, e) {
  var n = {},
    i = r === 'toggleSelected',
    a
  return (
    e.eachComponent('legend', function (o) {
      i && a != null
        ? o[a ? 'select' : 'unSelect'](t.name)
        : r === 'allSelect' || r === 'inverseSelect'
        ? o[r]()
        : (o[r](t.name), (a = o.isSelected(t.name)))
      var s = o.getData()
      R(s, function (l) {
        var u = l.get('name')
        if (
          !(
            u ===
              `
` || u === ''
          )
        ) {
          var c = o.isSelected(u)
          n.hasOwnProperty(u) ? (n[u] = n[u] && c) : (n[u] = c)
        }
      })
    }),
    r === 'allSelect' || r === 'inverseSelect'
      ? {
          selected: n,
        }
      : {
          name: t.name,
          selected: n,
        }
  )
}
function Jxt(r) {
  r.registerAction(
    'legendToggleSelect',
    'legendselectchanged',
    Zt(Sd, 'toggleSelected'),
  ),
    r.registerAction('legendAllSelect', 'legendselectall', Zt(Sd, 'allSelect')),
    r.registerAction(
      'legendInverseSelect',
      'legendinverseselect',
      Zt(Sd, 'inverseSelect'),
    ),
    r.registerAction('legendSelect', 'legendselected', Zt(Sd, 'select')),
    r.registerAction('legendUnSelect', 'legendunselected', Zt(Sd, 'unSelect'))
}
function WH(r) {
  r.registerComponentModel(sM),
    r.registerComponentView(HH),
    r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, jxt),
    r.registerSubTypeDefaulter('legend', function () {
      return 'plain'
    }),
    Jxt(r)
}
var Qxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.setScrollDataIndex = function (e) {
      this.option.scrollDataIndex = e
    }),
    (t.prototype.init = function (e, n, i) {
      var a = Mf(e)
      r.prototype.init.call(this, e, n, i), q3(this, e, a)
    }),
    (t.prototype.mergeOption = function (e, n) {
      r.prototype.mergeOption.call(this, e, n), q3(this, this.option, e)
    }),
    (t.type = 'legend.scroll'),
    (t.defaultOption = gl(sM.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: 'end',
      pageFormatter: '{current}/{total}',
      pageIcons: {
        horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
        vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z'],
      },
      pageIconColor: '#2f4554',
      pageIconInactiveColor: '#aaa',
      pageIconSize: 15,
      pageTextStyle: {
        color: '#333',
      },
      animationDurationUpdate: 800,
    })),
    t
  )
})(sM)
function q3(r, t, e) {
  var n = r.getOrient(),
    i = [1, 1]
  ;(i[n.index] = 0),
    ol(t, e, {
      type: 'box',
      ignoreSize: !!i,
    })
}
const t1t = Qxt
var Z3 = Ht,
  eA = ['width', 'height'],
  nA = ['x', 'y'],
  e1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type), (e.newlineDisabled = !0), (e._currentIndex = 0), e
      )
    }
    return (
      (t.prototype.init = function () {
        r.prototype.init.call(this),
          this.group.add((this._containerGroup = new Z3())),
          this._containerGroup.add(this.getContentGroup()),
          this.group.add((this._controllerGroup = new Z3()))
      }),
      (t.prototype.resetInner = function () {
        r.prototype.resetInner.call(this),
          this._controllerGroup.removeAll(),
          this._containerGroup.removeClipPath(),
          (this._containerGroup.__rectSize = null)
      }),
      (t.prototype.renderInner = function (e, n, i, a, o, s, l) {
        var u = this
        r.prototype.renderInner.call(this, e, n, i, a, o, s, l)
        var c = this._controllerGroup,
          h = n.get('pageIconSize', !0),
          f = at(h) ? h : [h, h]
        p('pagePrev', 0)
        var d = n.getModel('pageTextStyle')
        c.add(
          new Ae({
            name: 'pageText',
            style: {
              text: 'xx/xx',
              fill: d.getTextColor(),
              font: d.getFont(),
              verticalAlign: 'middle',
              align: 'center',
            },
            silent: !0,
          }),
        ),
          p('pageNext', 1)
        function p(g, v) {
          var m = g + 'DataIndex',
            y = Sv(
              n.get('pageIcons', !0)[n.getOrient().name][v],
              {
                onclick: Tt(u._pageGo, u, m, n, a),
              },
              {
                x: -f[0] / 2,
                y: -f[1] / 2,
                width: f[0],
                height: f[1],
              },
            )
          ;(y.name = g), c.add(y)
        }
      }),
      (t.prototype.layoutInner = function (e, n, i, a, o, s) {
        var l = this.getSelectorGroup(),
          u = e.getOrient().index,
          c = eA[u],
          h = nA[u],
          f = eA[1 - u],
          d = nA[1 - u]
        o && ku('horizontal', l, e.get('selectorItemGap', !0))
        var p = e.get('selectorButtonGap', !0),
          g = l.getBoundingRect(),
          v = [-g.x, -g.y],
          m = Vt(i)
        o && (m[c] = i[c] - g[c] - p)
        var y = this._layoutContentAndController(e, a, m, u, c, f, d, h)
        if (o) {
          if (s === 'end') v[u] += y[c] + p
          else {
            var _ = g[c] + p
            ;(v[u] -= _), (y[h] -= _)
          }
          ;(y[c] += g[c] + p),
            (v[1 - u] += y[d] + y[f] / 2 - g[f] / 2),
            (y[f] = Math.max(y[f], g[f])),
            (y[d] = Math.min(y[d], g[d] + v[1 - u])),
            (l.x = v[0]),
            (l.y = v[1]),
            l.markRedraw()
        }
        return y
      }),
      (t.prototype._layoutContentAndController = function (
        e,
        n,
        i,
        a,
        o,
        s,
        l,
        u,
      ) {
        var c = this.getContentGroup(),
          h = this._containerGroup,
          f = this._controllerGroup
        ku(
          e.get('orient'),
          c,
          e.get('itemGap'),
          a ? i.width : null,
          a ? null : i.height,
        ),
          ku('horizontal', f, e.get('pageButtonItemGap', !0))
        var d = c.getBoundingRect(),
          p = f.getBoundingRect(),
          g = (this._showController = d[o] > i[o]),
          v = [-d.x, -d.y]
        n || (v[a] = c[u])
        var m = [0, 0],
          y = [-p.x, -p.y],
          _ = $t(e.get('pageButtonGap', !0), e.get('itemGap', !0))
        if (g) {
          var x = e.get('pageButtonPosition', !0)
          x === 'end' ? (y[a] += i[o] - p[o]) : (m[a] += p[o] + _)
        }
        ;(y[1 - a] += d[s] / 2 - p[s] / 2),
          c.setPosition(v),
          h.setPosition(m),
          f.setPosition(y)
        var A = {
          x: 0,
          y: 0,
        }
        if (
          ((A[o] = g ? i[o] : d[o]),
          (A[s] = Math.max(d[s], p[s])),
          (A[l] = Math.min(0, p[l] + y[1 - a])),
          (h.__rectSize = i[o]),
          g)
        ) {
          var S = {
            x: 0,
            y: 0,
          }
          ;(S[o] = Math.max(i[o] - p[o] - _, 0)),
            (S[s] = A[s]),
            h.setClipPath(
              new ge({
                shape: S,
              }),
            ),
            (h.__rectSize = S[o])
        } else
          f.eachChild(function (T) {
            T.attr({
              invisible: !0,
              silent: !0,
            })
          })
        var b = this._getPageInfo(e)
        return (
          b.pageIndex != null &&
            we(
              c,
              {
                x: b.contentPosition[0],
                y: b.contentPosition[1],
              },
              g ? e : null,
            ),
          this._updatePageInfoView(e, b),
          A
        )
      }),
      (t.prototype._pageGo = function (e, n, i) {
        var a = this._getPageInfo(n)[e]
        a != null &&
          i.dispatchAction({
            type: 'legendScroll',
            scrollDataIndex: a,
            legendId: n.id,
          })
      }),
      (t.prototype._updatePageInfoView = function (e, n) {
        var i = this._controllerGroup
        R(['pagePrev', 'pageNext'], function (c) {
          var h = c + 'DataIndex',
            f = n[h] != null,
            d = i.childOfName(c)
          d &&
            (d.setStyle(
              'fill',
              f
                ? e.get('pageIconColor', !0)
                : e.get('pageIconInactiveColor', !0),
            ),
            (d.cursor = f ? 'pointer' : 'default'))
        })
        var a = i.childOfName('pageText'),
          o = e.get('pageFormatter'),
          s = n.pageIndex,
          l = s != null ? s + 1 : 0,
          u = n.pageCount
        a &&
          o &&
          a.setStyle(
            'text',
            bt(o)
              ? o
                  .replace('{current}', l == null ? '' : l + '')
                  .replace('{total}', u == null ? '' : u + '')
              : o({
                  current: l,
                  total: u,
                }),
          )
      }),
      (t.prototype._getPageInfo = function (e) {
        var n = e.get('scrollDataIndex', !0),
          i = this.getContentGroup(),
          a = this._containerGroup.__rectSize,
          o = e.getOrient().index,
          s = eA[o],
          l = nA[o],
          u = this._findTargetItemIndex(n),
          c = i.children(),
          h = c[u],
          f = c.length,
          d = f ? 1 : 0,
          p = {
            contentPosition: [i.x, i.y],
            pageCount: d,
            pageIndex: d - 1,
            pagePrevDataIndex: null,
            pageNextDataIndex: null,
          }
        if (!h) return p
        var g = x(h)
        p.contentPosition[o] = -g.s
        for (var v = u + 1, m = g, y = g, _ = null; v <= f; ++v)
          (_ = x(c[v])),
            ((!_ && y.e > m.s + a) || (_ && !A(_, m.s))) &&
              (y.i > m.i ? (m = y) : (m = _),
              m &&
                (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i),
                ++p.pageCount)),
            (y = _)
        for (var v = u - 1, m = g, y = g, _ = null; v >= -1; --v)
          (_ = x(c[v])),
            (!_ || !A(y, _.s)) &&
              m.i < y.i &&
              ((y = m),
              p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i),
              ++p.pageCount,
              ++p.pageIndex),
            (m = _)
        return p
        function x(S) {
          if (S) {
            var b = S.getBoundingRect(),
              T = b[l] + S[l]
            return {
              s: T,
              e: T + b[s],
              i: S.__legendDataIndex,
            }
          }
        }
        function A(S, b) {
          return S.e >= b && S.s <= b + a
        }
      }),
      (t.prototype._findTargetItemIndex = function (e) {
        if (!this._showController) return 0
        var n,
          i = this.getContentGroup(),
          a
        return (
          i.eachChild(function (o, s) {
            var l = o.__legendDataIndex
            a == null && l != null && (a = s), l === e && (n = s)
          }),
          n ?? a
        )
      }),
      (t.type = 'legend.scroll'),
      t
    )
  })(HH)
const n1t = e1t
function r1t(r) {
  r.registerAction('legendScroll', 'legendscroll', function (t, e) {
    var n = t.scrollDataIndex
    n != null &&
      e.eachComponent(
        {
          mainType: 'legend',
          subType: 'scroll',
          query: t,
        },
        function (i) {
          i.setScrollDataIndex(n)
        },
      )
  })
}
function i1t(r) {
  ie(WH), r.registerComponentModel(t1t), r.registerComponentView(n1t), r1t(r)
}
function a1t(r) {
  ie(WH), ie(i1t)
}
var o1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'dataZoom.inside'),
    (t.defaultOption = gl(sv.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0,
    })),
    t
  )
})(sv)
const s1t = o1t
var PE = ve()
function l1t(r, t, e) {
  PE(r).coordSysRecordMap.each(function (n) {
    var i = n.dataZoomInfoMap.get(t.uid)
    i && (i.getRange = e)
  })
}
function u1t(r, t) {
  for (
    var e = PE(r).coordSysRecordMap, n = e.keys(), i = 0;
    i < n.length;
    i++
  ) {
    var a = n[i],
      o = e.get(a),
      s = o.dataZoomInfoMap
    if (s) {
      var l = t.uid,
        u = s.get(l)
      u && (s.removeKey(l), s.keys().length || XH(e, o))
    }
  }
}
function XH(r, t) {
  if (t) {
    r.removeKey(t.model.uid)
    var e = t.controller
    e && e.dispose()
  }
}
function c1t(r, t) {
  var e = {
      model: t,
      containsPoint: Zt(f1t, t),
      dispatchAction: Zt(h1t, r),
      dataZoomInfoMap: null,
      controller: null,
    },
    n = (e.controller = new Rv(r.getZr()))
  return (
    R(['pan', 'zoom', 'scrollMove'], function (i) {
      n.on(i, function (a) {
        var o = []
        e.dataZoomInfoMap.each(function (s) {
          if (a.isAvailableBehavior(s.model.option)) {
            var l = (s.getRange || {})[i],
              u =
                l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a)
            !s.model.get('disabled', !0) &&
              u &&
              o.push({
                dataZoomId: s.model.id,
                start: u[0],
                end: u[1],
              })
          }
        }),
          o.length && e.dispatchAction(o)
      })
    }),
    e
  )
}
function h1t(r, t) {
  r.isDisposed() ||
    r.dispatchAction({
      type: 'dataZoom',
      animation: {
        easing: 'cubicOut',
        duration: 100,
      },
      batch: t,
    })
}
function f1t(r, t, e, n) {
  return r.coordinateSystem.containPoint([e, n])
}
function d1t(r) {
  var t,
    e = 'type_',
    n = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1,
    },
    i = !0
  return (
    r.each(function (a) {
      var o = a.model,
        s = o.get('disabled', !0) ? !1 : o.get('zoomLock', !0) ? 'move' : !0
      n[e + s] > n[e + t] && (t = s),
        (i = i && o.get('preventDefaultMouseMove', !0))
    }),
    {
      controlType: t,
      opt: {
        zoomOnMouseWheel: !0,
        moveOnMouseMove: !0,
        moveOnMouseWheel: !0,
        preventDefaultMouseMove: !!i,
      },
    }
  )
}
function p1t(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function (t, e) {
    var n = PE(e),
      i = n.coordSysRecordMap || (n.coordSysRecordMap = Pt())
    i.each(function (a) {
      a.dataZoomInfoMap = null
    }),
      t.eachComponent(
        {
          mainType: 'dataZoom',
          subType: 'inside',
        },
        function (a) {
          var o = TH(a)
          R(o.infoList, function (s) {
            var l = s.model.uid,
              u = i.get(l) || i.set(l, c1t(e, s.model)),
              c = u.dataZoomInfoMap || (u.dataZoomInfoMap = Pt())
            c.set(a.uid, {
              dzReferCoordSysInfo: s,
              model: a,
              getRange: null,
            })
          })
        },
      ),
      i.each(function (a) {
        var o = a.controller,
          s,
          l = a.dataZoomInfoMap
        if (l) {
          var u = l.keys()[0]
          u != null && (s = l.get(u))
        }
        if (!s) {
          XH(i, a)
          return
        }
        var c = d1t(l)
        o.enable(c.controlType, c.opt),
          o.setPointerChecker(a.containsPoint),
          Df(a, 'dispatchAction', s.model.get('throttle', !0), 'fixRate')
      })
  })
}
var v1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataZoom.inside'), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        if ((r.prototype.render.apply(this, arguments), e.noTarget())) {
          this._clear()
          return
        }
        ;(this.range = e.getPercentRange()),
          l1t(i, e, {
            pan: Tt(rA.pan, this),
            zoom: Tt(rA.zoom, this),
            scrollMove: Tt(rA.scrollMove, this),
          })
      }),
      (t.prototype.dispose = function () {
        this._clear(), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        u1t(this.api, this.dataZoomModel), (this.range = null)
      }),
      (t.type = 'dataZoom.inside'),
      t
    )
  })(AE),
  rA = {
    zoom: function (r, t, e, n) {
      var i = this.range,
        a = i.slice(),
        o = r.axisModels[0]
      if (o) {
        var s = iA[t](null, [n.originX, n.originY], o, e, r),
          l =
            ((s.signal > 0
              ? s.pixelStart + s.pixelLength - s.pixel
              : s.pixel - s.pixelStart) /
              s.pixelLength) *
              (a[1] - a[0]) +
            a[0],
          u = Math.max(1 / n.scale, 0)
        ;(a[0] = (a[0] - l) * u + l), (a[1] = (a[1] - l) * u + l)
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan()
        if (
          (lc(0, a, [0, 100], 0, c.minSpan, c.maxSpan),
          (this.range = a),
          i[0] !== a[0] || i[1] !== a[1])
        )
          return a
      }
    },
    pan: K3(function (r, t, e, n, i, a) {
      var o = iA[n]([a.oldX, a.oldY], [a.newX, a.newY], t, i, e)
      return (o.signal * (r[1] - r[0]) * o.pixel) / o.pixelLength
    }),
    scrollMove: K3(function (r, t, e, n, i, a) {
      var o = iA[n]([0, 0], [a.scrollDelta, a.scrollDelta], t, i, e)
      return o.signal * (r[1] - r[0]) * a.scrollDelta
    }),
  }
function K3(r) {
  return function (t, e, n, i) {
    var a = this.range,
      o = a.slice(),
      s = t.axisModels[0]
    if (s) {
      var l = r(o, s, t, e, n, i)
      if (
        (lc(l, o, [0, 100], 'all'),
        (this.range = o),
        a[0] !== o[0] || a[1] !== o[1])
      )
        return o
    }
  }
}
var iA = {
  grid: function (r, t, e, n, i) {
    var a = e.axis,
      o = {},
      s = i.model.coordinateSystem.getRect()
    return (
      (r = r || [0, 0]),
      a.dim === 'x'
        ? ((o.pixel = t[0] - r[0]),
          (o.pixelLength = s.width),
          (o.pixelStart = s.x),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - r[1]),
          (o.pixelLength = s.height),
          (o.pixelStart = s.y),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  polar: function (r, t, e, n, i) {
    var a = e.axis,
      o = {},
      s = i.model.coordinateSystem,
      l = s.getRadiusAxis().getExtent(),
      u = s.getAngleAxis().getExtent()
    return (
      (r = r ? s.pointToCoord(r) : [0, 0]),
      (t = s.pointToCoord(t)),
      e.mainType === 'radiusAxis'
        ? ((o.pixel = t[0] - r[0]),
          (o.pixelLength = l[1] - l[0]),
          (o.pixelStart = l[0]),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - r[1]),
          (o.pixelLength = u[1] - u[0]),
          (o.pixelStart = u[0]),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  singleAxis: function (r, t, e, n, i) {
    var a = e.axis,
      o = i.model.coordinateSystem.getRect(),
      s = {}
    return (
      (r = r || [0, 0]),
      a.orient === 'horizontal'
        ? ((s.pixel = t[0] - r[0]),
          (s.pixelLength = o.width),
          (s.pixelStart = o.x),
          (s.signal = a.inverse ? 1 : -1))
        : ((s.pixel = t[1] - r[1]),
          (s.pixelLength = o.height),
          (s.pixelStart = o.y),
          (s.signal = a.inverse ? -1 : 1)),
      s
    )
  },
}
const g1t = v1t
function YH(r) {
  bE(r), r.registerComponentModel(s1t), r.registerComponentView(g1t), p1t(r)
}
var m1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'dataZoom.slider'),
    (t.layoutMode = 'box'),
    (t.defaultOption = gl(sv.defaultOption, {
      show: !0,
      right: 'ph',
      top: 'ph',
      width: 'ph',
      height: 'ph',
      left: null,
      bottom: null,
      borderColor: '#d2dbee',
      borderRadius: 3,
      backgroundColor: 'rgba(47,69,84,0)',
      dataBackground: {
        lineStyle: {
          color: '#d2dbee',
          width: 0.5,
        },
        areaStyle: {
          color: '#d2dbee',
          opacity: 0.2,
        },
      },
      selectedDataBackground: {
        lineStyle: {
          color: '#8fb0f7',
          width: 0.5,
        },
        areaStyle: {
          color: '#8fb0f7',
          opacity: 0.2,
        },
      },
      fillerColor: 'rgba(135,175,274,0.2)',
      handleIcon:
        'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
      handleSize: '100%',
      handleStyle: {
        color: '#fff',
        borderColor: '#ACB8D1',
      },
      moveHandleSize: 7,
      moveHandleIcon:
        'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
      moveHandleStyle: {
        color: '#D2DBEE',
        opacity: 0.7,
      },
      showDetail: !0,
      showDataShadow: 'auto',
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: '#6E7079',
      },
      brushSelect: !0,
      brushStyle: {
        color: 'rgba(135,175,274,0.15)',
      },
      emphasis: {
        handleStyle: {
          borderColor: '#8FB0F7',
        },
        moveHandleStyle: {
          color: '#8FB0F7',
        },
      },
    })),
    t
  )
})(sv)
const y1t = m1t
var Ad = ge,
  j3 = 7,
  _1t = 1,
  aA = 30,
  x1t = 7,
  bd = 'horizontal',
  J3 = 'vertical',
  S1t = 5,
  A1t = ['line', 'bar', 'candlestick', 'scatter'],
  b1t = {
    easing: 'cubicOut',
    duration: 100,
    delay: 0,
  },
  w1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._displayables = {}), e
    }
    return (
      (t.prototype.init = function (e, n) {
        ;(this.api = n),
          (this._onBrush = Tt(this._onBrush, this)),
          (this._onBrushEnd = Tt(this._onBrushEnd, this))
      }),
      (t.prototype.render = function (e, n, i, a) {
        if (
          (r.prototype.render.apply(this, arguments),
          Df(this, '_dispatchZoomAction', e.get('throttle'), 'fixRate'),
          (this._orient = e.getOrient()),
          e.get('show') === !1)
        ) {
          this.group.removeAll()
          return
        }
        if (e.noTarget()) {
          this._clear(), this.group.removeAll()
          return
        }
        ;(!a || a.type !== 'dataZoom' || a.from !== this.uid) &&
          this._buildView(),
          this._updateView()
      }),
      (t.prototype.dispose = function () {
        this._clear(), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        Zp(this, '_dispatchZoomAction')
        var e = this.api.getZr()
        e.off('mousemove', this._onBrush), e.off('mouseup', this._onBrushEnd)
      }),
      (t.prototype._buildView = function () {
        var e = this.group
        e.removeAll(),
          (this._brushing = !1),
          (this._displayables.brushRect = null),
          this._resetLocation(),
          this._resetInterval()
        var n = (this._displayables.sliderGroup = new Ht())
        this._renderBackground(),
          this._renderHandle(),
          this._renderDataShadow(),
          e.add(n),
          this._positionGroup()
      }),
      (t.prototype._resetLocation = function () {
        var e = this.dataZoomModel,
          n = this.api,
          i = e.get('brushSelect'),
          a = i ? x1t : 0,
          o = this._findCoordRect(),
          s = {
            width: n.getWidth(),
            height: n.getHeight(),
          },
          l =
            this._orient === bd
              ? {
                  right: s.width - o.x - o.width,
                  top: s.height - aA - j3 - a,
                  width: o.width,
                  height: aA,
                }
              : {
                  right: j3,
                  top: o.y,
                  width: aA,
                  height: o.height,
                },
          u = Mf(e.option)
        R(['right', 'top', 'width', 'height'], function (h) {
          u[h] === 'ph' && (u[h] = l[h])
        })
        var c = Vn(u, s)
        ;(this._location = {
          x: c.x,
          y: c.y,
        }),
          (this._size = [c.width, c.height]),
          this._orient === J3 && this._size.reverse()
      }),
      (t.prototype._positionGroup = function () {
        var e = this.group,
          n = this._location,
          i = this._orient,
          a = this.dataZoomModel.getFirstTargetAxisModel(),
          o = a && a.get('inverse'),
          s = this._displayables.sliderGroup,
          l = (this._dataShadowInfo || {}).otherAxisInverse
        s.attr(
          i === bd && !o
            ? {
                scaleY: l ? 1 : -1,
                scaleX: 1,
              }
            : i === bd && o
            ? {
                scaleY: l ? 1 : -1,
                scaleX: -1,
              }
            : i === J3 && !o
            ? {
                scaleY: l ? -1 : 1,
                scaleX: 1,
                rotation: Math.PI / 2,
              }
            : {
                scaleY: l ? -1 : 1,
                scaleX: -1,
                rotation: Math.PI / 2,
              },
        )
        var u = e.getBoundingRect([s])
        ;(e.x = n.x - u.x), (e.y = n.y - u.y), e.markRedraw()
      }),
      (t.prototype._getViewExtent = function () {
        return [0, this._size[0]]
      }),
      (t.prototype._renderBackground = function () {
        var e = this.dataZoomModel,
          n = this._size,
          i = this._displayables.sliderGroup,
          a = e.get('brushSelect')
        i.add(
          new Ad({
            silent: !0,
            shape: {
              x: 0,
              y: 0,
              width: n[0],
              height: n[1],
            },
            style: {
              fill: e.get('backgroundColor'),
            },
            z2: -40,
          }),
        )
        var o = new Ad({
            shape: {
              x: 0,
              y: 0,
              width: n[0],
              height: n[1],
            },
            style: {
              fill: 'transparent',
            },
            z2: 0,
            onclick: Tt(this._onClickPanel, this),
          }),
          s = this.api.getZr()
        a
          ? (o.on('mousedown', this._onBrushStart, this),
            (o.cursor = 'crosshair'),
            s.on('mousemove', this._onBrush),
            s.on('mouseup', this._onBrushEnd))
          : (s.off('mousemove', this._onBrush),
            s.off('mouseup', this._onBrushEnd)),
          i.add(o)
      }),
      (t.prototype._renderDataShadow = function () {
        var e = (this._dataShadowInfo = this._prepareDataShadowInfo())
        if (((this._displayables.dataShadowSegs = []), !e)) return
        var n = this._size,
          i = this._shadowSize || [],
          a = e.series,
          o = a.getRawData(),
          s = a.getShadowDim && a.getShadowDim(),
          l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim
        if (l == null) return
        var u = this._shadowPolygonPts,
          c = this._shadowPolylinePts
        if (
          o !== this._shadowData ||
          l !== this._shadowDim ||
          n[0] !== i[0] ||
          n[1] !== i[1]
        ) {
          var h = o.getDataExtent(l),
            f = (h[1] - h[0]) * 0.3
          h = [h[0] - f, h[1] + f]
          var d = [0, n[1]],
            p = [0, n[0]],
            g = [
              [n[0], 0],
              [0, 0],
            ],
            v = [],
            m = p[1] / (o.count() - 1),
            y = 0,
            _ = Math.round(o.count() / n[0]),
            x
          o.each([l], function (w, M) {
            if (_ > 0 && M % _) {
              y += m
              return
            }
            var C = w == null || isNaN(w) || w === '',
              E = C ? 0 : Re(w, h, d, !0)
            C && !x && M
              ? (g.push([g[g.length - 1][0], 0]),
                v.push([v[v.length - 1][0], 0]))
              : !C && x && (g.push([y, 0]), v.push([y, 0])),
              g.push([y, E]),
              v.push([y, E]),
              (y += m),
              (x = C)
          }),
            (u = this._shadowPolygonPts = g),
            (c = this._shadowPolylinePts = v)
        }
        ;(this._shadowData = o),
          (this._shadowDim = l),
          (this._shadowSize = [n[0], n[1]])
        var A = this.dataZoomModel
        function S(w) {
          var M = A.getModel(w ? 'selectedDataBackground' : 'dataBackground'),
            C = new Ht(),
            E = new si({
              shape: {
                points: u,
              },
              segmentIgnoreThreshold: 1,
              style: M.getModel('areaStyle').getAreaStyle(),
              silent: !0,
              z2: -20,
            }),
            D = new li({
              shape: {
                points: c,
              },
              segmentIgnoreThreshold: 1,
              style: M.getModel('lineStyle').getLineStyle(),
              silent: !0,
              z2: -19,
            })
          return C.add(E), C.add(D), C
        }
        for (var b = 0; b < 3; b++) {
          var T = S(b === 1)
          this._displayables.sliderGroup.add(T),
            this._displayables.dataShadowSegs.push(T)
        }
      }),
      (t.prototype._prepareDataShadowInfo = function () {
        var e = this.dataZoomModel,
          n = e.get('showDataShadow')
        if (n !== !1) {
          var i,
            a = this.ecModel
          return (
            e.eachTargetAxis(function (o, s) {
              var l = e.getAxisProxy(o, s).getTargetSeriesModels()
              R(
                l,
                function (u) {
                  if (!i && !(n !== !0 && re(A1t, u.get('type')) < 0)) {
                    var c = a.getComponent(Ws(o), s).axis,
                      h = M1t(o),
                      f,
                      d = u.coordinateSystem
                    h != null &&
                      d.getOtherAxis &&
                      (f = d.getOtherAxis(c).inverse),
                      (h = u.getData().mapDimension(h)),
                      (i = {
                        thisAxis: c,
                        series: u,
                        thisDim: o,
                        otherDim: h,
                        otherAxisInverse: f,
                      })
                  }
                },
                this,
              )
            }, this),
            i
          )
        }
      }),
      (t.prototype._renderHandle = function () {
        var e = this.group,
          n = this._displayables,
          i = (n.handles = [null, null]),
          a = (n.handleLabels = [null, null]),
          o = this._displayables.sliderGroup,
          s = this._size,
          l = this.dataZoomModel,
          u = this.api,
          c = l.get('borderRadius') || 0,
          h = l.get('brushSelect'),
          f = (n.filler = new Ad({
            silent: h,
            style: {
              fill: l.get('fillerColor'),
            },
            textConfig: {
              position: 'inside',
            },
          }))
        o.add(f),
          o.add(
            new Ad({
              silent: !0,
              subPixelOptimize: !0,
              shape: {
                x: 0,
                y: 0,
                width: s[0],
                height: s[1],
                r: c,
              },
              style: {
                stroke: l.get('dataBackgroundColor') || l.get('borderColor'),
                lineWidth: _1t,
                fill: 'rgba(0,0,0,0)',
              },
            }),
          ),
          R(
            [0, 1],
            function (_) {
              var x = l.get('handleIcon')
              !t0[x] &&
                x.indexOf('path://') < 0 &&
                x.indexOf('image://') < 0 &&
                (x = 'path://' + x)
              var A = Rn(x, -1, 0, 2, 2, null, !0)
              A.attr({
                cursor: Q3(this._orient),
                draggable: !0,
                drift: Tt(this._onDragMove, this, _),
                ondragend: Tt(this._onDragEnd, this),
                onmouseover: Tt(this._showDataInfo, this, !0),
                onmouseout: Tt(this._showDataInfo, this, !1),
                z2: 5,
              })
              var S = A.getBoundingRect(),
                b = l.get('handleSize')
              ;(this._handleHeight = _t(b, this._size[1])),
                (this._handleWidth = (S.width / S.height) * this._handleHeight),
                A.setStyle(l.getModel('handleStyle').getItemStyle()),
                (A.style.strokeNoScale = !0),
                (A.rectHover = !0),
                (A.ensureState('emphasis').style = l
                  .getModel(['emphasis', 'handleStyle'])
                  .getItemStyle()),
                Ou(A)
              var T = l.get('handleColor')
              T != null && (A.style.fill = T), o.add((i[_] = A))
              var w = l.getModel('textStyle')
              e.add(
                (a[_] = new Ae({
                  silent: !0,
                  invisible: !0,
                  style: $e(w, {
                    x: 0,
                    y: 0,
                    text: '',
                    verticalAlign: 'middle',
                    align: 'center',
                    fill: w.getTextColor(),
                    font: w.getFont(),
                  }),
                  z2: 10,
                })),
              )
            },
            this,
          )
        var d = f
        if (h) {
          var p = _t(l.get('moveHandleSize'), s[1]),
            g = (n.moveHandle = new ge({
              style: l.getModel('moveHandleStyle').getItemStyle(),
              silent: !0,
              shape: {
                r: [0, 0, 2, 2],
                y: s[1] - 0.5,
                height: p,
              },
            })),
            v = p * 0.8,
            m = (n.moveHandleIcon = Rn(
              l.get('moveHandleIcon'),
              -v / 2,
              -v / 2,
              v,
              v,
              '#fff',
              !0,
            ))
          ;(m.silent = !0),
            (m.y = s[1] + p / 2 - 0.5),
            (g.ensureState('emphasis').style = l
              .getModel(['emphasis', 'moveHandleStyle'])
              .getItemStyle())
          var y = Math.min(s[1] / 2, Math.max(p, 10))
          ;(d = n.moveZone =
            new ge({
              invisible: !0,
              shape: {
                y: s[1] - y,
                height: p + y,
              },
            })),
            d
              .on('mouseover', function () {
                u.enterEmphasis(g)
              })
              .on('mouseout', function () {
                u.leaveEmphasis(g)
              }),
            o.add(g),
            o.add(m),
            o.add(d)
        }
        d.attr({
          draggable: !0,
          cursor: Q3(this._orient),
          drift: Tt(this._onDragMove, this, 'all'),
          ondragstart: Tt(this._showDataInfo, this, !0),
          ondragend: Tt(this._onDragEnd, this),
          onmouseover: Tt(this._showDataInfo, this, !0),
          onmouseout: Tt(this._showDataInfo, this, !1),
        })
      }),
      (t.prototype._resetInterval = function () {
        var e = (this._range = this.dataZoomModel.getPercentRange()),
          n = this._getViewExtent()
        this._handleEnds = [
          Re(e[0], [0, 100], n, !0),
          Re(e[1], [0, 100], n, !0),
        ]
      }),
      (t.prototype._updateInterval = function (e, n) {
        var i = this.dataZoomModel,
          a = this._handleEnds,
          o = this._getViewExtent(),
          s = i.findRepresentativeAxisProxy().getMinMaxSpan(),
          l = [0, 100]
        lc(
          n,
          a,
          o,
          i.get('zoomLock') ? 'all' : e,
          s.minSpan != null ? Re(s.minSpan, l, o, !0) : null,
          s.maxSpan != null ? Re(s.maxSpan, l, o, !0) : null,
        )
        var u = this._range,
          c = (this._range = Zi([Re(a[0], o, l, !0), Re(a[1], o, l, !0)]))
        return !u || u[0] !== c[0] || u[1] !== c[1]
      }),
      (t.prototype._updateView = function (e) {
        var n = this._displayables,
          i = this._handleEnds,
          a = Zi(i.slice()),
          o = this._size
        R(
          [0, 1],
          function (d) {
            var p = n.handles[d],
              g = this._handleHeight
            p.attr({
              scaleX: g / 2,
              scaleY: g / 2,
              x: i[d] + (d ? -1 : 1),
              y: o[1] / 2 - g / 2,
            })
          },
          this,
        ),
          n.filler.setShape({
            x: a[0],
            y: 0,
            width: a[1] - a[0],
            height: o[1],
          })
        var s = {
          x: a[0],
          width: a[1] - a[0],
        }
        n.moveHandle &&
          (n.moveHandle.setShape(s),
          n.moveZone.setShape(s),
          n.moveZone.getBoundingRect(),
          n.moveHandleIcon && n.moveHandleIcon.attr('x', s.x + s.width / 2))
        for (
          var l = n.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0;
          c < l.length;
          c++
        ) {
          var h = l[c],
            f = h.getClipPath()
          f || ((f = new ge()), h.setClipPath(f)),
            f.setShape({
              x: u[c],
              y: 0,
              width: u[c + 1] - u[c],
              height: o[1],
            })
        }
        this._updateDataInfo(e)
      }),
      (t.prototype._updateDataInfo = function (e) {
        var n = this.dataZoomModel,
          i = this._displayables,
          a = i.handleLabels,
          o = this._orient,
          s = ['', '']
        if (n.get('showDetail')) {
          var l = n.findRepresentativeAxisProxy()
          if (l) {
            var u = l.getAxisModel().axis,
              c = this._range,
              h = e
                ? l.calculateDataWindow({
                    start: c[0],
                    end: c[1],
                  }).valueWindow
                : l.getDataValueWindow()
            s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)]
          }
        }
        var f = Zi(this._handleEnds.slice())
        d.call(this, 0), d.call(this, 1)
        function d(p) {
          var g = Nu(i.handles[p].parent, this.group),
            v = s_(p === 0 ? 'right' : 'left', g),
            m = this._handleWidth / 2 + S1t,
            y = ba([f[p] + (p === 0 ? -m : m), this._size[1] / 2], g)
          a[p].setStyle({
            x: y[0],
            y: y[1],
            verticalAlign: o === bd ? 'middle' : v,
            align: o === bd ? v : 'center',
            text: s[p],
          })
        }
      }),
      (t.prototype._formatLabel = function (e, n) {
        var i = this.dataZoomModel,
          a = i.get('labelFormatter'),
          o = i.get('labelPrecision')
        ;(o == null || o === 'auto') && (o = n.getPixelPrecision())
        var s =
          e == null || isNaN(e)
            ? ''
            : n.type === 'category' || n.type === 'time'
            ? n.scale.getLabel({
                value: Math.round(e),
              })
            : e.toFixed(Math.min(o, 20))
        return Nt(a) ? a(e, s) : bt(a) ? a.replace('{value}', s) : s
      }),
      (t.prototype._showDataInfo = function (e) {
        e = this._dragging || e
        var n = this._displayables,
          i = n.handleLabels
        i[0].attr('invisible', !e),
          i[1].attr('invisible', !e),
          n.moveHandle &&
            this.api[e ? 'enterEmphasis' : 'leaveEmphasis'](n.moveHandle, 1)
      }),
      (t.prototype._onDragMove = function (e, n, i, a) {
        ;(this._dragging = !0), jo(a.event)
        var o = this._displayables.sliderGroup.getLocalTransform(),
          s = ba([n, i], o, !0),
          l = this._updateInterval(e, s[0]),
          u = this.dataZoomModel.get('realtime')
        this._updateView(!u), l && u && this._dispatchZoomAction(!0)
      }),
      (t.prototype._onDragEnd = function () {
        ;(this._dragging = !1), this._showDataInfo(!1)
        var e = this.dataZoomModel.get('realtime')
        !e && this._dispatchZoomAction(!1)
      }),
      (t.prototype._onClickPanel = function (e) {
        var n = this._size,
          i = this._displayables.sliderGroup.transformCoordToLocal(
            e.offsetX,
            e.offsetY,
          )
        if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
          var a = this._handleEnds,
            o = (a[0] + a[1]) / 2,
            s = this._updateInterval('all', i[0] - o)
          this._updateView(), s && this._dispatchZoomAction(!1)
        }
      }),
      (t.prototype._onBrushStart = function (e) {
        var n = e.offsetX,
          i = e.offsetY
        ;(this._brushStart = new Qt(n, i)),
          (this._brushing = !0),
          (this._brushStartTime = +new Date())
      }),
      (t.prototype._onBrushEnd = function (e) {
        if (this._brushing) {
          var n = this._displayables.brushRect
          if (((this._brushing = !1), !!n)) {
            n.attr('ignore', !0)
            var i = n.shape,
              a = +new Date()
            if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
              var o = this._getViewExtent(),
                s = [0, 100]
              ;(this._range = Zi([
                Re(i.x, o, s, !0),
                Re(i.x + i.width, o, s, !0),
              ])),
                (this._handleEnds = [i.x, i.x + i.width]),
                this._updateView(),
                this._dispatchZoomAction(!1)
            }
          }
        }
      }),
      (t.prototype._onBrush = function (e) {
        this._brushing &&
          (jo(e.event), this._updateBrushRect(e.offsetX, e.offsetY))
      }),
      (t.prototype._updateBrushRect = function (e, n) {
        var i = this._displayables,
          a = this.dataZoomModel,
          o = i.brushRect
        o ||
          ((o = i.brushRect =
            new Ad({
              silent: !0,
              style: a.getModel('brushStyle').getItemStyle(),
            })),
          i.sliderGroup.add(o)),
          o.attr('ignore', !1)
        var s = this._brushStart,
          l = this._displayables.sliderGroup,
          u = l.transformCoordToLocal(e, n),
          c = l.transformCoordToLocal(s.x, s.y),
          h = this._size
        ;(u[0] = Math.max(Math.min(h[0], u[0]), 0)),
          o.setShape({
            x: c[0],
            y: 0,
            width: u[0] - c[0],
            height: h[1],
          })
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var n = this._range
        this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          animation: e ? b1t : null,
          start: n[0],
          end: n[1],
        })
      }),
      (t.prototype._findCoordRect = function () {
        var e,
          n = TH(this.dataZoomModel).infoList
        if (!e && n.length) {
          var i = n[0].model.coordinateSystem
          e = i.getRect && i.getRect()
        }
        if (!e) {
          var a = this.api.getWidth(),
            o = this.api.getHeight()
          e = {
            x: a * 0.2,
            y: o * 0.2,
            width: a * 0.6,
            height: o * 0.6,
          }
        }
        return e
      }),
      (t.type = 'dataZoom.slider'),
      t
    )
  })(AE)
function M1t(r) {
  var t = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius',
  }
  return t[r]
}
function Q3(r) {
  return r === 'vertical' ? 'ns-resize' : 'ew-resize'
}
const T1t = w1t
function $H(r) {
  r.registerComponentModel(y1t), r.registerComponentView(T1t), bE(r)
}
function C1t(r) {
  ie(YH), ie($H)
}
var E1t = {
    get: function (r, t, e) {
      var n = Vt((D1t[r] || {})[t])
      return e && at(n) ? n[n.length - 1] : n
    },
  },
  D1t = {
    color: {
      active: ['#006edd', '#e0ffff'],
      inactive: ['rgba(0,0,0,0)'],
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0],
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0],
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    symbol: {
      active: ['circle', 'roundRect', 'diamond'],
      inactive: ['none'],
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0],
    },
  }
const qH = E1t
var tk = vr.mapVisual,
  L1t = vr.eachVisual,
  P1t = at,
  ek = R,
  R1t = Zi,
  I1t = Re,
  O1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.stateList = ['inRange', 'outOfRange']),
        (e.replacableOptionKeys = [
          'inRange',
          'outOfRange',
          'target',
          'controller',
          'color',
        ]),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        (e.dataBound = [-1 / 0, 1 / 0]),
        (e.targetVisuals = {}),
        (e.controllerVisuals = {}),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i)
      }),
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option
        !n && kH(i, e, this.replacableOptionKeys),
          (this.textStyleModel = this.getModel('textStyle')),
          this.resetItemSize(),
          this.completeVisualOption()
      }),
      (t.prototype.resetVisual = function (e) {
        var n = this.stateList
        ;(e = Tt(e, this)),
          (this.controllerVisuals = iM(this.option.controller, n, e)),
          (this.targetVisuals = iM(this.option.target, n, e))
      }),
      (t.prototype.getItemSymbol = function () {
        return null
      }),
      (t.prototype.getTargetSeriesIndices = function () {
        var e = this.option.seriesIndex,
          n = []
        return (
          e == null || e === 'all'
            ? this.ecModel.eachSeries(function (i, a) {
                n.push(a)
              })
            : (n = ke(e)),
          n
        )
      }),
      (t.prototype.eachTargetSeries = function (e, n) {
        R(
          this.getTargetSeriesIndices(),
          function (i) {
            var a = this.ecModel.getSeriesByIndex(i)
            a && e.call(n, a)
          },
          this,
        )
      }),
      (t.prototype.isTargetSeries = function (e) {
        var n = !1
        return (
          this.eachTargetSeries(function (i) {
            i === e && (n = !0)
          }),
          n
        )
      }),
      (t.prototype.formatValueText = function (e, n, i) {
        var a = this.option,
          o = a.precision,
          s = this.dataBound,
          l = a.formatter,
          u
        ;(i = i || ['<', '>']), at(e) && ((e = e.slice()), (u = !0))
        var c = n ? e : u ? [h(e[0]), h(e[1])] : h(e)
        if (bt(l))
          return l
            .replace('{value}', u ? c[0] : c)
            .replace('{value2}', u ? c[1] : c)
        if (Nt(l)) return u ? l(e[0], e[1]) : l(e)
        if (u)
          return e[0] === s[0]
            ? i[0] + ' ' + c[1]
            : e[1] === s[1]
            ? i[1] + ' ' + c[0]
            : c[0] + ' - ' + c[1]
        return c
        function h(f) {
          return f === s[0]
            ? 'min'
            : f === s[1]
            ? 'max'
            : (+f).toFixed(Math.min(o, 20))
        }
      }),
      (t.prototype.resetExtent = function () {
        var e = this.option,
          n = R1t([e.min, e.max])
        this._dataExtent = n
      }),
      (t.prototype.getDataDimensionIndex = function (e) {
        var n = this.option.dimension
        if (n != null) return e.getDimensionIndex(n)
        for (var i = e.dimensions, a = i.length - 1; a >= 0; a--) {
          var o = i[a],
            s = e.getDimensionInfo(o)
          if (!s.isCalculationCoord) return s.storeDimIndex
        }
      }),
      (t.prototype.getExtent = function () {
        return this._dataExtent.slice()
      }),
      (t.prototype.completeVisualOption = function () {
        var e = this.ecModel,
          n = this.option,
          i = {
            inRange: n.inRange,
            outOfRange: n.outOfRange,
          },
          a = n.target || (n.target = {}),
          o = n.controller || (n.controller = {})
        te(a, i), te(o, i)
        var s = this.isCategory()
        l.call(this, a),
          l.call(this, o),
          u.call(this, a, 'inRange', 'outOfRange'),
          c.call(this, o)
        function l(h) {
          P1t(n.color) &&
            !h.inRange &&
            (h.inRange = {
              color: n.color.slice().reverse(),
            }),
            (h.inRange = h.inRange || {
              color: e.get('gradientColor'),
            })
        }
        function u(h, f, d) {
          var p = h[f],
            g = h[d]
          p &&
            !g &&
            ((g = h[d] = {}),
            ek(p, function (v, m) {
              if (vr.isValidType(m)) {
                var y = qH.get(m, 'inactive', s)
                y != null &&
                  ((g[m] = y),
                  m === 'color' &&
                    !g.hasOwnProperty('opacity') &&
                    !g.hasOwnProperty('colorAlpha') &&
                    (g.opacity = [0, 0]))
              }
            }))
        }
        function c(h) {
          var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol,
            d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize,
            p = this.get('inactiveColor'),
            g = this.getItemSymbol(),
            v = g || 'roundRect'
          ek(
            this.stateList,
            function (m) {
              var y = this.itemSize,
                _ = h[m]
              _ ||
                (_ = h[m] =
                  {
                    color: s ? p : [p],
                  }),
                _.symbol == null && (_.symbol = (f && Vt(f)) || (s ? v : [v])),
                _.symbolSize == null &&
                  (_.symbolSize = (d && Vt(d)) || (s ? y[0] : [y[0], y[0]])),
                (_.symbol = tk(_.symbol, function (S) {
                  return S === 'none' ? v : S
                }))
              var x = _.symbolSize
              if (x != null) {
                var A = -1 / 0
                L1t(x, function (S) {
                  S > A && (A = S)
                }),
                  (_.symbolSize = tk(x, function (S) {
                    return I1t(S, [0, A], [0, y[0]], !0)
                  }))
              }
            },
            this,
          )
        }
      }),
      (t.prototype.resetItemSize = function () {
        this.itemSize = [
          parseFloat(this.get('itemWidth')),
          parseFloat(this.get('itemHeight')),
        ]
      }),
      (t.prototype.isCategory = function () {
        return !!this.option.categories
      }),
      (t.prototype.setSelected = function (e) {}),
      (t.prototype.getSelected = function () {
        return null
      }),
      (t.prototype.getValueState = function (e) {
        return null
      }),
      (t.prototype.getVisualMeta = function (e) {
        return null
      }),
      (t.type = 'visualMap'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        show: !0,
        z: 4,
        seriesIndex: 'all',
        min: 0,
        max: 200,
        left: 0,
        right: null,
        top: null,
        bottom: 0,
        itemWidth: null,
        itemHeight: null,
        inverse: !1,
        orient: 'vertical',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        contentColor: '#5793f3',
        inactiveColor: '#aaa',
        borderWidth: 0,
        padding: 5,
        textGap: 10,
        precision: 0,
        textStyle: {
          color: '#333',
        },
      }),
      t
    )
  })(xe)
const M0 = O1t
var nk = [20, 140],
  N1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        r.prototype.optionUpdated.apply(this, arguments),
          this.resetExtent(),
          this.resetVisual(function (i) {
            ;(i.mappingMethod = 'linear'), (i.dataExtent = this.getExtent())
          }),
          this._resetRange()
      }),
      (t.prototype.resetItemSize = function () {
        r.prototype.resetItemSize.apply(this, arguments)
        var e = this.itemSize
        ;(e[0] == null || isNaN(e[0])) && (e[0] = nk[0]),
          (e[1] == null || isNaN(e[1])) && (e[1] = nk[1])
      }),
      (t.prototype._resetRange = function () {
        var e = this.getExtent(),
          n = this.option.range
        !n || n.auto
          ? ((e.auto = 1), (this.option.range = e))
          : at(n) &&
            (n[0] > n[1] && n.reverse(),
            (n[0] = Math.max(n[0], e[0])),
            (n[1] = Math.min(n[1], e[1])))
      }),
      (t.prototype.completeVisualOption = function () {
        r.prototype.completeVisualOption.apply(this, arguments),
          R(
            this.stateList,
            function (e) {
              var n = this.option.controller[e].symbolSize
              n && n[0] !== n[1] && (n[0] = n[1] / 3)
            },
            this,
          )
      }),
      (t.prototype.setSelected = function (e) {
        ;(this.option.range = e.slice()), this._resetRange()
      }),
      (t.prototype.getSelected = function () {
        var e = this.getExtent(),
          n = Zi((this.get('range') || []).slice())
        return (
          n[0] > e[1] && (n[0] = e[1]),
          n[1] > e[1] && (n[1] = e[1]),
          n[0] < e[0] && (n[0] = e[0]),
          n[1] < e[0] && (n[1] = e[0]),
          n
        )
      }),
      (t.prototype.getValueState = function (e) {
        var n = this.option.range,
          i = this.getExtent()
        return (n[0] <= i[0] || n[0] <= e) && (n[1] >= i[1] || e <= n[1])
          ? 'inRange'
          : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var n = []
        return (
          this.eachTargetSeries(function (i) {
            var a = [],
              o = i.getData()
            o.each(
              this.getDataDimensionIndex(o),
              function (s, l) {
                e[0] <= s && s <= e[1] && a.push(l)
              },
              this,
            ),
              n.push({
                seriesId: i.id,
                dataIndex: a,
              })
          }, this),
          n
        )
      }),
      (t.prototype.getVisualMeta = function (e) {
        var n = rk(this, 'outOfRange', this.getExtent()),
          i = rk(this, 'inRange', this.option.range.slice()),
          a = []
        function o(d, p) {
          a.push({
            value: d,
            color: e(d, p),
          })
        }
        for (
          var s = 0, l = 0, u = i.length, c = n.length;
          l < c && (!i.length || n[l] <= i[0]);
          l++
        )
          n[l] < i[s] && o(n[l], 'outOfRange')
        for (var h = 1; s < u; s++, h = 0)
          h && a.length && o(i[s], 'outOfRange'), o(i[s], 'inRange')
        for (var h = 1; l < c; l++)
          (!i.length || i[i.length - 1] < n[l]) &&
            (h && (a.length && o(a[a.length - 1].value, 'outOfRange'), (h = 0)),
            o(n[l], 'outOfRange'))
        var f = a.length
        return {
          stops: a,
          outerColors: [
            f ? a[0].color : 'transparent',
            f ? a[f - 1].color : 'transparent',
          ],
        }
      }),
      (t.type = 'visualMap.continuous'),
      (t.defaultOption = gl(M0.defaultOption, {
        align: 'auto',
        calculable: !1,
        hoverLink: !0,
        realtime: !0,
        handleIcon:
          'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
        handleSize: '120%',
        handleStyle: {
          borderColor: '#fff',
          borderWidth: 1,
        },
        indicatorIcon: 'circle',
        indicatorSize: '50%',
        indicatorStyle: {
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0,0,0,0.2)',
        },
      })),
      t
    )
  })(M0)
function rk(r, t, e) {
  if (e[0] === e[1]) return e.slice()
  for (
    var n = 200, i = (e[1] - e[0]) / n, a = e[0], o = [], s = 0;
    s <= n && a < e[1];
    s++
  )
    o.push(a), (a += i)
  return o.push(e[1]), o
}
const k1t = N1t
var B1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1,
      }),
      e
    )
  }
  return (
    (t.prototype.init = function (e, n) {
      ;(this.ecModel = e), (this.api = n)
    }),
    (t.prototype.render = function (e, n, i, a) {
      if (((this.visualMapModel = e), e.get('show') === !1)) {
        this.group.removeAll()
        return
      }
      this.doRender(e, n, i, a)
    }),
    (t.prototype.renderBackground = function (e) {
      var n = this.visualMapModel,
        i = wf(n.get('padding') || 0),
        a = e.getBoundingRect()
      e.add(
        new ge({
          z2: -1,
          silent: !0,
          shape: {
            x: a.x - i[3],
            y: a.y - i[0],
            width: a.width + i[3] + i[1],
            height: a.height + i[0] + i[2],
          },
          style: {
            fill: n.get('backgroundColor'),
            stroke: n.get('borderColor'),
            lineWidth: n.get('borderWidth'),
          },
        }),
      )
    }),
    (t.prototype.getControllerVisual = function (e, n, i) {
      i = i || {}
      var a = i.forceState,
        o = this.visualMapModel,
        s = {}
      if (n === 'color') {
        var l = o.get('contentColor')
        s.color = l
      }
      function u(d) {
        return s[d]
      }
      function c(d, p) {
        s[d] = p
      }
      var h = o.controllerVisuals[a || o.getValueState(e)],
        f = vr.prepareVisualTypes(h)
      return (
        R(f, function (d) {
          var p = h[d]
          i.convertOpacityToAlpha &&
            d === 'opacity' &&
            ((d = 'colorAlpha'), (p = h.__alphaForOpacity)),
            vr.dependsOn(d, n) && p && p.applyVisual(e, u, c)
        }),
        s[n]
      )
    }),
    (t.prototype.positionGroup = function (e) {
      var n = this.visualMapModel,
        i = this.api
      p_(e, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight(),
      })
    }),
    (t.prototype.doRender = function (e, n, i, a) {}),
    (t.type = 'visualMap'),
    t
  )
})(dn)
const ZH = B1t
var ik = [
  ['left', 'right', 'width'],
  ['top', 'bottom', 'height'],
]
function KH(r, t, e) {
  var n = r.option,
    i = n.align
  if (i != null && i !== 'auto') return i
  for (
    var a = {
        width: t.getWidth(),
        height: t.getHeight(),
      },
      o = n.orient === 'horizontal' ? 1 : 0,
      s = ik[o],
      l = [0, null, 10],
      u = {},
      c = 0;
    c < 3;
    c++
  )
    (u[ik[1 - o][c]] = l[c]), (u[s[c]] = c === 2 ? e[0] : n[s[c]])
  var h = [
      ['x', 'width', 3],
      ['y', 'height', 0],
    ][o],
    f = Vn(u, a, n.padding)
  return s[
    (f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1
  ]
}
function cy(r, t) {
  return (
    R(r || [], function (e) {
      e.dataIndex != null &&
        ((e.dataIndexInside = e.dataIndex), (e.dataIndex = null)),
        (e.highlightKey = 'visualMap' + (t ? t.componentIndex : ''))
    }),
    r
  )
}
var Ga = Re,
  F1t = R,
  ak = Math.min,
  oA = Math.max,
  z1t = 12,
  U1t = 6,
  V1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e._shapes = {}),
        (e._dataInterval = []),
        (e._handleEnds = []),
        (e._hoverLinkDataIndices = []),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n) {
        r.prototype.init.call(this, e, n),
          (this._hoverLinkFromSeriesMouseOver = Tt(
            this._hoverLinkFromSeriesMouseOver,
            this,
          )),
          (this._hideIndicator = Tt(this._hideIndicator, this))
      }),
      (t.prototype.doRender = function (e, n, i, a) {
        ;(!a || a.type !== 'selectDataRange' || a.from !== this.uid) &&
          this._buildView()
      }),
      (t.prototype._buildView = function () {
        this.group.removeAll()
        var e = this.visualMapModel,
          n = this.group
        ;(this._orient = e.get('orient')),
          (this._useHandle = e.get('calculable')),
          this._resetInterval(),
          this._renderBar(n)
        var i = e.get('text')
        this._renderEndsText(n, i, 0),
          this._renderEndsText(n, i, 1),
          this._updateView(!0),
          this.renderBackground(n),
          this._updateView(),
          this._enableHoverLinkToSeries(),
          this._enableHoverLinkFromSeries(),
          this.positionGroup(n)
      }),
      (t.prototype._renderEndsText = function (e, n, i) {
        if (n) {
          var a = n[1 - i]
          a = a != null ? a + '' : ''
          var o = this.visualMapModel,
            s = o.get('textGap'),
            l = o.itemSize,
            u = this._shapes.mainGroup,
            c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u),
            h = this._applyTransform(i === 0 ? 'bottom' : 'top', u),
            f = this._orient,
            d = this.visualMapModel.textStyleModel
          this.group.add(
            new Ae({
              style: $e(d, {
                x: c[0],
                y: c[1],
                verticalAlign: f === 'horizontal' ? 'middle' : h,
                align: f === 'horizontal' ? h : 'center',
                text: a,
              }),
            }),
          )
        }
      }),
      (t.prototype._renderBar = function (e) {
        var n = this.visualMapModel,
          i = this._shapes,
          a = n.itemSize,
          o = this._orient,
          s = this._useHandle,
          l = KH(n, this.api, a),
          u = (i.mainGroup = this._createBarGroup(l)),
          c = new Ht()
        u.add(c),
          c.add((i.outOfRange = ok())),
          c.add(
            (i.inRange = ok(
              null,
              s ? lk(this._orient) : null,
              Tt(this._dragHandle, this, 'all', !1),
              Tt(this._dragHandle, this, 'all', !0),
            )),
          ),
          c.setClipPath(
            new ge({
              shape: {
                x: 0,
                y: 0,
                width: a[0],
                height: a[1],
                r: 3,
              },
            }),
          )
        var h = n.textStyleModel.getTextRect('国'),
          f = oA(h.width, h.height)
        s &&
          ((i.handleThumbs = []),
          (i.handleLabels = []),
          (i.handleLabelPoints = []),
          this._createHandle(n, u, 0, a, f, o),
          this._createHandle(n, u, 1, a, f, o)),
          this._createIndicator(n, u, a, f, o),
          e.add(u)
      }),
      (t.prototype._createHandle = function (e, n, i, a, o, s) {
        var l = Tt(this._dragHandle, this, i, !1),
          u = Tt(this._dragHandle, this, i, !0),
          c = Ta(e.get('handleSize'), a[0]),
          h = Rn(e.get('handleIcon'), -c / 2, -c / 2, c, c, null, !0),
          f = lk(this._orient)
        h.attr({
          cursor: f,
          draggable: !0,
          drift: l,
          ondragend: u,
          onmousemove: function (m) {
            jo(m.event)
          },
        }),
          (h.x = a[0] / 2),
          h.useStyle(e.getModel('handleStyle').getItemStyle()),
          h.setStyle({
            strokeNoScale: !0,
            strokeFirst: !0,
          }),
          (h.style.lineWidth *= 2),
          (h.ensureState('emphasis').style = e
            .getModel(['emphasis', 'handleStyle'])
            .getItemStyle()),
          yu(h, !0),
          n.add(h)
        var d = this.visualMapModel.textStyleModel,
          p = new Ae({
            cursor: f,
            draggable: !0,
            drift: l,
            onmousemove: function (m) {
              jo(m.event)
            },
            ondragend: u,
            style: $e(d, {
              x: 0,
              y: 0,
              text: '',
            }),
          })
        ;(p.ensureState('blur').style = {
          opacity: 0.1,
        }),
          (p.stateTransition = {
            duration: 200,
          }),
          this.group.add(p)
        var g = [c, 0],
          v = this._shapes
        ;(v.handleThumbs[i] = h),
          (v.handleLabelPoints[i] = g),
          (v.handleLabels[i] = p)
      }),
      (t.prototype._createIndicator = function (e, n, i, a, o) {
        var s = Ta(e.get('indicatorSize'), i[0]),
          l = Rn(e.get('indicatorIcon'), -s / 2, -s / 2, s, s, null, !0)
        l.attr({
          cursor: 'move',
          invisible: !0,
          silent: !0,
          x: i[0] / 2,
        })
        var u = e.getModel('indicatorStyle').getItemStyle()
        if (l instanceof yr) {
          var c = l.style
          l.useStyle(
            Q(
              {
                image: c.image,
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
              },
              u,
            ),
          )
        } else l.useStyle(u)
        n.add(l)
        var h = this.visualMapModel.textStyleModel,
          f = new Ae({
            silent: !0,
            invisible: !0,
            style: $e(h, {
              x: 0,
              y: 0,
              text: '',
            }),
          })
        this.group.add(f)
        var d = [(o === 'horizontal' ? a / 2 : U1t) + i[0] / 2, 0],
          p = this._shapes
        ;(p.indicator = l),
          (p.indicatorLabel = f),
          (p.indicatorLabelPoint = d),
          (this._firstShowIndicator = !0)
      }),
      (t.prototype._dragHandle = function (e, n, i, a) {
        if (this._useHandle) {
          if (((this._dragging = !n), !n)) {
            var o = this._applyTransform([i, a], this._shapes.mainGroup, !0)
            this._updateInterval(e, o[1]),
              this._hideIndicator(),
              this._updateView()
          }
          n === !this.visualMapModel.get('realtime') &&
            this.api.dispatchAction({
              type: 'selectDataRange',
              from: this.uid,
              visualMapId: this.visualMapModel.id,
              selected: this._dataInterval.slice(),
            }),
            n
              ? !this._hovering && this._clearHoverLinkToSeries()
              : sk(this.visualMapModel) &&
                this._doHoverLinkToSeries(this._handleEnds[e], !1)
        }
      }),
      (t.prototype._resetInterval = function () {
        var e = this.visualMapModel,
          n = (this._dataInterval = e.getSelected()),
          i = e.getExtent(),
          a = [0, e.itemSize[1]]
        this._handleEnds = [Ga(n[0], i, a, !0), Ga(n[1], i, a, !0)]
      }),
      (t.prototype._updateInterval = function (e, n) {
        n = n || 0
        var i = this.visualMapModel,
          a = this._handleEnds,
          o = [0, i.itemSize[1]]
        lc(n, a, o, e, 0)
        var s = i.getExtent()
        this._dataInterval = [Ga(a[0], o, s, !0), Ga(a[1], o, s, !0)]
      }),
      (t.prototype._updateView = function (e) {
        var n = this.visualMapModel,
          i = n.getExtent(),
          a = this._shapes,
          o = [0, n.itemSize[1]],
          s = e ? o : this._handleEnds,
          l = this._createBarVisual(this._dataInterval, i, s, 'inRange'),
          u = this._createBarVisual(i, i, o, 'outOfRange')
        a.inRange
          .setStyle({
            fill: l.barColor,
          })
          .setShape('points', l.barPoints),
          a.outOfRange
            .setStyle({
              fill: u.barColor,
            })
            .setShape('points', u.barPoints),
          this._updateHandle(s, l)
      }),
      (t.prototype._createBarVisual = function (e, n, i, a) {
        var o = {
            forceState: a,
            convertOpacityToAlpha: !0,
          },
          s = this._makeColorGradient(e, o),
          l = [
            this.getControllerVisual(e[0], 'symbolSize', o),
            this.getControllerVisual(e[1], 'symbolSize', o),
          ],
          u = this._createBarPoints(i, l)
        return {
          barColor: new He(0, 0, 0, 1, s),
          barPoints: u,
          handlesColor: [s[0].color, s[s.length - 1].color],
        }
      }),
      (t.prototype._makeColorGradient = function (e, n) {
        var i = 100,
          a = [],
          o = (e[1] - e[0]) / i
        a.push({
          color: this.getControllerVisual(e[0], 'color', n),
          offset: 0,
        })
        for (var s = 1; s < i; s++) {
          var l = e[0] + o * s
          if (l > e[1]) break
          a.push({
            color: this.getControllerVisual(l, 'color', n),
            offset: s / i,
          })
        }
        return (
          a.push({
            color: this.getControllerVisual(e[1], 'color', n),
            offset: 1,
          }),
          a
        )
      }),
      (t.prototype._createBarPoints = function (e, n) {
        var i = this.visualMapModel.itemSize
        return [
          [i[0] - n[0], e[0]],
          [i[0], e[0]],
          [i[0], e[1]],
          [i[0] - n[1], e[1]],
        ]
      }),
      (t.prototype._createBarGroup = function (e) {
        var n = this._orient,
          i = this.visualMapModel.get('inverse')
        return new Ht(
          n === 'horizontal' && !i
            ? {
                scaleX: e === 'bottom' ? 1 : -1,
                rotation: Math.PI / 2,
              }
            : n === 'horizontal' && i
            ? {
                scaleX: e === 'bottom' ? -1 : 1,
                rotation: -Math.PI / 2,
              }
            : n === 'vertical' && !i
            ? {
                scaleX: e === 'left' ? 1 : -1,
                scaleY: -1,
              }
            : {
                scaleX: e === 'left' ? 1 : -1,
              },
        )
      }),
      (t.prototype._updateHandle = function (e, n) {
        if (this._useHandle) {
          var i = this._shapes,
            a = this.visualMapModel,
            o = i.handleThumbs,
            s = i.handleLabels,
            l = a.itemSize,
            u = a.getExtent()
          F1t(
            [0, 1],
            function (c) {
              var h = o[c]
              h.setStyle('fill', n.handlesColor[c]), (h.y = e[c])
              var f = Ga(e[c], [0, l[1]], u, !0),
                d = this.getControllerVisual(f, 'symbolSize')
              ;(h.scaleX = h.scaleY = d / l[0]), (h.x = l[0] - d / 2)
              var p = ba(i.handleLabelPoints[c], Nu(h, this.group))
              s[c].setStyle({
                x: p[0],
                y: p[1],
                text: a.formatValueText(this._dataInterval[c]),
                verticalAlign: 'middle',
                align:
                  this._orient === 'vertical'
                    ? this._applyTransform('left', i.mainGroup)
                    : 'center',
              })
            },
            this,
          )
        }
      }),
      (t.prototype._showIndicator = function (e, n, i, a) {
        var o = this.visualMapModel,
          s = o.getExtent(),
          l = o.itemSize,
          u = [0, l[1]],
          c = this._shapes,
          h = c.indicator
        if (h) {
          h.attr('invisible', !1)
          var f = {
              convertOpacityToAlpha: !0,
            },
            d = this.getControllerVisual(e, 'color', f),
            p = this.getControllerVisual(e, 'symbolSize'),
            g = Ga(e, s, u, !0),
            v = l[0] - p / 2,
            m = {
              x: h.x,
              y: h.y,
            }
          ;(h.y = g), (h.x = v)
          var y = ba(c.indicatorLabelPoint, Nu(h, this.group)),
            _ = c.indicatorLabel
          _.attr('invisible', !1)
          var x = this._applyTransform('left', c.mainGroup),
            A = this._orient,
            S = A === 'horizontal'
          _.setStyle({
            text: (i || '') + o.formatValueText(n),
            verticalAlign: S ? x : 'middle',
            align: S ? 'center' : x,
          })
          var b = {
              x: v,
              y: g,
              style: {
                fill: d,
              },
            },
            T = {
              style: {
                x: y[0],
                y: y[1],
              },
            }
          if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
            var w = {
              duration: 100,
              easing: 'cubicInOut',
              additive: !0,
            }
            ;(h.x = m.x), (h.y = m.y), h.animateTo(b, w), _.animateTo(T, w)
          } else h.attr(b), _.attr(T)
          this._firstShowIndicator = !1
          var M = this._shapes.handleLabels
          if (M) for (var C = 0; C < M.length; C++) this.api.enterBlur(M[C])
        }
      }),
      (t.prototype._enableHoverLinkToSeries = function () {
        var e = this
        this._shapes.mainGroup
          .on('mousemove', function (n) {
            if (((e._hovering = !0), !e._dragging)) {
              var i = e.visualMapModel.itemSize,
                a = e._applyTransform(
                  [n.offsetX, n.offsetY],
                  e._shapes.mainGroup,
                  !0,
                  !0,
                )
              ;(a[1] = ak(oA(0, a[1]), i[1])),
                e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0])
            }
          })
          .on('mouseout', function () {
            ;(e._hovering = !1), !e._dragging && e._clearHoverLinkToSeries()
          })
      }),
      (t.prototype._enableHoverLinkFromSeries = function () {
        var e = this.api.getZr()
        this.visualMapModel.option.hoverLink
          ? (e.on('mouseover', this._hoverLinkFromSeriesMouseOver, this),
            e.on('mouseout', this._hideIndicator, this))
          : this._clearHoverLinkFromSeries()
      }),
      (t.prototype._doHoverLinkToSeries = function (e, n) {
        var i = this.visualMapModel,
          a = i.itemSize
        if (i.option.hoverLink) {
          var o = [0, a[1]],
            s = i.getExtent()
          e = ak(oA(o[0], e), o[1])
          var l = G1t(i, s, o),
            u = [e - l, e + l],
            c = Ga(e, o, s, !0),
            h = [Ga(u[0], o, s, !0), Ga(u[1], o, s, !0)]
          u[0] < o[0] && (h[0] = -1 / 0),
            u[1] > o[1] && (h[1] = 1 / 0),
            n &&
              (h[0] === -1 / 0
                ? this._showIndicator(c, h[1], '< ', l)
                : h[1] === 1 / 0
                ? this._showIndicator(c, h[0], '> ', l)
                : this._showIndicator(c, c, '≈ ', l))
          var f = this._hoverLinkDataIndices,
            d = []
          ;(n || sk(i)) &&
            (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h))
          var p = Ett(f, d)
          this._dispatchHighDown('downplay', cy(p[0], i)),
            this._dispatchHighDown('highlight', cy(p[1], i))
        }
      }),
      (t.prototype._hoverLinkFromSeriesMouseOver = function (e) {
        var n
        if (
          (xu(
            e.target,
            function (l) {
              var u = Wt(l)
              if (u.dataIndex != null) return (n = u), !0
            },
            !0,
          ),
          !!n)
        ) {
          var i = this.ecModel.getSeriesByIndex(n.seriesIndex),
            a = this.visualMapModel
          if (a.isTargetSeries(i)) {
            var o = i.getData(n.dataType),
              s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex)
            isNaN(s) || this._showIndicator(s, s)
          }
        }
      }),
      (t.prototype._hideIndicator = function () {
        var e = this._shapes
        e.indicator && e.indicator.attr('invisible', !0),
          e.indicatorLabel && e.indicatorLabel.attr('invisible', !0)
        var n = this._shapes.handleLabels
        if (n) for (var i = 0; i < n.length; i++) this.api.leaveBlur(n[i])
      }),
      (t.prototype._clearHoverLinkToSeries = function () {
        this._hideIndicator()
        var e = this._hoverLinkDataIndices
        this._dispatchHighDown('downplay', cy(e, this.visualMapModel)),
          (e.length = 0)
      }),
      (t.prototype._clearHoverLinkFromSeries = function () {
        this._hideIndicator()
        var e = this.api.getZr()
        e.off('mouseover', this._hoverLinkFromSeriesMouseOver),
          e.off('mouseout', this._hideIndicator)
      }),
      (t.prototype._applyTransform = function (e, n, i, a) {
        var o = Nu(n, a ? null : this.group)
        return at(e) ? ba(e, o, i) : s_(e, o, i)
      }),
      (t.prototype._dispatchHighDown = function (e, n) {
        n &&
          n.length &&
          this.api.dispatchAction({
            type: e,
            batch: n,
          })
      }),
      (t.prototype.dispose = function () {
        this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
      }),
      (t.type = 'visualMap.continuous'),
      t
    )
  })(ZH)
function ok(r, t, e, n) {
  return new si({
    shape: {
      points: r,
    },
    draggable: !!e,
    cursor: t,
    drift: e,
    onmousemove: function (i) {
      jo(i.event)
    },
    ondragend: n,
  })
}
function G1t(r, t, e) {
  var n = z1t / 2,
    i = r.get('hoverLinkDataSize')
  return i && (n = Ga(i, t, e, !0) / 2), n
}
function sk(r) {
  var t = r.get('hoverLinkOnHandle')
  return !!(t ?? r.get('realtime'))
}
function lk(r) {
  return r === 'vertical' ? 'ns-resize' : 'ew-resize'
}
const H1t = V1t
var W1t = {
    type: 'selectDataRange',
    event: 'dataRangeSelected',
    update: 'update',
  },
  X1t = function (r, t) {
    t.eachComponent(
      {
        mainType: 'visualMap',
        query: r,
      },
      function (e) {
        e.setSelected(r.selected)
      },
    )
  },
  Y1t = [
    {
      createOnAllSeries: !0,
      reset: function (r, t) {
        var e = []
        return (
          t.eachComponent('visualMap', function (n) {
            var i = r.pipelineContext
            !n.isTargetSeries(r) ||
              (i && i.large) ||
              e.push(
                U_t(
                  n.stateList,
                  n.targetVisuals,
                  Tt(n.getValueState, n),
                  n.getDataDimensionIndex(r.getData()),
                ),
              )
          }),
          e
        )
      },
    },
    {
      createOnAllSeries: !0,
      reset: function (r, t) {
        var e = r.getData(),
          n = []
        t.eachComponent('visualMap', function (i) {
          if (i.isTargetSeries(r)) {
            var a = i.getVisualMeta(Tt($1t, null, r, i)) || {
                stops: [],
                outerColors: [],
              },
              o = i.getDataDimensionIndex(e)
            o >= 0 && ((a.dimension = o), n.push(a))
          }
        }),
          r.getData().setVisual('visualMeta', n)
      },
    },
  ]
function $1t(r, t, e, n) {
  for (
    var i = t.targetVisuals[n],
      a = vr.prepareVisualTypes(i),
      o = {
        color: bv(r.getData(), 'color'),
      },
      s = 0,
      l = a.length;
    s < l;
    s++
  ) {
    var u = a[s],
      c = i[u === 'opacity' ? '__alphaForOpacity' : u]
    c && c.applyVisual(e, h, f)
  }
  return o.color
  function h(d) {
    return o[d]
  }
  function f(d, p) {
    o[d] = p
  }
}
var uk = R
function q1t(r) {
  var t = r && r.visualMap
  at(t) || (t = t ? [t] : []),
    uk(t, function (e) {
      if (e) {
        nh(e, 'splitList') &&
          !nh(e, 'pieces') &&
          ((e.pieces = e.splitList), delete e.splitList)
        var n = e.pieces
        n &&
          at(n) &&
          uk(n, function (i) {
            Ut(i) &&
              (nh(i, 'start') && !nh(i, 'min') && (i.min = i.start),
              nh(i, 'end') && !nh(i, 'max') && (i.max = i.end))
          })
      }
    })
}
function nh(r, t) {
  return r && r.hasOwnProperty && r.hasOwnProperty(t)
}
var ck = !1
function jH(r) {
  ck ||
    ((ck = !0),
    r.registerSubTypeDefaulter('visualMap', function (t) {
      return !t.categories &&
        (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable)
        ? 'continuous'
        : 'piecewise'
    }),
    r.registerAction(W1t, X1t),
    R(Y1t, function (t) {
      r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, t)
    }),
    r.registerPreprocessor(q1t))
}
function JH(r) {
  r.registerComponentModel(k1t), r.registerComponentView(H1t), jH(r)
}
var Z1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._pieceList = []), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        r.prototype.optionUpdated.apply(this, arguments), this.resetExtent()
        var i = (this._mode = this._determineMode())
        ;(this._pieceList = []),
          K1t[this._mode].call(this, this._pieceList),
          this._resetSelected(e, n)
        var a = this.option.categories
        this.resetVisual(function (o, s) {
          i === 'categories'
            ? ((o.mappingMethod = 'category'), (o.categories = Vt(a)))
            : ((o.dataExtent = this.getExtent()),
              (o.mappingMethod = 'piecewise'),
              (o.pieceList = st(this._pieceList, function (l) {
                return (l = Vt(l)), s !== 'inRange' && (l.visual = null), l
              })))
        })
      }),
      (t.prototype.completeVisualOption = function () {
        var e = this.option,
          n = {},
          i = vr.listVisualTypes(),
          a = this.isCategory()
        R(e.pieces, function (s) {
          R(i, function (l) {
            s.hasOwnProperty(l) && (n[l] = 1)
          })
        }),
          R(
            n,
            function (s, l) {
              var u = !1
              R(
                this.stateList,
                function (c) {
                  u = u || o(e, c, l) || o(e.target, c, l)
                },
                this,
              ),
                !u &&
                  R(this.stateList, function (c) {
                    ;(e[c] || (e[c] = {}))[l] = qH.get(
                      l,
                      c === 'inRange' ? 'active' : 'inactive',
                      a,
                    )
                  })
            },
            this,
          )
        function o(s, l, u) {
          return s && s[l] && s[l].hasOwnProperty(u)
        }
        r.prototype.completeVisualOption.apply(this, arguments)
      }),
      (t.prototype._resetSelected = function (e, n) {
        var i = this.option,
          a = this._pieceList,
          o = (n ? i : e).selected || {}
        if (
          ((i.selected = o),
          R(
            a,
            function (l, u) {
              var c = this.getSelectedMapKey(l)
              o.hasOwnProperty(c) || (o[c] = !0)
            },
            this,
          ),
          i.selectedMode === 'single')
        ) {
          var s = !1
          R(
            a,
            function (l, u) {
              var c = this.getSelectedMapKey(l)
              o[c] && (s ? (o[c] = !1) : (s = !0))
            },
            this,
          )
        }
      }),
      (t.prototype.getItemSymbol = function () {
        return this.get('itemSymbol')
      }),
      (t.prototype.getSelectedMapKey = function (e) {
        return this._mode === 'categories' ? e.value + '' : e.index + ''
      }),
      (t.prototype.getPieceList = function () {
        return this._pieceList
      }),
      (t.prototype._determineMode = function () {
        var e = this.option
        return e.pieces && e.pieces.length > 0
          ? 'pieces'
          : this.option.categories
          ? 'categories'
          : 'splitNumber'
      }),
      (t.prototype.setSelected = function (e) {
        this.option.selected = Vt(e)
      }),
      (t.prototype.getValueState = function (e) {
        var n = vr.findPieceIndex(e, this._pieceList)
        return n != null &&
          this.option.selected[this.getSelectedMapKey(this._pieceList[n])]
          ? 'inRange'
          : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var n = [],
          i = this._pieceList
        return (
          this.eachTargetSeries(function (a) {
            var o = [],
              s = a.getData()
            s.each(
              this.getDataDimensionIndex(s),
              function (l, u) {
                var c = vr.findPieceIndex(l, i)
                c === e && o.push(u)
              },
              this,
            ),
              n.push({
                seriesId: a.id,
                dataIndex: o,
              })
          }, this),
          n
        )
      }),
      (t.prototype.getRepresentValue = function (e) {
        var n
        if (this.isCategory()) n = e.value
        else if (e.value != null) n = e.value
        else {
          var i = e.interval || []
          n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
        }
        return n
      }),
      (t.prototype.getVisualMeta = function (e) {
        if (this.isCategory()) return
        var n = [],
          i = ['', ''],
          a = this
        function o(c, h) {
          var f = a.getRepresentValue({
            interval: c,
          })
          h || (h = a.getValueState(f))
          var d = e(f, h)
          c[0] === -1 / 0
            ? (i[0] = d)
            : c[1] === 1 / 0
            ? (i[1] = d)
            : n.push(
                {
                  value: c[0],
                  color: d,
                },
                {
                  value: c[1],
                  color: d,
                },
              )
        }
        var s = this._pieceList.slice()
        if (!s.length)
          s.push({
            interval: [-1 / 0, 1 / 0],
          })
        else {
          var l = s[0].interval[0]
          l !== -1 / 0 &&
            s.unshift({
              interval: [-1 / 0, l],
            }),
            (l = s[s.length - 1].interval[1]),
            l !== 1 / 0 &&
              s.push({
                interval: [l, 1 / 0],
              })
        }
        var u = -1 / 0
        return (
          R(
            s,
            function (c) {
              var h = c.interval
              h &&
                (h[0] > u && o([u, h[0]], 'outOfRange'),
                o(h.slice()),
                (u = h[1]))
            },
            this,
          ),
          {
            stops: n,
            outerColors: i,
          }
        )
      }),
      (t.type = 'visualMap.piecewise'),
      (t.defaultOption = gl(M0.defaultOption, {
        selected: null,
        minOpen: !1,
        maxOpen: !1,
        align: 'auto',
        itemWidth: 20,
        itemHeight: 14,
        itemSymbol: 'roundRect',
        pieces: null,
        categories: null,
        splitNumber: 5,
        selectedMode: 'multiple',
        itemGap: 10,
        hoverLink: !0,
      })),
      t
    )
  })(M0),
  K1t = {
    splitNumber: function (r) {
      var t = this.option,
        e = Math.min(t.precision, 20),
        n = this.getExtent(),
        i = t.splitNumber
      ;(i = Math.max(parseInt(i, 10), 1)), (t.splitNumber = i)
      for (var a = (n[1] - n[0]) / i; +a.toFixed(e) !== a && e < 5; ) e++
      ;(t.precision = e),
        (a = +a.toFixed(e)),
        t.minOpen &&
          r.push({
            interval: [-1 / 0, n[0]],
            close: [0, 0],
          })
      for (var o = 0, s = n[0]; o < i; s += a, o++) {
        var l = o === i - 1 ? n[1] : s + a
        r.push({
          interval: [s, l],
          close: [1, 1],
        })
      }
      t.maxOpen &&
        r.push({
          interval: [n[1], 1 / 0],
          close: [0, 0],
        }),
        rP(r),
        R(
          r,
          function (u, c) {
            ;(u.index = c), (u.text = this.formatValueText(u.interval))
          },
          this,
        )
    },
    categories: function (r) {
      var t = this.option
      R(
        t.categories,
        function (e) {
          r.push({
            text: this.formatValueText(e, !0),
            value: e,
          })
        },
        this,
      ),
        hk(t, r)
    },
    pieces: function (r) {
      var t = this.option
      R(
        t.pieces,
        function (e, n) {
          Ut(e) ||
            (e = {
              value: e,
            })
          var i = {
            text: '',
            index: n,
          }
          if (
            (e.label != null && (i.text = e.label), e.hasOwnProperty('value'))
          ) {
            var a = (i.value = e.value)
            ;(i.interval = [a, a]), (i.close = [1, 1])
          } else {
            for (
              var o = (i.interval = []),
                s = (i.close = [0, 0]),
                l = [1, 0, 1],
                u = [-1 / 0, 1 / 0],
                c = [],
                h = 0;
              h < 2;
              h++
            ) {
              for (
                var f = [
                    ['gte', 'gt', 'min'],
                    ['lte', 'lt', 'max'],
                  ][h],
                  d = 0;
                d < 3 && o[h] == null;
                d++
              )
                (o[h] = e[f[d]]), (s[h] = l[d]), (c[h] = d === 2)
              o[h] == null && (o[h] = u[h])
            }
            c[0] && o[1] === 1 / 0 && (s[0] = 0),
              c[1] && o[0] === -1 / 0 && (s[1] = 0),
              o[0] === o[1] && s[0] && s[1] && (i.value = o[0])
          }
          ;(i.visual = vr.retrieveVisuals(e)), r.push(i)
        },
        this,
      ),
        hk(t, r),
        rP(r),
        R(
          r,
          function (e) {
            var n = e.close,
              i = [['<', '≤'][n[1]], ['>', '≥'][n[0]]]
            e.text =
              e.text ||
              this.formatValueText(
                e.value != null ? e.value : e.interval,
                !1,
                i,
              )
          },
          this,
        )
    },
  }
function hk(r, t) {
  var e = r.inverse
  ;(r.orient === 'vertical' ? !e : e) && t.reverse()
}
const j1t = Z1t
var J1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.doRender = function () {
      var e = this.group
      e.removeAll()
      var n = this.visualMapModel,
        i = n.get('textGap'),
        a = n.textStyleModel,
        o = a.getFont(),
        s = a.getTextColor(),
        l = this._getItemAlign(),
        u = n.itemSize,
        c = this._getViewData(),
        h = c.endsText,
        f = nr(n.get('showLabel', !0), !h)
      h && this._renderEndsText(e, h[0], u, f, l),
        R(
          c.viewPieceList,
          function (d) {
            var p = d.piece,
              g = new Ht()
            ;(g.onclick = Tt(this._onItemClick, this, p)),
              this._enableHoverLink(g, d.indexInModelPieceList)
            var v = n.getRepresentValue(p)
            if ((this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), f)) {
              var m = this.visualMapModel.getValueState(v)
              g.add(
                new Ae({
                  style: {
                    x: l === 'right' ? -i : u[0] + i,
                    y: u[1] / 2,
                    text: p.text,
                    verticalAlign: 'middle',
                    align: l,
                    font: o,
                    fill: s,
                    opacity: m === 'outOfRange' ? 0.5 : 1,
                  },
                }),
              )
            }
            e.add(g)
          },
          this,
        ),
        h && this._renderEndsText(e, h[1], u, f, l),
        ku(n.get('orient'), e, n.get('itemGap')),
        this.renderBackground(e),
        this.positionGroup(e)
    }),
    (t.prototype._enableHoverLink = function (e, n) {
      var i = this
      e.on('mouseover', function () {
        return a('highlight')
      }).on('mouseout', function () {
        return a('downplay')
      })
      var a = function (o) {
        var s = i.visualMapModel
        s.option.hoverLink &&
          i.api.dispatchAction({
            type: o,
            batch: cy(s.findTargetDataIndices(n), s),
          })
      }
    }),
    (t.prototype._getItemAlign = function () {
      var e = this.visualMapModel,
        n = e.option
      if (n.orient === 'vertical') return KH(e, this.api, e.itemSize)
      var i = n.align
      return (!i || i === 'auto') && (i = 'left'), i
    }),
    (t.prototype._renderEndsText = function (e, n, i, a, o) {
      if (n) {
        var s = new Ht(),
          l = this.visualMapModel.textStyleModel
        s.add(
          new Ae({
            style: $e(l, {
              x: a ? (o === 'right' ? i[0] : 0) : i[0] / 2,
              y: i[1] / 2,
              verticalAlign: 'middle',
              align: a ? o : 'center',
              text: n,
            }),
          }),
        ),
          e.add(s)
      }
    }),
    (t.prototype._getViewData = function () {
      var e = this.visualMapModel,
        n = st(e.getPieceList(), function (s, l) {
          return {
            piece: s,
            indexInModelPieceList: l,
          }
        }),
        i = e.get('text'),
        a = e.get('orient'),
        o = e.get('inverse')
      return (
        (a === 'horizontal' ? o : !o)
          ? n.reverse()
          : i && (i = i.slice().reverse()),
        {
          viewPieceList: n,
          endsText: i,
        }
      )
    }),
    (t.prototype._createItemSymbol = function (e, n, i) {
      e.add(
        Rn(
          this.getControllerVisual(n, 'symbol'),
          i[0],
          i[1],
          i[2],
          i[3],
          this.getControllerVisual(n, 'color'),
        ),
      )
    }),
    (t.prototype._onItemClick = function (e) {
      var n = this.visualMapModel,
        i = n.option,
        a = i.selectedMode
      if (a) {
        var o = Vt(i.selected),
          s = n.getSelectedMapKey(e)
        a === 'single' || a === !0
          ? ((o[s] = !0),
            R(o, function (l, u) {
              o[u] = u === s
            }))
          : (o[s] = !o[s]),
          this.api.dispatchAction({
            type: 'selectDataRange',
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: o,
          })
      }
    }),
    (t.type = 'visualMap.piecewise'),
    t
  )
})(ZH)
const Q1t = J1t
function QH(r) {
  r.registerComponentModel(j1t), r.registerComponentView(Q1t), jH(r)
}
function tSt(r) {
  ie(JH), ie(QH)
}
var eSt = {
    label: {
      enabled: !0,
    },
    decal: {
      show: !1,
    },
  },
  fk = ve(),
  nSt = {}
function rSt(r, t) {
  var e = r.getModel('aria')
  if (!e.get('enabled')) return
  var n = Vt(eSt)
  te(n.label, r.getLocaleModel().get('aria'), !1), te(e.option, n, !1), i(), a()
  function i() {
    var u = e.getModel('decal'),
      c = u.get('show')
    if (c) {
      var h = Pt()
      r.eachSeries(function (f) {
        if (!f.isColorBySeries()) {
          var d = h.get(f.type)
          d || ((d = {}), h.set(f.type, d)), (fk(f).scope = d)
        }
      }),
        r.eachRawSeries(function (f) {
          if (r.isSeriesFiltered(f)) return
          if (Nt(f.enableAriaDecal)) {
            f.enableAriaDecal()
            return
          }
          var d = f.getData()
          if (f.isColorBySeries()) {
            var y = fw(f.ecModel, f.name, nSt, r.getSeriesCount()),
              _ = d.getVisual('decal')
            d.setVisual('decal', x(_, y))
          } else {
            var p = f.getRawData(),
              g = {},
              v = fk(f).scope
            d.each(function (A) {
              var S = d.getRawIndex(A)
              g[S] = A
            })
            var m = p.count()
            p.each(function (A) {
              var S = g[A],
                b = p.getName(A) || A + '',
                T = fw(f.ecModel, b, v, m),
                w = d.getItemVisual(S, 'decal')
              d.setItemVisual(S, 'decal', x(w, T))
            })
          }
          function x(A, S) {
            var b = A ? Q(Q({}, S), A) : S
            return (b.dirty = !0), b
          }
        })
    }
  }
  function a() {
    var u = t.getZr().dom
    if (u) {
      var c = r.getLocaleModel().get('aria'),
        h = e.getModel('label')
      if (((h.option = zt(h.option, c)), !!h.get('enabled'))) {
        if (h.get('description')) {
          u.setAttribute('aria-label', h.get('description'))
          return
        }
        var f = r.getSeriesCount(),
          d = h.get(['data', 'maxCount']) || 10,
          p = h.get(['series', 'maxCount']) || 10,
          g = Math.min(f, p),
          v
        if (!(f < 1)) {
          var m = s()
          if (m) {
            var y = h.get(['general', 'withTitle'])
            v = o(y, {
              title: m,
            })
          } else v = h.get(['general', 'withoutTitle'])
          var _ = [],
            x =
              f > 1
                ? h.get(['series', 'multiple', 'prefix'])
                : h.get(['series', 'single', 'prefix'])
          ;(v += o(x, {
            seriesCount: f,
          })),
            r.eachSeries(function (T, w) {
              if (w < g) {
                var M = void 0,
                  C = T.get('name'),
                  E = C ? 'withName' : 'withoutName'
                ;(M =
                  f > 1
                    ? h.get(['series', 'multiple', E])
                    : h.get(['series', 'single', E])),
                  (M = o(M, {
                    seriesId: T.seriesIndex,
                    seriesName: T.get('name'),
                    seriesType: l(T.subType),
                  }))
                var D = T.getData()
                if (D.count() > d) {
                  var P = h.get(['data', 'partialData'])
                  M += o(P, {
                    displayCnt: d,
                  })
                } else M += h.get(['data', 'allData'])
                for (
                  var L = h.get(['data', 'separator', 'middle']),
                    I = h.get(['data', 'separator', 'end']),
                    F = [],
                    k = 0;
                  k < D.count();
                  k++
                )
                  if (k < d) {
                    var V = D.getName(k),
                      H = D.getValues(k),
                      Y = h.get(['data', V ? 'withName' : 'withoutName'])
                    F.push(
                      o(Y, {
                        name: V,
                        value: H.join(L),
                      }),
                    )
                  }
                ;(M += F.join(L) + I), _.push(M)
              }
            })
          var A = h.getModel(['series', 'multiple', 'separator']),
            S = A.get('middle'),
            b = A.get('end')
          ;(v += _.join(S) + b), u.setAttribute('aria-label', v)
        }
      }
    }
  }
  function o(u, c) {
    if (!bt(u)) return u
    var h = u
    return (
      R(c, function (f, d) {
        h = h.replace(new RegExp('\\{\\s*' + d + '\\s*\\}', 'g'), f)
      }),
      h
    )
  }
  function s() {
    var u = r.get('title')
    return u && u.length && (u = u[0]), u && u.text
  }
  function l(u) {
    var c = r.getLocaleModel().get(['series', 'typeNames'])
    return c[u] || c.chart
  }
}
function iSt(r) {
  if (!(!r || !r.aria)) {
    var t = r.aria
    t.show != null && (t.enabled = t.show),
      (t.label = t.label || {}),
      R(['description', 'general', 'series', 'data'], function (e) {
        t[e] != null && (t.label[e] = t[e])
      })
  }
}
function aSt(r) {
  r.registerPreprocessor(iSt), r.registerVisual(r.PRIORITY.VISUAL.ARIA, rSt)
}
var dk = {
    value: 'eq',
    '<': 'lt',
    '<=': 'lte',
    '>': 'gt',
    '>=': 'gte',
    '=': 'eq',
    '!=': 'ne',
    '<>': 'ne',
  },
  oSt = (function () {
    function r(t) {
      var e = (this._condVal = bt(t) ? new RegExp(t) : BJ(t) ? t : null)
      if (e == null) {
        var n = ''
        Ce(n)
      }
    }
    return (
      (r.prototype.evaluate = function (t) {
        var e = typeof t
        return bt(e)
          ? this._condVal.test(t)
          : be(e)
          ? this._condVal.test(t + '')
          : !1
      }),
      r
    )
  })(),
  sSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        return this.value
      }),
      r
    )
  })(),
  lSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (var t = this.children, e = 0; e < t.length; e++)
          if (!t[e].evaluate()) return !1
        return !0
      }),
      r
    )
  })(),
  uSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (var t = this.children, e = 0; e < t.length; e++)
          if (t[e].evaluate()) return !0
        return !1
      }),
      r
    )
  })(),
  cSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        return !this.child.evaluate()
      }),
      r
    )
  })(),
  hSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (
          var t = !!this.valueParser,
            e = this.getValue,
            n = e(this.valueGetterParam),
            i = t ? this.valueParser(n) : null,
            a = 0;
          a < this.subCondList.length;
          a++
        )
          if (!this.subCondList[a].evaluate(t ? i : n)) return !1
        return !0
      }),
      r
    )
  })()
function RE(r, t) {
  if (r === !0 || r === !1) {
    var e = new sSt()
    return (e.value = r), e
  }
  var n = ''
  return (
    t8(r) || Ce(n),
    r.and
      ? pk('and', r, t)
      : r.or
      ? pk('or', r, t)
      : r.not
      ? fSt(r, t)
      : dSt(r, t)
  )
}
function pk(r, t, e) {
  var n = t[r],
    i = ''
  at(n) || Ce(i), n.length || Ce(i)
  var a = r === 'and' ? new lSt() : new uSt()
  return (
    (a.children = st(n, function (o) {
      return RE(o, e)
    })),
    a.children.length || Ce(i),
    a
  )
}
function fSt(r, t) {
  var e = r.not,
    n = ''
  t8(e) || Ce(n)
  var i = new cSt()
  return (i.child = RE(e, t)), i.child || Ce(n), i
}
function dSt(r, t) {
  for (
    var e = '',
      n = t.prepareGetValue(r),
      i = [],
      a = pe(r),
      o = r.parser,
      s = o ? T5(o) : null,
      l = 0;
    l < a.length;
    l++
  ) {
    var u = a[l]
    if (!(u === 'parser' || t.valueGetterAttrMap.get(u))) {
      var c = Et(dk, u) ? dk[u] : u,
        h = r[u],
        f = s ? s(h) : h,
        d = Xrt(c, f) || (c === 'reg' && new oSt(f))
      d || Ce(e), i.push(d)
    }
  }
  i.length || Ce(e)
  var p = new hSt()
  return (
    (p.valueGetterParam = n),
    (p.valueParser = s),
    (p.getValue = t.getValue),
    (p.subCondList = i),
    p
  )
}
function t8(r) {
  return Ut(r) && !Er(r)
}
var pSt = (function () {
  function r(t, e) {
    this._cond = RE(t, e)
  }
  return (
    (r.prototype.evaluate = function () {
      return this._cond.evaluate()
    }),
    r
  )
})()
function vSt(r, t) {
  return new pSt(r, t)
}
var gSt = {
    type: 'echarts:filter',
    transform: function (r) {
      for (
        var t = r.upstream,
          e,
          n = vSt(r.config, {
            valueGetterAttrMap: Pt({
              dimension: !0,
            }),
            prepareGetValue: function (s) {
              var l = '',
                u = s.dimension
              Et(s, 'dimension') || Ce(l)
              var c = t.getDimensionInfo(u)
              return (
                c || Ce(l),
                {
                  dimIdx: c.index,
                }
              )
            },
            getValue: function (s) {
              return t.retrieveValueFromItem(e, s.dimIdx)
            },
          }),
          i = [],
          a = 0,
          o = t.count();
        a < o;
        a++
      )
        (e = t.getRawDataItem(a)), n.evaluate() && i.push(e)
      return {
        data: i,
      }
    },
  },
  mSt = {
    type: 'echarts:sort',
    transform: function (r) {
      var t = r.upstream,
        e = r.config,
        n = '',
        i = ke(e)
      i.length || Ce(n)
      var a = []
      R(i, function (c) {
        var h = c.dimension,
          f = c.order,
          d = c.parser,
          p = c.incomparable
        if (
          (h == null && Ce(n),
          f !== 'asc' && f !== 'desc' && Ce(n),
          p && p !== 'min' && p !== 'max')
        ) {
          var g = ''
          Ce(g)
        }
        if (f !== 'asc' && f !== 'desc') {
          var v = ''
          Ce(v)
        }
        var m = t.getDimensionInfo(h)
        m || Ce(n)
        var y = d ? T5(d) : null
        d && !y && Ce(n),
          a.push({
            dimIdx: m.index,
            parser: y,
            comparator: new E5(f, p),
          })
      })
      var o = t.sourceFormat
      o !== Dr && o !== aa && Ce(n)
      for (var s = [], l = 0, u = t.count(); l < u; l++)
        s.push(t.getRawDataItem(l))
      return (
        s.sort(function (c, h) {
          for (var f = 0; f < a.length; f++) {
            var d = a[f],
              p = t.retrieveValueFromItem(c, d.dimIdx),
              g = t.retrieveValueFromItem(h, d.dimIdx)
            d.parser && ((p = d.parser(p)), (g = d.parser(g)))
            var v = d.comparator.evaluate(p, g)
            if (v !== 0) return v
          }
          return 0
        }),
        {
          data: s,
        }
      )
    },
  }
function ySt(r) {
  r.registerTransform(gSt), r.registerTransform(mSt)
}
var _St = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataset'), e
    }
    return (
      (t.prototype.init = function (e, n, i) {
        r.prototype.init.call(this, e, n, i),
          (this._sourceManager = new R5(this)),
          vR(this)
      }),
      (t.prototype.mergeOption = function (e, n) {
        r.prototype.mergeOption.call(this, e, n), vR(this)
      }),
      (t.prototype.optionUpdated = function () {
        this._sourceManager.dirty()
      }),
      (t.prototype.getSourceManager = function () {
        return this._sourceManager
      }),
      (t.type = 'dataset'),
      (t.defaultOption = {
        seriesLayoutBy: oo,
      }),
      t
    )
  })(xe),
  xSt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataset'), e
    }
    return (t.type = 'dataset'), t
  })(dn)
function SSt(r) {
  r.registerComponentModel(_St), r.registerComponentView(xSt)
}
var Ua = vo.CMD
function Sh(r, t) {
  return Math.abs(r - t) < 1e-5
}
function hM(r) {
  var t = r.data,
    e = r.len(),
    n = [],
    i,
    a = 0,
    o = 0,
    s = 0,
    l = 0
  function u(D, P) {
    i && i.length > 2 && n.push(i), (i = [D, P])
  }
  function c(D, P, L, I) {
    ;(Sh(D, L) && Sh(P, I)) || i.push(D, P, L, I, L, I)
  }
  function h(D, P, L, I, F, k) {
    var V = Math.abs(P - D),
      H = (Math.tan(V / 4) * 4) / 3,
      Y = P < D ? -1 : 1,
      K = Math.cos(D),
      ut = Math.sin(D),
      W = Math.cos(P),
      Z = Math.sin(P),
      ft = K * F + L,
      lt = ut * k + I,
      ct = W * F + L,
      At = Z * k + I,
      gt = F * H * Y,
      dt = k * H * Y
    i.push(ft - gt * ut, lt + dt * K, ct + gt * Z, At - dt * W, ct, At)
  }
  for (var f, d, p, g, v = 0; v < e; ) {
    var m = t[v++],
      y = v === 1
    switch (
      (y &&
        ((a = t[v]),
        (o = t[v + 1]),
        (s = a),
        (l = o),
        (m === Ua.L || m === Ua.C || m === Ua.Q) && (i = [s, l])),
      m)
    ) {
      case Ua.M:
        ;(a = s = t[v++]), (o = l = t[v++]), u(s, l)
        break
      case Ua.L:
        ;(f = t[v++]), (d = t[v++]), c(a, o, f, d), (a = f), (o = d)
        break
      case Ua.C:
        i.push(t[v++], t[v++], t[v++], t[v++], (a = t[v++]), (o = t[v++]))
        break
      case Ua.Q:
        ;(f = t[v++]),
          (d = t[v++]),
          (p = t[v++]),
          (g = t[v++]),
          i.push(
            a + (2 / 3) * (f - a),
            o + (2 / 3) * (d - o),
            p + (2 / 3) * (f - p),
            g + (2 / 3) * (d - g),
            p,
            g,
          ),
          (a = p),
          (o = g)
        break
      case Ua.A:
        var _ = t[v++],
          x = t[v++],
          A = t[v++],
          S = t[v++],
          b = t[v++],
          T = t[v++] + b
        v += 1
        var w = !t[v++]
        ;(f = Math.cos(b) * A + _),
          (d = Math.sin(b) * S + x),
          y ? ((s = f), (l = d), u(s, l)) : c(a, o, f, d),
          (a = Math.cos(T) * A + _),
          (o = Math.sin(T) * S + x)
        for (
          var M = ((w ? -1 : 1) * Math.PI) / 2, C = b;
          w ? C > T : C < T;
          C += M
        ) {
          var E = w ? Math.max(C + M, T) : Math.min(C + M, T)
          h(C, E, _, x, A, S)
        }
        break
      case Ua.R:
        ;(s = a = t[v++]),
          (l = o = t[v++]),
          (f = s + t[v++]),
          (d = l + t[v++]),
          u(f, l),
          c(f, l, f, d),
          c(f, d, s, d),
          c(s, d, s, l),
          c(s, l, f, l)
        break
      case Ua.Z:
        i && c(a, o, s, l), (a = s), (o = l)
        break
    }
  }
  return i && i.length > 2 && n.push(i), n
}
function fM(r, t, e, n, i, a, o, s, l, u) {
  if (Sh(r, e) && Sh(t, n) && Sh(i, o) && Sh(a, s)) {
    l.push(o, s)
    return
  }
  var c = 2 / u,
    h = c * c,
    f = o - r,
    d = s - t,
    p = Math.sqrt(f * f + d * d)
  ;(f /= p), (d /= p)
  var g = e - r,
    v = n - t,
    m = i - o,
    y = a - s,
    _ = g * g + v * v,
    x = m * m + y * y
  if (_ < h && x < h) {
    l.push(o, s)
    return
  }
  var A = f * g + d * v,
    S = -f * m - d * y,
    b = _ - A * A,
    T = x - S * S
  if (b < h && A >= 0 && T < h && S >= 0) {
    l.push(o, s)
    return
  }
  var w = [],
    M = []
  il(r, e, i, o, 0.5, w),
    il(t, n, a, s, 0.5, M),
    fM(w[0], M[0], w[1], M[1], w[2], M[2], w[3], M[3], l, u),
    fM(w[4], M[4], w[5], M[5], w[6], M[6], w[7], M[7], l, u)
}
function ASt(r, t) {
  var e = hM(r),
    n = []
  t = t || 1
  for (var i = 0; i < e.length; i++) {
    var a = e[i],
      o = [],
      s = a[0],
      l = a[1]
    o.push(s, l)
    for (var u = 2; u < a.length; ) {
      var c = a[u++],
        h = a[u++],
        f = a[u++],
        d = a[u++],
        p = a[u++],
        g = a[u++]
      fM(s, l, c, h, f, d, p, g, o, t), (s = p), (l = g)
    }
    n.push(o)
  }
  return n
}
function e8(r, t, e) {
  var n = r[t],
    i = r[1 - t],
    a = Math.abs(n / i),
    o = Math.ceil(Math.sqrt(a * e)),
    s = Math.floor(e / o)
  s === 0 && ((s = 1), (o = e))
  for (var l = [], u = 0; u < o; u++) l.push(s)
  var c = o * s,
    h = e - c
  if (h > 0) for (var u = 0; u < h; u++) l[u % o] += 1
  return l
}
function vk(r, t, e) {
  for (
    var n = r.r0,
      i = r.r,
      a = r.startAngle,
      o = r.endAngle,
      s = Math.abs(o - a),
      l = s * i,
      u = i - n,
      c = l > Math.abs(u),
      h = e8([l, u], c ? 0 : 1, t),
      f = (c ? s : u) / h.length,
      d = 0;
    d < h.length;
    d++
  )
    for (var p = (c ? u : s) / h[d], g = 0; g < h[d]; g++) {
      var v = {}
      c
        ? ((v.startAngle = a + f * d),
          (v.endAngle = a + f * (d + 1)),
          (v.r0 = n + p * g),
          (v.r = n + p * (g + 1)))
        : ((v.startAngle = a + p * g),
          (v.endAngle = a + p * (g + 1)),
          (v.r0 = n + f * d),
          (v.r = n + f * (d + 1))),
        (v.clockwise = r.clockwise),
        (v.cx = r.cx),
        (v.cy = r.cy),
        e.push(v)
    }
}
function bSt(r, t, e) {
  for (
    var n = r.width,
      i = r.height,
      a = n > i,
      o = e8([n, i], a ? 0 : 1, t),
      s = a ? 'width' : 'height',
      l = a ? 'height' : 'width',
      u = a ? 'x' : 'y',
      c = a ? 'y' : 'x',
      h = r[s] / o.length,
      f = 0;
    f < o.length;
    f++
  )
    for (var d = r[l] / o[f], p = 0; p < o[f]; p++) {
      var g = {}
      ;(g[u] = f * h),
        (g[c] = p * d),
        (g[s] = h),
        (g[l] = d),
        (g.x += r.x),
        (g.y += r.y),
        e.push(g)
    }
}
function gk(r, t, e, n) {
  return r * n - e * t
}
function wSt(r, t, e, n, i, a, o, s) {
  var l = e - r,
    u = n - t,
    c = o - i,
    h = s - a,
    f = gk(c, h, l, u)
  if (Math.abs(f) < 1e-6) return null
  var d = r - i,
    p = t - a,
    g = gk(d, p, c, h) / f
  return g < 0 || g > 1 ? null : new Qt(g * l + r, g * u + t)
}
function MSt(r, t, e) {
  var n = new Qt()
  Qt.sub(n, e, t), n.normalize()
  var i = new Qt()
  Qt.sub(i, r, t)
  var a = i.dot(n)
  return a
}
function rh(r, t) {
  var e = r[r.length - 1]
  ;(e && e[0] === t[0] && e[1] === t[1]) || r.push(t)
}
function TSt(r, t, e) {
  for (var n = r.length, i = [], a = 0; a < n; a++) {
    var o = r[a],
      s = r[(a + 1) % n],
      l = wSt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y)
    l &&
      i.push({
        projPt: MSt(l, t, e),
        pt: l,
        idx: a,
      })
  }
  if (i.length < 2)
    return [
      {
        points: r,
      },
      {
        points: r,
      },
    ]
  i.sort(function (v, m) {
    return v.projPt - m.projPt
  })
  var u = i[0],
    c = i[i.length - 1]
  if (c.idx < u.idx) {
    var h = u
    ;(u = c), (c = h)
  }
  for (
    var f = [u.pt.x, u.pt.y],
      d = [c.pt.x, c.pt.y],
      p = [f],
      g = [d],
      a = u.idx + 1;
    a <= c.idx;
    a++
  )
    rh(p, r[a].slice())
  rh(p, d), rh(p, f)
  for (var a = c.idx + 1; a <= u.idx + n; a++) rh(g, r[a % n].slice())
  return (
    rh(g, f),
    rh(g, d),
    [
      {
        points: p,
      },
      {
        points: g,
      },
    ]
  )
}
function mk(r) {
  var t = r.points,
    e = [],
    n = []
  e_(t, e, n)
  var i = new ee(e[0], e[1], n[0] - e[0], n[1] - e[1]),
    a = i.width,
    o = i.height,
    s = i.x,
    l = i.y,
    u = new Qt(),
    c = new Qt()
  return (
    a > o
      ? ((u.x = c.x = s + a / 2), (u.y = l), (c.y = l + o))
      : ((u.y = c.y = l + o / 2), (u.x = s), (c.x = s + a)),
    TSt(t, u, c)
  )
}
function T0(r, t, e, n) {
  if (e === 1) n.push(t)
  else {
    var i = Math.floor(e / 2),
      a = r(t)
    T0(r, a[0], i, n), T0(r, a[1], e - i, n)
  }
  return n
}
function CSt(r, t) {
  for (var e = [], n = 0; n < t; n++) e.push(ZT(r))
  return e
}
function ESt(r, t) {
  t.setStyle(r.style), (t.z = r.z), (t.z2 = r.z2), (t.zlevel = r.zlevel)
}
function DSt(r) {
  for (var t = [], e = 0; e < r.length; ) t.push([r[e++], r[e++]])
  return t
}
function LSt(r, t) {
  var e = [],
    n = r.shape,
    i
  switch (r.type) {
    case 'rect':
      bSt(n, t, e), (i = ge)
      break
    case 'sector':
      vk(n, t, e), (i = oi)
      break
    case 'circle':
      vk(
        {
          r0: 0,
          r: n.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: n.cx,
          cy: n.cy,
        },
        t,
        e,
      ),
        (i = oi)
      break
    default:
      var a = r.getComputedTransform(),
        o = a
          ? Math.sqrt(
              Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3]),
            )
          : 1,
        s = st(ASt(r.getUpdatedPathProxy(), o), function (m) {
          return DSt(m)
        }),
        l = s.length
      if (l === 0)
        T0(
          mk,
          {
            points: s[0],
          },
          t,
          e,
        )
      else if (l === t)
        for (var u = 0; u < l; u++)
          e.push({
            points: s[u],
          })
      else {
        var c = 0,
          h = st(s, function (m) {
            var y = [],
              _ = []
            e_(m, y, _)
            var x = (_[1] - y[1]) * (_[0] - y[0])
            return (
              (c += x),
              {
                poly: m,
                area: x,
              }
            )
          })
        h.sort(function (m, y) {
          return y.area - m.area
        })
        for (var f = t, u = 0; u < l; u++) {
          var d = h[u]
          if (f <= 0) break
          var p = u === l - 1 ? f : Math.ceil((d.area / c) * t)
          p < 0 ||
            (T0(
              mk,
              {
                points: d.poly,
              },
              p,
              e,
            ),
            (f -= p))
        }
      }
      i = si
      break
  }
  if (!i) return CSt(r, t)
  for (var g = [], u = 0; u < e.length; u++) {
    var v = new i()
    v.setShape(e[u]), ESt(r, v), g.push(v)
  }
  return g
}
function PSt(r, t) {
  var e = r.length,
    n = t.length
  if (e === n) return [r, t]
  for (
    var i = [],
      a = [],
      o = e < n ? r : t,
      s = Math.min(e, n),
      l = Math.abs(n - e) / 6,
      u = (s - 2) / 6,
      c = Math.ceil(l / u) + 1,
      h = [o[0], o[1]],
      f = l,
      d = 2;
    d < s;

  ) {
    var p = o[d - 2],
      g = o[d - 1],
      v = o[d++],
      m = o[d++],
      y = o[d++],
      _ = o[d++],
      x = o[d++],
      A = o[d++]
    if (f <= 0) {
      h.push(v, m, y, _, x, A)
      continue
    }
    for (var S = Math.min(f, c - 1) + 1, b = 1; b <= S; b++) {
      var T = b / S
      il(p, v, y, x, T, i),
        il(g, m, _, A, T, a),
        (p = i[3]),
        (g = a[3]),
        h.push(i[1], a[1], i[2], a[2], p, g),
        (v = i[5]),
        (m = a[5]),
        (y = i[6]),
        (_ = a[6])
    }
    f -= S - 1
  }
  return o === r ? [h, t] : [r, h]
}
function yk(r, t) {
  for (
    var e = r.length, n = r[e - 2], i = r[e - 1], a = [], o = 0;
    o < t.length;

  )
    (a[o++] = n), (a[o++] = i)
  return a
}
function RSt(r, t) {
  for (
    var e, n, i, a = [], o = [], s = 0;
    s < Math.max(r.length, t.length);
    s++
  ) {
    var l = r[s],
      u = t[s],
      c = void 0,
      h = void 0
    l
      ? u
        ? ((e = PSt(l, u)), (c = e[0]), (h = e[1]), (n = c), (i = h))
        : ((h = yk(i || l, l)), (c = l))
      : ((c = yk(n || u, u)), (h = u)),
      a.push(c),
      o.push(h)
  }
  return [a, o]
}
function _k(r) {
  for (
    var t = 0, e = 0, n = 0, i = r.length, a = 0, o = i - 2;
    a < i;
    o = a, a += 2
  ) {
    var s = r[o],
      l = r[o + 1],
      u = r[a],
      c = r[a + 1],
      h = s * c - u * l
    ;(t += h), (e += (s + u) * h), (n += (l + c) * h)
  }
  return t === 0 ? [r[0] || 0, r[1] || 0] : [e / t / 3, n / t / 3, t]
}
function ISt(r, t, e, n) {
  for (
    var i = (r.length - 2) / 6,
      a = 1 / 0,
      o = 0,
      s = r.length,
      l = s - 2,
      u = 0;
    u < i;
    u++
  ) {
    for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
      var d = f === 0 ? c : ((c + f - 2) % l) + 2,
        p = r[d] - e[0],
        g = r[d + 1] - e[1],
        v = t[f] - n[0],
        m = t[f + 1] - n[1],
        y = v - p,
        _ = m - g
      h += y * y + _ * _
    }
    h < a && ((a = h), (o = u))
  }
  return o
}
function OSt(r) {
  for (var t = [], e = r.length, n = 0; n < e; n += 2)
    (t[n] = r[e - n - 2]), (t[n + 1] = r[e - n - 1])
  return t
}
function NSt(r, t, e, n) {
  for (var i = [], a, o = 0; o < r.length; o++) {
    var s = r[o],
      l = t[o],
      u = _k(s),
      c = _k(l)
    a == null && (a = u[2] < 0 != c[2] < 0)
    var h = [],
      f = [],
      d = 0,
      p = 1 / 0,
      g = [],
      v = s.length
    a && (s = OSt(s))
    for (var m = ISt(s, l, u, c) * 6, y = v - 2, _ = 0; _ < y; _ += 2) {
      var x = ((m + _) % y) + 2
      ;(h[_ + 2] = s[x] - u[0]), (h[_ + 3] = s[x + 1] - u[1])
    }
    if (((h[0] = s[m] - u[0]), (h[1] = s[m + 1] - u[1]), e > 0))
      for (var A = n / e, S = -n / 2; S <= n / 2; S += A) {
        for (
          var b = Math.sin(S), T = Math.cos(S), w = 0, _ = 0;
          _ < s.length;
          _ += 2
        ) {
          var M = h[_],
            C = h[_ + 1],
            E = l[_] - c[0],
            D = l[_ + 1] - c[1],
            P = E * T - D * b,
            L = E * b + D * T
          ;(g[_] = P), (g[_ + 1] = L)
          var I = P - M,
            F = L - C
          w += I * I + F * F
        }
        if (w < p) {
          ;(p = w), (d = S)
          for (var k = 0; k < g.length; k++) f[k] = g[k]
        }
      }
    else
      for (var V = 0; V < v; V += 2)
        (f[V] = l[V] - c[0]), (f[V + 1] = l[V + 1] - c[1])
    i.push({
      from: h,
      to: f,
      fromCp: u,
      toCp: c,
      rotation: -d,
    })
  }
  return i
}
function C0(r) {
  return r.__isCombineMorphing
}
var n8 = '__mOriginal_'
function E0(r, t, e) {
  var n = n8 + t,
    i = r[n] || r[t]
  r[n] || (r[n] = r[t])
  var a = e.replace,
    o = e.after,
    s = e.before
  r[t] = function () {
    var l = arguments,
      u
    return (
      s && s.apply(this, l),
      a ? (u = a.apply(this, l)) : (u = i.apply(this, l)),
      o && o.apply(this, l),
      u
    )
  }
}
function vp(r, t) {
  var e = n8 + t
  r[e] && ((r[t] = r[e]), (r[e] = null))
}
function xk(r, t) {
  for (var e = 0; e < r.length; e++)
    for (var n = r[e], i = 0; i < n.length; ) {
      var a = n[i],
        o = n[i + 1]
      ;(n[i++] = t[0] * a + t[2] * o + t[4]),
        (n[i++] = t[1] * a + t[3] * o + t[5])
    }
}
function r8(r, t) {
  var e = r.getUpdatedPathProxy(),
    n = t.getUpdatedPathProxy(),
    i = RSt(hM(e), hM(n)),
    a = i[0],
    o = i[1],
    s = r.getComputedTransform(),
    l = t.getComputedTransform()
  function u() {
    this.transform = null
  }
  s && xk(a, s),
    l && xk(o, l),
    E0(t, 'updateTransform', {
      replace: u,
    }),
    (t.transform = null)
  var c = NSt(a, o, 10, Math.PI),
    h = []
  E0(t, 'buildPath', {
    replace: function (f) {
      for (var d = t.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
        var m = c[v],
          y = m.from,
          _ = m.to,
          x = m.rotation * d,
          A = m.fromCp,
          S = m.toCp,
          b = Math.sin(x),
          T = Math.cos(x)
        Ym(g, A, S, d)
        for (var w = 0; w < y.length; w += 2) {
          var M = y[w],
            C = y[w + 1],
            E = _[w],
            D = _[w + 1],
            P = M * p + E * d,
            L = C * p + D * d
          ;(h[w] = P * T - L * b + g[0]), (h[w + 1] = P * b + L * T + g[1])
        }
        var I = h[0],
          F = h[1]
        f.moveTo(I, F)
        for (var w = 2; w < y.length; ) {
          var E = h[w++],
            D = h[w++],
            k = h[w++],
            V = h[w++],
            H = h[w++],
            Y = h[w++]
          I === E && F === D && k === H && V === Y
            ? f.lineTo(H, Y)
            : f.bezierCurveTo(E, D, k, V, H, Y),
            (I = H),
            (F = Y)
        }
      }
    },
  })
}
function IE(r, t, e) {
  if (!r || !t) return t
  var n = e.done,
    i = e.during
  r8(r, t), (t.__morphT = 0)
  function a() {
    vp(t, 'buildPath'),
      vp(t, 'updateTransform'),
      (t.__morphT = -1),
      t.createPathProxy(),
      t.dirtyShape()
  }
  return (
    t.animateTo(
      {
        __morphT: 1,
      },
      zt(
        {
          during: function (o) {
            t.dirtyShape(), i && i(o)
          },
          done: function () {
            a(), n && n()
          },
        },
        e,
      ),
    ),
    t
  )
}
function kSt(r, t, e, n, i, a) {
  var o = 16
  ;(r = i === e ? 0 : Math.round((32767 * (r - e)) / (i - e))),
    (t = a === n ? 0 : Math.round((32767 * (t - n)) / (a - n)))
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0,
      h = 0
    ;(r & u) > 0 && (c = 1),
      (t & u) > 0 && (h = 1),
      (s += u * u * ((3 * c) ^ h)),
      h === 0 &&
        (c === 1 && ((r = u - 1 - r), (t = u - 1 - t)),
        (l = r),
        (r = t),
        (t = l))
  }
  return s
}
function D0(r) {
  var t = 1 / 0,
    e = 1 / 0,
    n = -1 / 0,
    i = -1 / 0,
    a = st(r, function (s) {
      var l = s.getBoundingRect(),
        u = s.getComputedTransform(),
        c = l.x + l.width / 2 + (u ? u[4] : 0),
        h = l.y + l.height / 2 + (u ? u[5] : 0)
      return (
        (t = Math.min(c, t)),
        (e = Math.min(h, e)),
        (n = Math.max(c, n)),
        (i = Math.max(h, i)),
        [c, h]
      )
    }),
    o = st(a, function (s, l) {
      return {
        cp: s,
        z: kSt(s[0], s[1], t, e, n, i),
        path: r[l],
      }
    })
  return o
    .sort(function (s, l) {
      return s.z - l.z
    })
    .map(function (s) {
      return s.path
    })
}
function i8(r) {
  return LSt(r.path, r.count)
}
function dM() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0,
  }
}
function BSt(r, t, e) {
  var n = []
  function i(A) {
    for (var S = 0; S < A.length; S++) {
      var b = A[S]
      C0(b) ? i(b.childrenRef()) : b instanceof oe && n.push(b)
    }
  }
  i(r)
  var a = n.length
  if (!a) return dM()
  var o = e.dividePath || i8,
    s = o({
      path: t,
      count: a,
    })
  if (s.length !== a)
    return console.error('Invalid morphing: unmatched splitted path'), dM()
  ;(n = D0(n)), (s = D0(s))
  for (
    var l = e.done, u = e.during, c = e.individualDelay, h = new Uo(), f = 0;
    f < a;
    f++
  ) {
    var d = n[f],
      p = s[f]
    ;(p.parent = t), p.copyTransform(h), c || r8(d, p)
  }
  ;(t.__isCombineMorphing = !0),
    (t.childrenRef = function () {
      return s
    })
  function g(A) {
    for (var S = 0; S < s.length; S++) s[S].addSelfToZr(A)
  }
  E0(t, 'addSelfToZr', {
    after: function (A) {
      g(A)
    },
  }),
    E0(t, 'removeSelfFromZr', {
      after: function (A) {
        for (var S = 0; S < s.length; S++) s[S].removeSelfFromZr(A)
      },
    })
  function v() {
    ;(t.__isCombineMorphing = !1),
      (t.__morphT = -1),
      (t.childrenRef = null),
      vp(t, 'addSelfToZr'),
      vp(t, 'removeSelfFromZr')
  }
  var m = s.length
  if (c)
    for (
      var y = m,
        _ = function () {
          y--, y === 0 && (v(), l && l())
        },
        f = 0;
      f < m;
      f++
    ) {
      var x = c
        ? zt(
            {
              delay: (e.delay || 0) + c(f, m, n[f], s[f]),
              done: _,
            },
            e,
          )
        : e
      IE(n[f], s[f], x)
    }
  else
    (t.__morphT = 0),
      t.animateTo(
        {
          __morphT: 1,
        },
        zt(
          {
            during: function (A) {
              for (var S = 0; S < m; S++) {
                var b = s[S]
                ;(b.__morphT = t.__morphT), b.dirtyShape()
              }
              u && u(A)
            },
            done: function () {
              v()
              for (var A = 0; A < r.length; A++) vp(r[A], 'updateTransform')
              l && l()
            },
          },
          e,
        ),
      )
  return (
    t.__zr && g(t.__zr),
    {
      fromIndividuals: n,
      toIndividuals: s,
      count: m,
    }
  )
}
function FSt(r, t, e) {
  var n = t.length,
    i = [],
    a = e.dividePath || i8
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p]
      C0(g) ? o(g.childrenRef()) : g instanceof oe && i.push(g)
    }
  }
  if (C0(r)) {
    o(r.childrenRef())
    var s = i.length
    if (s < n) for (var l = 0, u = s; u < n; u++) i.push(ZT(i[l++ % s]))
    i.length = n
  } else {
    i = a({
      path: r,
      count: n,
    })
    for (var c = r.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c)
    if (i.length !== n)
      return console.error('Invalid morphing: unmatched splitted path'), dM()
  }
  ;(i = D0(i)), (t = D0(t))
  for (var h = e.individualDelay, u = 0; u < n; u++) {
    var f = h
      ? zt(
          {
            delay: (e.delay || 0) + h(u, n, i[u], t[u]),
          },
          e,
        )
      : e
    IE(i[u], t[u], f)
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length,
  }
}
function Sk(r) {
  return at(r[0])
}
function Ak(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++)
    e.push({
      one: r[i],
      many: [],
    })
  for (var i = 0; i < t.length; i++) {
    var a = t[i].length,
      o = void 0
    for (o = 0; o < a; o++) e[o % n].many.push(t[i][o])
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!e[i].many.length) {
      var l = e[s].many
      if (l.length <= 1)
        if (s) s = 0
        else return e
      var a = l.length,
        u = Math.ceil(a / 2)
      ;(e[i].many = l.slice(u, a)), (e[s].many = l.slice(0, u)), s++
    }
  return e
}
var zSt = {
  clone: function (r) {
    for (
      var t = [],
        e = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count),
        n = 0;
      n < r.count;
      n++
    ) {
      var i = ZT(r.path)
      i.setStyle('opacity', e), t.push(i)
    }
    return t
  },
  split: null,
}
function sA(r, t, e, n, i, a) {
  if (!r.length || !t.length) return
  var o = xf('update', n, i)
  if (!(o && o.duration > 0)) return
  var s = n.getModel('universalTransition').get('delay'),
    l = Object.assign(
      {
        setToFinal: !0,
      },
      o,
    ),
    u,
    c
  Sk(r) && ((u = r), (c = t)), Sk(t) && ((u = t), (c = r))
  function h(m, y, _, x, A) {
    var S = m.many,
      b = m.one
    if (S.length === 1 && !A) {
      var T = y ? S[0] : b,
        w = y ? b : S[0]
      if (C0(T))
        h(
          {
            many: [T],
            one: w,
          },
          !0,
          _,
          x,
          !0,
        )
      else {
        var M = s
          ? zt(
              {
                delay: s(_, x),
              },
              l,
            )
          : l
        IE(T, w, M), a(T, w, T, w, M)
      }
    } else
      for (
        var C = zt(
            {
              dividePath: zSt[e],
              individualDelay:
                s &&
                function (F, k, V, H) {
                  return s(F + _, x)
                },
            },
            l,
          ),
          E = y ? BSt(S, b, C) : FSt(b, S, C),
          D = E.fromIndividuals,
          P = E.toIndividuals,
          L = D.length,
          I = 0;
        I < L;
        I++
      ) {
        var M = s
          ? zt(
              {
                delay: s(I, L),
              },
              l,
            )
          : l
        a(D[I], P[I], y ? S[I] : m.one, y ? m.one : S[I], M)
      }
  }
  for (
    var f = u ? u === r : r.length > t.length,
      d = u ? Ak(c, u) : Ak(f ? t : r, [f ? r : t]),
      p = 0,
      g = 0;
    g < d.length;
    g++
  )
    p += d[g].many.length
  for (var v = 0, g = 0; g < d.length; g++)
    h(d[g], f, v, p), (v += d[g].many.length)
}
function lu(r) {
  if (!r) return []
  if (at(r)) {
    for (var t = [], e = 0; e < r.length; e++) t.push(lu(r[e]))
    return t
  }
  var n = []
  return (
    r.traverse(function (i) {
      i instanceof oe &&
        !i.disableMorphing &&
        !i.invisible &&
        !i.ignore &&
        n.push(i)
    }),
    n
  )
}
var a8 = 1e4,
  USt = 0,
  bk = 1,
  wk = 2,
  VSt = ve()
function GSt(r, t) {
  for (var e = r.dimensions, n = 0; n < e.length; n++) {
    var i = r.getDimensionInfo(e[n])
    if (i && i.otherDims[t] === 0) return e[n]
  }
}
function HSt(r, t, e) {
  var n = r.getDimensionInfo(e),
    i = n && n.ordinalMeta
  if (n) {
    var a = r.get(n.name, t)
    return (i && i.categories[a]) || a + ''
  }
}
function Mk(r, t, e, n) {
  var i = n ? 'itemChildGroupId' : 'itemGroupId',
    a = GSt(r, i)
  if (a) {
    var o = HSt(r, t, a)
    return o
  }
  var s = r.getRawDataItem(t),
    l = n ? 'childGroupId' : 'groupId'
  if (s && s[l]) return s[l] + ''
  if (!n) return e || r.getId(t)
}
function Tk(r) {
  var t = []
  return (
    R(r, function (e) {
      var n = e.data,
        i = e.dataGroupId
      if (!(n.count() > a8))
        for (var a = n.getIndices(), o = 0; o < a.length; o++)
          t.push({
            data: n,
            groupId: Mk(n, o, i, !1),
            childGroupId: Mk(n, o, i, !0),
            divide: e.divide,
            dataIndex: o,
          })
    }),
    t
  )
}
function lA(r, t, e) {
  r.traverse(function (n) {
    n instanceof oe &&
      Je(
        n,
        {
          style: {
            opacity: 0,
          },
        },
        t,
        {
          dataIndex: e,
          isFrom: !0,
        },
      )
  })
}
function uA(r) {
  if (r.parent) {
    var t = r.getComputedTransform()
    r.setLocalTransform(t), r.parent.remove(r)
  }
}
function ih(r) {
  r.stopAnimation(),
    r.isGroup &&
      r.traverse(function (t) {
        t.stopAnimation()
      })
}
function WSt(r, t, e) {
  var n = xf('update', e, t)
  n &&
    r.traverse(function (i) {
      if (i instanceof ea) {
        var a = wnt(i)
        a &&
          i.animateFrom(
            {
              style: a,
            },
            n,
          )
      }
    })
}
function XSt(r, t) {
  var e = r.length
  if (e !== t.length) return !1
  for (var n = 0; n < e; n++) {
    var i = r[n],
      a = t[n]
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return !1
  }
  return !0
}
function o8(r, t, e) {
  var n = Tk(r),
    i = Tk(t)
  function a(_, x, A, S, b) {
    ;(A || _) &&
      x.animateFrom(
        {
          style: A && A !== _ ? Q(Q({}, A.style), _.style) : _.style,
        },
        b,
      )
  }
  var o = !1,
    s = USt,
    l = Pt(),
    u = Pt()
  n.forEach(function (_) {
    _.groupId && l.set(_.groupId, !0),
      _.childGroupId && u.set(_.childGroupId, !0)
  })
  for (var c = 0; c < i.length; c++) {
    var h = i[c].groupId
    if (u.get(h)) {
      s = bk
      break
    }
    var f = i[c].childGroupId
    if (f && l.get(f)) {
      s = wk
      break
    }
  }
  function d(_, x) {
    return function (A) {
      var S = A.data,
        b = A.dataIndex
      return x
        ? S.getId(b)
        : _
        ? s === bk
          ? A.childGroupId
          : A.groupId
        : s === wk
        ? A.childGroupId
        : A.groupId
    }
  }
  var p = XSt(n, i),
    g = {}
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c],
        m = v.data.getItemGraphicEl(v.dataIndex)
      m && (g[m.id] = !0)
    }
  function y(_, x) {
    var A = n[x],
      S = i[_],
      b = S.data.hostModel,
      T = A.data.getItemGraphicEl(A.dataIndex),
      w = S.data.getItemGraphicEl(S.dataIndex)
    if (T === w) {
      w && WSt(w, S.dataIndex, b)
      return
    }
    ;(T && g[T.id]) ||
      (w &&
        (ih(w),
        T
          ? (ih(T), uA(T), (o = !0), sA(lu(T), lu(w), S.divide, b, _, a))
          : lA(w, b, _)))
  }
  new es(n, i, d(!0, p), d(!1, p), null, 'multiple')
    .update(y)
    .updateManyToOne(function (_, x) {
      var A = i[_],
        S = A.data,
        b = S.hostModel,
        T = S.getItemGraphicEl(A.dataIndex),
        w = Ne(
          st(x, function (M) {
            return n[M].data.getItemGraphicEl(n[M].dataIndex)
          }),
          function (M) {
            return M && M !== T && !g[M.id]
          },
        )
      T &&
        (ih(T),
        w.length
          ? (R(w, function (M) {
              ih(M), uA(M)
            }),
            (o = !0),
            sA(lu(w), lu(T), A.divide, b, _, a))
          : lA(T, b, A.dataIndex))
    })
    .updateOneToMany(function (_, x) {
      var A = n[x],
        S = A.data.getItemGraphicEl(A.dataIndex)
      if (!(S && g[S.id])) {
        var b = Ne(
            st(_, function (w) {
              return i[w].data.getItemGraphicEl(i[w].dataIndex)
            }),
            function (w) {
              return w && w !== S
            },
          ),
          T = i[_[0]].data.hostModel
        b.length &&
          (R(b, function (w) {
            return ih(w)
          }),
          S
            ? (ih(S), uA(S), (o = !0), sA(lu(S), lu(b), A.divide, T, _[0], a))
            : R(b, function (w) {
                return lA(w, T, _[0])
              }))
      }
    })
    .updateManyToMany(function (_, x) {
      new es(
        x,
        _,
        function (A) {
          return n[A].data.getId(n[A].dataIndex)
        },
        function (A) {
          return i[A].data.getId(i[A].dataIndex)
        },
      )
        .update(function (A, S) {
          y(_[A], x[S])
        })
        .execute()
    })
    .execute(),
    o &&
      R(t, function (_) {
        var x = _.data,
          A = x.hostModel,
          S = A && e.getViewOfSeriesModel(A),
          b = xf('update', A, 0)
        S &&
          A.isAnimationEnabled() &&
          b &&
          b.duration > 0 &&
          S.group.traverse(function (T) {
            T instanceof oe &&
              !T.animators.length &&
              T.animateFrom(
                {
                  style: {
                    opacity: 0,
                  },
                },
                b,
              )
          })
      })
}
function Ck(r) {
  var t = r.getModel('universalTransition').get('seriesKey')
  return t || r.id
}
function Ek(r) {
  return at(r) ? r.sort().join(',') : r
}
function Ds(r) {
  if (r.hostModel)
    return r.hostModel.getModel('universalTransition').get('divideShape')
}
function YSt(r, t) {
  var e = Pt(),
    n = Pt(),
    i = Pt()
  return (
    R(r.oldSeries, function (a, o) {
      var s = r.oldDataGroupIds[o],
        l = r.oldData[o],
        u = Ck(a),
        c = Ek(u)
      n.set(c, {
        dataGroupId: s,
        data: l,
      }),
        at(u) &&
          R(u, function (h) {
            i.set(h, {
              key: c,
              dataGroupId: s,
              data: l,
            })
          })
    }),
    R(t.updatedSeries, function (a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var o = a.get('dataGroupId'),
          s = a.getData(),
          l = Ck(a),
          u = Ek(l),
          c = n.get(u)
        if (c)
          e.set(u, {
            oldSeries: [
              {
                dataGroupId: c.dataGroupId,
                divide: Ds(c.data),
                data: c.data,
              },
            ],
            newSeries: [
              {
                dataGroupId: o,
                divide: Ds(s),
                data: s,
              },
            ],
          })
        else if (at(l)) {
          var h = []
          R(l, function (p) {
            var g = n.get(p)
            g.data &&
              h.push({
                dataGroupId: g.dataGroupId,
                divide: Ds(g.data),
                data: g.data,
              })
          }),
            h.length &&
              e.set(u, {
                oldSeries: h,
                newSeries: [
                  {
                    dataGroupId: o,
                    data: s,
                    divide: Ds(s),
                  },
                ],
              })
        } else {
          var f = i.get(l)
          if (f) {
            var d = e.get(f.key)
            d ||
              ((d = {
                oldSeries: [
                  {
                    dataGroupId: f.dataGroupId,
                    data: f.data,
                    divide: Ds(f.data),
                  },
                ],
                newSeries: [],
              }),
              e.set(f.key, d)),
              d.newSeries.push({
                dataGroupId: o,
                data: s,
                divide: Ds(s),
              })
          }
        }
      }
    }),
    e
  )
}
function Dk(r, t) {
  for (var e = 0; e < r.length; e++) {
    var n =
      (t.seriesIndex != null && t.seriesIndex === r[e].seriesIndex) ||
      (t.seriesId != null && t.seriesId === r[e].id)
    if (n) return e
  }
}
function $St(r, t, e, n) {
  var i = [],
    a = []
  R(ke(r.from), function (o) {
    var s = Dk(t.oldSeries, o)
    s >= 0 &&
      i.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: t.oldData[s],
        divide: Ds(t.oldData[s]),
        groupIdDim: o.dimension,
      })
  }),
    R(ke(r.to), function (o) {
      var s = Dk(e.updatedSeries, o)
      if (s >= 0) {
        var l = e.updatedSeries[s].getData()
        a.push({
          dataGroupId: t.oldDataGroupIds[s],
          data: l,
          divide: Ds(l),
          groupIdDim: o.dimension,
        })
      }
    }),
    i.length > 0 && a.length > 0 && o8(i, a, n)
}
function qSt(r) {
  r.registerUpdateLifecycle('series:beforeupdate', function (t, e, n) {
    R(ke(n.seriesTransition), function (i) {
      R(ke(i.to), function (a) {
        for (var o = n.updatedSeries, s = 0; s < o.length; s++)
          ((a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex) ||
            (a.seriesId != null && a.seriesId === o[s].id)) &&
            (o[s][iy] = !0)
      })
    })
  }),
    r.registerUpdateLifecycle('series:transition', function (t, e, n) {
      var i = VSt(e)
      if (i.oldSeries && n.updatedSeries && n.optionChanged) {
        var a = n.seriesTransition
        if (a)
          R(ke(a), function (d) {
            $St(d, i, n, e)
          })
        else {
          var o = YSt(i, n)
          R(o.keys(), function (d) {
            var p = o.get(d)
            o8(p.oldSeries, p.newSeries, e)
          })
        }
        R(n.updatedSeries, function (d) {
          d[iy] && (d[iy] = !1)
        })
      }
      for (
        var s = t.getSeries(),
          l = (i.oldSeries = []),
          u = (i.oldDataGroupIds = []),
          c = (i.oldData = []),
          h = 0;
        h < s.length;
        h++
      ) {
        var f = s[h].getData()
        f.count() < a8 &&
          (l.push(s[h]), u.push(s[h].get('dataGroupId')), c.push(f))
      }
    })
}
ie([ult])
ie([nlt])
ie([
  Ilt,
  jlt,
  cut,
  jut,
  pct,
  lht,
  zht,
  Mft,
  Qft,
  ldt,
  _dt,
  bpt,
  Kpt,
  uvt,
  Dvt,
  kvt,
  tgt,
  cgt,
  bgt,
  Pgt,
  Wgt,
  Dmt,
])
ie(Jmt)
ie(Ryt)
ie(e4)
ie(Zyt)
ie(V4)
ie(n0t)
ie(h0t)
ie(f_t)
ie(N_t)
ie(Ov)
ie(ext)
ie(ixt)
ie(_xt)
ie(Dxt)
ie(Bxt)
ie(Xxt)
ie(a1t)
ie(C1t)
ie(YH)
ie($H)
ie(tSt)
ie(JH)
ie(QH)
ie(aSt)
ie(ySt)
ie(SSt)
ie(qSt)
ie(xst)
const ZSt = {
    class: 'm-card-hd',
  },
  KSt = {
    class: 'm-card-hd-title',
  },
  jSt = {
    class: 'm-card-bd-content',
  },
  ml = {
    __name: 'index',
    props: {
      width: {
        type: Number,
        default: 398,
      },
      height: {
        type: Number,
        default: 100,
      },
      title: {
        type: String,
        default: '标题',
      },
    },
    setup(r) {
      const t = r,
        e = Ql(() => `width:${t.width}px;height:${t.height}px;`)
      return (n, i) => (
        en(),
        sn(
          'div',
          {
            class: 'm-card',
            style: fy(e.value),
          },
          [
            wt('div', ZSt, [
              wt('div', KSt, Si(r.title), 1),
              i[0] ||
                (i[0] = wt(
                  'div',
                  {
                    class: 'm-card-hd-dot',
                  },
                  [
                    wt('div', {
                      class: 'dot dot1',
                    }),
                    wt('div', {
                      class: 'dot dot2',
                    }),
                    wt('div', {
                      class: 'dot dot3',
                    }),
                  ],
                  -1,
                )),
            ]),
            wt(
              'div',
              {
                class: 'm-card-bd',
                style: fy(e.value),
              },
              [wt('div', jSt, [Bh(n.$slots, 'default')])],
              4,
            ),
          ],
          4,
        )
      )
    },
  }
var cA = null
function JSt(r) {
  return (
    cA ||
      (cA = (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (t) {
          return setTimeout(t, 16)
        }
      ).bind(window)),
    cA(r)
  )
}
var hA = null
function QSt(r) {
  hA ||
    (hA = (
      window.cancelAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame ||
      function (t) {
        clearTimeout(t)
      }
    ).bind(window)),
    hA(r)
}
function tAt(r) {
  var t = document.createElement('style')
  return (
    t.styleSheet
      ? (t.styleSheet.cssText = r)
      : t.appendChild(document.createTextNode(r)),
    (document.querySelector('head') || document.body).appendChild(t),
    t
  )
}
function Pm(r, t) {
  t === void 0 && (t = {})
  var e = document.createElement(r)
  return (
    Object.keys(t).forEach(function (n) {
      e[n] = t[n]
    }),
    e
  )
}
function s8(r, t, e) {
  var n = window.getComputedStyle(r, e || null) || {
    display: 'none',
  }
  return n[t]
}
function pM(r) {
  if (!document.documentElement.contains(r))
    return {
      detached: !0,
      rendered: !1,
    }
  for (var t = r; t !== document; ) {
    if (s8(t, 'display') === 'none')
      return {
        detached: !1,
        rendered: !1,
      }
    t = t.parentNode
  }
  return {
    detached: !1,
    rendered: !0,
  }
}
var eAt =
    '.resize-triggers{visibility:hidden;opacity:0;pointer-events:none}.resize-contract-trigger,.resize-contract-trigger:before,.resize-expand-trigger,.resize-triggers{content:"";position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden}.resize-contract-trigger,.resize-expand-trigger{background:#eee;overflow:auto}.resize-contract-trigger:before{width:200%;height:200%}',
  vM = 0,
  hy = null
function nAt(r, t) {
  r.__resize_mutation_handler__ || (r.__resize_mutation_handler__ = aAt.bind(r))
  var e = r.__resize_listeners__
  if (!e) {
    if (((r.__resize_listeners__ = []), window.ResizeObserver)) {
      var n = r.offsetWidth,
        i = r.offsetHeight,
        a = new ResizeObserver(function () {
          ;(!r.__resize_observer_triggered__ &&
            ((r.__resize_observer_triggered__ = !0),
            r.offsetWidth === n && r.offsetHeight === i)) ||
            L0(r)
        }),
        o = pM(r),
        s = o.detached,
        l = o.rendered
      ;(r.__resize_observer_triggered__ = s === !1 && l === !1),
        (r.__resize_observer__ = a),
        a.observe(r)
    } else if (r.attachEvent && r.addEventListener)
      (r.__resize_legacy_resize_handler__ = function () {
        L0(r)
      }),
        r.attachEvent('onresize', r.__resize_legacy_resize_handler__),
        document.addEventListener(
          'DOMSubtreeModified',
          r.__resize_mutation_handler__,
        )
    else if (
      (vM || (hy = tAt(eAt)),
      oAt(r),
      (r.__resize_rendered__ = pM(r).rendered),
      window.MutationObserver)
    ) {
      var u = new MutationObserver(r.__resize_mutation_handler__)
      u.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0,
      }),
        (r.__resize_mutation_observer__ = u)
    }
  }
  r.__resize_listeners__.push(t), vM++
}
function rAt(r, t) {
  var e = r.__resize_listeners__
  if (e) {
    if ((t && e.splice(e.indexOf(t), 1), !e.length || !t)) {
      if (r.detachEvent && r.removeEventListener) {
        r.detachEvent('onresize', r.__resize_legacy_resize_handler__),
          document.removeEventListener(
            'DOMSubtreeModified',
            r.__resize_mutation_handler__,
          )
        return
      }
      r.__resize_observer__
        ? (r.__resize_observer__.unobserve(r),
          r.__resize_observer__.disconnect(),
          (r.__resize_observer__ = null))
        : (r.__resize_mutation_observer__ &&
            (r.__resize_mutation_observer__.disconnect(),
            (r.__resize_mutation_observer__ = null)),
          r.removeEventListener('scroll', OE),
          r.removeChild(r.__resize_triggers__.triggers),
          (r.__resize_triggers__ = null)),
        (r.__resize_listeners__ = null)
    }
    !--vM && hy && hy.parentNode.removeChild(hy)
  }
}
function iAt(r) {
  var t = r.__resize_last__,
    e = t.width,
    n = t.height,
    i = r.offsetWidth,
    a = r.offsetHeight
  return i !== e || a !== n
    ? {
        width: i,
        height: a,
      }
    : null
}
function aAt() {
  var r = pM(this),
    t = r.rendered,
    e = r.detached
  t !== this.__resize_rendered__ &&
    (!e &&
      this.__resize_triggers__ &&
      (NE(this), this.addEventListener('scroll', OE, !0)),
    (this.__resize_rendered__ = t),
    L0(this))
}
function OE() {
  var r = this
  NE(this),
    this.__resize_raf__ && QSt(this.__resize_raf__),
    (this.__resize_raf__ = JSt(function () {
      var t = iAt(r)
      t && ((r.__resize_last__ = t), L0(r))
    }))
}
function L0(r) {
  !r ||
    !r.__resize_listeners__ ||
    r.__resize_listeners__.forEach(function (t) {
      t.call(r, r)
    })
}
function oAt(r) {
  var t = s8(r, 'position')
  ;(!t || t === 'static') && (r.style.position = 'relative'),
    (r.__resize_old_position__ = t),
    (r.__resize_last__ = {})
  var e = Pm('div', {
      className: 'resize-triggers',
    }),
    n = Pm('div', {
      className: 'resize-expand-trigger',
    }),
    i = Pm('div'),
    a = Pm('div', {
      className: 'resize-contract-trigger',
    })
  n.appendChild(i),
    e.appendChild(n),
    e.appendChild(a),
    r.appendChild(e),
    (r.__resize_triggers__ = {
      triggers: e,
      expand: n,
      expandChild: i,
      contract: a,
    }),
    NE(r),
    r.addEventListener('scroll', OE, !0),
    (r.__resize_last__ = {
      width: r.offsetWidth,
      height: r.offsetHeight,
    })
}
function NE(r) {
  var t = r.__resize_triggers__,
    e = t.expand,
    n = t.expandChild,
    i = t.contract,
    a = i.scrollWidth,
    o = i.scrollHeight,
    s = e.offsetWidth,
    l = e.offsetHeight,
    u = e.scrollWidth,
    c = e.scrollHeight
  ;(i.scrollLeft = a),
    (i.scrollTop = o),
    (n.style.width = s + 1 + 'px'),
    (n.style.height = l + 1 + 'px'),
    (e.scrollLeft = u),
    (e.scrollTop = c)
}
var Ha = function () {
  return (
    (Ha =
      Object.assign ||
      function (r) {
        for (var t, e = 1, n = arguments.length; e < n; e++)
          for (var i in (t = arguments[e]))
            Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i])
        return r
      }),
    Ha.apply(this, arguments)
  )
}
var sAt = [
  'getWidth',
  'getHeight',
  'getDom',
  'getOption',
  'resize',
  'dispatchAction',
  'convertToPixel',
  'convertFromPixel',
  'containPixel',
  'getDataURL',
  'getConnectedDataURL',
  'appendData',
  'clear',
  'isDisposed',
  'dispose',
]
function lAt(r) {
  return (
    (t = Object.create(null)),
    sAt.forEach(function (e) {
      t[e] = (function (n) {
        return function () {
          for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a]
          if (!r.value) throw new Error('ECharts is not initialized yet.')
          return r.value[n].apply(r.value, i)
        }
      })(e)
    }),
    t
  )
  var t
}
var uAt = {
    autoresize: [Boolean, Object],
  },
  cAt = /^on[^a-z]/,
  Lk = function (r) {
    return cAt.test(r)
  }
function Rm(r, t) {
  var e = m8(r) ? La(r) : r
  return e && typeof e == 'object' && 'value' in e ? e.value || t : e || t
}
var hAt = 'ecLoadingOptions',
  fAt = {
    loading: Boolean,
    loadingOptions: Object,
  },
  wd = null,
  l8 = 'x-vue-echarts',
  Pk = [],
  Md = []
;(function (r, t) {
  if (r && typeof document < 'u') {
    var e,
      n = t.prepend === !0 ? 'prepend' : 'append',
      i = t.singleTag === !0,
      a =
        typeof t.container == 'string'
          ? document.querySelector(t.container)
          : document.getElementsByTagName('head')[0]
    if (i) {
      var o = Pk.indexOf(a)
      o === -1 && ((o = Pk.push(a) - 1), (Md[o] = {})),
        (e = Md[o] && Md[o][n] ? Md[o][n] : (Md[o][n] = s()))
    } else e = s()
    r.charCodeAt(0) === 65279 && (r = r.substring(1)),
      e.styleSheet
        ? (e.styleSheet.cssText += r)
        : e.appendChild(document.createTextNode(r))
  }
  function s() {
    var l = document.createElement('style')
    if ((l.setAttribute('type', 'text/css'), t.attributes))
      for (var u = Object.keys(t.attributes), c = 0; c < u.length; c++)
        l.setAttribute(u[c], t.attributes[u[c]])
    var h = n === 'prepend' ? 'afterbegin' : 'beforeend'
    return a.insertAdjacentElement(h, l), l
  }
})(
  `x-vue-echarts{display:flex;flex-direction:column;width:100%;height:100%;min-width:0}
.vue-echarts-inner{flex-grow:1;min-width:0;width:auto!important;height:auto!important}
`,
  {},
)
var dAt = (function () {
    if (wd != null) return wd
    if (typeof HTMLElement > 'u' || typeof customElements > 'u')
      return (wd = !1)
    try {
      new Function(
        'tag',
        `class EChartsElement extends HTMLElement {
  __dispose = null;

  disconnectedCallback() {
    if (this.__dispose) {
      this.__dispose();
      this.__dispose = null;
    }
  }
}

if (customElements.get(tag) == null) {
  customElements.define(tag, EChartsElement);
}
`,
      )(l8)
    } catch {
      return (wd = !1)
    }
    return (wd = !0)
  })(),
  pAt = 'ecTheme',
  vAt = 'ecInitOptions',
  gAt = 'ecUpdateOptions',
  Rk = /(^&?~?!?)native:/,
  uc = p8({
    name: 'echarts',
    props: Ha(
      Ha(
        {
          option: Object,
          theme: {
            type: [Object, String],
          },
          initOptions: Object,
          updateOptions: Object,
          group: String,
          manualUpdate: Boolean,
        },
        uAt,
      ),
      fAt,
    ),
    emits: {},
    inheritAttrs: !1,
    setup: function (r, t) {
      var e = t.attrs,
        n = hh(),
        i = hh(),
        a = hh(),
        o = hh(),
        s = dh(pAt, null),
        l = dh(vAt, null),
        u = dh(gAt, null),
        c = v8(r),
        h = c.autoresize,
        f = c.manualUpdate,
        d = c.loading,
        p = c.loadingOptions,
        g = Ql(function () {
          return o.value || r.option || null
        }),
        v = Ql(function () {
          return r.theme || Rm(s, {})
        }),
        m = Ql(function () {
          return r.initOptions || Rm(l, {})
        }),
        y = Ql(function () {
          return r.updateOptions || Rm(u, {})
        }),
        _ = Ql(function () {
          return (function (C) {
            var E = {}
            for (var D in C) Lk(D) || (E[D] = C[D])
            return E
          })(e)
        }),
        x = {},
        A = g8().proxy.$listeners,
        S = {}
      function b(C) {
        if (i.value) {
          var E = (a.value = kat(i.value, v.value, m.value))
          r.group && (E.group = r.group),
            Object.keys(S).forEach(function (P) {
              var L = S[P]
              if (L) {
                var I = P.toLowerCase()
                I.charAt(0) === '~' && ((I = I.substring(1)), (L.__once__ = !0))
                var F = E
                if (
                  (I.indexOf('zr:') === 0 &&
                    ((F = E.getZr()), (I = I.substring(3))),
                  L.__once__)
                ) {
                  delete L.__once__
                  var k = L
                  L = function () {
                    for (var V = [], H = 0; H < arguments.length; H++)
                      V[H] = arguments[H]
                    k.apply(void 0, V), F.off(I, L)
                  }
                }
                F.on(I, L)
              }
            }),
            h.value
              ? so(function () {
                  E && !E.isDisposed() && E.resize(), D()
                })
              : D()
        }
        function D() {
          var P = C || g.value
          P && E.setOption(P, y.value)
        }
      }
      function T() {
        a.value && (a.value.dispose(), (a.value = void 0))
      }
      A
        ? Object.keys(A).forEach(function (C) {
            Rk.test(C) ? (x[C.replace(Rk, '$1')] = A[C]) : (S[C] = A[C])
          })
        : Object.keys(e)
            .filter(function (C) {
              return Lk(C)
            })
            .forEach(function (C) {
              var E = C.charAt(2).toLowerCase() + C.slice(3)
              if (E.indexOf('native:') !== 0)
                E.substring(E.length - 4) === 'Once' &&
                  (E = '~'.concat(E.substring(0, E.length - 4))),
                  (S[E] = e[C])
              else {
                var D = 'on'
                  .concat(E.charAt(7).toUpperCase())
                  .concat(E.slice(8))
                x[D] = e[C]
              }
            })
      var w = null
      Td(
        f,
        function (C) {
          typeof w == 'function' && (w(), (w = null)),
            C ||
              (w = Td(
                function () {
                  return r.option
                },
                function (E, D) {
                  E &&
                    (a.value
                      ? a.value.setOption(
                          E,
                          Ha(
                            {
                              notMerge: E !== D,
                            },
                            y.value,
                          ),
                        )
                      : b())
                },
                {
                  deep: !0,
                },
              ))
        },
        {
          immediate: !0,
        },
      ),
        Td(
          [v, m],
          function () {
            T(), b()
          },
          {
            deep: !0,
          },
        ),
        WE(function () {
          r.group && a.value && (a.value.group = r.group)
        })
      var M = lAt(a)
      return (
        (function (C, E, D) {
          var P = dh(hAt, {}),
            L = Ql(function () {
              return Ha(Ha({}, Rm(P, {})), D == null ? void 0 : D.value)
            })
          WE(function () {
            var I = C.value
            I && (E.value ? I.showLoading(L.value) : I.hideLoading())
          })
        })(a, d, p),
        (function (C, E, D) {
          var P = null
          Td([D, C, E], function (L, I, F) {
            var k = L[0],
              V = L[1],
              H = L[2]
            if (k && V && H) {
              var Y = H === !0 ? {} : H,
                K = Y.throttle,
                ut = K === void 0 ? 100 : K,
                W = Y.onResize,
                Z = function () {
                  V.resize(), W == null || W()
                }
              ;(P = ut ? __(Z, ut) : Z), nAt(k, P)
            }
            F(function () {
              k && P && rAt(k, P)
            })
          })
        })(a, h, i),
        Ea(function () {
          b()
        }),
        Da(function () {
          dAt && n.value ? (n.value.__dispose = T) : T()
        }),
        Ha(
          {
            chart: a,
            root: n,
            inner: i,
            setOption: function (C, E) {
              r.manualUpdate && (o.value = C),
                a.value ? a.value.setOption(C, E || {}) : b(C)
            },
            nonEventAttrs: _,
            nativeListeners: x,
          },
          M,
        )
      )
    },
    render: function () {
      var r = Ha(Ha({}, this.nonEventAttrs), this.nativeListeners)
      return (
        (r.ref = 'root'),
        (r.class = r.class ? ['echarts'].concat(r.class) : 'echarts'),
        XE(l8, r, [
          XE('div', {
            ref: 'inner',
            class: 'vue-echarts-inner',
          }),
        ])
      )
    },
  })
function yl(r, t = 500) {
  let e = null,
    n = je(!1)
  const i = () => {
    n.value ||
      (r(),
      (n.value = !0),
      (e = setTimeout(() => {
        n.value = !1
      }, t)))
  }
  return (
    window.addEventListener('resize', i),
    {
      destroy() {
        window.removeEventListener('resize', i), clearTimeout(e)
      },
    }
  )
}
const mAt = {
    __name: 'BulkCommoditySalesChart',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#ffffff',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          xAxis: [
            {
              type: 'category',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['农产品', '能源', '金属', '化工', '木材'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '',
              data: [100, 120, 150, 110, 100],
              type: 'bar',
              barWidth: 4,
              stack: 'b',
              z: 3,
              yAxisIndex: 0,
              showBackground: !1,
              backgroundStyle: {
                color: 'rgba(180, 180, 180, 0.2)',
              },
              label: {
                show: !0,
                position: 'top',
                distance: 15,
                color: '#ffffff',
                fontSize: 10,
              },
              itemStyle: {
                borderRadius: 2,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#19FFC6',
                  },
                  {
                    offset: 1,
                    color: '#33AAFF',
                  },
                ]),
              },
            },
            {
              type: 'custom',
              renderItem: (o, s) => {
                const l = s.value(0),
                  u = s.value(1),
                  c = s.coord([l, u]),
                  h = c[1]
                return {
                  type: 'image',
                  style: {
                    x: c[0] - 4.5,
                    y: h - 9,
                    width: 10,
                    height: 10,
                    image:
                      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAAXNSR0IArs4c6QAAAL1JREFUOE9j/P///38GMgAjSKOMdxRJWp9sXcYA18giJMLw99MHhv9//mA1hJGZhYGZX4Dhz7s3DCgaGVlYGDjVtBi+37rO8P/PbxTNjCysDJyqWgzfb18Dy6FoBKmEKfh17wZcM0iMTUkDrgmkDkMjSJCFnZ3hwbr5KDYqBCUy/Pn5Ey6GVSMzMxPDw01LUDTK+8Uw/P37j0YayXIqWYGDHuTInsQbHeAE8PEDw/+/JCYAUtIcPDpI0QRTCwDhurXXJ/EmUwAAAABJRU5ErkJggg==',
                  },
                }
              },
              xAxisIndex: 1,
              data: [100, 120, 150, 110, 100],
            },
            {
              type: 'bar',
              barWidth: 32,
              xAxisIndex: 1,
              barGap: '-220%',
              data: [150, 150, 150, 150, 150],
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'rgba(255,255,255,0.8)',
                },
              },
              itemStyle: {
                color: 'rgba(122,140,153,0.6)',
                opacity: 0.1,
              },
              z: 0,
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '大宗商品销售额',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  yAt = './assets/ring2-a1b91808.png',
  _At = './assets/ring3-fe0f60d7.png',
  xAt = './assets/ring4-f2e324d6.png'
const SAt = {
    name: 'ThreePie',
    props: {
      data: {
        type: Array,
        default: () => [],
      },
      colors: {
        type: Array,
        default: () => [2161326, 15380744, 3122407, 65535, 16536624],
      },
      opacity: {
        type: Number,
        default: 0.5,
      },
      delay: {
        type: Number,
        default: 5e3,
      },
      loopComplete: {
        type: Function,
        default: () => {},
      },
    },
    computed: {
      currentData() {
        return {
          ...this.data[this.activeIndex],
          count: this.count,
        }
      },
    },
    data() {
      return (
        (this.scene = null),
        (this.camera = null),
        (this.renderer = null),
        (this.controls = null),
        (this.axes = null),
        (this.pieGroup = new un()),
        {
          width: 300,
          height: 200,
          activeIndex: 0,
          count: 0,
          timer: null,
        }
      )
    },
    mounted() {
      ;(this.width = this.$refs.pieDom.offsetWidth),
        (this.height = this.$refs.pieDom.offsetHeight),
        (this.count = this.data.map(r => r.value).reduce((r, t) => r + t, 0)),
        this.init()
    },
    beforeUnmount() {
      clearInterval(this.timer), this.destroy()
    },
    methods: {
      init() {
        ;(this.scene = new hB()),
          this.initCamera(),
          this.initRenderer(),
          this.initLight(),
          this.initAxes(),
          this.initControls(),
          this.createPlane({
            url: yAt,
            width: 5,
            position: new U(0, 0, -0.01),
            color: '#00ffff',
          }),
          this.createPlane({
            url: _At,
            width: 6.5,
            position: new U(0, 0, -0.02),
            color: '#00ffff',
          }),
          this.createPlane({
            url: xAt,
            width: 5.5,
            position: new U(0, 0, -0.03),
            animate: !0,
            color: '#00ffff',
          }),
          this.createPie(),
          this.loop()
      },
      createPlane(r) {
        let t = {
            url: 'texture/ring1.png',
            width: 5.5,
            z: 0,
            position: new U(0, 0, 0),
            animate: !1,
            color: null,
          },
          e = Object.assign(t, r)
        const n = new Ti(e.width, e.width),
          i = new on({
            map: this.getTexture(e.url),
            transparent: !0,
            side: dr,
            depthTest: !1,
          })
        e.color && (i.color = new qt(e.color))
        const a = new De(n, i)
        a.position.copy(e.position),
          (a.rotation.x = (-1 * Math.PI) / 2),
          e.animate &&
            Sn.to(a.rotation, {
              z: 2 * Math.PI,
              repeat: -1,
              ease: 'none',
              duration: 3,
            }),
          this.scene.add(a)
      },
      getTexture(r) {
        const t = new ZM().load(r)
        return (t.wrapS = t.wrapT = Jn), t
      },
      createPie() {
        let r = 0,
          t = 0
        for (var e = 0; e < this.data.length; e++) {
          let n = this.data[e].value / this.count
          e == 0 ? (r = 0) : (r = t + 1e-4), (t = t + 2 * Math.PI * n - 1e-4)
          let i = this.addRing({
            startAngle: r,
            endAngle: t,
            color: new qt(this.colors[e % this.colors.length]),
          })
          ;(i.name = 'ring' + e), this.pieGroup.add(i)
        }
        this.scene.add(this.pieGroup),
          this.chooseRing(this.activeIndex, !0),
          (this.timer = setInterval(() => {
            this.loopChange()
          }, this.delay))
      },
      loopChange() {
        let r = this.activeIndex + 1
        r >= this.data.length &&
          ((r = 0), this.loopComplete && this.loopComplete()),
          this.chooseRing(r)
      },
      chooseRing(r = 0, t = !1) {
        let e = r - 1 < 0 ? this.data.length - 1 : r - 1,
          n = this.pieGroup.children[e]
        ;(this.prevMesh = n), (this.activeIndex = r)
        let i = this.pieGroup.children[r]
        t ||
          (Sn.to(n.scale, {
            z: 1,
          }),
          Sn.to(n.material, {
            opacity: this.opacity,
          })),
          Sn.to(i.scale, {
            z: 2,
          }),
          Sn.to(i.material, {
            opacity: 0.8,
          })
      },
      addRing(r = {}) {
        let t = {
            innerRadius: 1.5,
            outerRadius: 2,
            thickness: 0.5,
            startAngle: 0,
            endAngle: Math.PI / 2,
            color: 65535,
            segments: 120,
          },
          e = Object.assign(t, r),
          n = new wu()
        n.arc(0, 0, e.outerRadius, e.startAngle, e.endAngle)
        let i = n.getPoints(e.segments),
          a = new wu()
        a.arc(0, 0, e.innerRadius, e.endAngle, e.startAngle, !0)
        let o = a.getPoints(e.segments),
          s = new wu(i.concat(o))
        const l = {
            steps: 1,
            depth: e.thickness,
            bevelEnabled: !0,
            bevelThickness: 0,
            bevelSize: 0,
            bevelOffset: 0,
            bevelSegments: 0,
          },
          u = new B0(s, l)
        let c = new CB({
          color: e.color,
          transparent: !0,
          opacity: this.opacity,
          side: dr,
        })
        const h = new De(u, c.clone())
        return (h.renderOrder = 10), (h.rotation.x = (-1 * Math.PI) / 2), h
      },
      initCamera() {
        var r = this.width / this.height
        ;(this.camera = new wr(30, r, 0.1, 1500)),
          this.camera.position.set(
            6.023813305272227,
            4.838542633695233,
            6.111272698256137,
          ),
          this.camera.lookAt(0, 0, 0)
      },
      initRenderer() {
        ;(this.renderer = new cB({
          antialias: !0,
          alpha: !0,
        })),
          this.renderer.setPixelRatio(window.devicePixelRatio),
          this.renderer.setSize(this.width, this.height),
          this.$refs.pieDom.appendChild(this.renderer.domElement)
      },
      initLight() {
        let r = new Ay(16777215, 2)
        r.position.set(200, 300, 200)
        let t = new Ay(16777215, 2)
        t.position.set(-200, -300, -200)
        let e = new PB(16777215, 2)
        this.scene.add(r), this.scene.add(t), this.scene.add(e)
      },
      initAxes() {
        ;(this.axes = new RB(0)), this.scene.add(this.axes)
      },
      initControls() {
        ;(this.controls = new FB(this.camera, this.renderer.domElement)),
          (this.controls.maxPolarAngle = Math.PI),
          (this.controls.autoRotate = !1),
          (this.controls.enableDamping = !0),
          (this.controls.enabled = !1)
      },
      loop() {
        this.renderer.setAnimationLoop(() => {
          this.renderer.render(this.scene, this.camera),
            this.controls && this.controls.update()
        })
      },
      start() {
        this.loop(),
          (this.controls.enabled = !0),
          (this.timer = setInterval(() => {
            this.loopChange()
          }, this.delay))
      },
      stop() {
        clearInterval(this.timer),
          this.controls && (this.controls.enabled = !1),
          this.renderer && this.renderer.setAnimationLoop(null)
      },
      getScene() {
        return this.scene
      },
      getRender() {
        return this.renderer
      },
      resize() {
        ;(this.width = this.$refs.pieDom.offsetWidth),
          (this.height = this.$refs.pieDom.offsetHeight)
        let r = this.width / this.height
        ;(this.camera.aspect = r),
          this.camera.updateProjectionMatrix(),
          this.renderer.setSize(this.width, this.height),
          this.renderer.setPixelRatio(window.devicePixelRatio)
      },
      destroy() {
        this.prevMesh &&
          (Sn.set(this.prevMesh.scale, {
            z: 1,
          }),
          Sn.set(this.prevMesh.material, {
            opacity: this.opacity,
          })),
          this.stop(),
          window.removeEventListener('resize', () => {
            this.resize()
          }),
          this.renderer &&
            (va(this.pieGroup),
            this.renderer.dispose(),
            this.renderer.forceContextLoss(),
            this.controls.dispose(),
            (this.$refs.pieDom.innerHTML = ''),
            (this.scene = null),
            (this.camera = null),
            (this.renderer = null),
            (this.controls = null),
            (this.axes = null))
      },
    },
  },
  AAt = {
    class: 'three-pie-wrap',
  },
  bAt = {
    class: 'three-pie',
    ref: 'pieDom',
  },
  wAt = {
    class: 'three-pie-slot',
  }
function MAt(r, t, e, n, i, a) {
  return (
    en(),
    sn('div', AAt, [
      wt('div', bAt, null, 512),
      wt('div', wAt, [
        Bh(r.$slots, 'default', {
          data: a.currentData,
        }),
      ]),
    ])
  )
}
const TAt = X0(SAt, [['render', MAt]])
const CAt = {
    class: 'pie-chat-wrap',
  },
  EAt = {
    class: 'pie-chat',
  },
  DAt = {
    class: 'pieCanvas-content',
  },
  LAt = {
    class: 'pieCanvas-content-value',
  },
  PAt = {
    class: 'pieCanvas-content-name',
  },
  RAt = {
    class: 'pie-legend',
  },
  IAt = {
    class: 'name',
  },
  OAt = {
    class: 'value',
  },
  NAt = {
    __name: 'YearlyEconomyTrend',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je(null),
        i = yM({
          pieDataColor: ['#17E6C3', '#40CFFF', '#1979FF', '#FFC472'],
          pieData: [
            {
              name: '类型1',
              value: 400,
            },
            {
              name: '类型2',
              value: 250,
            },
            {
              name: '类型3',
              value: 200,
            },
            {
              name: '类型4',
              value: 150,
            },
          ],
        })
      function a(l) {
        return Number(((l.data.value / l.data.count) * 100).toFixed(2))
      }
      const o = () => {
          ;(e.value = t.value.offsetHeight - 2),
            console.log('resize'),
            so(() => {
              setTimeout(() => {
                n.value && n.value.resize()
              })
            })
        },
        {destroy: s} = yl(o)
      return (
        Ea(() => {
          so(() => {
            o()
          })
        }),
        Da(() => {
          s()
        }),
        (l, u) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '年度经济增长点',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    wt('div', CAt, [
                      wt('div', EAt, [
                        ye(
                          TAt,
                          {
                            ref_key: 'pie',
                            ref: n,
                            data: i.pieData,
                            delay: 3e3,
                            colors: i.pieDataColor,
                            opacity: 0.6,
                            class: 'pieCanvas',
                          },
                          {
                            default: Qn(c => [
                              wt('div', DAt, [
                                wt('div', LAt, [
                                  ye(
                                    La(bT),
                                    {
                                      startVal: 0,
                                      endVal: a(c),
                                      decimals: 2,
                                      duration: 1e3,
                                      autoplay: !0,
                                    },
                                    null,
                                    8,
                                    ['endVal'],
                                  ),
                                  u[0] || (u[0] = ko(' % ')),
                                ]),
                                wt('div', PAt, Si(c.data.name), 1),
                              ]),
                            ]),
                            _: 1,
                          },
                          8,
                          ['data', 'colors'],
                        ),
                      ]),
                      wt('div', RAt, [
                        (en(!0),
                        sn(
                          _M,
                          null,
                          xM(
                            i.pieData,
                            (c, h) => (
                              en(),
                              sn(
                                'div',
                                {
                                  class: 'pie-legend-item',
                                  key: h,
                                },
                                [
                                  wt(
                                    'div',
                                    {
                                      class: 'icon',
                                      style: fy({
                                        borderColor: i.pieDataColor[h],
                                      }),
                                    },
                                    null,
                                    4,
                                  ),
                                  wt('div', IAt, Si(c.name), 1),
                                  wt('div', OAt, [
                                    ko(Si(c.value), 1),
                                    u[1] ||
                                      (u[1] = wt(
                                        'span',
                                        {
                                          class: 'unit',
                                        },
                                        '亿',
                                        -1,
                                      )),
                                  ]),
                                ],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ]),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  kAt = {
    __name: 'EconomicTrendChart',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          color: ['#6BC7F6'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 1,
                padding: [0, 0, 0, 0],
              },
              data: [
                '2023/04',
                '2023/05',
                '2023/06',
                '2023/07',
                '2023/08',
                '2023/09',
                '2023/10',
                '2023/11',
                '2023/12',
                '2024/01',
                '2024/02',
                '2024/03',
              ],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              data: [
                500, 1e3, 300, 1300, 500, 1330, 620, 400, 700, 1300, 300, 1234,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 10,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '近年经济情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  BAt = {
    __name: 'DistrictEconomicIncome',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          color: ['#6BC7F6'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['南山区', '天河区', '福田区', '龙岗区', '宝安区'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !1,
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '',
              type: 'pictorialBar',
              symbol:
                'path://M0,10 L10,10 C5.5,10 5.5,5 5,0 C4.5,5 4.5,10 0,10 z',
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 10,
              },
              data: [
                {
                  value: 8e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 7500,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(25, 255, 198, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(0, 204, 187, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 6e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 5800,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(25, 255, 198, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(0, 204, 187, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 5e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
              ],
            },
            {
              name: '',
              type: 'custom',
              z: 3,
              xAxisIndex: 1,
              renderItem: (o, s) => {
                const l = s.value(0),
                  u = s.value(1),
                  c = s.coord([l, u]),
                  h = c[1]
                return {
                  type: 'image',
                  style: {
                    x: c[0] - 5,
                    y: h - 5,
                    width: 10,
                    height: 10,
                    image:
                      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAcfSURBVHgB1Zh5bFRFHMdn3rHbCr3+MFG0lEOEQKQQoyY06TYagZIeYoEQQIwaRSkVFYGkKKWtrAEUkBYixmAUmxC0aXbbtCAo2xKJGhJL1XhAQ7cef9rt9qL7Lmfezmx/b/YtQv/SSX47x3tv5jPfmZ35zSD0Hw0YTTJYloVJsGjsqFAoo3k0iXBLYGLjJSXrsyP64NPItPIxRost08ojNWXHX0YRku4jRGEFSwGvB4fOBoN9EJDUJ5G8iSYLBoDsuKik3GfEtBrSgg/dTsA44JXlI1+2B0M2OppQNpWi+BaAcEnF+rzB4cgJUs6AcIR0ucejqsGMrMyL8xfMDe+tro7QJ9tra7N++fHnRWNj4w9oulZomGbZRGtSIDNn6rb2U6euw+bc4HAKKIn1TCosLqsyDX03SWdTIK9HPVr40OLGmpqaKPhMYnWZLLa4PVNVldffG94Q042nLGRNx6QOWZbrQh3BBva+K5wbGIeSi1aU7tZ1401aripqY1FRwds1O3YMsldlriiAs1jeYGUmb3xT1eu5v177bZdu6BtoXlHk+lB7ax2Es4EYIE6lFoHaw6HuSE/f+UWg+Rh7BqEkAQ4GDmWB2Fi6cnXl6MjIPrsnklzfdaZ1D4dyBXNAFZdtJT07SMszMqa82NH8WRN7pgAYiZnM64Q9Z6rRtM6hOGRxxdp1Q0PR9204WXmtqyN4hD2zUikmrVi7dmb07+hlks0GSskADLMYDiV/bgHjiukAymCmP16+avPY2Oh+OueyMtIebGtu7oNgEhJCdGDoXQqlyMqnDEoBysgsz8E8xLwsVoW0yt6B6UQHzwU+P6Z61Ebyh8geHBo7IYokAbVwUUmJjyTKyTvhBfNm+4EiigClgAY9wBQASC0NlMGO2dNhyZJH/FQxui4+tuJJH/xnOhQzNOtlGntVz8mjhw71A6UkFzjVRSUOw/NwXvJ8wsjaF/WQ5Ye2GdNv7IY7jMTV8i0rm0HiJ2h++qx7m1DyUgB7DIdLEQAVAKECg53jo4ALfQWNXLXla9bkcDgbzN4eJMNe1WUZt37U0BAWYKBqigugFwynF5SJcy1pOGu2b4+S/baHtj0cHd6YpBj5z9hqKbLaBdSCywKEUoE6ucQOEwsS+4rYW6xMdVGMd9CxKKuq2mpnTLTIAUaDaZozaJzm8VxhRXC/lAGgB0BSgA+I5RObyt4vIHac2D2CuqL6ic5nZGRetBkwXuSyXOA8+js/f8EV5FzZ3SrkkJsBEAy0bKdLPRIQJDEic+bNjm/qFspzzDH2gu1PHaipGUQTq7e41Yh/iAKUOsxGE2qLUwPWgw8kHAIrG4HKkeC0ce8ACbGjMhYPo9QBKmmBumBZ0jPHULLJb/tTu/z+LJcP4YYMN+VelDp8jZxbFBa+TwhA2mRKkWVDGEpku8Mk9HT/lIfce0orM0AZTVMvwU21EWKNwjd8z+RQPJjdl7sXMoYwL0yAEQnttWR0dKQQQHEg2FONGW3oT2IvMHU4UDcr+wu8B6FMEXI8pi1kTSXOBgoHIweK7wnxRk3TSkn2KOitxCqC6w+cb38QewN00gCNx24Cl3AQNU33xcVRAkmKTcuZ9onNbFn5bMzF+aQLjXLlaOPjwGICkJHC7Lo3VVVNNyyj1FYJKxeStqTTpz8cICWdJJv1zaXvKoWe8QY4kAgHIcW0AWIHFG372vXfbVdbIgeVCx0tyXOMBtmj1tI4FtMq/YcPZwkKGQBu3AUEqhUTgPl3Ouis8Xzlq7mkLQaG3uMiOcBoQagtEKKqUeft3PkL1Wji32eCnmtCOiaAxkBaF5QzQYyu9vVWk7byCFUgdKatE4oEHUU7nTHF+xxd07SYtmVpeUUlkN0QVBOH0A1KnPgJ5ZeVrnpJ1+iJCUfuTM/YhoQAh9L2t9tbWvo8HrmeFoyOje0rrli9DiVP3JigFo1vALhxQV0OZXdw2cqKdSPjo/tpGwo5Y7a0OA7A8REEijmvA5aT45sZP76lpXt3ng+0HEPO/U50YeApCa6BcJE16SjQDttQilQXam+rg9+4npIAoN0gPPDSw8nc+/L2Hm9o6EfOjVhGzhFwrFEcyO/3Z5699G01ufvYYr8oSXVdZ9rqCYjudoeRCizx7NHi0ldihg2XTVzgsKIqJ++fNafpeMM7/eA9UTWDpc1acpcRutxdqY3HtsS9BxxR4lcER1gHsNvNj9sJGkLaHia5VJkZHY4cNO0TVDzIkhQk1wZdXk96z8P5c38gdxkDtL4dtbXZvVf7ciORAR/dRSwLLbSYO0Nc6M6sqTnPtjU38fXKSnUdhW8ChYX3cNHykkKi+1YEAG8pWCikeNU6shx1IhcX57bAOBy8x+Kw8ROV4TMxOSdYFvVGZiDmaJJALu6ssIQw2czxlbuy7v6Y7CoRJPhjk71pRP8GDA2Wu6Xd8v/b8A8dvJWPIScuiwAAAABJRU5ErkJggg==',
                  },
                }
              },
              data: [8e3, 7500, 6e3, 5800, 5e3],
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '各区经济收益',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  FAt = {
    __name: 'PurposeSpecialFunds',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          grid: {
            left: '5%',
            top: '10%',
            width: '90%',
            height: '86%',
          },
          legend: {
            top: '8%',
            icon: 'circle',
            itemWidth: 8,
            itemHeight: 8,
            textStyle: {
              color: '#90979c',
              fontSize: 12,
              lineHeight: 20,
            },
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
              lineHeight: 156,
            },
          },
          color: ['#6BC7F6', '#44E6A2'],
          xAxis: [
            {
              type: 'value',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#407A80',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#CFDAE6',
                fontSize: 10,
                interval: 0,
              },
            },
          ],
          yAxis: [
            {
              type: 'category',
              inverse: !0,
              axisLabel: {
                color: '#CFDAE6',
                fontSize: 10,
                interval: 0,
                show: !1,
                verticalAlign: 'top',
              },
              axisLine: {
                show: !1,
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              data: ['扶贫资金', '医疗卫生', '渔业资金', '社区改造'],
            },
            {
              inverse: !0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          color: [
            'rgba(115,208,255,1)',
            'rgba(77, 255, 181, 1)',
            'rgba(230, 230, 230, 1)',
            'rgba(255, 200, 89, 1)',
          ],
          series: [
            {
              data: [
                {
                  value: 100,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(3,65,128,1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(115,208,255,1)',
                      },
                    ]),
                  },
                },
                {
                  value: 80,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(11, 77, 44, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(77, 255, 181, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 60,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(117, 117, 117, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(230, 230, 230, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 50,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(153, 105, 38, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(255, 200, 89, 1)',
                      },
                    ]),
                  },
                },
              ],
              type: 'bar',
              barWidth: 7,
              yAxisIndex: 0,
              showBackground: !1,
              z: 2,
              label: {
                show: !0,
                position: 'middle',
                padding: [-18, 0, 0, 0],
                color: '#16C1A6',
                fontSize: 12,
                formatter:
                  '{title|{b}}                                                                              {value|{c}}  {unit|万元}',
                rich: {
                  title: {
                    color: '#FFFFFF',
                    fontSize: 10,
                  },
                  value: {
                    fontSize: 10,
                  },
                  unit: {
                    color: '#717477',
                    fontSize: 10,
                  },
                },
              },
              itemStyle: {
                borderRadius: 0,
                borderWidth: 2,
                borderColor: 'rgba(26, 57, 77,1)',
              },
            },
            {
              name: '背景',
              type: 'bar',
              yAxisIndex: 1,
              barGap: '-100%',
              data: [120, 120, 120, 120],
              barWidth: 10,
              z: 0,
              itemStyle: {
                color: 'none',
                borderColor: 'rgba(172,191,188,0.4)',
                borderWidth: 1,
                borderRadius: 0,
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '专项资金用途',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  }
const zAt = {
    class: 'population-proportion',
  },
  UAt = {
    class: 'population-proportion-chart',
  },
  VAt = {
    class: 'pie-legend',
  },
  GAt = {
    class: 'name',
  },
  HAt = {
    class: 'value',
  },
  WAt = {
    __name: 'ProportionPopulationConsumption',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = yM({
          pieDataColor: ['#17E6C3', '#40CFFF', '#1979FF', '#FFC472'],
          pieData: [
            {
              name: '类型1',
              value: 40,
            },
            {
              name: '类型2',
              value: 25,
            },
            {
              name: '类型3',
              value: 20,
            },
            {
              name: '类型4',
              value: 15,
            },
          ],
        }),
        i = je({
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          series: [
            {
              name: '',
              type: 'pie',
              itemStyle: {
                borderWidth: 5,
                borderColor: 'rgba(26, 57, 77,1)',
              },
              label: {
                show: !1,
              },
              radius: ['55%', '70%'],
              color: [
                '#c487ee',
                '#deb140',
                '#49dff0',
                '#034079',
                '#6f81da',
                '#00ffb4',
              ],
              data: [
                {
                  value: 40,
                  name: '类型1',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(3,65,128,1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(115,208,255,1)',
                      },
                    ]),
                  },
                },
                {
                  value: 25,
                  name: '类型2',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(11, 77, 44, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(77, 255, 181, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 20,
                  name: '类型3',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(117, 117, 117, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(230, 230, 230, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 15,
                  name: '类型4',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(153, 105, 38, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(255, 200, 89, 1)',
                      },
                    ]),
                  },
                },
              ],
            },
          ],
        }),
        a = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: o} = yl(a)
      return (
        Ea(() => {
          so(() => {
            a()
          })
        }),
        Da(() => {
          o()
        }),
        (s, l) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '人群消费占比',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    wt('div', zAt, [
                      wt('div', UAt, [
                        ye(
                          La(uc),
                          {
                            ref: 'vChart',
                            option: i.value,
                            autoresize: !0,
                          },
                          null,
                          8,
                          ['option'],
                        ),
                        l[0] ||
                          (l[0] = wt(
                            'div',
                            {
                              class: 'label-name',
                            },
                            '消费占比',
                            -1,
                          )),
                      ]),
                      wt('div', VAt, [
                        (en(!0),
                        sn(
                          _M,
                          null,
                          xM(
                            n.pieData,
                            (u, c) => (
                              en(),
                              sn(
                                'div',
                                {
                                  class: 'pie-legend-item',
                                  key: c,
                                },
                                [
                                  wt(
                                    'div',
                                    {
                                      class: 'icon',
                                      style: fy({
                                        borderColor: n.pieDataColor[c],
                                      }),
                                    },
                                    null,
                                    4,
                                  ),
                                  wt('div', GAt, Si(u.name), 1),
                                  wt('div', HAt, [
                                    ko(Si(u.value), 1),
                                    l[1] ||
                                      (l[1] = wt(
                                        'span',
                                        {
                                          class: 'unit',
                                        },
                                        '%',
                                        -1,
                                      )),
                                  ]),
                                ],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ]),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  XAt = {
    __name: 'ElectricityUsage',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '万度',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          legend: {
            top: '4%',
            icon: 'circle',
            itemWidth: 8,
            itemHeight: 8,
            textStyle: {
              color: '#90979c',
              fontSize: 12,
              lineHeight: 20,
            },
            data: ['2022年', '2023年'],
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
              lineHeight: 156,
            },
          },
          color: ['#6BC7F6', '#44E6A2'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 1,
                padding: [0, 0, 0, 0],
              },
              data: [
                '2023/04',
                '2023/05',
                '2023/06',
                '2023/07',
                '2023/08',
                '2023/09',
                '2023/10',
                '2023/11',
                '2023/12',
                '2024/01',
                '2024/02',
                '2024/03',
              ],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '2022年',
              data: [
                1200, 700, 500, 700, 1300, 500, 200, 500, 1200, 700, 400, 1100,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              xAxisIndex: 1,
              z: 3,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(115, 208, 255, 1)',
                shadowBlur: 20,
                shadowOffsetY: 0,
                width: 1,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
            },
            {
              name: '2023年',
              data: [
                500, 900, 1100, 600, 400, 600, 1300, 900, 700, 1e3, 500, 300,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              xAxisIndex: 1,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(69, 233, 164, 1)',
                shadowBlur: 20,
                shadowOffsetY: 0,
                width: 1,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#45E9A4',
                  },
                  {
                    offset: 1,
                    color: 'rgba(19,99,61,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
            {
              name: '2022年',
              data: [
                1200, 700, 500, 700, 1300, 500, 200, 500, 1200, 700, 400, 1100,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
            {
              name: '2023年',
              data: [
                500, 900, 1100, 600, 400, 600, 1300, 900, 700, 1e3, 500, 300,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#44E6A2',
                  },
                  {
                    offset: 1,
                    color: 'rgba(19,99,61,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '用电情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  YAt = {
    __name: 'QuarterlyGrowthSituation',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          xAxis: [
            {
              type: 'category',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['一季度', '二季度', '三季度', '四季度'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '类型1',
              data: [100, 120, 130, 110],
              type: 'bar',
              barWidth: 4,
              label: {
                show: !1,
              },
              itemStyle: {
                borderRadius: 0,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#79EBCF',
                  },
                  {
                    offset: 1,
                    color: '#0B6360',
                  },
                ]),
              },
            },
            {
              name: '类型2',
              data: [60, 100, 150, 90],
              type: 'bar',
              barWidth: 4,
              barGap: 2,
              label: {
                show: !1,
              },
              itemStyle: {
                borderRadius: 0,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#40AEFE',
                  },
                  {
                    offset: 1,
                    color: '#25567A',
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '各季度增长情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  $At = './assets/bg-2e5c39b6.jpg',
  qAt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYQAAAAoCAMAAADJyn3AAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAHhQTFRFGleXGlaWGlWUGVSSGVOQGFKOGFCLF0+IF02GFkuDFUmAFUd8FEV5E0N2EkFyEj9uET1rEDtnDzhjDjZfDTRbDTFYDC9UCy1QCitMCShJCSZFCCRBByI+BiA6Bh43BRw0BBsxBBkuAxcsAxYpAhQnAhMlARIjAREhh/IA4wAAALtJREFUeJzt0WtWAQAABeF7yauoPCqSktD+d8gu5s98K5hzphGupQuUDugCpUO6QOkDXaB0RBcoHdMFSid0gdIpXaB0RhcofaQLlD7RBUrndIHSBV2g9JkuUPpCFyh9pQuULukCpSu6QOmaLlC6oQuUvtEFSt/pAqUfdIHSLV2gdEcXKP2kC5Tu6QKlX3SB0gNdoPSbLlD6QxcoPcIBuk/4pQuUnugCpX90gdIzXaD0QhcovdIFSv/pAuUGYfADNSroY60AAAAASUVORK5CYII=',
  ZAt = './assets/topFace-09e0583a.png',
  KAt = './assets/quan1-85173a16.png',
  jAt = './assets/quan2-3159cd1f.png',
  JAt = './assets/quan3-0cc4c03d.png',
  QAt = './assets/quan4-7496b968.png',
  tbt = './assets/diffuse-65cced71.png',
  ebt = './assets/particle-073bb0c5.png',
  nbt = './assets/flyline10-82d946ae.png',
  Ik =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAD0SURBVHgB7dEBDcAgEACxZ/5NTgkg40JaC137mgesf57wDSlCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTEHKbcBaYZyb5dAAAAAElFTkSuQmCC',
  rbt = './assets/pathLine2-d4134d4b.png',
  ibt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADzSURBVHgB7dEBDcAwDMCw9vw5f4MRTTYF73/NC3bnBd+QIiRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSMwBQCIExogIrTYAAAAASUVORK5CYII=',
  abt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFPSURBVHgB7ddhbcMwEAXglyEoBEPoGARCIYTBymBhMAgrhDFoIZTBIATC21lxtGhdYieOW7u6T7L6x5HvfPXJBpRSSj0jko2MGqWTJL7tQMkkgSN/tSiRBG5cNQadjB1KI0GfeOsDJXHVmFKjFBLseSaRM0rg2q3PAbn7c8Cn2Dn5HnwJ7p3hWuSI/QHvFiRi5xrkhv+3W59P5ITz7danRi4YdsCn5NGOGdZufRo8kgSwi6zGIPoe9oI4bzIM4tkkjngExh3wqaoYrBRTkRbbslW5bzuWnTswnRorVFiB/dPVII1rVVWvWGjxX4t9qzRIZy9rpD34vH2+zrnIaN03dtj3+zXw27TPYvrvUxcXsMH8ZjRu7pw0z2JOt9sh+MU7GJCUwdZG1ejcwg03LP8oqa9RItvew9i325P7Tf6yY3/1GdbcQymllFJKKaUy9gO4eI9ILG1riwAAAABJRU5ErkJggg==',
  obt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA0ESURBVHgB7Z3/VRu7E8XFO+9/kgpIKoAOEioAKoBUAFSAqSCkAkwFQAVABUAFhAoIFfjt3bzl+TlGtndG0oz2fs6ZY/L94R2v9u6MpJG0FkKYBELIXP4KhJB3oUAIiUCBEBKBAiEkAgVCSAQKhJAIFAghESgQQiJQIIREoEAIiUCBEBKBAiEkAgVCSAQKhJAIFAghESgQQiJQIIREoEAIiUCBEBKBAiEkAgVCSAQKhJAIfweSlA8fPoRPnz6Fra2t9u+NjY23/wyfsBg/f/58+/z161d4fn5++/vh4aH9JOlYC9wXSw089F+/fg2bm5tvosBnSjqhwO7u7lrx4G+iAwUiAA//7u5uKwh8LooGuehEcn19HW5vb9+iEFkdCmRFECF2dnZaQaSODlpAIBDKxcVF+0lWY0Jb3s7OziaeeXp6mpyfn08aobu67wXNlbPFDQ9WLUAsBwcHkyYSumqDzObKWRP28vIyqQ1EFQrlT+M8SA+Qy9dGE0lCE1HCzc1N288i/+FK0RaspjTrPRqhsJ/y21w5a8ZqTLPmMfTUa3ApFuYqMEQrpcY0ax5d6tUIxc2wtjauFC2xw8PDtze/NH0YQpo1SzfqVbINC5grZ3sZUgTk1NPg39LvHUqaNcv9/f2Q0i5Xzq5s01FjlibVEn33eDyeDJmTkxMz7ZzQXDm7tM2LGrMgZWj6JL2vMcQ0axbc45qjSZW1WBjHv7y8XKp48PT0NIxGo9AHfD86sKsUKaL6FrVRXcn66+vruyXr+N719fW3znFXMm8N/Jbj4+NwdXUVasSNmpcxhP1VQPoleQO+l2bhe/F2Re0WOrbNwy2KVp3hOxC5kB7iu3ENK32hSlMuV85GH5wmakz6gLH+vtfFgwo6QRwdHbViyP37cU1ce1FamRq0gcaLwJC5cnauIQKgPyGh77Bv90a39lBAuIhuJaIL2qKifokrZ/8wvDml4gAaw75WDSle7shSkUhcOfs/gzg035C1T4LhgUVU0XihLAPapkS6qWyunH2z/f199fQB31dZ/jzXIBS8DHIIBfcUbeXp/syYK2dbww1PRTPk6+peSA0d+xxCcSwSV84mFQfAG8/T/dAwRJQcS4mdisSPs9p9jllqnxVeZMtUH0hw2ifx4SgaL5U48L1INbzci9SWsn/iUCT2ndSY53iPoUeN2D1PFU2cDQHbdhCjSqnEwaix2DBokQJpoWhGs+1g3/KRRY3D9dbLm9Zk7CxoWwe/365zqxYeLsPAFvuoGe4Z7p02DgocbTrWFQFqglnkIUwEprQUi8SMR3N7TqXolA9tAjClafdLpEsOEps9p7RHTygOfdMWieFiUVsOafc7KI50pi0So6OKdpxBmNWE4khvmiIxmmrZcUZzlITiyGeaIjGYatlwBOUNWmCkxcrvGoppjm4ZS7XKO6E5aoUoZOE3Dc0wfK6VARhbl1PeCWyaoEFla6HdmeaL7vv371Z+V/mbqkUFyzvdm+Zmekbas6wDWtGDnXI7hj6EBkY67OUurvW2qXlHEq+mNdlroAzF901kv8OmaS1wM/DyK3NhregxwPMq3JhWqlU4ipS5sEb0YGpl3ypo5/wX1Rq5Ympl37TaulQUKXJG4cnJSZDy48ePdtt9Yhu0EY6YkKJxrmRf3L1R2DH3ZZgVl3bYS82uZ48gGofUM3r4AgcEoc0k4OCgptMfSpBVkdJSBPz/c/tMk5tGFClUZ5fvYhpDuxzW9WsaZfG5O+tZU6z9/f0gAWnV7e1tID45Ozt79zzGZSnRWc+mRml6JTkqjWbDpFGkwObieS6kkV5x5Mq/oS8iJWealS3FkqZXSK04cuUfpFjSNDl3mpVFidL0ip3zeky6KWDmkcz0F5FODg7xUJuaTWPId2NjI4uvWVIs6eTg1dVVIPWANOv6+jpI2NvbCznIIpCdnZ0gQXoziT3G43GQsLm5GXKwFn6HkqQ0OWNo0qzQl7W1tUDqAqUjeC7w2QdEoY8fP4bUJI8gW1tbInFwYrBO8IA/PDyEvkBYTT8kpCa5QCTiAEyv6kXattvb2yE1yQUi7aAzgtSLtG2RnaQmuUAknSlpGCa2QdtKarOk2ckyZOmD9IXiqB9JG+cYyUoqEHSk+o5SgMfHx0DqRtLGiCCS52sZkgpEmiOy/1E/0iwhdZqVPIJIkK4dIPaRCiR1Rz2pQKTqZh+kfqQV2q5TLIlAED0YQepH2s6DTbG49mM4SNp6fX09pCSpQCSlAIwew0EiENcRRAIjyHB4fX0NfRlsH0Ry04gvJNmCa4FIYIo1HCy3tVmBEGIBCoSQCBQIKc5oNGpXjfaxz58/h5RQIIREoEAIiWBWIKmH7whZhqQCkQzfpS4hIGQZzAokx5YuhCwiqUCen59DX3Js6ULIIsxGkBwL8glZRFKBSAoOpevZCdHAbAQBjCKkNEkFYn29MSGLMJtiAQqElCZ5iiURSa4t7kk5rKfRf4fEIM3qexMYQern/v6+/cRzcnd31+6FJt2SVJukR1idnZ1NJDQiyXLUFi2/oW3foxHO5PLycnJ0dJT1VNtZyxJBJGB3eO6PVSexnf+RPcCmT7TFc4AIg+1K8Xeu5yKpAqUHeN7c3BR7e9DSGtpWQo7sIssRbC8vL6KjtrAohmvU66N5xkNfMPiTerEUyFLuLjlJCMJiZ70+plOnPuTa+T+LQKS54v7+fiB1IT35OOfR4MnzOGk/BIfO4/D5HL7S8hjaVAKeqRx+ZokgyBelhYvSsw6JHQ4ODsT7NufaeTPbklvpiaaHh4eB1IE0Zc59sFKWUIXJHilMs/ybNN0GmScO890cad45Go1y3hhaAjs/P59IeHp6yupv1l1NLi4uggSkWVxE5RfU5En7krnTq6wCkQ7NQRxHR0eB+ATikFbvSl+yfcgaslCEJoFDvn4N6ZGn9AqWfeM46WgWo4hPkB5Lo8fp6WkoQVZF4u0v7awzivgyjFxJowfINTk4bdkjCIoOpXkko4gvNKLHeDwudixfdlVqzImUeqPQVjONeY/CbV3kouK1AIBrRexbBe1c5sJaUQRLMgvePFrEDg4OJhqUXHIbCl5Y5e2CDjtTLXum1TE3kCWUu7hWFGGqZc80Xn6gcPSAFb242o1kqmXHTk5OJhqgbsvA7ynrQGzrl1Ux8LYZvGm2p5HUubgD4r2zOpDzsj9SzrT6HcBI9ICVd0Jjdr0DtV6cZS9j0jq7DmMvOhNOtH0ILQy9fQZj0nUe02B42NBvM+OIWocdoKNo6bfVbFqdcoAoZOz32XEGYVUr1QIUSXrTFAcw2Ic05YxqqgUoknSmLQ6jS6rNOaSaagGKRN+0xWF4steeU9qpFuBEop5pi8P48LxJp9TKUADrtXQMw+eao1Udu7u7ln+3WcfanFQDHsIjN7xgtOY5pnGwlZNp59pThiQYG1N3aYjmWjPk06BtHfx+2w4irPdtHG40J7fDw8NJCtCmTioezDvYq8aH4pDfc+3RxA5nNXMunGz7EcuObKH40cvvsmiIGtqjiB0OB0zcOLqUSJzktSYtZdToxOFwwMSVs9F1zlqVvBjnH9KwMO6Z9tzGPJwOmLhytrV5ItHKa7sHBd9X++RiJ4xU6VQF4oC5cvbNcMO7htUSx7zBAPwb16opouQUBq7hfKjdlbP/M+SzmiMisVliXAf/vWeh5BRGJ44KJmldOZvMVtkBEB1ZL29FiAKlHCk73/PAC6WSCgZXziazPmUUeEMiqlirJYIoMPsN33JFi2kq2xvAlbNJTGsHQLyl0bEv8ebENXFt+FBCFB0YZq9pT4C1f/8YNM0bT7z7+CzYxf7h4aG1u7u7t3/jUwJ2toevjSDC5uZm+wmzcDQdzu8YjUahJgYvkKbTmrVRIRBs4z/9+fr6Ovd/u76+3j74nShgFs9oxG/Y29vLfn5gDgYtEDxwiB6kPxDFt2/fip3dkZrsB+hYAtGD9ANR4/j4OGxvb1crjg7zHaUUprlF5tDAQMCASnFcOatmKRYA1Q5Gxwa4tt+Vsyqmud59KGAJwUC3dHXlrJohRRiPxxMSB+nUwNf0u3JW3RBNcpdheAD3hMdJBAqkMwrlNxTGH+bK2eQ2xNQLnW/0MSiMuebK2WwGoaBGq+bRLhRoYnMLnqcSNVfOFjG8WRFVahALo8VqxmLFFWkerNBElvDlyxf1AsdUYKb7+vo6XF1dVVkvlRIKRAAEAsHs7Oy0FbVWBIMyEIjh8fGx/ay9FCQlFIginUggmq4UPXX1LR5+lNE/Pz+3n4gQFIQeFEhiIJBOKF3JOsrYu2izKOogGnSl8SiL70rkIYbub5IOCoSQCIMudydkERQIIREoEEIiUCCERKBACIlAgRASgQIhJAIFQkgECoSQCBQIIREoEEIiUCCERKBACIlAgRASgQIhJAIFQkgECoSQCBQIIREoEEIiUCCERKBACIlAgRAS4R+Py6dcyrAs4QAAAABJRU5ErkJggg==',
  sbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAnCSURBVHgB7d3tURtXGwbgR563AN4OtgToADrAFYRUYKjASgV2KrBTAUkF0AHuQOrATgUn53iXQBxE9LHfuq6ZM/J4BKPhz3Pv2fusIgAAAAAAAAAAAAAAgGlYBDALKaVP+eU8pu2PxWJxHUDnBACYiRwATvLLQ15VTNM6r7McAL4F0Lk3AcxCMzgvoh6kU7PO68Lwh/7YAYCZyTsBp1HvBExJufL/EkBv7ADAzDSD9Cam48bwB4CW5J2AZRq/ZQAA7coD9nMar9sABqMDADOW6pMBd3mdxrisQ+MfBqUDADPWDNi3Ma6TAevQ+IfB2QGAI5DqkwFlJ+AkhvX9qKLSHwD0JIeAqzQ8T/kDgL6lYU8GLAMAGEYa5mTAxwAAhpOH8UleD6k/q1SfRgAAhpQHctUM5j6GfxUAwDjkwXya19fUna+GPwCMUOr2ZMBlAADjlLo5GbAMAGDcUrsnAzT+AWAqUjsnAx4CAJiOdPjJgFVS+gOA6WlCwD4nAzT+AWDK8iC/TLvT+AeAqUu7nQxYBgAwD3mwf9xi+Gv8A8Dc5AF/98rw1/gHgDlK9RcHrV4Y/uX/qgAA5in9+2SA4Q8AxyAP/PNnAeA8AIDjkAf/tcY/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwGFSSpdlBQAwOXmGn+T1KXaVf+gq1d4HADAZeXZXea3Kil09CwDFhwAARi/P7NNm+Kc2AkDxUBJFAACjlOf0ux9mdysB4PsvEgIAYHzKLfuX5nbsakMAKL4qBwLAODyW/TbM7FYDwCPlQAAYUKrLfg+vzOpOAkChHAgAA0j/LPvtHADexGGuk3IgAPQqz92f8stdXlXs6dAAUJyWDyEEAED3mlvwn/M6iQO0EQCKKuoQcB4AQOvS05P9ltGCtgJAUUUdApQDAaBFzS572fK/ipa0GQAeLYUAAGhHKftFPfxPo0VdBICihIDbsl0RAMBe2ij7bdJVACjKw4KcEACAPbRV9tukywBQVFH3AlrdtgCAOWuz7LdJ1wGgqKLeCbgOAGCjxyf7RYtlv036CACPPigHAsDLnjX9e9k17zMAFMqBAPCDVH/JXrnyr6InfQeAQjkQABrN7vhtdFT222SIAFBUoRwIwJFrvlRvGQMYKgAUVSgHAnCEmsf6lvv9g83AIQPAI+VAAI5Gcwu83O8/jwGNIQAUyoEAzF7zpXm9lv02GUsAKJQDAZitPN/eRX3MbxQXu2MKAMW3AIB5+n+MyJgCwG95XSwWi3UAwMzk+bbMLxcxkovdsQSAX/If5iovOwAAzFaec/f55SyvdQxs6ABQBv7PTSoCgNlrdrrLTsCXGNCQAWAd9Zb/5wCAI1JCQF5lJ+DXGMhQAWAd9fAfNP0AwJDyHCwPAvolBjBEAPg9rzNlPwD4uxz4NnouB/YdAErZ762yHwA8yXPx+8Vx9FgO7DMA3Cj7AcDL+i4H9hEAytV+ud//MQCAjfosB3YdANZR3++/DwBgK32UA7sMAPeh7AcAe+m6HNhVAPg1f/ALZT8A2F+X5cAuAsBNs3UBABzoWTlwHS1qMwAo+wFAB5oQ0Go5sK0AsA5lPwDoTLmt3mY5sI0AcB/KfgDQi6YceBMHOjQAKPsBQM+a2+3dPDkwpXSVXqfoBwADyrO4ymv1yqxebfrZfXYAlP0AYASelQN/j7Zs2AFYlbQRAMCo5Pm83GUH4LVf9GMAeDD8AWC8yu35tgOA7X4AmIA8s0/TUy/goACwDABgMp6VA/cKAJclBAQAMDl5hp/k9SEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6XUqrKCgDgOOTBf5LXKq+H8u8AAOYvD/1P6cmnAADmLQ/89+nf3gcAME950L9Lm/0UAMC85AF/ml73tbwnAIB5aBr/q/TfynuqAACmLT01/rdV3utkAABMWR7mt2l3twEATFN6ufG/LScDAGBq0uuN/21dBwAwDem/G/+7cDIAAMYubd/431Y5HlgFADBOaffG/7ZWyckAABintF/jf1t3AQCMSzqs8b+tDwEAjENPw/+RkwEAMLQ8kM9T/84DGJVFAEcj1e38cm++in59y+tssVisAxgFAQCOxIDD/9E66hDwLYDBvQngWJTn9VcxnKr5DMAICABwBFLdxh/DE/rOk5MBANC91G/jf1tOBsDAdABgxvKgvYzxbrtfLBaL+wAGIQDATKW69PeQ11gfyetkAAxIBwBmKD01/sf8PP7y2e6SLw6CQdgBgBnKQ7Vc+U/la3m/5F2AswB6ZQcAZiaNp/G/rdPkZAAA7C+Ns/G/rfcB9MYtAJiJNO7G/7au8u2A3wLo3P8CmJOfY9r+DAAAAAAAAAAAAAAAAOCZvwCgkvxAcNS/iwAAAABJRU5ErkJggg==',
  lbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAD/CAMAAABb2Q/2AAAAsVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+3mHKcAAAAO3RSTlMABQoPExgdISgxJTYsQDtTRUr+9vpOWXJdaWVhgIx2om2n6oiWmYTKr5G68J22eqvBfeHZ5c++1LPdxUM4ZWUAAAZvSURBVGjerdrZdpswFAXQmnk0EMB4Ajwbz2Mc1///Yb0SuLg1km66mtfsdRBXRyIP+fH205IURZZa7794h7KqKZKEkrqFCgVpOSpOKoaJljZWOm1VwUnTRUv7/0sbvc62r2FlgJOy0o6x0kVL30NJiUh0ZkfHZuLXGWj/PTNArzPu68hMr4/MVEGqMlJaWNkDKWGukM4IK70uTipq3NVBthASMoWb1CJS644cIoG2OJDIQUYlm4KDH7mWxDJoKfX+3iSyooxEMqRSyhVlJFJp9YY2SGZoiyGZkMh+YtPRN4eWDqQCckSl1CoxIxKkQTMVSWp+pyeUQY4WbSqftuG9S+kkqWupitwkgdZSe5VSo5SeMgOpiaWqmfuVb1BZUUbkU6pyHdokJSJPs0AoZcjU7WRBMhWgQjnkSqmW2dB3ailx5HAW1FJqzJRLOd3Gjo6R7cVTym+y9aecbr1KCjLdae7hMt0090yupBAq/yLld1lHapa7WMVEElqNnimnr1JiS3+Rxqal8aVCZZp3+FJ+ylnRBalSyperA1IGM7ScFwNbIJXvSSOY3/u2QaTSIKVXudp2uVIupW7Eq3kHLetMmSu3RQ8p8/XoVQJtGieVu55A0lfXHY9m6iqhQpkg5fhNtljySKSGkPNxry2SKpGdec6VciUtIvtIOV5nbQekypLKUx4ep1rKHNk9PPZIWdRSEcmTi5KDYjl0HatZSn/IO1Kag/E9E0m1kkVSSlUg++Mic02UvD8WCKkbZn/3ORVLrZSLb0kdIdf06brGkspT9tZf6T9KiSmL25Aj5Ve5Bml8VyqNUn2u8zP1cfJ2mQmlRuToeJnRp2v/TdpE+jaVKk86IH8iZfJAy/UjRcrdkUhLIC0iH1j5uMwDnFyec7TcBrYjkDrIrJI6RuYYaYK8YqRh2vvP61gkNSpPy69t0EbI9pDK+iDx5GUbU6kJ5OIyKQKc/LnZ4TKnZ5R0zHZ63qxxmatreItdkbQM011NwqPHk1WVcJIWxJ2dJzuQDl5aukjOr5O159oYOYmWT6ny5Sb6xMktSkI9fSp9jMw30VcHpCGW4QeRpki2vyM34bITtHmSFqSSPkaO8TKMvujT4WZiSZ3IYBx+XLoI6WKljZVOJQccqbxJhyeNSv4cBLRMfBnDPD8HMVIuqTQwmRjpx7BHF5GkVYoP8EZ9DyG9UkJBOdJ6le3/JB2okleA7OFlWVBmQ0C6IDfhF5UOS2oaLUjnXkqXJ+kWUTnCyTA6j7qwSSxJBw+yew8/zgmVhqaxpe91d7XUEXIQ+zRTZUnYokEpq41XBPKaVZKb2aeSbDxb0hukAzK8iCSMs5J72CS+hMzeGuSJSJsnYfAgP64nsp0Mqfwhh1Q6fDkqZTcWy1v4McHIAZWLpC5Tk4QqeThJNzP5jgzPC6iISPaTI8gpXxovstx4kYR1iiUUJDtGONnLHiDTPU/qpdx/W9KCsiQUuTuicnXqieWJyqFIxiCXYXRd0YIypUPlcBmGRMJHli+TWvIzB8liCeucLWiV2dKv5Ga2SKjUm6RGpFfJOZRJIPsZXk5LmdF7kSVJ6fbTz0p6bGnWcgu140lakPQzjCbbVCxPIEOBtF5kXhaUKeH2HA1XX7DOfLXvYeWJL6EgtewEzVKt5GJG5LiqcrM0XuWsklqjpKWjMgQ5EshsSjMPAul7IOdfUbQ5zKHKIC2uvEThBGTCl1C6LchNQWTMlynIj7DYTkG6PLmv5YAre/vVU2YCeVrlP4nMsfKep3A8GFIH2flL2oxMUuThbFzJfZ8ldQfkiMpos8tXWDkm0ufJxfwpT0J5OMM61wcoPUiDKRMiP4ic8WU3mW6pvEFBhbI4RyALjLxSOYfSs2VM5P0KTz9CQblykKQ5kdHxLpIZkVEUVrLNkC6VOyIf9y3IgCHNV7mD0nPlfjXekXUudzkcJLb0+iDXE5ycVXItkqdapgypUNk7zQ63/y2Hv+U4zVjSKmVxm8A8P29COS+Ov+WgUcog/VouK+nwJawTl0nlmitdpNRrWc8TLW2OpJOvukROh6pITZ33+q8STodpNUgFZFz2k3SenCPPfZctkOT+pKeDyCO5Q0CW/3vyJu3qZgC5Jrdi7Dram6xGT+9kuEOie135Ur4dOfLlOoOsLjCr/rzXki6U/nVBvkf0c1Qu809Z9w4+8GeYUnrqkWm+LvMXnJRTlwruvBIAAAAASUVORK5CYII=',
  ubt = './assets/focus_bg-b6803e2d.png',
  cbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAOVBMVEUAAAD///////////////////////////////////////////////////////////////////////8KOjVvAAAAEnRSTlMA3yDvvxBAn3CAYFCQzzCgj6+a/gWFAAAIxklEQVR42uzBgQAAAACAoP2pF6kCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGB27gRJcRiGAqi8O2sH3f+wM1XM1lOAHZwQKfnvBF3tjyxbBgAAAAAAAAAAAAAAAAAAAAAAAAAAAACAvfBPxkz+lro8xEBwMfyd87dumAkugx9xfhkswRXwUyb1CMH58UvTEgm0CjOVcYlLA4FCMTkOVQFABs4nLo5/ylTEdUxCP6BGyJ7vPBVxNd8TKBA6x3+EugCgDJxGTPyvnkp4HURAtOj5O18RAETgLKLn/7lQDgAicA7W8wN9OQCIwBmEhR/y5QAgAieQHT/mwj4BYJMJpIgTPxVLAXibwdRYhrDwC6kmANgHFBsc/7V+D+AWBpeDRws3LojFAKAI6BUdl4zFAKAIaBUWLnOFADRb8JL0INZwjUiv+MkYw00MtoFDZMdVRqpgY8zdbXL8Doc7gQMsXMnRCvPQ3RyvthB8lp24WqSV5v7L8DoTtoGPmg3XG+kNc+/RCIg1OK7nB3pP6G9cz+Hh6MdkruZzoAZ2TR3oCD6i40pujNTMfhkkQJSlemAbaBOhN0iAHImr+Egbqo1AIthZalj+tgggARIkrjBF2kFvkIDDpUMvZnuDBBwrcVkXaDe2QwKO1HGRt7QrO2EwcJhOxFiuNzgNHqM7/ON/Zz2XYDy8g0HCx7/2Khpzgc1ZJ2gcZ00pjPjOwKf/5WOgDwqjoDhewiRt18382kSwoUXet7Rmg8Pgx2SJ9dYaYUXpvAoNoA90iOD5FYc2YCPB8CtfdJgvfsXgGyPbWOReu3VoA/bXy13/UgLwQ8MbsEbw+hcS4LAJtEui17+QgBtBo174+hN1GArsyBqZ/f+/vrAJNGjYADwJ4XES2Mus4pgdDE4COzHS7n8fswZToV1kfk7UxH3GTGAP1qj5t2b0gTtI/NRIwozoAzdnNTSANY2goG5FlaTqX2qd/POqLlZNA3CXcRTcVtL2ifLa/mDZrIobgH9ZhxLwkQIg9td5M0rAdqzGqzWPErCZpOkE8JvFd8a3YmW/AVj/NkDcxYVwSVsHeBecytwKZNR1gHcZE4F9H4IZEm5SdXkllldaAIgiToIbsGoLAJHHSbBdUlsAiKKaCbZgRm8BeF4CHEGlQXEBIIrYA1olzQWAyOA2sJHTXACIMq4C2gxq3oE9FpyGh8yCJe0ldOQHfFaS3+M5fWPAQhvofI/Vrxb1X6V5rH6DUXcL+L0NdCli9VeatO8AROHX6o9Y/fXsGX5swzO7ERc/b+n17wBEA1b/bQlvqq7NqD8DQAt7hh0A3jfgGvXaRtWDQGjmlc8BoJFDC3BpM1qAaxvwnu7auhPcA8MP9u40yU0ghgIw6s2AWcy7/2EzNUmq8iMzeNwNSNb7jgCNpFYvVNh4ss63xEu3fYusAV3LrAF9K+ZuhaGm7pwE+NZzEuDbwMsVfFt5rNK3jQPAt2R+RzgdcSagIyeEA8A34X4w37gh0DkOAOe4FOAcTwXR+0ic0vjGpoZzbGo4xwHgHLtazrGp4RybGr4FNjV8K9zg6lvhTQe+cYezc9zh7NzGc66+zdzh7FvkjaeuLTzo7NudfSDfeNuRc7ztyLnIWaBrvPHSuZGTAN9unAT4JvivqSMXFrAGdG20//NDqpG4I9S1bP0H6OqUh6ns+RZ/v9SjPKKxCdTGEqCVXB7R3EJ6AM8ENJHLLVrcTDeCXYB6eUzRaBMtgdvBGrx9s48vgAsBVXKfTAfQGyeBh7RRo5EyMAv7wFVyhOkzFSMzQKUVphupwgxQqcByFT2CGaBWhOHtFGI7fqkwGQ4BI5gBqhXYDQECrgPUS2ZDwGh47CrSw+pyioArwQ3kCJu9gBEsAZsYYLIdGIQlYBsZgMHDdQNYAjayWnyUAQwArRQYLKdni6NWqwRzdeDIAHBKCIhKP6cgDAAtJWtJIDEANFVgKwn0YABoK5lKAgEMAOc9UlHXDsrCANDchC89OmUeDADt5WimDOjxJWEAqHusFm5bWmBmqNoy2/iwggBcBjxCgYVCMIuVSGXPBOjvByWwAjxKjvof7g02EpVNdwC69wYM+MCNYIfZlI+AAfpjlGk5qh4BA5gADlageAQMYAI43KR3BAz4xBthDpUFSvPsDTDRqLAuRHwn5e4SOeGDqTVrq3pAX60VBADXAM4x4VuydKdbBCwAzjND2efW4zezhxiNCYLvPXJ3ovyAxqz0zpao6JEHAVgAnuwOaEkDfcQfvA7oRD32pNCdICR80Nucel8D9sjYHa6PfP9XmbBrDt2hQgLf/3VW7BtCd5g8YN/a0WFW4MI80Ee+/6utuGwIlBl8/9dbcc0QKAl8/yqsuGAIlAS+fy0GPEfG3DWRe8FfXABSYMCT5Bba/LPuE+d/agx4WhpDq5/X6GlF0z3iedvLqeCe8LzI/v+JguAn0rjUdx717UnxLMz4GbmN4eUN6de3oGn/89wXt+G+dD8QwfJfrz7iFXHehr6U0HCQRZZ/lwiCKiIyp2dygKK9SPSvPKFafQ6YeP7jOqOgUm0OiOp/YvPewoo6lfOAjZ//j+kKAntn09n8Ua8uCHTfW5n9DVgEL3u9FzQz++vRy0EDIEfO/U14OQ90OxKjvxEvDoGXfgOT2Pr5xc6d4zAIAwEUDdjsm+D+h02X1pZFgcN7V5ivGRr8REUJFLxRFR3/pypI4JMSjb8m7VESQP4NGIz/6dqjuTWA7voJk0+/KsyxIIDkDYij8Vcjfw1k/pYeVru/MssR7gmgu4LLX6ecBj5pu9Vfr37dEgHw79r5aATwcu2yxiCAl9uX6YxBAC/X9cs4DWfcmkYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMC3PTgkAAAAABD0/7UrbAAAAAAAAAAAAAAAAAAAAAAAAHAKGbwwCsmp53wAAAAASUVORK5CYII=',
  hbt = './assets/focus_move_bg-cf41417a.png'
class fbt {
  constructor() {
    this.init()
  }
  init() {
    ;(this.instance = new Hq()), this.instance.addLoader(wp, 'FileLoader')
    let t = '/',
      e = [
        {
          type: 'Texture',
          name: 'bg',
          path: $At,
        },
        {
          type: 'Texture',
          name: 'face',
          path: ZAt,
        },
        {
          type: 'Texture',
          name: 'side',
          path: qAt,
        },
        {
          type: 'Texture',
          name: 'quan1',
          path: KAt,
        },
        {
          type: 'Texture',
          name: 'quan2',
          path: jAt,
        },
        {
          type: 'Texture',
          name: 'quan3',
          path: JAt,
        },
        {
          type: 'Texture',
          name: 'quan4',
          path: QAt,
        },
        {
          type: 'Texture',
          name: 'diffuse',
          path: tbt,
        },
        {
          type: 'Texture',
          name: 'particle',
          path: ebt,
        },
        {
          type: 'Texture',
          name: 'mapFlyline',
          path: nbt,
        },
        {
          type: 'Texture',
          name: 'flyline',
          path: Ik,
        },
        {
          type: 'Texture',
          name: 'pathLine',
          path: Ik,
        },
        {
          type: 'Texture',
          name: 'pathLine2',
          path: ibt,
        },
        {
          type: 'Texture',
          name: 'pathLine3',
          path: rbt,
        },
        {
          type: 'File',
          name: 'mapJson',
          path: t + './packages/3DMap/zhejiang-map/assets/json/zj.json',
        },
        {
          type: 'File',
          name: 'mapStroke',
          path: t + './packages/3DMap/zhejiang-map/assets/json/zj-stroke.json',
        },
        {
          type: 'File',
          name: 'hotmapData',
          path:
            t + './packages/3DMap/zhejiang-map/assets/json/hotPoint.geojson',
        },
        {
          type: 'Texture',
          name: 'flyLineFocus',
          path: obt,
        },
        {
          type: 'Texture',
          name: 'arrow',
          path: abt,
        },
        {
          type: 'Texture',
          name: 'focusArrows',
          path: sbt,
        },
        {
          type: 'Texture',
          name: 'focusBar',
          path: lbt,
        },
        {
          type: 'Texture',
          name: 'focusBg',
          path: ubt,
        },
        {
          type: 'Texture',
          name: 'focusMidQuan',
          path: cbt,
        },
        {
          type: 'Texture',
          name: 'focusMoveBg',
          path: hbt,
        },
      ]
    this.instance.loadAll(e)
  }
}
var kE = {},
  BE =
    (Mb && Mb.__values) ||
    function (r) {
      var t = typeof Symbol == 'function' && Symbol.iterator,
        e = t && r[t],
        n = 0
      if (e) return e.call(r)
      if (r && typeof r.length == 'number')
        return {
          next: function () {
            return (
              r && n >= r.length && (r = void 0),
              {
                value: r && r[n++],
                done: !r,
              }
            )
          },
        }
      throw new TypeError(
        t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
      )
    }
Object.defineProperty(kE, '__esModule', {
  value: !0,
})
kE.elRectification = P0
var fA = null,
  cv = '',
  gM = '',
  mM = '',
  dA = null,
  Ok = null,
  Or = 1,
  Ah = !1,
  FE = {
    isAutofitRunnig: !1,
    init: function (r, t) {
      r === void 0 && (r = {}),
        t === void 0 && (t = !0),
        t && console.log('autofit.js is running')
      var e = r,
        n = e.dw,
        i = n === void 0 ? 1920 : n,
        a = e.dh,
        o = a === void 0 ? 1080 : a,
        s = e.el,
        l = s === void 0 ? (typeof r == 'string' ? r : 'body') : s,
        u = e.resize,
        c = u === void 0 ? !0 : u,
        h = e.ignore,
        f = h === void 0 ? [] : h,
        d = e.transition,
        p = d === void 0 ? 'none' : d,
        g = e.delay,
        v = g === void 0 ? 0 : g,
        m = e.limit,
        y = m === void 0 ? 0.1 : m,
        _ = e.cssMode,
        x = _ === void 0 ? 'scale' : _
      fA = l
      var A = document.querySelector(l)
      if (!A) {
        console.error("autofit: '".concat(l, "' is not exist"))
        return
      }
      var S = document.createElement('style'),
        b = document.createElement('style')
      ;(S.lang = 'text/css'),
        (b.lang = 'text/css'),
        (S.id = 'autofit-style'),
        (b.id = 'ignoreStyle'),
        (S.innerHTML = 'body {overflow: hidden;}')
      var T = document.querySelector('body')
      T.appendChild(S),
        T.appendChild(b),
        (A.style.height = ''.concat(o, 'px')),
        (A.style.width = ''.concat(i, 'px')),
        (A.style.transformOrigin = '0 0'),
        (A.style.overflow = 'hidden'),
        pA(i, o, A, f, y, x),
        (dA = function () {
          clearTimeout(Ok),
            v != 0
              ? (Ok = setTimeout(function () {
                  pA(i, o, A, f, y, x), Ah && P0(cv, mM, gM)
                }, v))
              : (pA(i, o, A, f, y, x), Ah && P0(cv, mM, gM))
        }),
        c && window.addEventListener('resize', dA),
        (this.isAutofitRunnig = !0),
        setTimeout(function () {
          A.style.transition = ''.concat(p, 's')
        })
    },
    off: function (r) {
      var t
      r === void 0 && (r = 'body')
      try {
        ;(Ah = !1),
          window.removeEventListener('resize', dA),
          (t = document.querySelector('#autofit-style')) === null ||
            t === void 0 ||
            t.remove()
        var e = document.querySelector('#ignoreStyle')
        e && e.remove()
        var n = document.querySelector(fA || r)
        n && (n.style = ''), Ah && dbt()
      } catch (i) {
        console.error('autofit: Failed to remove normally', i),
          (this.isAutofitRunnig = !1)
      }
      this.isAutofitRunnig && console.log('autofit.js is off')
    },
    elRectification: null,
  }
function P0(r, t, e) {
  var n, i
  t === void 0 && (t = !0),
    e === void 0 && (e = 1),
    FE.isAutofitRunnig ||
      console.error('autofit.js：autofit has not been initialized yet'),
    !r && console.error('autofit.js：bad selector: '.concat(r)),
    (cv = r),
    (gM = e),
    (mM = t)
  var a = Array.from(document.querySelectorAll(r))
  if (a.length == 0) {
    console.error('autofit.js：elRectification found no element')
    return
  }
  try {
    for (var o = BE(a), s = o.next(); !s.done; s = o.next()) {
      var l = s.value,
        u = Or == 1 ? 1 : Number(Or) * Number(e)
      Ah ||
        ((l.originalWidth = l.clientWidth),
        (l.originalHeight = l.clientHeight)),
        t
          ? ((l.style.width = ''.concat(l.originalWidth * u, 'px')),
            (l.style.height = ''.concat(l.originalHeight * u, 'px')))
          : ((l.style.width = ''.concat(100 * u, '%')),
            (l.style.height = ''.concat(100 * u, '%'))),
        (l.style.transform = 'scale('.concat(1 / Number(Or), ')')),
        (l.style.transformOrigin = '0 0')
    }
  } catch (c) {
    n = {
      error: c,
    }
  } finally {
    try {
      s && !s.done && (i = o.return) && i.call(o)
    } finally {
      if (n) throw n.error
    }
  }
  Ah = !0
}
function dbt() {
  var r, t
  if (cv)
    try {
      for (
        var e = BE(Array.from(document.querySelectorAll(cv))), n = e.next();
        !n.done;
        n = e.next()
      ) {
        var i = n.value
        ;(i.style.width = ''), (i.style.height = ''), (i.style.transform = '')
      }
    } catch (a) {
      r = {
        error: a,
      }
    } finally {
      try {
        n && !n.done && (t = e.return) && t.call(e)
      } finally {
        if (r) throw r.error
      }
    }
}
function pA(r, t, e, n, i, a) {
  var o, s
  a === void 0 && (a = 'scale')
  var l = document.documentElement.clientHeight,
    u = document.documentElement.clientWidth
  ;(Or = u / l < r / t ? u / r : l / t),
    (Or = Math.abs(1 - Or) > i ? Or.toFixed(2) : 1)
  var c = Math.round(l / Number(Or)),
    h = Math.round(u / Number(Or))
  ;(e.style.height = ''.concat(c, 'px')),
    (e.style.width = ''.concat(h, 'px')),
    a === 'zoom'
      ? (e.style.zoom = ''.concat(Or))
      : (e.style.transform = 'scale('.concat(Or, ')'))
  var f = document.querySelector('#ignoreStyle')
  f.innerHTML = ''
  try {
    for (var d = BE(n), p = d.next(); !p.done; p = d.next()) {
      var g = p.value,
        v = g,
        m = v.el || v.dom
      if ((typeof v == 'string' && (m = v), !m)) {
        console.error('autofit: bad selector: '.concat(m))
        continue
      }
      var y = v.scale ? v.scale : 1 / Number(Or),
        _ = y != Or ? v.fontSize : 'autofit',
        x = y != Or ? v.width : 'autofit',
        A = y != Or ? v.height : 'autofit',
        S = new RegExp(''.concat(m, '( |{)'), 'gm'),
        b = S.test(f.innerHTML)
      b ||
        ((f.innerHTML += `
`
          .concat(
            m,
            ` {
      transform: scale(`,
          )
          .concat(
            y,
            `)!important;
      transform-origin: 0 0;
      width: `,
          )
          .concat(
            x,
            `!important;
      height: `,
          )
          .concat(
            A,
            `!important;
    }`,
          )),
        _ &&
          (f.innerHTML += `
`
            .concat(m, ' div ,')
            .concat(m, ' span,')
            .concat(m, ' a,')
            .concat(
              m,
              ` * {
        font-size: `,
            )
            .concat(
              _,
              `px;
      }`,
            )))
    }
  } catch (T) {
    o = {
      error: T,
    }
  } finally {
    try {
      p && !p.done && (s = d.return) && s.call(d)
    } finally {
      if (o) throw o.error
    }
  }
}
FE.elRectification = P0
var pbt = (kE.default = FE)
const vbt = [
    {
      name: '告警点#01',
      level: '差',
      value: 84.9,
      centroid: [119.16164693, 27.58366386],
    },
    {
      name: '告警点#02',
      level: '极好',
      value: 12.5,
      centroid: [122.24179543, 30.01102572],
    },
  ],
  gbt = {
    startPoint: {
      type: 'start',
      name: '出发点：上庄',
      weight: 50,
      trainCarriageNum: 15,
      staffNum: 30,
      goods: '钢铁',
      carrierCompany: 'xxx铁路公司',
      position: [118.06147249, 29.09437053],
    },
    endPoint: {
      type: 'end',
      name: '终点：温州',
      weight: 50,
      trainCarriageNum: 15,
      staffNum: 30,
      goods: '钢铁',
      carrierCompany: 'xxx铁路公司',
      position: [120.69660819, 27.98703907],
    },
    coordinates: [
      [118.06147249, 29.09437053],
      [118.0956414, 29.09402359],
      [118.13796938, 29.07640924],
      [118.19642225, 29.0535061],
      [118.23673457, 29.03588484],
      [118.25487517, 29.02178567],
      [118.31937461, 29.01649799],
      [118.3596869, 28.99710752],
      [118.37782752, 28.97595002],
      [118.40806161, 28.97418682],
      [118.44837378, 28.96360633],
      [118.49876403, 28.94244211],
      [118.52899822, 28.92127359],
      [118.66807481, 28.92833024],
      [118.70435566, 28.93009433],
      [118.77087071, 28.92480197],
      [118.80715149, 28.90892329],
      [118.85955716, 28.90715884],
      [118.92607201, 28.94420596],
      [118.96235299, 28.97242348],
      [118.98452452, 28.97947666],
      [119.03491463, 28.97066011],
      [119.06917992, 28.98652936],
      [119.09135159, 28.99710752],
      [119.19616307, 29.00239608],
      [119.28686544, 29.03412255],
      [119.40578655, 29.09578486],
      [119.50656697, 29.09930731],
      [119.56098837, 29.0975461],
      [119.63355037, 29.10987389],
      [119.69200306, 29.11515685],
      [119.73836221, 29.13100395],
      [119.77464363, 29.15036932],
      [119.82704933, 29.15917056],
      [119.89961165, 29.18908909],
      [119.95201847, 29.26120993],
      [119.96123083, 29.29514243],
      [120.00510185, 29.24251983],
      [120.0626832154384, 29.220984539819884],
      [120.09993742, 29.22210696],
      [120.26445654, 29.21971398],
      [120.33849027, 29.19817389],
      [120.37413582, 29.15986946],
      [120.40703949, 29.10957315],
      [120.43171697, 28.98732283],
      [120.45639466, 28.94894001],
      [120.56607363, 28.9153434],
      [120.62639697, 28.88413668],
      [120.72236446, 28.59563483],
      [120.76349295, 28.43175891],
      [120.78268673, 28.39075924],
      [120.77994446, 28.33526374],
      [120.80462206, 28.2676651],
      [120.78268575, 28.19035693],
      [120.74155543, 28.08154798],
      [120.73389575, 28.06827078],
      [120.67590086, 28.06740345],
      [120.64444606, 28.06653608],
      [120.61814852, 28.0513999],
      [120.59521892, 28.02477031],
      [120.59373218, 28.01024159],
      [120.60435526, 27.98605162],
      [120.61609654, 27.9761766],
      [120.64908394, 27.97765792],
      [120.69660819, 27.98703907],
    ],
  },
  mbt = {
    startPoint: {
      type: 'start',
      name: '出发点：绍兴',
      weight: 150,
      trainCarriageNum: 10,
      staffNum: 20,
      goods: '卷材',
      carrierCompany: 'yyy铁路公司',
      position: [120.35689132, 30.12687758],
    },
    endPoint: {
      type: 'end',
      name: '终点：台州',
      weight: 150,
      trainCarriageNum: 10,
      staffNum: 30,
      goods: '卷材',
      carrierCompany: 'yyy铁路公司',
      position: [121.37717601, 28.64967864],
    },
    coordinates: [
      [120.35689132, 30.12687758],
      [120.43682248, 30.11874389],
      [120.55201739, 30.09840659],
      [120.70012505, 30.05364984],
      [120.78710885, 30.04958005],
      [120.9211109, 30.03736966],
      [121.01044568, 30.06178894],
      [121.06451676, 30.08009946],
      [121.1373952, 30.10044051],
      [121.2267299, 30.08823638],
      [121.29725698, 30.03329919],
      [121.39599494, 29.98240432],
      [121.46887301, 29.96000233],
      [121.52764563, 29.94370674],
      [121.53704885, 29.89888038],
      [121.5252938, 29.84383863],
      [121.60757555, 29.84179941],
      [121.63578675, 29.84383863],
      [121.60522392, 29.77040247],
      [121.5440996, 29.68874383],
      [121.45476474, 29.62541263],
      [121.42420266, 29.58044402],
      [121.41479865, 29.52931891],
      [121.40069301, 29.4965853],
      [121.44065772, 29.4290389],
      [121.42184961, 29.32622424],
      [121.40539271, 29.27702104],
      [121.41009399, 29.2216391],
      [121.41714604, 29.15390948],
      [121.40539083, 29.0881897],
      [121.34426671, 29.03476155],
      [121.29959906, 28.98747511],
      [121.26198414, 28.93605246],
      [121.25728198, 28.89283758],
      [121.23377263, 28.85372318],
      [121.2525793, 28.78575252],
      [121.31370255, 28.76720739],
      [121.35601859, 28.75072007],
      [121.38422909, 28.71979934],
      [121.37717601, 28.64967864],
    ],
  }
const ybt = {
    class: 'large-screen',
  },
  _bt = {
    class: 'large-screen-wrap',
    id: 'large-screen',
  },
  xbt = {
    class: 'top-menu',
  },
  Sbt = {
    class: 'top-count-card',
  },
  Abt = {
    class: 'left-wrap',
  },
  bbt = {
    class: 'left-wrap-3d',
  },
  wbt = {
    class: 'right-wrap',
  },
  Mbt = {
    class: 'right-wrap-3d',
  },
  Tbt = {
    class: 'bottom-tray',
  },
  Cbt = {
    class: 'bottom-menu',
  },
  Ebt = {
    class: 'bottom-radar',
  },
  Dbt = {
    class: 'loading',
  },
  Lbt = {
    class: 'loading-progress',
  },
  Pbt = {
    class: 'value',
  },
  Ubt = {
    __name: 'index',
    setup(r) {
      const t = hh(null),
        e = je(null),
        n = yM({
          progress: 0,
          activeIndex: '1',
          totalView: [
            {
              icon: 'xiaoshoujine',
              zh: '2024年生产总值',
              en: 'Gross Domestic Product in 2024',
              value: 31500,
              unit: '亿元',
            },
            {
              icon: 'zongxiaoliang',
              zh: '2024年常驻人数',
              en: 'resident population in 2024',
              value: 15e3,
              unit: '万人',
            },
          ],
          bottomMenuIndex: 0,
          bottomMenuStatus: {
            bar: !0,
            point: !1,
            path: !1,
            hotmap: !1,
          },
        })
      Ea(() => {
        Ee.$on('mapPlayComplete', s),
          (t.value = pbt.init({
            dh: 1080,
            dw: 1920,
            el: '#large-screen',
            resize: !0,
          })),
          i(async () => {
            Ee.$emit('loadMap', t.value), await a(), e.value.play()
          })
      }),
        Da(() => {
          Ee.$off('mapPlayComplete', s)
        })
      function i(d) {
        t.value = new fbt()
        let p = {
          progress: 0,
        }
        t.value.instance.on('onProgress', (g, v, m) => {
          let y = Math.floor((v / m) * 100)
          Sn.to(p, {
            progress: y,
            onUpdate: () => {
              n.progress = Math.floor(p.progress)
            },
          })
        }),
          t.value.instance.on('onLoad', () => {
            d && d()
          })
      }
      async function a() {
        return new Promise((d, p) => {
          let g = Sn.timeline()
          g.to('.loading-text span', {
            y: '200%',
            opacity: 0,
            ease: 'power4.inOut',
            duration: 2,
            stagger: 0.2,
          }),
            g.to(
              '.loading-progress',
              {
                opacity: 0,
                ease: 'power4.inOut',
                duration: 2,
              },
              '<',
            ),
            g.to(
              '.loading',
              {
                opacity: 0,
                ease: 'power4.inOut',
                onComplete: () => {
                  d()
                },
              },
              '-=1',
            )
        })
      }
      function o(d) {
        n.activeIndex = d
      }
      function s() {
        let d = Sn.timeline({
            paused: !1,
          }),
          p = Sn.utils.toArray('.left-card'),
          g = Sn.utils.toArray('.right-card'),
          v = Sn.utils.toArray('.count-card')
        d.addLabel('start', 0.5),
          d.addLabel('menu', 0.5),
          d.addLabel('card', 1),
          d.addLabel('countCard', 3),
          d.to(
            '.m-header',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            'start',
          ),
          d.to(
            '.bottom-tray',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            'start',
          ),
          d.to(
            '.top-menu',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            '-=1',
          ),
          d.to(
            '.bottom-radar',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            '-=2',
          ),
          d.to(
            p,
            {
              x: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          ),
          d.to(
            g,
            {
              x: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          ),
          d.to(
            v,
            {
              y: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          )
      }
      function l() {
        let d = jF.filter((p, g) => g < 7)
        Ee.$emit('createBar', d)
      }
      function u() {
        Ee.$emit('createPoint', vbt)
      }
      function c() {
        let d = Math.random() > 0.5 ? gbt : mbt
        Ee.$emit('createPath', d)
      }
      function h() {
        Ee.$emit('createHeatmap')
      }
      function f(d) {
        n.bottomMenuStatus[d] = !n.bottomMenuStatus[d]
        const p = {
            bar: () => {
              Ee.$emit('destroyBar')
            },
            point: () => {
              Ee.$emit('destroyPoint')
            },
            path: () => {
              Ee.$emit('destroyPath')
            },
            hotmap: () => {
              Ee.$emit('destroyHeatmap')
            },
          },
          g = {
            bar: () => {
              l()
            },
            point: () => {
              u()
            },
            path: () => {
              c()
            },
            hotmap: () => {
              h()
            },
          }
        n.bottomMenuStatus[d] ? g[d] && g[d]() : p[d] && p[d]()
      }
      return (d, p) => (
        en(),
        sn('div', ybt, [
          ye(
            Nj,
            {
              ref_key: 'mapSceneRef',
              ref: e,
            },
            null,
            512,
          ),
          wt('div', _bt, [
            Of(
              ye(
                tJ,
                {
                  title: '浙江省数据可视化平台',
                  'sub-text': 'Zhejiang Province Data Visualization Platform',
                },
                {
                  left: Qn(
                    () =>
                      p[4] ||
                      (p[4] = [
                        wt(
                          'div',
                          {
                            class: 'm-header-weather',
                          },
                          [wt('span', null, '小雨'), wt('span', null, '27℃')],
                          -1,
                        ),
                      ]),
                  ),
                  right: Qn(
                    () =>
                      p[5] ||
                      (p[5] = [
                        wt(
                          'div',
                          {
                            class: 'm-header-date',
                          },
                          [
                            wt('span', null, '2024-10-12'),
                            wt('span', null, '17:53:16'),
                          ],
                          -1,
                        ),
                      ]),
                  ),
                  _: 1,
                },
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                xbt,
                [
                  ye(
                    pJ,
                    {
                      'default-active': n.activeIndex,
                      onSelect: o,
                    },
                    {
                      default: Qn(() => [
                        ye(
                          Bc,
                          {
                            index: '1',
                          },
                          {
                            default: Qn(
                              () => p[6] || (p[6] = [ko('经济概览')]),
                            ),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '2',
                          },
                          {
                            default: Qn(() => p[7] || (p[7] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '3',
                          },
                          {
                            default: Qn(() => p[8] || (p[8] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        p[12] ||
                          (p[12] = wt(
                            'div',
                            {
                              class: 'top-menu-mid-space',
                            },
                            null,
                            -1,
                          )),
                        ye(
                          Bc,
                          {
                            index: '4',
                          },
                          {
                            default: Qn(() => p[9] || (p[9] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '5',
                          },
                          {
                            default: Qn(
                              () => p[10] || (p[10] = [ko('导航栏')]),
                            ),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '6',
                          },
                          {
                            default: Qn(
                              () => p[11] || (p[11] = [ko('导航栏')]),
                            ),
                            _: 1,
                          },
                        ),
                      ]),
                      _: 1,
                    },
                    8,
                    ['default-active'],
                  ),
                ],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                Sbt,
                [
                  (en(!0),
                  sn(
                    _M,
                    null,
                    xM(
                      n.totalView,
                      (g, v) => (
                        en(),
                        _8(
                          fJ,
                          {
                            info: g,
                            key: v,
                          },
                          null,
                          8,
                          ['info'],
                        )
                      ),
                    ),
                    128,
                  )),
                ],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                Abt,
                [wt('div', bbt, [ye(mAt), ye(NAt), ye(kAt), ye(BAt)])],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                wbt,
                [wt('div', Mbt, [ye(FAt), ye(WAt), ye(XAt), ye(YAt)])],
                512,
              ),
              [[Nf, !0]],
            ),
            wt('div', Tbt, [
              ye(Oy, {
                class: 'bottom-svg-line-left',
                width: 721,
                height: 57,
                color: '#30DCFF',
                strokeWidth: 2,
                dir: [0, 1],
                length: 50,
                path: 'M1 56.6105C1 31.5123 185.586 10.0503 451.904 1.35519C458.942 1.12543 465.781 4.00883 470.505 9.22964L484.991 25.2383C487.971 28.4775 492.938 30.4201 498.254 30.4201H720.142',
              }),
              ye(Oy, {
                class: 'bottom-svg-line-left bottom-svg-line-right',
                width: 721,
                height: 57,
                color: '#30DCFF',
                strokeWidth: 2,
                dir: [0, 1],
                length: 50,
                path: 'M1 56.6105C1 31.5123 185.586 10.0503 451.904 1.35519C458.942 1.12543 465.781 4.00883 470.505 9.22964L484.991 25.2383C487.971 28.4775 492.938 30.4201 498.254 30.4201H720.142',
              }),
              p[17] ||
                (p[17] = wt(
                  'div',
                  {
                    class: 'bottom-tray-arrow',
                  },
                  [
                    wt('img', {
                      src: YE,
                      alt: '',
                    }),
                    wt('img', {
                      src: $E,
                      alt: '',
                    }),
                  ],
                  -1,
                )),
              wt('div', Cbt, [
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.bar,
                      },
                    ]),
                    onClick: p[0] || (p[0] = g => f('bar')),
                  },
                  p[13] || (p[13] = [wt('span', null, '柱状图', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.point,
                      },
                    ]),
                    onClick: p[1] || (p[1] = g => f('point')),
                  },
                  p[14] || (p[14] = [wt('span', null, '告警点位', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.path,
                      },
                    ]),
                    onClick: p[2] || (p[2] = g => f('path')),
                  },
                  p[15] || (p[15] = [wt('span', null, '轨道路线', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.hotmap,
                      },
                    ]),
                    onClick: p[3] || (p[3] = g => f('hotmap')),
                  },
                  p[16] || (p[16] = [wt('span', null, '热力图', -1)]),
                  2,
                ),
              ]),
              p[18] ||
                (p[18] = wt(
                  'div',
                  {
                    class: 'bottom-tray-arrow is-reverse',
                  },
                  [
                    wt('img', {
                      src: YE,
                      alt: '',
                    }),
                    wt('img', {
                      src: $E,
                      alt: '',
                    }),
                  ],
                  -1,
                )),
            ]),
            wt('div', Ebt, [ye(xJ)]),
            p[19] ||
              (p[19] = wt(
                'div',
                {
                  class: 'large-screen-left-zsline',
                },
                null,
                -1,
              )),
            p[20] ||
              (p[20] = wt(
                'div',
                {
                  class: 'large-screen-right-zsline',
                },
                null,
                -1,
              )),
          ]),
          wt('div', Dbt, [
            p[22] ||
              (p[22] = y8(
                '<div class="loading-text"><span style="--index:1;">L</span><span style="--index:2;">O</span><span style="--index:3;">A</span><span style="--index:4;">D</span><span style="--index:5;">I</span><span style="--index:6;">N</span><span style="--index:7;">G</span></div>',
                1,
              )),
            wt('div', Lbt, [
              wt('span', Pbt, Si(n.progress), 1),
              p[21] ||
                (p[21] = wt(
                  'span',
                  {
                    class: 'unit',
                  },
                  '%',
                  -1,
                )),
            ]),
          ]),
        ])
      )
    },
  }
export {Ubt as default}
