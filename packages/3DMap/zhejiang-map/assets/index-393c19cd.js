import {
  u as d8,
  s as hh,
  o as Ea,
  a as Da,
  b as en,
  c as sn,
  d as wt,
  t as Si,
  r as Bh,
  e as ye,
  n as fh,
  f as La,
  g as je,
  p as HE,
  w as Td,
  i as dh,
  h as Ql,
  j as fy,
  k as p8,
  l as v8,
  m as g8,
  q as WE,
  v as XE,
  x as so,
  y as m8,
  z as Qn,
  A as yM,
  B as ko,
  F as _M,
  C as xM,
  D as Of,
  E as y8,
  G as _8,
  H as Nf,
} from './index-7acb3ea1.js'
const YE = './assets/bottom-menu-arrow-big-180b7071.svg',
  $E = './assets/bottom-menu-arrow-small-19304179.svg'
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const SM = '166',
  hc = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
  },
  fc = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3,
  },
  x8 = 0,
  qE = 1,
  S8 = 2,
  Nk = 1,
  A8 = 2,
  Po = 3,
  $o = 0,
  Qr = 1,
  dr = 2,
  Xs = 0,
  bh = 1,
  $r = 2,
  ZE = 3,
  KE = 4,
  b8 = 5,
  uu = 100,
  w8 = 101,
  M8 = 102,
  T8 = 103,
  C8 = 104,
  E8 = 200,
  D8 = 201,
  L8 = 202,
  P8 = 203,
  vA = 204,
  gA = 205,
  R8 = 206,
  I8 = 207,
  O8 = 208,
  N8 = 209,
  k8 = 210,
  B8 = 211,
  F8 = 212,
  z8 = 213,
  U8 = 214,
  V8 = 0,
  G8 = 1,
  H8 = 2,
  dy = 3,
  W8 = 4,
  X8 = 5,
  Y8 = 6,
  $8 = 7,
  AM = 0,
  q8 = 1,
  Z8 = 2,
  Ys = 0,
  K8 = 1,
  j8 = 2,
  J8 = 3,
  Q8 = 4,
  t6 = 5,
  e6 = 6,
  n6 = 7,
  jE = 'attached',
  r6 = 'detached',
  kk = 300,
  Fh = 301,
  zh = 302,
  mA = 303,
  yA = 304,
  R0 = 306,
  Jn = 1e3,
  Ps = 1001,
  py = 1002,
  Ur = 1003,
  Bk = 1004,
  Cd = 1005,
  gi = 1006,
  Im = 1007,
  Fo = 1008,
  qo = 1009,
  Fk = 1010,
  zk = 1011,
  gp = 1012,
  bM = 1013,
  Uu = 1014,
  ya = 1015,
  hv = 1016,
  wM = 1017,
  MM = 1018,
  Uh = 1020,
  Uk = 35902,
  Vk = 1021,
  Gk = 1022,
  Yi = 1023,
  Hk = 1024,
  Wk = 1025,
  wh = 1026,
  Vh = 1027,
  TM = 1028,
  CM = 1029,
  Xk = 1030,
  EM = 1031,
  DM = 1033,
  Om = 33776,
  Nm = 33777,
  km = 33778,
  Bm = 33779,
  _A = 35840,
  xA = 35841,
  SA = 35842,
  AA = 35843,
  bA = 36196,
  wA = 37492,
  MA = 37496,
  TA = 37808,
  CA = 37809,
  EA = 37810,
  DA = 37811,
  LA = 37812,
  PA = 37813,
  RA = 37814,
  IA = 37815,
  OA = 37816,
  NA = 37817,
  kA = 37818,
  BA = 37819,
  FA = 37820,
  zA = 37821,
  Fm = 36492,
  UA = 36494,
  VA = 36495,
  Yk = 36283,
  GA = 36284,
  HA = 36285,
  WA = 36286,
  mp = 2300,
  yp = 2301,
  k_ = 2302,
  JE = 2400,
  QE = 2401,
  t2 = 2402,
  i6 = 2500,
  a6 = 0,
  $k = 1,
  XA = 2,
  o6 = 3200,
  s6 = 3201,
  LM = 0,
  l6 = 1,
  Ls = '',
  cn = 'srgb',
  ar = 'srgb-linear',
  PM = 'display-p3',
  I0 = 'display-p3-linear',
  vy = 'linear',
  an = 'srgb',
  gy = 'rec709',
  my = 'p3',
  dc = 7680,
  e2 = 519,
  u6 = 512,
  c6 = 513,
  h6 = 514,
  qk = 515,
  f6 = 516,
  d6 = 517,
  p6 = 518,
  v6 = 519,
  YA = 35044,
  n2 = '300 es',
  zo = 2e3,
  yy = 2001
class Ju {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {})
    const n = this._listeners
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e)
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0) return !1
    const n = this._listeners
    return n[t] !== void 0 && n[t].indexOf(e) !== -1
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0) return
    const i = this._listeners[t]
    if (i !== void 0) {
      const a = i.indexOf(e)
      a !== -1 && i.splice(a, 1)
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0) return
    const n = this._listeners[t.type]
    if (n !== void 0) {
      t.target = this
      const i = n.slice(0)
      for (let a = 0, o = i.length; a < o; a++) i[a].call(this, t)
      t.target = null
    }
  }
}
const _r = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
]
let r2 = 1234567
const Yd = Math.PI / 180,
  Gh = 180 / Math.PI
function Ki() {
  const r = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0
  return (
    _r[r & 255] +
    _r[(r >> 8) & 255] +
    _r[(r >> 16) & 255] +
    _r[(r >> 24) & 255] +
    '-' +
    _r[t & 255] +
    _r[(t >> 8) & 255] +
    '-' +
    _r[((t >> 16) & 15) | 64] +
    _r[(t >> 24) & 255] +
    '-' +
    _r[(e & 63) | 128] +
    _r[(e >> 8) & 255] +
    '-' +
    _r[(e >> 16) & 255] +
    _r[(e >> 24) & 255] +
    _r[n & 255] +
    _r[(n >> 8) & 255] +
    _r[(n >> 16) & 255] +
    _r[(n >> 24) & 255]
  ).toLowerCase()
}
function zn(r, t, e) {
  return Math.max(t, Math.min(e, r))
}
function RM(r, t) {
  return ((r % t) + t) % t
}
function g6(r, t, e, n, i) {
  return n + ((r - t) * (i - n)) / (e - t)
}
function m6(r, t, e) {
  return r !== t ? (e - r) / (t - r) : 0
}
function $d(r, t, e) {
  return (1 - e) * r + e * t
}
function y6(r, t, e, n) {
  return $d(r, t, 1 - Math.exp(-e * n))
}
function _6(r, t = 1) {
  return t - Math.abs(RM(r, t * 2) - t)
}
function x6(r, t, e) {
  return r <= t
    ? 0
    : r >= e
    ? 1
    : ((r = (r - t) / (e - t)), r * r * (3 - 2 * r))
}
function S6(r, t, e) {
  return r <= t
    ? 0
    : r >= e
    ? 1
    : ((r = (r - t) / (e - t)), r * r * r * (r * (r * 6 - 15) + 10))
}
function A6(r, t) {
  return r + Math.floor(Math.random() * (t - r + 1))
}
function b6(r, t) {
  return r + Math.random() * (t - r)
}
function w6(r) {
  return r * (0.5 - Math.random())
}
function M6(r) {
  r !== void 0 && (r2 = r)
  let t = (r2 += 1831565813)
  return (
    (t = Math.imul(t ^ (t >>> 15), t | 1)),
    (t ^= t + Math.imul(t ^ (t >>> 7), t | 61)),
    ((t ^ (t >>> 14)) >>> 0) / 4294967296
  )
}
function T6(r) {
  return r * Yd
}
function C6(r) {
  return r * Gh
}
function E6(r) {
  return (r & (r - 1)) === 0 && r !== 0
}
function D6(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}
function L6(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}
function P6(r, t, e, n, i) {
  const a = Math.cos,
    o = Math.sin,
    s = a(e / 2),
    l = o(e / 2),
    u = a((t + n) / 2),
    c = o((t + n) / 2),
    h = a((t - n) / 2),
    f = o((t - n) / 2),
    d = a((n - t) / 2),
    p = o((n - t) / 2)
  switch (i) {
    case 'XYX':
      r.set(s * c, l * h, l * f, s * u)
      break
    case 'YZY':
      r.set(l * f, s * c, l * h, s * u)
      break
    case 'ZXZ':
      r.set(l * h, l * f, s * c, s * u)
      break
    case 'XZX':
      r.set(s * c, l * p, l * d, s * u)
      break
    case 'YXY':
      r.set(l * d, s * c, l * p, s * u)
      break
    case 'ZYZ':
      r.set(l * p, l * d, s * c, s * u)
      break
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          i,
      )
  }
}
function ma(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r
    case Uint32Array:
      return r / 4294967295
    case Uint16Array:
      return r / 65535
    case Uint8Array:
      return r / 255
    case Int32Array:
      return Math.max(r / 2147483647, -1)
    case Int16Array:
      return Math.max(r / 32767, -1)
    case Int8Array:
      return Math.max(r / 127, -1)
    default:
      throw new Error('Invalid component type.')
  }
}
function We(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r
    case Uint32Array:
      return Math.round(r * 4294967295)
    case Uint16Array:
      return Math.round(r * 65535)
    case Uint8Array:
      return Math.round(r * 255)
    case Int32Array:
      return Math.round(r * 2147483647)
    case Int16Array:
      return Math.round(r * 32767)
    case Int8Array:
      return Math.round(r * 127)
    default:
      throw new Error('Invalid component type.')
  }
}
const IM = {
  DEG2RAD: Yd,
  RAD2DEG: Gh,
  generateUUID: Ki,
  clamp: zn,
  euclideanModulo: RM,
  mapLinear: g6,
  inverseLerp: m6,
  lerp: $d,
  damp: y6,
  pingpong: _6,
  smoothstep: x6,
  smootherstep: S6,
  randInt: A6,
  randFloat: b6,
  randFloatSpread: w6,
  seededRandom: M6,
  degToRad: T6,
  radToDeg: C6,
  isPowerOfTwo: E6,
  ceilPowerOfTwo: D6,
  floorPowerOfTwo: L6,
  setQuaternionFromProperEuler: P6,
  normalize: We,
  denormalize: ma,
}
class pt {
  constructor(t = 0, e = 0) {
    ;(pt.prototype.isVector2 = !0), (this.x = t), (this.y = e)
  }
  get width() {
    return this.x
  }
  set width(t) {
    this.x = t
  }
  get height() {
    return this.y
  }
  set height(t) {
    this.y = t
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), this
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), this
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = t.elements
    return (
      (this.x = i[0] * e + i[3] * n + i[6]),
      (this.y = i[1] * e + i[4] * n + i[7]),
      this
    )
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y
  }
  cross(t) {
    return this.x * t.y - this.y * t.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq())
    if (e === 0) return Math.PI / 2
    const n = this.dot(t) / e
    return Math.acos(zn(n, -1, 1))
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y
    return e * e + n * n
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    )
  }
  equals(t) {
    return t.x === this.x && t.y === this.y
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t
  }
  fromBufferAttribute(t, e) {
    return (this.x = t.getX(e)), (this.y = t.getY(e)), this
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      a = this.x - t.x,
      o = this.y - t.y
    return (this.x = a * n - o * i + t.x), (this.y = a * i + o * n + t.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
class _e {
  constructor(t, e, n, i, a, o, s, l, u) {
    ;(_e.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, n, i, a, o, s, l, u)
  }
  set(t, e, n, i, a, o, s, l, u) {
    const c = this.elements
    return (
      (c[0] = t),
      (c[1] = i),
      (c[2] = s),
      (c[3] = e),
      (c[4] = a),
      (c[5] = l),
      (c[6] = n),
      (c[7] = o),
      (c[8] = u),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    )
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(t) {
    const e = t.elements
    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
  }
  multiply(t) {
    return this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      a = this.elements,
      o = n[0],
      s = n[3],
      l = n[6],
      u = n[1],
      c = n[4],
      h = n[7],
      f = n[2],
      d = n[5],
      p = n[8],
      g = i[0],
      v = i[3],
      m = i[6],
      y = i[1],
      _ = i[4],
      x = i[7],
      A = i[2],
      S = i[5],
      b = i[8]
    return (
      (a[0] = o * g + s * y + l * A),
      (a[3] = o * v + s * _ + l * S),
      (a[6] = o * m + s * x + l * b),
      (a[1] = u * g + c * y + h * A),
      (a[4] = u * v + c * _ + h * S),
      (a[7] = u * m + c * x + h * b),
      (a[2] = f * g + d * y + p * A),
      (a[5] = f * v + d * _ + p * S),
      (a[8] = f * m + d * x + p * b),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      a = t[3],
      o = t[4],
      s = t[5],
      l = t[6],
      u = t[7],
      c = t[8]
    return e * o * c - e * s * u - n * a * c + n * s * l + i * a * u - i * o * l
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      a = t[3],
      o = t[4],
      s = t[5],
      l = t[6],
      u = t[7],
      c = t[8],
      h = c * o - s * u,
      f = s * l - c * a,
      d = u * a - o * l,
      p = e * h + n * f + i * d
    if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const g = 1 / p
    return (
      (t[0] = h * g),
      (t[1] = (i * u - c * n) * g),
      (t[2] = (s * n - i * o) * g),
      (t[3] = f * g),
      (t[4] = (c * e - i * l) * g),
      (t[5] = (i * a - s * e) * g),
      (t[6] = d * g),
      (t[7] = (n * l - u * e) * g),
      (t[8] = (o * e - n * a) * g),
      this
    )
  }
  transpose() {
    let t
    const e = this.elements
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    )
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose()
  }
  transposeIntoArray(t) {
    const e = this.elements
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    )
  }
  setUvTransform(t, e, n, i, a, o, s) {
    const l = Math.cos(a),
      u = Math.sin(a)
    return (
      this.set(
        n * l,
        n * u,
        -n * (l * o + u * s) + o + t,
        -i * u,
        i * l,
        -i * (-u * o + l * s) + s + e,
        0,
        0,
        1,
      ),
      this
    )
  }
  scale(t, e) {
    return this.premultiply(B_.makeScale(t, e)), this
  }
  rotate(t) {
    return this.premultiply(B_.makeRotation(-t)), this
  }
  translate(t, e) {
    return this.premultiply(B_.makeTranslation(t, e)), this
  }
  makeTranslation(t, e) {
    return (
      t.isVector2
        ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
        : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
      this
    )
  }
  makeRotation(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this
  }
  makeScale(t, e) {
    return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
const B_ = new _e()
function Zk(r) {
  for (let t = r.length - 1; t >= 0; --t) if (r[t] >= 65535) return !0
  return !1
}
function _p(r) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', r)
}
function R6() {
  const r = _p('canvas')
  return (r.style.display = 'block'), r
}
const i2 = {}
function OM(r) {
  r in i2 || ((i2[r] = !0), console.warn(r))
}
function I6(r, t, e) {
  return new Promise(function (n, i) {
    function a() {
      switch (r.clientWaitSync(t, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case r.WAIT_FAILED:
          i()
          break
        case r.TIMEOUT_EXPIRED:
          setTimeout(a, e)
          break
        default:
          n()
      }
    }
    setTimeout(a, e)
  })
}
const a2 = new _e().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199,
  ),
  o2 = new _e().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735,
  ),
  Bv = {
    [ar]: {
      transfer: vy,
      primaries: gy,
      toReference: r => r,
      fromReference: r => r,
    },
    [cn]: {
      transfer: an,
      primaries: gy,
      toReference: r => r.convertSRGBToLinear(),
      fromReference: r => r.convertLinearToSRGB(),
    },
    [I0]: {
      transfer: vy,
      primaries: my,
      toReference: r => r.applyMatrix3(o2),
      fromReference: r => r.applyMatrix3(a2),
    },
    [PM]: {
      transfer: an,
      primaries: my,
      toReference: r => r.convertSRGBToLinear().applyMatrix3(o2),
      fromReference: r => r.applyMatrix3(a2).convertLinearToSRGB(),
    },
  },
  O6 = new Set([ar, I0]),
  Be = {
    enabled: !0,
    _workingColorSpace: ar,
    get workingColorSpace() {
      return this._workingColorSpace
    },
    set workingColorSpace(r) {
      if (!O6.has(r))
        throw new Error(`Unsupported working color space, "${r}".`)
      this._workingColorSpace = r
    },
    convert: function (r, t, e) {
      if (this.enabled === !1 || t === e || !t || !e) return r
      const n = Bv[t].toReference,
        i = Bv[e].fromReference
      return i(n(r))
    },
    fromWorkingColorSpace: function (r, t) {
      return this.convert(r, this._workingColorSpace, t)
    },
    toWorkingColorSpace: function (r, t) {
      return this.convert(r, t, this._workingColorSpace)
    },
    getPrimaries: function (r) {
      return Bv[r].primaries
    },
    getTransfer: function (r) {
      return r === Ls ? vy : Bv[r].transfer
    },
  }
function Mh(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4)
}
function F_(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055
}
let pc
class N6 {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > 'u') return t.src
    let e
    if (t instanceof HTMLCanvasElement) e = t
    else {
      pc === void 0 && (pc = _p('canvas')),
        (pc.width = t.width),
        (pc.height = t.height)
      const n = pc.getContext('2d')
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (e = pc)
    }
    return e.width > 2048 || e.height > 2048
      ? (console.warn(
          'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
          t,
        ),
        e.toDataURL('image/jpeg', 0.6))
      : e.toDataURL('image/png')
  }
  static sRGBToLinear(t) {
    if (
      (typeof HTMLImageElement < 'u' && t instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < 'u' && t instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < 'u' && t instanceof ImageBitmap)
    ) {
      const e = _p('canvas')
      ;(e.width = t.width), (e.height = t.height)
      const n = e.getContext('2d')
      n.drawImage(t, 0, 0, t.width, t.height)
      const i = n.getImageData(0, 0, t.width, t.height),
        a = i.data
      for (let o = 0; o < a.length; o++) a[o] = Mh(a[o] / 255) * 255
      return n.putImageData(i, 0, 0), e
    } else if (t.data) {
      const e = t.data.slice(0)
      for (let n = 0; n < e.length; n++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray
          ? (e[n] = Math.floor(Mh(e[n] / 255) * 255))
          : (e[n] = Mh(e[n]))
      return {
        data: e,
        width: t.width,
        height: t.height,
      }
    } else
      return (
        console.warn(
          'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.',
        ),
        t
      )
  }
}
let k6 = 0
class Kk {
  constructor(t = null) {
    ;(this.isSource = !0),
      Object.defineProperty(this, 'id', {
        value: k6++,
      }),
      (this.uuid = Ki()),
      (this.data = t),
      (this.dataReady = !0),
      (this.version = 0)
  }
  set needsUpdate(t) {
    t === !0 && this.version++
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string'
    if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid]
    const n = {
        uuid: this.uuid,
        url: '',
      },
      i = this.data
    if (i !== null) {
      let a
      if (Array.isArray(i)) {
        a = []
        for (let o = 0, s = i.length; o < s; o++)
          i[o].isDataTexture ? a.push(z_(i[o].image)) : a.push(z_(i[o]))
      } else a = z_(i)
      n.url = a
    }
    return e || (t.images[this.uuid] = n), n
  }
}
function z_(r) {
  return (typeof HTMLImageElement < 'u' && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < 'u' && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < 'u' && r instanceof ImageBitmap)
    ? N6.getDataURL(r)
    : r.data
    ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name,
      }
    : (console.warn('THREE.Texture: Unable to serialize Texture.'), {})
}
let B6 = 0
class Yn extends Ju {
  constructor(
    t = Yn.DEFAULT_IMAGE,
    e = Yn.DEFAULT_MAPPING,
    n = Ps,
    i = Ps,
    a = gi,
    o = Fo,
    s = Yi,
    l = qo,
    u = Yn.DEFAULT_ANISOTROPY,
    c = Ls,
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, 'id', {
        value: B6++,
      }),
      (this.uuid = Ki()),
      (this.name = ''),
      (this.source = new Kk(t)),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = a),
      (this.minFilter = o),
      (this.anisotropy = u),
      (this.format = s),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new pt(0, 0)),
      (this.repeat = new pt(1, 1)),
      (this.center = new pt(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new _e()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = c),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.pmremVersion = 0)
  }
  get image() {
    return this.source.data
  }
  set image(t = null) {
    this.source.data = t
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.source = t.source),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.channel = t.channel),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.colorSpace = t.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string'
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid]
    const n = {
      metadata: {
        version: 4.6,
        type: 'Texture',
        generator: 'Texture.toJSON',
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      e || (t.textures[this.uuid] = n),
      n
    )
  }
  dispose() {
    this.dispatchEvent({
      type: 'dispose',
    })
  }
  transformUv(t) {
    if (this.mapping !== kk) return t
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case Jn:
          t.x = t.x - Math.floor(t.x)
          break
        case Ps:
          t.x = t.x < 0 ? 0 : 1
          break
        case py:
          Math.abs(Math.floor(t.x) % 2) === 1
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x))
          break
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case Jn:
          t.y = t.y - Math.floor(t.y)
          break
        case Ps:
          t.y = t.y < 0 ? 0 : 1
          break
        case py:
          Math.abs(Math.floor(t.y) % 2) === 1
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y))
          break
      }
    return this.flipY && (t.y = 1 - t.y), t
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, (this.source.needsUpdate = !0))
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++
  }
}
Yn.DEFAULT_IMAGE = null
Yn.DEFAULT_MAPPING = kk
Yn.DEFAULT_ANISOTROPY = 1
class Oe {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(Oe.prototype.isVector4 = !0),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      (this.w = i)
  }
  get width() {
    return this.z
  }
  set width(t) {
    this.z = t
  }
  get height() {
    return this.w
  }
  set height(t) {
    this.w = t
  }
  set(t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setW(t) {
    return (this.w = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      case 3:
        this.w = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = t.w !== void 0 ? t.w : 1),
      this
    )
  }
  add(t) {
    return (
      (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
    )
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    )
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    )
  }
  sub(t) {
    return (
      (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
    )
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    )
  }
  multiply(t) {
    return (
      (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
    )
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      a = this.w,
      o = t.elements
    return (
      (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * a),
      (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * a),
      (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * a),
      (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * a),
      this
    )
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w)
    const e = Math.sqrt(1 - t.w * t.w)
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, a
    const l = t.elements,
      u = l[0],
      c = l[4],
      h = l[8],
      f = l[1],
      d = l[5],
      p = l[9],
      g = l[2],
      v = l[6],
      m = l[10]
    if (
      Math.abs(c - f) < 0.01 &&
      Math.abs(h - g) < 0.01 &&
      Math.abs(p - v) < 0.01
    ) {
      if (
        Math.abs(c + f) < 0.1 &&
        Math.abs(h + g) < 0.1 &&
        Math.abs(p + v) < 0.1 &&
        Math.abs(u + d + m - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this
      e = Math.PI
      const _ = (u + 1) / 2,
        x = (d + 1) / 2,
        A = (m + 1) / 2,
        S = (c + f) / 4,
        b = (h + g) / 4,
        T = (p + v) / 4
      return (
        _ > x && _ > A
          ? _ < 0.01
            ? ((n = 0), (i = 0.707106781), (a = 0.707106781))
            : ((n = Math.sqrt(_)), (i = S / n), (a = b / n))
          : x > A
          ? x < 0.01
            ? ((n = 0.707106781), (i = 0), (a = 0.707106781))
            : ((i = Math.sqrt(x)), (n = S / i), (a = T / i))
          : A < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (a = 0))
          : ((a = Math.sqrt(A)), (n = b / a), (i = T / a)),
        this.set(n, i, a, e),
        this
      )
    }
    let y = Math.sqrt((v - p) * (v - p) + (h - g) * (h - g) + (f - c) * (f - c))
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (v - p) / y),
      (this.y = (h - g) / y),
      (this.z = (f - c) / y),
      (this.w = Math.acos((u + d + m - 1) / 2)),
      this
    )
  }
  setFromMatrixPosition(t) {
    const e = t.elements
    return (
      (this.x = e[12]),
      (this.y = e[13]),
      (this.z = e[14]),
      (this.w = e[15]),
      this
    )
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    )
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    )
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    )
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
  }
  fromArray(t, e = 0) {
    return (
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    )
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
class F6 extends Ju {
  constructor(t = 1, e = 1, n = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = t),
      (this.height = e),
      (this.depth = 1),
      (this.scissor = new Oe(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new Oe(0, 0, t, e))
    const i = {
      width: t,
      height: e,
      depth: 1,
    }
    n = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: gi,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      n,
    )
    const a = new Yn(
      i,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace,
    )
    ;(a.flipY = !1),
      (a.generateMipmaps = n.generateMipmaps),
      (a.internalFormat = n.internalFormat),
      (this.textures = [])
    const o = n.count
    for (let s = 0; s < o; s++)
      (this.textures[s] = a.clone()),
        (this.textures[s].isRenderTargetTexture = !0)
    ;(this.depthBuffer = n.depthBuffer),
      (this.stencilBuffer = n.stencilBuffer),
      (this.resolveDepthBuffer = n.resolveDepthBuffer),
      (this.resolveStencilBuffer = n.resolveStencilBuffer),
      (this.depthTexture = n.depthTexture),
      (this.samples = n.samples)
  }
  get texture() {
    return this.textures[0]
  }
  set texture(t) {
    this.textures[0] = t
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      ;(this.width = t), (this.height = e), (this.depth = n)
      for (let i = 0, a = this.textures.length; i < a; i++)
        (this.textures[i].image.width = t),
          (this.textures[i].image.height = e),
          (this.textures[i].image.depth = n)
      this.dispose()
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.scissor.copy(t.scissor),
      (this.scissorTest = t.scissorTest),
      this.viewport.copy(t.viewport),
      (this.textures.length = 0)
    for (let n = 0, i = t.textures.length; n < i; n++)
      (this.textures[n] = t.textures[n].clone()),
        (this.textures[n].isRenderTargetTexture = !0)
    const e = Object.assign({}, t.texture.image)
    return (
      (this.texture.source = new Kk(e)),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.resolveDepthBuffer = t.resolveDepthBuffer),
      (this.resolveStencilBuffer = t.resolveStencilBuffer),
      t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()),
      (this.samples = t.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({
      type: 'dispose',
    })
  }
}
class Vu extends F6 {
  constructor(t = 1, e = 1, n = {}) {
    super(t, e, n), (this.isWebGLRenderTarget = !0)
  }
}
class jk extends Yn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = {
        data: t,
        width: e,
        height: n,
        depth: i,
      }),
      (this.magFilter = Ur),
      (this.minFilter = Ur),
      (this.wrapR = Ps),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set())
  }
  addLayerUpdate(t) {
    this.layerUpdates.add(t)
  }
  clearLayerUpdates() {
    this.layerUpdates.clear()
  }
}
class z6 extends Yn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = {
        data: t,
        width: e,
        height: n,
        depth: i,
      }),
      (this.magFilter = Ur),
      (this.minFilter = Ur),
      (this.wrapR = Ps),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
class wa {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    ;(this.isQuaternion = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i)
  }
  static slerpFlat(t, e, n, i, a, o, s) {
    let l = n[i + 0],
      u = n[i + 1],
      c = n[i + 2],
      h = n[i + 3]
    const f = a[o + 0],
      d = a[o + 1],
      p = a[o + 2],
      g = a[o + 3]
    if (s === 0) {
      ;(t[e + 0] = l), (t[e + 1] = u), (t[e + 2] = c), (t[e + 3] = h)
      return
    }
    if (s === 1) {
      ;(t[e + 0] = f), (t[e + 1] = d), (t[e + 2] = p), (t[e + 3] = g)
      return
    }
    if (h !== g || l !== f || u !== d || c !== p) {
      let v = 1 - s
      const m = l * f + u * d + c * p + h * g,
        y = m >= 0 ? 1 : -1,
        _ = 1 - m * m
      if (_ > Number.EPSILON) {
        const A = Math.sqrt(_),
          S = Math.atan2(A, m * y)
        ;(v = Math.sin(v * S) / A), (s = Math.sin(s * S) / A)
      }
      const x = s * y
      if (
        ((l = l * v + f * x),
        (u = u * v + d * x),
        (c = c * v + p * x),
        (h = h * v + g * x),
        v === 1 - s)
      ) {
        const A = 1 / Math.sqrt(l * l + u * u + c * c + h * h)
        ;(l *= A), (u *= A), (c *= A), (h *= A)
      }
    }
    ;(t[e] = l), (t[e + 1] = u), (t[e + 2] = c), (t[e + 3] = h)
  }
  static multiplyQuaternionsFlat(t, e, n, i, a, o) {
    const s = n[i],
      l = n[i + 1],
      u = n[i + 2],
      c = n[i + 3],
      h = a[o],
      f = a[o + 1],
      d = a[o + 2],
      p = a[o + 3]
    return (
      (t[e] = s * p + c * h + l * d - u * f),
      (t[e + 1] = l * p + c * f + u * h - s * d),
      (t[e + 2] = u * p + c * d + s * f - l * h),
      (t[e + 3] = c * p - s * h - l * f - u * d),
      t
    )
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(t) {
    ;(this._w = t), this._onChangeCallback()
  }
  set(t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(t, e = !0) {
    const n = t._x,
      i = t._y,
      a = t._z,
      o = t._order,
      s = Math.cos,
      l = Math.sin,
      u = s(n / 2),
      c = s(i / 2),
      h = s(a / 2),
      f = l(n / 2),
      d = l(i / 2),
      p = l(a / 2)
    switch (o) {
      case 'XYZ':
        ;(this._x = f * c * h + u * d * p),
          (this._y = u * d * h - f * c * p),
          (this._z = u * c * p + f * d * h),
          (this._w = u * c * h - f * d * p)
        break
      case 'YXZ':
        ;(this._x = f * c * h + u * d * p),
          (this._y = u * d * h - f * c * p),
          (this._z = u * c * p - f * d * h),
          (this._w = u * c * h + f * d * p)
        break
      case 'ZXY':
        ;(this._x = f * c * h - u * d * p),
          (this._y = u * d * h + f * c * p),
          (this._z = u * c * p + f * d * h),
          (this._w = u * c * h - f * d * p)
        break
      case 'ZYX':
        ;(this._x = f * c * h - u * d * p),
          (this._y = u * d * h + f * c * p),
          (this._z = u * c * p - f * d * h),
          (this._w = u * c * h + f * d * p)
        break
      case 'YZX':
        ;(this._x = f * c * h + u * d * p),
          (this._y = u * d * h + f * c * p),
          (this._z = u * c * p - f * d * h),
          (this._w = u * c * h - f * d * p)
        break
      case 'XZY':
        ;(this._x = f * c * h - u * d * p),
          (this._y = u * d * h - f * c * p),
          (this._z = u * c * p + f * d * h),
          (this._w = u * c * h + f * d * p)
        break
      default:
        console.warn(
          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
            o,
        )
    }
    return e === !0 && this._onChangeCallback(), this
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      i = Math.sin(n)
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      a = e[8],
      o = e[1],
      s = e[5],
      l = e[9],
      u = e[2],
      c = e[6],
      h = e[10],
      f = n + s + h
    if (f > 0) {
      const d = 0.5 / Math.sqrt(f + 1)
      ;(this._w = 0.25 / d),
        (this._x = (c - l) * d),
        (this._y = (a - u) * d),
        (this._z = (o - i) * d)
    } else if (n > s && n > h) {
      const d = 2 * Math.sqrt(1 + n - s - h)
      ;(this._w = (c - l) / d),
        (this._x = 0.25 * d),
        (this._y = (i + o) / d),
        (this._z = (a + u) / d)
    } else if (s > h) {
      const d = 2 * Math.sqrt(1 + s - n - h)
      ;(this._w = (a - u) / d),
        (this._x = (i + o) / d),
        (this._y = 0.25 * d),
        (this._z = (l + c) / d)
    } else {
      const d = 2 * Math.sqrt(1 + h - n - s)
      ;(this._w = (o - i) / d),
        (this._x = (a + u) / d),
        (this._y = (l + c) / d),
        (this._z = 0.25 * d)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    )
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(zn(this.dot(t), -1, 1)))
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t)
    if (n === 0) return this
    const i = Math.min(1, e / n)
    return this.slerp(t, i), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    )
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    )
  }
  normalize() {
    let t = this.length()
    return (
      t === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t)
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this)
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      i = t._y,
      a = t._z,
      o = t._w,
      s = e._x,
      l = e._y,
      u = e._z,
      c = e._w
    return (
      (this._x = n * c + o * s + i * u - a * l),
      (this._y = i * c + o * l + a * s - n * u),
      (this._z = a * c + o * u + n * l - i * s),
      (this._w = o * c - n * s - i * l - a * u),
      this._onChangeCallback(),
      this
    )
  }
  slerp(t, e) {
    if (e === 0) return this
    if (e === 1) return this.copy(t)
    const n = this._x,
      i = this._y,
      a = this._z,
      o = this._w
    let s = o * t._w + n * t._x + i * t._y + a * t._z
    if (
      (s < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (s = -s))
        : this.copy(t),
      s >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = a), this
    const l = 1 - s * s
    if (l <= Number.EPSILON) {
      const d = 1 - e
      return (
        (this._w = d * o + e * this._w),
        (this._x = d * n + e * this._x),
        (this._y = d * i + e * this._y),
        (this._z = d * a + e * this._z),
        this.normalize(),
        this
      )
    }
    const u = Math.sqrt(l),
      c = Math.atan2(u, s),
      h = Math.sin((1 - e) * c) / u,
      f = Math.sin(e * c) / u
    return (
      (this._w = o * h + this._w * f),
      (this._x = n * h + this._x * f),
      (this._y = i * h + this._y * f),
      (this._z = a * h + this._z * f),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n)
  }
  random() {
    const t = 2 * Math.PI * Math.random(),
      e = 2 * Math.PI * Math.random(),
      n = Math.random(),
      i = Math.sqrt(1 - n),
      a = Math.sqrt(n)
    return this.set(
      i * Math.sin(t),
      i * Math.cos(t),
      a * Math.sin(e),
      a * Math.cos(e),
    )
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    )
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    )
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this._onChangeCallback(),
      this
    )
  }
  toJSON() {
    return this.toArray()
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w
  }
}
class U {
  constructor(t = 0, e = 0, n = 0) {
    ;(U.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n)
  }
  set(t, e, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      this
    )
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this
  }
  setX(t) {
    return (this.x = t), this
  }
  setY(t) {
    return (this.y = t), this
  }
  setZ(t) {
    return (this.z = t), this
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e
        break
      case 1:
        this.y = e
        break
      case 2:
        this.z = e
        break
      default:
        throw new Error('index is out of range: ' + t)
    }
    return this
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + t)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
  }
  add(t) {
    return (this.x += t.x), (this.y += t.y), (this.z += t.z), this
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    )
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
  }
  sub(t) {
    return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    )
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    )
  }
  applyEuler(t) {
    return this.applyQuaternion(s2.setFromEuler(t))
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(s2.setFromAxisAngle(t, e))
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      a = t.elements
    return (
      (this.x = a[0] * e + a[3] * n + a[6] * i),
      (this.y = a[1] * e + a[4] * n + a[7] * i),
      (this.z = a[2] * e + a[5] * n + a[8] * i),
      this
    )
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize()
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      a = t.elements,
      o = 1 / (a[3] * e + a[7] * n + a[11] * i + a[15])
    return (
      (this.x = (a[0] * e + a[4] * n + a[8] * i + a[12]) * o),
      (this.y = (a[1] * e + a[5] * n + a[9] * i + a[13]) * o),
      (this.z = (a[2] * e + a[6] * n + a[10] * i + a[14]) * o),
      this
    )
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      a = t.x,
      o = t.y,
      s = t.z,
      l = t.w,
      u = 2 * (o * i - s * n),
      c = 2 * (s * e - a * i),
      h = 2 * (a * n - o * e)
    return (
      (this.x = e + l * u + o * h - s * c),
      (this.y = n + l * c + s * u - a * h),
      (this.z = i + l * h + a * c - o * u),
      this
    )
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix,
    )
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld,
    )
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      a = t.elements
    return (
      (this.x = a[0] * e + a[4] * n + a[8] * i),
      (this.y = a[1] * e + a[5] * n + a[9] * i),
      (this.z = a[2] * e + a[6] * n + a[10] * i),
      this.normalize()
    )
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t)
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    )
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    )
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    )
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    )
  }
  clampLength(t, e) {
    const n = this.length()
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t)
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    )
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    )
  }
  cross(t) {
    return this.crossVectors(this, t)
  }
  crossVectors(t, e) {
    const n = t.x,
      i = t.y,
      a = t.z,
      o = e.x,
      s = e.y,
      l = e.z
    return (
      (this.x = i * l - a * s),
      (this.y = a * o - n * l),
      (this.z = n * s - i * o),
      this
    )
  }
  projectOnVector(t) {
    const e = t.lengthSq()
    if (e === 0) return this.set(0, 0, 0)
    const n = t.dot(this) / e
    return this.copy(t).multiplyScalar(n)
  }
  projectOnPlane(t) {
    return U_.copy(this).projectOnVector(t), this.sub(U_)
  }
  reflect(t) {
    return this.sub(U_.copy(t).multiplyScalar(2 * this.dot(t)))
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq())
    if (e === 0) return Math.PI / 2
    const n = this.dot(t) / e
    return Math.acos(zn(n, -1, 1))
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t))
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z
    return e * e + n * n + i * i
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    )
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = i * Math.cos(n)),
      this
    )
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
  }
  setFromCylindricalCoords(t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    )
  }
  setFromMatrixPosition(t) {
    const e = t.elements
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length()
    return (this.x = e), (this.y = n), (this.z = i), this
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4)
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3)
  }
  setFromEuler(t) {
    return (this.x = t._x), (this.y = t._y), (this.z = t._z), this
  }
  setFromColor(t) {
    return (this.x = t.r), (this.y = t.g), (this.z = t.b), this
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    )
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2,
      e = Math.random() * 2 - 1,
      n = Math.sqrt(1 - e * e)
    return (
      (this.x = n * Math.cos(t)), (this.y = e), (this.z = n * Math.sin(t)), this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
const U_ = new U(),
  s2 = new wa()
class Ei {
  constructor(
    t = new U(1 / 0, 1 / 0, 1 / 0),
    e = new U(-1 / 0, -1 / 0, -1 / 0),
  ) {
    ;(this.isBox3 = !0), (this.min = t), (this.max = e)
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this
  }
  setFromArray(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e += 3)
      this.expandByPoint(sa.fromArray(t, e))
    return this
  }
  setFromBufferAttribute(t) {
    this.makeEmpty()
    for (let e = 0, n = t.count; e < n; e++)
      this.expandByPoint(sa.fromBufferAttribute(t, e))
    return this
  }
  setFromPoints(t) {
    this.makeEmpty()
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e])
    return this
  }
  setFromCenterAndSize(t, e) {
    const n = sa.copy(e).multiplyScalar(0.5)
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1)
    const n = t.geometry
    if (n !== void 0) {
      const a = n.getAttribute('position')
      if (e === !0 && a !== void 0 && t.isInstancedMesh !== !0)
        for (let o = 0, s = a.count; o < s; o++)
          t.isMesh === !0
            ? t.getVertexPosition(o, sa)
            : sa.fromBufferAttribute(a, o),
            sa.applyMatrix4(t.matrixWorld),
            this.expandByPoint(sa)
      else
        t.boundingBox !== void 0
          ? (t.boundingBox === null && t.computeBoundingBox(),
            Fv.copy(t.boundingBox))
          : (n.boundingBox === null && n.computeBoundingBox(),
            Fv.copy(n.boundingBox)),
          Fv.applyMatrix4(t.matrixWorld),
          this.union(Fv)
    }
    const i = t.children
    for (let a = 0, o = i.length; a < o; a++) this.expandByObject(i[a], e)
    return this
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    )
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    )
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z),
    )
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    )
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, sa),
      sa.distanceToSquared(t.center) <= t.radius * t.radius
    )
  }
  intersectsPlane(t) {
    let e, n
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    )
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1
    this.getCenter(kf),
      zv.subVectors(this.max, kf),
      vc.subVectors(t.a, kf),
      gc.subVectors(t.b, kf),
      mc.subVectors(t.c, kf),
      us.subVectors(gc, vc),
      cs.subVectors(mc, gc),
      xl.subVectors(vc, mc)
    let e = [
      0,
      -us.z,
      us.y,
      0,
      -cs.z,
      cs.y,
      0,
      -xl.z,
      xl.y,
      us.z,
      0,
      -us.x,
      cs.z,
      0,
      -cs.x,
      xl.z,
      0,
      -xl.x,
      -us.y,
      us.x,
      0,
      -cs.y,
      cs.x,
      0,
      -xl.y,
      xl.x,
      0,
    ]
    return !V_(e, vc, gc, mc, zv) ||
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !V_(e, vc, gc, mc, zv))
      ? !1
      : (Uv.crossVectors(us, cs),
        (e = [Uv.x, Uv.y, Uv.z]),
        V_(e, vc, gc, mc, zv))
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max)
  }
  distanceToPoint(t) {
    return this.clampPoint(t, sa).distanceTo(t)
  }
  getBoundingSphere(t) {
    return (
      this.isEmpty()
        ? t.makeEmpty()
        : (this.getCenter(t.center),
          (t.radius = this.getSize(sa).length() * 0.5)),
      t
    )
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this
  }
  applyMatrix4(t) {
    return this.isEmpty()
      ? this
      : (Ao[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        Ao[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        Ao[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        Ao[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        Ao[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        Ao[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        Ao[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        Ao[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(Ao),
        this)
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max)
  }
}
const Ao = [
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
    new U(),
  ],
  sa = new U(),
  Fv = new Ei(),
  vc = new U(),
  gc = new U(),
  mc = new U(),
  us = new U(),
  cs = new U(),
  xl = new U(),
  kf = new U(),
  zv = new U(),
  Uv = new U(),
  Sl = new U()
function V_(r, t, e, n, i) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    Sl.fromArray(r, a)
    const s =
        i.x * Math.abs(Sl.x) + i.y * Math.abs(Sl.y) + i.z * Math.abs(Sl.z),
      l = t.dot(Sl),
      u = e.dot(Sl),
      c = n.dot(Sl)
    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s) return !1
  }
  return !0
}
const U6 = new Ei(),
  Bf = new U(),
  G_ = new U()
class na {
  constructor(t = new U(), e = -1) {
    ;(this.isSphere = !0), (this.center = t), (this.radius = e)
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this
  }
  setFromPoints(t, e) {
    const n = this.center
    e !== void 0 ? n.copy(e) : U6.setFromPoints(t).getCenter(n)
    let i = 0
    for (let a = 0, o = t.length; a < o; a++)
      i = Math.max(i, n.distanceToSquared(t[a]))
    return (this.radius = Math.sqrt(i)), this
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius
    return t.center.distanceToSquared(this.center) <= e * e
  }
  intersectsBox(t) {
    return t.intersectsSphere(this)
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t)
    return (
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    )
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    )
  }
  translate(t) {
    return this.center.add(t), this
  }
  expandByPoint(t) {
    if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this
    Bf.subVectors(t, this.center)
    const e = Bf.lengthSq()
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e),
        i = (n - this.radius) * 0.5
      this.center.addScaledVector(Bf, i / n), (this.radius += i)
    }
    return this
  }
  union(t) {
    return t.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(t), this)
      : (this.center.equals(t.center) === !0
          ? (this.radius = Math.max(this.radius, t.radius))
          : (G_.subVectors(t.center, this.center).setLength(t.radius),
            this.expandByPoint(Bf.copy(t.center).add(G_)),
            this.expandByPoint(Bf.copy(t.center).sub(G_))),
        this)
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const bo = new U(),
  H_ = new U(),
  Vv = new U(),
  hs = new U(),
  W_ = new U(),
  Gv = new U(),
  X_ = new U()
class hf {
  constructor(t = new U(), e = new U(0, 0, -1)) {
    ;(this.origin = t), (this.direction = e)
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t)
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this
  }
  recast(t) {
    return this.origin.copy(this.at(t, bo)), this
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin)
    const n = e.dot(this.direction)
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.origin).addScaledVector(this.direction, n)
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t))
  }
  distanceSqToPoint(t) {
    const e = bo.subVectors(t, this.origin).dot(this.direction)
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (bo.copy(this.origin).addScaledVector(this.direction, e),
        bo.distanceToSquared(t))
  }
  distanceSqToSegment(t, e, n, i) {
    H_.copy(t).add(e).multiplyScalar(0.5),
      Vv.copy(e).sub(t).normalize(),
      hs.copy(this.origin).sub(H_)
    const a = t.distanceTo(e) * 0.5,
      o = -this.direction.dot(Vv),
      s = hs.dot(this.direction),
      l = -hs.dot(Vv),
      u = hs.lengthSq(),
      c = Math.abs(1 - o * o)
    let h, f, d, p
    if (c > 0)
      if (((h = o * l - s), (f = o * s - l), (p = a * c), h >= 0))
        if (f >= -p)
          if (f <= p) {
            const g = 1 / c
            ;(h *= g),
              (f *= g),
              (d = h * (h + o * f + 2 * s) + f * (o * h + f + 2 * l) + u)
          } else
            (f = a),
              (h = Math.max(0, -(o * f + s))),
              (d = -h * h + f * (f + 2 * l) + u)
        else
          (f = -a),
            (h = Math.max(0, -(o * f + s))),
            (d = -h * h + f * (f + 2 * l) + u)
      else
        f <= -p
          ? ((h = Math.max(0, -(-o * a + s))),
            (f = h > 0 ? -a : Math.min(Math.max(-a, -l), a)),
            (d = -h * h + f * (f + 2 * l) + u))
          : f <= p
          ? ((h = 0),
            (f = Math.min(Math.max(-a, -l), a)),
            (d = f * (f + 2 * l) + u))
          : ((h = Math.max(0, -(o * a + s))),
            (f = h > 0 ? a : Math.min(Math.max(-a, -l), a)),
            (d = -h * h + f * (f + 2 * l) + u))
    else
      (f = o > 0 ? -a : a),
        (h = Math.max(0, -(o * f + s))),
        (d = -h * h + f * (f + 2 * l) + u)
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, h),
      i && i.copy(H_).addScaledVector(Vv, f),
      d
    )
  }
  intersectSphere(t, e) {
    bo.subVectors(t.center, this.origin)
    const n = bo.dot(this.direction),
      i = bo.dot(bo) - n * n,
      a = t.radius * t.radius
    if (i > a) return null
    const o = Math.sqrt(a - i),
      s = n - o,
      l = n + o
    return l < 0 ? null : s < 0 ? this.at(l, e) : this.at(s, e)
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction)
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null
    const n = -(this.origin.dot(t.normal) + t.constant) / e
    return n >= 0 ? n : null
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t)
    return n === null ? null : this.at(n, e)
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin)
    return e === 0 || t.normal.dot(this.direction) * e < 0
  }
  intersectBox(t, e) {
    let n, i, a, o, s, l
    const u = 1 / this.direction.x,
      c = 1 / this.direction.y,
      h = 1 / this.direction.z,
      f = this.origin
    return (
      u >= 0
        ? ((n = (t.min.x - f.x) * u), (i = (t.max.x - f.x) * u))
        : ((n = (t.max.x - f.x) * u), (i = (t.min.x - f.x) * u)),
      c >= 0
        ? ((a = (t.min.y - f.y) * c), (o = (t.max.y - f.y) * c))
        : ((a = (t.max.y - f.y) * c), (o = (t.min.y - f.y) * c)),
      n > o ||
      a > i ||
      ((a > n || isNaN(n)) && (n = a),
      (o < i || isNaN(i)) && (i = o),
      h >= 0
        ? ((s = (t.min.z - f.z) * h), (l = (t.max.z - f.z) * h))
        : ((s = (t.max.z - f.z) * h), (l = (t.min.z - f.z) * h)),
      n > l || s > i) ||
      ((s > n || n !== n) && (n = s), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, e)
    )
  }
  intersectsBox(t) {
    return this.intersectBox(t, bo) !== null
  }
  intersectTriangle(t, e, n, i, a) {
    W_.subVectors(e, t), Gv.subVectors(n, t), X_.crossVectors(W_, Gv)
    let o = this.direction.dot(X_),
      s
    if (o > 0) {
      if (i) return null
      s = 1
    } else if (o < 0) (s = -1), (o = -o)
    else return null
    hs.subVectors(this.origin, t)
    const l = s * this.direction.dot(Gv.crossVectors(hs, Gv))
    if (l < 0) return null
    const u = s * this.direction.dot(W_.cross(hs))
    if (u < 0 || l + u > o) return null
    const c = -s * hs.dot(X_)
    return c < 0 ? null : this.at(c / o, a)
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    )
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class ae {
  constructor(t, e, n, i, a, o, s, l, u, c, h, f, d, p, g, v) {
    ;(ae.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      t !== void 0 && this.set(t, e, n, i, a, o, s, l, u, c, h, f, d, p, g, v)
  }
  set(t, e, n, i, a, o, s, l, u, c, h, f, d, p, g, v) {
    const m = this.elements
    return (
      (m[0] = t),
      (m[4] = e),
      (m[8] = n),
      (m[12] = i),
      (m[1] = a),
      (m[5] = o),
      (m[9] = s),
      (m[13] = l),
      (m[2] = u),
      (m[6] = c),
      (m[10] = h),
      (m[14] = f),
      (m[3] = d),
      (m[7] = p),
      (m[11] = g),
      (m[15] = v),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new ae().fromArray(this.elements)
  }
  copy(t) {
    const e = this.elements,
      n = t.elements
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    )
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
  }
  setFromMatrix3(t) {
    const e = t.elements
    return (
      this.set(
        e[0],
        e[3],
        e[6],
        0,
        e[1],
        e[4],
        e[7],
        0,
        e[2],
        e[5],
        e[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / yc.setFromMatrixColumn(t, 0).length(),
      a = 1 / yc.setFromMatrixColumn(t, 1).length(),
      o = 1 / yc.setFromMatrixColumn(t, 2).length()
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * a),
      (e[5] = n[5] * a),
      (e[6] = n[6] * a),
      (e[7] = 0),
      (e[8] = n[8] * o),
      (e[9] = n[9] * o),
      (e[10] = n[10] * o),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    )
  }
  makeRotationFromEuler(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      a = t.z,
      o = Math.cos(n),
      s = Math.sin(n),
      l = Math.cos(i),
      u = Math.sin(i),
      c = Math.cos(a),
      h = Math.sin(a)
    if (t.order === 'XYZ') {
      const f = o * c,
        d = o * h,
        p = s * c,
        g = s * h
      ;(e[0] = l * c),
        (e[4] = -l * h),
        (e[8] = u),
        (e[1] = d + p * u),
        (e[5] = f - g * u),
        (e[9] = -s * l),
        (e[2] = g - f * u),
        (e[6] = p + d * u),
        (e[10] = o * l)
    } else if (t.order === 'YXZ') {
      const f = l * c,
        d = l * h,
        p = u * c,
        g = u * h
      ;(e[0] = f + g * s),
        (e[4] = p * s - d),
        (e[8] = o * u),
        (e[1] = o * h),
        (e[5] = o * c),
        (e[9] = -s),
        (e[2] = d * s - p),
        (e[6] = g + f * s),
        (e[10] = o * l)
    } else if (t.order === 'ZXY') {
      const f = l * c,
        d = l * h,
        p = u * c,
        g = u * h
      ;(e[0] = f - g * s),
        (e[4] = -o * h),
        (e[8] = p + d * s),
        (e[1] = d + p * s),
        (e[5] = o * c),
        (e[9] = g - f * s),
        (e[2] = -o * u),
        (e[6] = s),
        (e[10] = o * l)
    } else if (t.order === 'ZYX') {
      const f = o * c,
        d = o * h,
        p = s * c,
        g = s * h
      ;(e[0] = l * c),
        (e[4] = p * u - d),
        (e[8] = f * u + g),
        (e[1] = l * h),
        (e[5] = g * u + f),
        (e[9] = d * u - p),
        (e[2] = -u),
        (e[6] = s * l),
        (e[10] = o * l)
    } else if (t.order === 'YZX') {
      const f = o * l,
        d = o * u,
        p = s * l,
        g = s * u
      ;(e[0] = l * c),
        (e[4] = g - f * h),
        (e[8] = p * h + d),
        (e[1] = h),
        (e[5] = o * c),
        (e[9] = -s * c),
        (e[2] = -u * c),
        (e[6] = d * h + p),
        (e[10] = f - g * h)
    } else if (t.order === 'XZY') {
      const f = o * l,
        d = o * u,
        p = s * l,
        g = s * u
      ;(e[0] = l * c),
        (e[4] = -h),
        (e[8] = u * c),
        (e[1] = f * h + g),
        (e[5] = o * c),
        (e[9] = d * h - p),
        (e[2] = p * h - d),
        (e[6] = s * c),
        (e[10] = g * h + f)
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(t) {
    return this.compose(V6, t, G6)
  }
  lookAt(t, e, n) {
    const i = this.elements
    return (
      hi.subVectors(t, e),
      hi.lengthSq() === 0 && (hi.z = 1),
      hi.normalize(),
      fs.crossVectors(n, hi),
      fs.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (hi.x += 1e-4) : (hi.z += 1e-4),
        hi.normalize(),
        fs.crossVectors(n, hi)),
      fs.normalize(),
      Hv.crossVectors(hi, fs),
      (i[0] = fs.x),
      (i[4] = Hv.x),
      (i[8] = hi.x),
      (i[1] = fs.y),
      (i[5] = Hv.y),
      (i[9] = hi.y),
      (i[2] = fs.z),
      (i[6] = Hv.z),
      (i[10] = hi.z),
      this
    )
  }
  multiply(t) {
    return this.multiplyMatrices(this, t)
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this)
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      a = this.elements,
      o = n[0],
      s = n[4],
      l = n[8],
      u = n[12],
      c = n[1],
      h = n[5],
      f = n[9],
      d = n[13],
      p = n[2],
      g = n[6],
      v = n[10],
      m = n[14],
      y = n[3],
      _ = n[7],
      x = n[11],
      A = n[15],
      S = i[0],
      b = i[4],
      T = i[8],
      w = i[12],
      M = i[1],
      C = i[5],
      E = i[9],
      D = i[13],
      P = i[2],
      L = i[6],
      I = i[10],
      F = i[14],
      k = i[3],
      V = i[7],
      H = i[11],
      Y = i[15]
    return (
      (a[0] = o * S + s * M + l * P + u * k),
      (a[4] = o * b + s * C + l * L + u * V),
      (a[8] = o * T + s * E + l * I + u * H),
      (a[12] = o * w + s * D + l * F + u * Y),
      (a[1] = c * S + h * M + f * P + d * k),
      (a[5] = c * b + h * C + f * L + d * V),
      (a[9] = c * T + h * E + f * I + d * H),
      (a[13] = c * w + h * D + f * F + d * Y),
      (a[2] = p * S + g * M + v * P + m * k),
      (a[6] = p * b + g * C + v * L + m * V),
      (a[10] = p * T + g * E + v * I + m * H),
      (a[14] = p * w + g * D + v * F + m * Y),
      (a[3] = y * S + _ * M + x * P + A * k),
      (a[7] = y * b + _ * C + x * L + A * V),
      (a[11] = y * T + _ * E + x * I + A * H),
      (a[15] = y * w + _ * D + x * F + A * Y),
      this
    )
  }
  multiplyScalar(t) {
    const e = this.elements
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    )
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      a = t[12],
      o = t[1],
      s = t[5],
      l = t[9],
      u = t[13],
      c = t[2],
      h = t[6],
      f = t[10],
      d = t[14],
      p = t[3],
      g = t[7],
      v = t[11],
      m = t[15]
    return (
      p *
        (+a * l * h -
          i * u * h -
          a * s * f +
          n * u * f +
          i * s * d -
          n * l * d) +
      g *
        (+e * l * d -
          e * u * f +
          a * o * f -
          i * o * d +
          i * u * c -
          a * l * c) +
      v *
        (+e * u * h -
          e * s * d -
          a * o * h +
          n * o * d +
          a * s * c -
          n * u * c) +
      m *
        (-i * s * c - e * l * h + e * s * f + i * o * h - n * o * f + n * l * c)
    )
  }
  transpose() {
    const t = this.elements
    let e
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    )
  }
  setPosition(t, e, n) {
    const i = this.elements
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    )
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      a = t[3],
      o = t[4],
      s = t[5],
      l = t[6],
      u = t[7],
      c = t[8],
      h = t[9],
      f = t[10],
      d = t[11],
      p = t[12],
      g = t[13],
      v = t[14],
      m = t[15],
      y = h * v * u - g * f * u + g * l * d - s * v * d - h * l * m + s * f * m,
      _ = p * f * u - c * v * u - p * l * d + o * v * d + c * l * m - o * f * m,
      x = c * g * u - p * h * u + p * s * d - o * g * d - c * s * m + o * h * m,
      A = p * h * l - c * g * l - p * s * f + o * g * f + c * s * v - o * h * v,
      S = e * y + n * _ + i * x + a * A
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const b = 1 / S
    return (
      (t[0] = y * b),
      (t[1] =
        (g * f * a -
          h * v * a -
          g * i * d +
          n * v * d +
          h * i * m -
          n * f * m) *
        b),
      (t[2] =
        (s * v * a -
          g * l * a +
          g * i * u -
          n * v * u -
          s * i * m +
          n * l * m) *
        b),
      (t[3] =
        (h * l * a -
          s * f * a -
          h * i * u +
          n * f * u +
          s * i * d -
          n * l * d) *
        b),
      (t[4] = _ * b),
      (t[5] =
        (c * v * a -
          p * f * a +
          p * i * d -
          e * v * d -
          c * i * m +
          e * f * m) *
        b),
      (t[6] =
        (p * l * a -
          o * v * a -
          p * i * u +
          e * v * u +
          o * i * m -
          e * l * m) *
        b),
      (t[7] =
        (o * f * a -
          c * l * a +
          c * i * u -
          e * f * u -
          o * i * d +
          e * l * d) *
        b),
      (t[8] = x * b),
      (t[9] =
        (p * h * a -
          c * g * a -
          p * n * d +
          e * g * d +
          c * n * m -
          e * h * m) *
        b),
      (t[10] =
        (o * g * a -
          p * s * a +
          p * n * u -
          e * g * u -
          o * n * m +
          e * s * m) *
        b),
      (t[11] =
        (c * s * a -
          o * h * a -
          c * n * u +
          e * h * u +
          o * n * d -
          e * s * d) *
        b),
      (t[12] = A * b),
      (t[13] =
        (c * g * i -
          p * h * i +
          p * n * f -
          e * g * f -
          c * n * v +
          e * h * v) *
        b),
      (t[14] =
        (p * s * i -
          o * g * i -
          p * n * l +
          e * g * l +
          o * n * v -
          e * s * v) *
        b),
      (t[15] =
        (o * h * i -
          c * s * i +
          c * n * l -
          e * h * l -
          o * n * f +
          e * s * f) *
        b),
      this
    )
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      a = t.z
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= a),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= a),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= a),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= a),
      this
    )
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
    return Math.sqrt(Math.max(e, n, i))
  }
  makeTranslation(t, e, n) {
    return (
      t.isVector3
        ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
      this
    )
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t)
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      a = 1 - n,
      o = t.x,
      s = t.y,
      l = t.z,
      u = a * o,
      c = a * s
    return (
      this.set(
        u * o + n,
        u * s - i * l,
        u * l + i * s,
        0,
        u * s + i * l,
        c * s + n,
        c * l - i * o,
        0,
        u * l - i * s,
        c * l + i * o,
        a * l * l + n,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    )
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
  }
  makeShear(t, e, n, i, a, o) {
    return this.set(1, n, a, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this
  }
  compose(t, e, n) {
    const i = this.elements,
      a = e._x,
      o = e._y,
      s = e._z,
      l = e._w,
      u = a + a,
      c = o + o,
      h = s + s,
      f = a * u,
      d = a * c,
      p = a * h,
      g = o * c,
      v = o * h,
      m = s * h,
      y = l * u,
      _ = l * c,
      x = l * h,
      A = n.x,
      S = n.y,
      b = n.z
    return (
      (i[0] = (1 - (g + m)) * A),
      (i[1] = (d + x) * A),
      (i[2] = (p - _) * A),
      (i[3] = 0),
      (i[4] = (d - x) * S),
      (i[5] = (1 - (f + m)) * S),
      (i[6] = (v + y) * S),
      (i[7] = 0),
      (i[8] = (p + _) * b),
      (i[9] = (v - y) * b),
      (i[10] = (1 - (f + g)) * b),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    )
  }
  decompose(t, e, n) {
    const i = this.elements
    let a = yc.set(i[0], i[1], i[2]).length()
    const o = yc.set(i[4], i[5], i[6]).length(),
      s = yc.set(i[8], i[9], i[10]).length()
    this.determinant() < 0 && (a = -a),
      (t.x = i[12]),
      (t.y = i[13]),
      (t.z = i[14]),
      la.copy(this)
    const u = 1 / a,
      c = 1 / o,
      h = 1 / s
    return (
      (la.elements[0] *= u),
      (la.elements[1] *= u),
      (la.elements[2] *= u),
      (la.elements[4] *= c),
      (la.elements[5] *= c),
      (la.elements[6] *= c),
      (la.elements[8] *= h),
      (la.elements[9] *= h),
      (la.elements[10] *= h),
      e.setFromRotationMatrix(la),
      (n.x = a),
      (n.y = o),
      (n.z = s),
      this
    )
  }
  makePerspective(t, e, n, i, a, o, s = zo) {
    const l = this.elements,
      u = (2 * a) / (e - t),
      c = (2 * a) / (n - i),
      h = (e + t) / (e - t),
      f = (n + i) / (n - i)
    let d, p
    if (s === zo) (d = -(o + a) / (o - a)), (p = (-2 * o * a) / (o - a))
    else if (s === yy) (d = -o / (o - a)), (p = (-o * a) / (o - a))
    else
      throw new Error(
        'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + s,
      )
    return (
      (l[0] = u),
      (l[4] = 0),
      (l[8] = h),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = c),
      (l[9] = f),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = d),
      (l[14] = p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    )
  }
  makeOrthographic(t, e, n, i, a, o, s = zo) {
    const l = this.elements,
      u = 1 / (e - t),
      c = 1 / (n - i),
      h = 1 / (o - a),
      f = (e + t) * u,
      d = (n + i) * c
    let p, g
    if (s === zo) (p = (o + a) * h), (g = -2 * h)
    else if (s === yy) (p = a * h), (g = -1 * h)
    else
      throw new Error(
        'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + s,
      )
    return (
      (l[0] = 2 * u),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -f),
      (l[1] = 0),
      (l[5] = 2 * c),
      (l[9] = 0),
      (l[13] = -d),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = -p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    )
  }
  equals(t) {
    const e = this.elements,
      n = t.elements
    for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1
    return !0
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e]
    return this
  }
  toArray(t = [], e = 0) {
    const n = this.elements
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    )
  }
}
const yc = new U(),
  la = new ae(),
  V6 = new U(0, 0, 0),
  G6 = new U(1, 1, 1),
  fs = new U(),
  Hv = new U(),
  hi = new U(),
  l2 = new ae(),
  u2 = new wa()
class Ma {
  constructor(t = 0, e = 0, n = 0, i = Ma.DEFAULT_ORDER) {
    ;(this.isEuler = !0),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i)
  }
  get x() {
    return this._x
  }
  set x(t) {
    ;(this._x = t), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(t) {
    ;(this._y = t), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(t) {
    ;(this._z = t), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(t) {
    ;(this._order = t), this._onChangeCallback()
  }
  set(t, e, n, i = this._order) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements,
      a = i[0],
      o = i[4],
      s = i[8],
      l = i[1],
      u = i[5],
      c = i[9],
      h = i[2],
      f = i[6],
      d = i[10]
    switch (e) {
      case 'XYZ':
        ;(this._y = Math.asin(zn(s, -1, 1))),
          Math.abs(s) < 0.9999999
            ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-o, a)))
            : ((this._x = Math.atan2(f, u)), (this._z = 0))
        break
      case 'YXZ':
        ;(this._x = Math.asin(-zn(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(l, u)))
            : ((this._y = Math.atan2(-h, a)), (this._z = 0))
        break
      case 'ZXY':
        ;(this._x = Math.asin(zn(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-o, u)))
            : ((this._y = 0), (this._z = Math.atan2(l, a)))
        break
      case 'ZYX':
        ;(this._y = Math.asin(-zn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(f, d)), (this._z = Math.atan2(l, a)))
            : ((this._x = 0), (this._z = Math.atan2(-o, u)))
        break
      case 'YZX':
        ;(this._z = Math.asin(zn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-c, u)), (this._y = Math.atan2(-h, a)))
            : ((this._x = 0), (this._y = Math.atan2(s, d)))
        break
      case 'XZY':
        ;(this._z = Math.asin(-zn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(f, u)), (this._y = Math.atan2(s, a)))
            : ((this._x = Math.atan2(-c, d)), (this._y = 0))
        break
      default:
        console.warn(
          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
            e,
        )
    }
    return (this._order = e), n === !0 && this._onChangeCallback(), this
  }
  setFromQuaternion(t, e, n) {
    return (
      l2.makeRotationFromQuaternion(t), this.setFromRotationMatrix(l2, e, n)
    )
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e)
  }
  reorder(t) {
    return u2.setFromEuler(this), this.setFromQuaternion(u2, t)
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    )
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      t[3] !== void 0 && (this._order = t[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    )
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order
  }
}
Ma.DEFAULT_ORDER = 'XYZ'
class NM {
  constructor() {
    this.mask = 1
  }
  set(t) {
    this.mask = ((1 << t) | 0) >>> 0
  }
  enable(t) {
    this.mask |= (1 << t) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(t) {
    return (this.mask & t.mask) !== 0
  }
  isEnabled(t) {
    return (this.mask & ((1 << t) | 0)) !== 0
  }
}
let H6 = 0
const c2 = new U(),
  _c = new wa(),
  wo = new ae(),
  Wv = new U(),
  Ff = new U(),
  W6 = new U(),
  X6 = new wa(),
  h2 = new U(1, 0, 0),
  f2 = new U(0, 1, 0),
  d2 = new U(0, 0, 1),
  p2 = {
    type: 'added',
  },
  Y6 = {
    type: 'removed',
  },
  xc = {
    type: 'childadded',
    child: null,
  },
  Y_ = {
    type: 'childremoved',
    child: null,
  }
class Fe extends Ju {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, 'id', {
        value: H6++,
      }),
      (this.uuid = Ki()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = Fe.DEFAULT_UP.clone())
    const t = new U(),
      e = new Ma(),
      n = new wa(),
      i = new U(1, 1, 1)
    function a() {
      n.setFromEuler(e, !1)
    }
    function o() {
      e.setFromQuaternion(n, void 0, !1)
    }
    e._onChange(a),
      n._onChange(o),
      Object.defineProperties(this, {
        position: {
          configurable: !0,
          enumerable: !0,
          value: t,
        },
        rotation: {
          configurable: !0,
          enumerable: !0,
          value: e,
        },
        quaternion: {
          configurable: !0,
          enumerable: !0,
          value: n,
        },
        scale: {
          configurable: !0,
          enumerable: !0,
          value: i,
        },
        modelViewMatrix: {
          value: new ae(),
        },
        normalMatrix: {
          value: new _e(),
        },
      }),
      (this.matrix = new ae()),
      (this.matrixWorld = new ae()),
      (this.matrixAutoUpdate = Fe.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new NM()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e)
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0)
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t)
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t)
  }
  rotateOnAxis(t, e) {
    return _c.setFromAxisAngle(t, e), this.quaternion.multiply(_c), this
  }
  rotateOnWorldAxis(t, e) {
    return _c.setFromAxisAngle(t, e), this.quaternion.premultiply(_c), this
  }
  rotateX(t) {
    return this.rotateOnAxis(h2, t)
  }
  rotateY(t) {
    return this.rotateOnAxis(f2, t)
  }
  rotateZ(t) {
    return this.rotateOnAxis(d2, t)
  }
  translateOnAxis(t, e) {
    return (
      c2.copy(t).applyQuaternion(this.quaternion),
      this.position.add(c2.multiplyScalar(e)),
      this
    )
  }
  translateX(t) {
    return this.translateOnAxis(h2, t)
  }
  translateY(t) {
    return this.translateOnAxis(f2, t)
  }
  translateZ(t) {
    return this.translateOnAxis(d2, t)
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      t.applyMatrix4(wo.copy(this.matrixWorld).invert())
    )
  }
  lookAt(t, e, n) {
    t.isVector3 ? Wv.copy(t) : Wv.set(t, e, n)
    const i = this.parent
    this.updateWorldMatrix(!0, !1),
      Ff.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? wo.lookAt(Ff, Wv, this.up)
        : wo.lookAt(Wv, Ff, this.up),
      this.quaternion.setFromRotationMatrix(wo),
      i &&
        (wo.extractRotation(i.matrixWorld),
        _c.setFromRotationMatrix(wo),
        this.quaternion.premultiply(_c.invert()))
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e])
      return this
    }
    return t === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          t,
        ),
        this)
      : (t && t.isObject3D
          ? (t.removeFromParent(),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(p2),
            (xc.child = t),
            this.dispatchEvent(xc),
            (xc.child = null))
          : console.error(
              'THREE.Object3D.add: object not an instance of THREE.Object3D.',
              t,
            ),
        this)
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n])
      return this
    }
    const e = this.children.indexOf(t)
    return (
      e !== -1 &&
        ((t.parent = null),
        this.children.splice(e, 1),
        t.dispatchEvent(Y6),
        (Y_.child = t),
        this.dispatchEvent(Y_),
        (Y_.child = null)),
      this
    )
  }
  removeFromParent() {
    const t = this.parent
    return t !== null && t.remove(this), this
  }
  clear() {
    return this.remove(...this.children)
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      wo.copy(this.matrixWorld).invert(),
      t.parent !== null &&
        (t.parent.updateWorldMatrix(!0, !1), wo.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(wo),
      t.removeFromParent(),
      (t.parent = this),
      this.children.push(t),
      t.updateWorldMatrix(!1, !0),
      t.dispatchEvent(p2),
      (xc.child = t),
      this.dispatchEvent(xc),
      (xc.child = null),
      this
    )
  }
  getObjectById(t) {
    return this.getObjectByProperty('id', t)
  }
  getObjectByName(t) {
    return this.getObjectByProperty('name', t)
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(t, e)
      if (o !== void 0) return o
    }
  }
  getObjectsByProperty(t, e, n = []) {
    this[t] === e && n.push(this)
    const i = this.children
    for (let a = 0, o = i.length; a < o; a++) i[a].getObjectsByProperty(t, e, n)
    return n
  }
  getWorldPosition(t) {
    return (
      this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    )
  }
  getWorldQuaternion(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ff, t, W6), t
    )
  }
  getWorldScale(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ff, X6, t), t
    )
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1)
    const e = this.matrixWorld.elements
    return t.set(e[8], e[9], e[10]).normalize()
  }
  raycast() {}
  traverse(t) {
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
  }
  traverseVisible(t) {
    if (this.visible === !1) return
    t(this)
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
  }
  traverseAncestors(t) {
    const e = this.parent
    e !== null && (t(e), e.traverseAncestors(t))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0))
    const e = this.children
    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
  }
  updateWorldMatrix(t, e) {
    const n = this.parent
    if (
      (t === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      e === !0)
    ) {
      const i = this.children
      for (let a = 0, o = i.length; a < o; a++) i[a].updateWorldMatrix(!1, !0)
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string',
      n = {}
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.6,
        type: 'Object',
        generator: 'Object3D.toJSON',
      }))
    const i = {}
    ;(i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== '' && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = 'InstancedMesh'),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = 'BatchedMesh'),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.visibility = this._visibility),
        (i.active = this._active),
        (i.bounds = this._bounds.map(s => ({
          boxInitialized: s.boxInitialized,
          boxMin: s.box.min.toArray(),
          boxMax: s.box.max.toArray(),
          sphereInitialized: s.sphereInitialized,
          sphereRadius: s.sphere.radius,
          sphereCenter: s.sphere.center.toArray(),
        }))),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.geometryCount = this._geometryCount),
        (i.matricesTexture = this._matricesTexture.toJSON(t)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(t)),
        this.boundingSphere !== null &&
          (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray(),
          }))
    function a(s, l) {
      return s[l.uuid] === void 0 && (s[l.uuid] = l.toJSON(t)), l.uuid
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(t).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(t.geometries, this.geometry)
      const s = this.geometry.parameters
      if (s !== void 0 && s.shapes !== void 0) {
        const l = s.shapes
        if (Array.isArray(l))
          for (let u = 0, c = l.length; u < c; u++) {
            const h = l[u]
            a(t.shapes, h)
          }
        else a(t.shapes, l)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (a(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const s = []
        for (let l = 0, u = this.material.length; l < u; l++)
          s.push(a(t.materials, this.material[l]))
        i.material = s
      } else i.material = a(t.materials, this.material)
    if (this.children.length > 0) {
      i.children = []
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(t).object)
    }
    if (this.animations.length > 0) {
      i.animations = []
      for (let s = 0; s < this.animations.length; s++) {
        const l = this.animations[s]
        i.animations.push(a(t.animations, l))
      }
    }
    if (e) {
      const s = o(t.geometries),
        l = o(t.materials),
        u = o(t.textures),
        c = o(t.images),
        h = o(t.shapes),
        f = o(t.skeletons),
        d = o(t.animations),
        p = o(t.nodes)
      s.length > 0 && (n.geometries = s),
        l.length > 0 && (n.materials = l),
        u.length > 0 && (n.textures = u),
        c.length > 0 && (n.images = c),
        h.length > 0 && (n.shapes = h),
        f.length > 0 && (n.skeletons = f),
        d.length > 0 && (n.animations = d),
        p.length > 0 && (n.nodes = p)
    }
    return (n.object = i), n
    function o(s) {
      const l = []
      for (const u in s) {
        const c = s[u]
        delete c.metadata, l.push(c)
      }
      return l
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t)
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.animations = t.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      e === !0)
    )
      for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n]
        this.add(i.clone())
      }
    return this
  }
}
Fe.DEFAULT_UP = new U(0, 1, 0)
Fe.DEFAULT_MATRIX_AUTO_UPDATE = !0
Fe.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0
const ua = new U(),
  Mo = new U(),
  $_ = new U(),
  To = new U(),
  Sc = new U(),
  Ac = new U(),
  v2 = new U(),
  q_ = new U(),
  Z_ = new U(),
  K_ = new U()
let Ed = class ah {
  constructor(t = new U(), e = new U(), n = new U()) {
    ;(this.a = t), (this.b = e), (this.c = n)
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), ua.subVectors(t, e), i.cross(ua)
    const a = i.lengthSq()
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0)
  }
  static getBarycoord(t, e, n, i, a) {
    ua.subVectors(i, e), Mo.subVectors(n, e), $_.subVectors(t, e)
    const o = ua.dot(ua),
      s = ua.dot(Mo),
      l = ua.dot($_),
      u = Mo.dot(Mo),
      c = Mo.dot($_),
      h = o * u - s * s
    if (h === 0) return a.set(0, 0, 0), null
    const f = 1 / h,
      d = (u * l - s * c) * f,
      p = (o * c - s * l) * f
    return a.set(1 - d - p, p, d)
  }
  static containsPoint(t, e, n, i) {
    return this.getBarycoord(t, e, n, i, To) === null
      ? !1
      : To.x >= 0 && To.y >= 0 && To.x + To.y <= 1
  }
  static getInterpolation(t, e, n, i, a, o, s, l) {
    return this.getBarycoord(t, e, n, i, To) === null
      ? ((l.x = 0),
        (l.y = 0),
        'z' in l && (l.z = 0),
        'w' in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(a, To.x),
        l.addScaledVector(o, To.y),
        l.addScaledVector(s, To.z),
        l)
  }
  static isFrontFacing(t, e, n, i) {
    return ua.subVectors(n, e), Mo.subVectors(t, e), ua.cross(Mo).dot(i) < 0
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, n),
      this.c.fromBufferAttribute(t, i),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
  }
  getArea() {
    return (
      ua.subVectors(this.c, this.b),
      Mo.subVectors(this.a, this.b),
      ua.cross(Mo).length() * 0.5
    )
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(t) {
    return ah.getNormal(this.a, this.b, this.c, t)
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(t, e) {
    return ah.getBarycoord(t, this.a, this.b, this.c, e)
  }
  getInterpolation(t, e, n, i, a) {
    return ah.getInterpolation(t, this.a, this.b, this.c, e, n, i, a)
  }
  containsPoint(t) {
    return ah.containsPoint(t, this.a, this.b, this.c)
  }
  isFrontFacing(t) {
    return ah.isFrontFacing(this.a, this.b, this.c, t)
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this)
  }
  closestPointToPoint(t, e) {
    const n = this.a,
      i = this.b,
      a = this.c
    let o, s
    Sc.subVectors(i, n), Ac.subVectors(a, n), q_.subVectors(t, n)
    const l = Sc.dot(q_),
      u = Ac.dot(q_)
    if (l <= 0 && u <= 0) return e.copy(n)
    Z_.subVectors(t, i)
    const c = Sc.dot(Z_),
      h = Ac.dot(Z_)
    if (c >= 0 && h <= c) return e.copy(i)
    const f = l * h - c * u
    if (f <= 0 && l >= 0 && c <= 0)
      return (o = l / (l - c)), e.copy(n).addScaledVector(Sc, o)
    K_.subVectors(t, a)
    const d = Sc.dot(K_),
      p = Ac.dot(K_)
    if (p >= 0 && d <= p) return e.copy(a)
    const g = d * u - l * p
    if (g <= 0 && u >= 0 && p <= 0)
      return (s = u / (u - p)), e.copy(n).addScaledVector(Ac, s)
    const v = c * p - d * h
    if (v <= 0 && h - c >= 0 && d - p >= 0)
      return (
        v2.subVectors(a, i),
        (s = (h - c) / (h - c + (d - p))),
        e.copy(i).addScaledVector(v2, s)
      )
    const m = 1 / (v + g + f)
    return (
      (o = g * m),
      (s = f * m),
      e.copy(n).addScaledVector(Sc, o).addScaledVector(Ac, s)
    )
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
  }
}
const Jk = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  ds = {
    h: 0,
    s: 0,
    l: 0,
  },
  Xv = {
    h: 0,
    s: 0,
    l: 0,
  }
function j_(r, t, e) {
  return (
    e < 0 && (e += 1),
    e > 1 && (e -= 1),
    e < 1 / 6
      ? r + (t - r) * 6 * e
      : e < 1 / 2
      ? t
      : e < 2 / 3
      ? r + (t - r) * 6 * (2 / 3 - e)
      : r
  )
}
class qt {
  constructor(t, e, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(t, e, n)
    )
  }
  set(t, e, n) {
    if (e === void 0 && n === void 0) {
      const i = t
      i && i.isColor
        ? this.copy(i)
        : typeof i == 'number'
        ? this.setHex(i)
        : typeof i == 'string' && this.setStyle(i)
    } else this.setRGB(t, e, n)
    return this
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this
  }
  setHex(t, e = cn) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (t & 255) / 255),
      Be.toWorkingColorSpace(this, e),
      this
    )
  }
  setRGB(t, e, n, i = Be.workingColorSpace) {
    return (
      (this.r = t),
      (this.g = e),
      (this.b = n),
      Be.toWorkingColorSpace(this, i),
      this
    )
  }
  setHSL(t, e, n, i = Be.workingColorSpace) {
    if (((t = RM(t, 1)), (e = zn(e, 0, 1)), (n = zn(n, 0, 1)), e === 0))
      this.r = this.g = this.b = n
    else {
      const a = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        o = 2 * n - a
      ;(this.r = j_(o, a, t + 1 / 3)),
        (this.g = j_(o, a, t)),
        (this.b = j_(o, a, t - 1 / 3))
    }
    return Be.toWorkingColorSpace(this, i), this
  }
  setStyle(t, e = cn) {
    function n(a) {
      a !== void 0 &&
        parseFloat(a) < 1 &&
        console.warn(
          'THREE.Color: Alpha component of ' + t + ' will be ignored.',
        )
    }
    let i
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
      let a
      const o = i[1],
        s = i[2]
      switch (o) {
        case 'rgb':
        case 'rgba':
          if (
            (a =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s,
              ))
          )
            return (
              n(a[4]),
              this.setRGB(
                Math.min(255, parseInt(a[1], 10)) / 255,
                Math.min(255, parseInt(a[2], 10)) / 255,
                Math.min(255, parseInt(a[3], 10)) / 255,
                e,
              )
            )
          if (
            (a =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s,
              ))
          )
            return (
              n(a[4]),
              this.setRGB(
                Math.min(100, parseInt(a[1], 10)) / 100,
                Math.min(100, parseInt(a[2], 10)) / 100,
                Math.min(100, parseInt(a[3], 10)) / 100,
                e,
              )
            )
          break
        case 'hsl':
        case 'hsla':
          if (
            (a =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                s,
              ))
          )
            return (
              n(a[4]),
              this.setHSL(
                parseFloat(a[1]) / 360,
                parseFloat(a[2]) / 100,
                parseFloat(a[3]) / 100,
                e,
              )
            )
          break
        default:
          console.warn('THREE.Color: Unknown color model ' + t)
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const a = i[1],
        o = a.length
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          e,
        )
      if (o === 6) return this.setHex(parseInt(a, 16), e)
      console.warn('THREE.Color: Invalid hex color ' + t)
    } else if (t && t.length > 0) return this.setColorName(t, e)
    return this
  }
  setColorName(t, e = cn) {
    const n = Jk[t.toLowerCase()]
    return (
      n !== void 0
        ? this.setHex(n, e)
        : console.warn('THREE.Color: Unknown color ' + t),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
  }
  copySRGBToLinear(t) {
    return (this.r = Mh(t.r)), (this.g = Mh(t.g)), (this.b = Mh(t.b)), this
  }
  copyLinearToSRGB(t) {
    return (this.r = F_(t.r)), (this.g = F_(t.g)), (this.b = F_(t.b)), this
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex(t = cn) {
    return (
      Be.fromWorkingColorSpace(xr.copy(this), t),
      Math.round(zn(xr.r * 255, 0, 255)) * 65536 +
        Math.round(zn(xr.g * 255, 0, 255)) * 256 +
        Math.round(zn(xr.b * 255, 0, 255))
    )
  }
  getHexString(t = cn) {
    return ('000000' + this.getHex(t).toString(16)).slice(-6)
  }
  getHSL(t, e = Be.workingColorSpace) {
    Be.fromWorkingColorSpace(xr.copy(this), e)
    const n = xr.r,
      i = xr.g,
      a = xr.b,
      o = Math.max(n, i, a),
      s = Math.min(n, i, a)
    let l, u
    const c = (s + o) / 2
    if (s === o) (l = 0), (u = 0)
    else {
      const h = o - s
      switch (((u = c <= 0.5 ? h / (o + s) : h / (2 - o - s)), o)) {
        case n:
          l = (i - a) / h + (i < a ? 6 : 0)
          break
        case i:
          l = (a - n) / h + 2
          break
        case a:
          l = (n - i) / h + 4
          break
      }
      l /= 6
    }
    return (t.h = l), (t.s = u), (t.l = c), t
  }
  getRGB(t, e = Be.workingColorSpace) {
    return (
      Be.fromWorkingColorSpace(xr.copy(this), e),
      (t.r = xr.r),
      (t.g = xr.g),
      (t.b = xr.b),
      t
    )
  }
  getStyle(t = cn) {
    Be.fromWorkingColorSpace(xr.copy(this), t)
    const e = xr.r,
      n = xr.g,
      i = xr.b
    return t !== cn
      ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(
          i * 255,
        )})`
  }
  offsetHSL(t, e, n) {
    return this.getHSL(ds), this.setHSL(ds.h + t, ds.s + e, ds.l + n)
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    )
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    )
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    )
  }
  lerpColors(t, e, n) {
    return (
      (this.r = t.r + (e.r - t.r) * n),
      (this.g = t.g + (e.g - t.g) * n),
      (this.b = t.b + (e.b - t.b) * n),
      this
    )
  }
  lerpHSL(t, e) {
    this.getHSL(ds), t.getHSL(Xv)
    const n = $d(ds.h, Xv.h, e),
      i = $d(ds.s, Xv.s, e),
      a = $d(ds.l, Xv.l, e)
    return this.setHSL(n, i, a), this
  }
  setFromVector3(t) {
    return (this.r = t.x), (this.g = t.y), (this.b = t.z), this
  }
  applyMatrix3(t) {
    const e = this.r,
      n = this.g,
      i = this.b,
      a = t.elements
    return (
      (this.r = a[0] * e + a[3] * n + a[6] * i),
      (this.g = a[1] * e + a[4] * n + a[7] * i),
      (this.b = a[2] * e + a[5] * n + a[8] * i),
      this
    )
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
    )
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b
  }
}
const xr = new qt()
qt.NAMES = Jk
let $6 = 0
class ji extends Ju {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, 'id', {
        value: $6++,
      }),
      (this.uuid = Ki()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.blending = bh),
      (this.side = $o),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = vA),
      (this.blendDst = gA),
      (this.blendEquation = uu),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new qt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = dy),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = e2),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = dc),
      (this.stencilZFail = dc),
      (this.stencilZPass = dc),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t)
  }
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e]
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${e}' has value of undefined.`,
          )
          continue
        }
        const i = this[e]
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${e}' is not a property of THREE.${this.type}.`,
          )
          continue
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[e] = n)
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == 'string'
    e &&
      (t = {
        textures: {},
        images: {},
      })
    const n = {
      metadata: {
        version: 4.6,
        type: 'Material',
        generator: 'Material.toJSON',
      },
    }
    ;(n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== '' && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (n.dispersion = this.dispersion),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(t).uuid),
      this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (n.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(t).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (n.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== bh && (n.blending = this.blending),
      this.side !== $o && (n.side = this.side),
      this.vertexColors === !0 && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = !0),
      this.blendSrc !== vA && (n.blendSrc = this.blendSrc),
      this.blendDst !== gA && (n.blendDst = this.blendDst),
      this.blendEquation !== uu && (n.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (n.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (n.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
      this.depthFunc !== dy && (n.depthFunc = this.depthFunc),
      this.depthTest === !1 && (n.depthTest = this.depthTest),
      this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (n.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== e2 && (n.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (n.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== dc && (n.stencilFail = this.stencilFail),
      this.stencilZFail !== dc && (n.stencilZFail = this.stencilZFail),
      this.stencilZPass !== dc && (n.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (n.alphaHash = !0),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (n.forceSinglePass = !0),
      this.wireframe === !0 && (n.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== 'round' &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== 'round' &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = !0),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData)
    function i(a) {
      const o = []
      for (const s in a) {
        const l = a[s]
        delete l.metadata, o.push(l)
      }
      return o
    }
    if (e) {
      const a = i(t.textures),
        o = i(t.images)
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o)
    }
    return n
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.name = t.name),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      this.blendColor.copy(t.blendColor),
      (this.blendAlpha = t.blendAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite)
    const e = t.clippingPlanes
    let n = null
    if (e !== null) {
      const i = e.length
      n = new Array(i)
      for (let a = 0; a !== i; ++a) n[a] = e[a].clone()
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaHash = t.alphaHash),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.forceSinglePass = t.forceSinglePass),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({
      type: 'dispose',
    })
  }
  set needsUpdate(t) {
    t === !0 && this.version++
  }
  onBuild() {
    console.warn('Material: onBuild() has been removed.')
  }
  onBeforeRender() {
    console.warn('Material: onBeforeRender() has been removed.')
  }
}
class on extends ji {
  constructor(t) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new qt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Ma()),
      (this.combine = AM),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.fog = t.fog),
      this
    )
  }
}
const kn = new U(),
  Yv = new pt()
class ir {
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.',
      )
    ;(this.isBufferAttribute = !0),
      (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.normalized = n),
      (this.usage = YA),
      (this._updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.updateRanges = []),
      (this.gpuType = ya),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++
  }
  get updateRange() {
    return (
      OM(
        'THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.',
      ),
      this._updateRange
    )
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({
      start: t,
      count: e,
    })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      (this.gpuType = t.gpuType),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.itemSize), (n *= e.itemSize)
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[t + i] = e.array[n + i]
    return this
  }
  copyArray(t) {
    return this.array.set(t), this
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Yv.fromBufferAttribute(this, e),
          Yv.applyMatrix3(t),
          this.setXY(e, Yv.x, Yv.y)
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        kn.fromBufferAttribute(this, e),
          kn.applyMatrix3(t),
          this.setXYZ(e, kn.x, kn.y, kn.z)
    return this
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      kn.fromBufferAttribute(this, e),
        kn.applyMatrix4(t),
        this.setXYZ(e, kn.x, kn.y, kn.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      kn.fromBufferAttribute(this, e),
        kn.applyNormalMatrix(t),
        this.setXYZ(e, kn.x, kn.y, kn.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      kn.fromBufferAttribute(this, e),
        kn.transformDirection(t),
        this.setXYZ(e, kn.x, kn.y, kn.z)
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  getComponent(t, e) {
    let n = this.array[t * this.itemSize + e]
    return this.normalized && (n = ma(n, this.array)), n
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = We(n, this.array)),
      (this.array[t * this.itemSize + e] = n),
      this
    )
  }
  getX(t) {
    let e = this.array[t * this.itemSize]
    return this.normalized && (e = ma(e, this.array)), e
  }
  setX(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.array[t * this.itemSize] = e),
      this
    )
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1]
    return this.normalized && (e = ma(e, this.array)), e
  }
  setY(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.array[t * this.itemSize + 1] = e),
      this
    )
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2]
    return this.normalized && (e = ma(e, this.array)), e
  }
  setZ(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.array[t * this.itemSize + 2] = e),
      this
    )
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3]
    return this.normalized && (e = ma(e, this.array)), e
  }
  setW(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.array[t * this.itemSize + 3] = e),
      this
    )
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      this.normalized && ((e = We(e, this.array)), (n = We(n, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = We(e, this.array)),
        (n = We(n, this.array)),
        (i = We(i, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, a) {
    return (
      (t *= this.itemSize),
      this.normalized &&
        ((e = We(e, this.array)),
        (n = We(n, this.array)),
        (i = We(i, this.array)),
        (a = We(a, this.array))),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      (this.array[t + 3] = a),
      this
    )
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    }
    return (
      this.name !== '' && (t.name = this.name),
      this.usage !== YA && (t.usage = this.usage),
      t
    )
  }
}
class Qk extends ir {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n)
  }
}
class tB extends ir {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n)
  }
}
class nn extends ir {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n)
  }
}
let q6 = 0
const Li = new ae(),
  J_ = new Fe(),
  bc = new U(),
  fi = new Ei(),
  zf = new Ei(),
  jn = new U()
class Mn extends Ju {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, 'id', {
        value: q6++,
      }),
      (this.uuid = Ki()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = {
        start: 0,
        count: 1 / 0,
      }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(t) {
    return (
      Array.isArray(t)
        ? (this.index = new (Zk(t) ? tB : Qk)(t, 1))
        : (this.index = t),
      this
    )
  }
  getAttribute(t) {
    return this.attributes[t]
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0
  }
  addGroup(t, e, n = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n,
    })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(t, e) {
    ;(this.drawRange.start = t), (this.drawRange.count = e)
  }
  applyMatrix4(t) {
    const e = this.attributes.position
    e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0))
    const n = this.attributes.normal
    if (n !== void 0) {
      const a = new _e().getNormalMatrix(t)
      n.applyNormalMatrix(a), (n.needsUpdate = !0)
    }
    const i = this.attributes.tangent
    return (
      i !== void 0 && (i.transformDirection(t), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(t) {
    return Li.makeRotationFromQuaternion(t), this.applyMatrix4(Li), this
  }
  rotateX(t) {
    return Li.makeRotationX(t), this.applyMatrix4(Li), this
  }
  rotateY(t) {
    return Li.makeRotationY(t), this.applyMatrix4(Li), this
  }
  rotateZ(t) {
    return Li.makeRotationZ(t), this.applyMatrix4(Li), this
  }
  translate(t, e, n) {
    return Li.makeTranslation(t, e, n), this.applyMatrix4(Li), this
  }
  scale(t, e, n) {
    return Li.makeScale(t, e, n), this.applyMatrix4(Li), this
  }
  lookAt(t) {
    return J_.lookAt(t), J_.updateMatrix(), this.applyMatrix4(J_.matrix), this
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(bc).negate(),
      this.translate(bc.x, bc.y, bc.z),
      this
    )
  }
  setFromPoints(t) {
    const e = []
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n]
      e.push(a.x, a.y, a.z || 0)
    }
    return this.setAttribute('position', new nn(e, 3)), this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ei())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.',
        this,
      ),
        this.boundingBox.set(
          new U(-1 / 0, -1 / 0, -1 / 0),
          new U(1 / 0, 1 / 0, 1 / 0),
        )
      return
    }
    if (t !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let n = 0, i = e.length; n < i; n++) {
          const a = e[n]
          fi.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (jn.addVectors(this.boundingBox.min, fi.min),
                this.boundingBox.expandByPoint(jn),
                jn.addVectors(this.boundingBox.max, fi.max),
                this.boundingBox.expandByPoint(jn))
              : (this.boundingBox.expandByPoint(fi.min),
                this.boundingBox.expandByPoint(fi.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      )
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new na())
    const t = this.attributes.position,
      e = this.morphAttributes.position
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.',
        this,
      ),
        this.boundingSphere.set(new U(), 1 / 0)
      return
    }
    if (t) {
      const n = this.boundingSphere.center
      if ((fi.setFromBufferAttribute(t), e))
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a]
          zf.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (jn.addVectors(fi.min, zf.min),
                fi.expandByPoint(jn),
                jn.addVectors(fi.max, zf.max),
                fi.expandByPoint(jn))
              : (fi.expandByPoint(zf.min), fi.expandByPoint(zf.max))
        }
      fi.getCenter(n)
      let i = 0
      for (let a = 0, o = t.count; a < o; a++)
        jn.fromBufferAttribute(t, a), (i = Math.max(i, n.distanceToSquared(jn)))
      if (e)
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a],
            l = this.morphTargetsRelative
          for (let u = 0, c = s.count; u < c; u++)
            jn.fromBufferAttribute(s, u),
              l && (bc.fromBufferAttribute(t, u), jn.add(bc)),
              (i = Math.max(i, n.distanceToSquared(jn)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          )
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes
    if (
      t === null ||
      e.position === void 0 ||
      e.normal === void 0 ||
      e.uv === void 0
    ) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
      )
      return
    }
    const n = e.position,
      i = e.normal,
      a = e.uv
    this.hasAttribute('tangent') === !1 &&
      this.setAttribute('tangent', new ir(new Float32Array(4 * n.count), 4))
    const o = this.getAttribute('tangent'),
      s = [],
      l = []
    for (let T = 0; T < n.count; T++) (s[T] = new U()), (l[T] = new U())
    const u = new U(),
      c = new U(),
      h = new U(),
      f = new pt(),
      d = new pt(),
      p = new pt(),
      g = new U(),
      v = new U()
    function m(T, w, M) {
      u.fromBufferAttribute(n, T),
        c.fromBufferAttribute(n, w),
        h.fromBufferAttribute(n, M),
        f.fromBufferAttribute(a, T),
        d.fromBufferAttribute(a, w),
        p.fromBufferAttribute(a, M),
        c.sub(u),
        h.sub(u),
        d.sub(f),
        p.sub(f)
      const C = 1 / (d.x * p.y - p.x * d.y)
      isFinite(C) &&
        (g
          .copy(c)
          .multiplyScalar(p.y)
          .addScaledVector(h, -d.y)
          .multiplyScalar(C),
        v
          .copy(h)
          .multiplyScalar(d.x)
          .addScaledVector(c, -p.x)
          .multiplyScalar(C),
        s[T].add(g),
        s[w].add(g),
        s[M].add(g),
        l[T].add(v),
        l[w].add(v),
        l[M].add(v))
    }
    let y = this.groups
    y.length === 0 &&
      (y = [
        {
          start: 0,
          count: t.count,
        },
      ])
    for (let T = 0, w = y.length; T < w; ++T) {
      const M = y[T],
        C = M.start,
        E = M.count
      for (let D = C, P = C + E; D < P; D += 3)
        m(t.getX(D + 0), t.getX(D + 1), t.getX(D + 2))
    }
    const _ = new U(),
      x = new U(),
      A = new U(),
      S = new U()
    function b(T) {
      A.fromBufferAttribute(i, T), S.copy(A)
      const w = s[T]
      _.copy(w),
        _.sub(A.multiplyScalar(A.dot(w))).normalize(),
        x.crossVectors(S, w)
      const C = x.dot(l[T]) < 0 ? -1 : 1
      o.setXYZW(T, _.x, _.y, _.z, C)
    }
    for (let T = 0, w = y.length; T < w; ++T) {
      const M = y[T],
        C = M.start,
        E = M.count
      for (let D = C, P = C + E; D < P; D += 3)
        b(t.getX(D + 0)), b(t.getX(D + 1)), b(t.getX(D + 2))
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute('position')
    if (e !== void 0) {
      let n = this.getAttribute('normal')
      if (n === void 0)
        (n = new ir(new Float32Array(e.count * 3), 3)),
          this.setAttribute('normal', n)
      else for (let f = 0, d = n.count; f < d; f++) n.setXYZ(f, 0, 0, 0)
      const i = new U(),
        a = new U(),
        o = new U(),
        s = new U(),
        l = new U(),
        u = new U(),
        c = new U(),
        h = new U()
      if (t)
        for (let f = 0, d = t.count; f < d; f += 3) {
          const p = t.getX(f + 0),
            g = t.getX(f + 1),
            v = t.getX(f + 2)
          i.fromBufferAttribute(e, p),
            a.fromBufferAttribute(e, g),
            o.fromBufferAttribute(e, v),
            c.subVectors(o, a),
            h.subVectors(i, a),
            c.cross(h),
            s.fromBufferAttribute(n, p),
            l.fromBufferAttribute(n, g),
            u.fromBufferAttribute(n, v),
            s.add(c),
            l.add(c),
            u.add(c),
            n.setXYZ(p, s.x, s.y, s.z),
            n.setXYZ(g, l.x, l.y, l.z),
            n.setXYZ(v, u.x, u.y, u.z)
        }
      else
        for (let f = 0, d = e.count; f < d; f += 3)
          i.fromBufferAttribute(e, f + 0),
            a.fromBufferAttribute(e, f + 1),
            o.fromBufferAttribute(e, f + 2),
            c.subVectors(o, a),
            h.subVectors(i, a),
            c.cross(h),
            n.setXYZ(f + 0, c.x, c.y, c.z),
            n.setXYZ(f + 1, c.x, c.y, c.z),
            n.setXYZ(f + 2, c.x, c.y, c.z)
      this.normalizeNormals(), (n.needsUpdate = !0)
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal
    for (let e = 0, n = t.count; e < n; e++)
      jn.fromBufferAttribute(t, e),
        jn.normalize(),
        t.setXYZ(e, jn.x, jn.y, jn.z)
  }
  toNonIndexed() {
    function t(s, l) {
      const u = s.array,
        c = s.itemSize,
        h = s.normalized,
        f = new u.constructor(l.length * c)
      let d = 0,
        p = 0
      for (let g = 0, v = l.length; g < v; g++) {
        s.isInterleavedBufferAttribute
          ? (d = l[g] * s.data.stride + s.offset)
          : (d = l[g] * c)
        for (let m = 0; m < c; m++) f[p++] = u[d++]
      }
      return new ir(f, c, h)
    }
    if (this.index === null)
      return (
        console.warn(
          'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',
        ),
        this
      )
    const e = new Mn(),
      n = this.index.array,
      i = this.attributes
    for (const s in i) {
      const l = i[s],
        u = t(l, n)
      e.setAttribute(s, u)
    }
    const a = this.morphAttributes
    for (const s in a) {
      const l = [],
        u = a[s]
      for (let c = 0, h = u.length; c < h; c++) {
        const f = u[c],
          d = t(f, n)
        l.push(d)
      }
      e.morphAttributes[s] = l
    }
    e.morphTargetsRelative = this.morphTargetsRelative
    const o = this.groups
    for (let s = 0, l = o.length; s < l; s++) {
      const u = o[s]
      e.addGroup(u.start, u.count, u.materialIndex)
    }
    return e
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON',
      },
    }
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== '' && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters
      for (const u in l) l[u] !== void 0 && (t[u] = l[u])
      return t
    }
    t.data = {
      attributes: {},
    }
    const e = this.index
    e !== null &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      })
    const n = this.attributes
    for (const l in n) {
      const u = n[l]
      t.data.attributes[l] = u.toJSON(t.data)
    }
    const i = {}
    let a = !1
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l],
        c = []
      for (let h = 0, f = u.length; h < f; h++) {
        const d = u[h]
        c.push(d.toJSON(t.data))
      }
      c.length > 0 && ((i[l] = c), (a = !0))
    }
    a &&
      ((t.data.morphAttributes = i),
      (t.data.morphTargetsRelative = this.morphTargetsRelative))
    const o = this.groups
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)))
    const s = this.boundingSphere
    return (
      s !== null &&
        (t.data.boundingSphere = {
          center: s.center.toArray(),
          radius: s.radius,
        }),
      t
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const e = {}
    this.name = t.name
    const n = t.index
    n !== null && this.setIndex(n.clone(e))
    const i = t.attributes
    for (const u in i) {
      const c = i[u]
      this.setAttribute(u, c.clone(e))
    }
    const a = t.morphAttributes
    for (const u in a) {
      const c = [],
        h = a[u]
      for (let f = 0, d = h.length; f < d; f++) c.push(h[f].clone(e))
      this.morphAttributes[u] = c
    }
    this.morphTargetsRelative = t.morphTargetsRelative
    const o = t.groups
    for (let u = 0, c = o.length; u < c; u++) {
      const h = o[u]
      this.addGroup(h.start, h.count, h.materialIndex)
    }
    const s = t.boundingBox
    s !== null && (this.boundingBox = s.clone())
    const l = t.boundingSphere
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    )
  }
  dispose() {
    this.dispatchEvent({
      type: 'dispose',
    })
  }
}
const g2 = new ae(),
  Al = new hf(),
  $v = new na(),
  m2 = new U(),
  wc = new U(),
  Mc = new U(),
  Tc = new U(),
  Q_ = new U(),
  qv = new U(),
  Zv = new pt(),
  Kv = new pt(),
  jv = new pt(),
  y2 = new U(),
  _2 = new U(),
  x2 = new U(),
  Jv = new U(),
  Qv = new U()
class De extends Fe {
  constructor(t = new Mn(), e = new on()) {
    super(),
      (this.isMesh = !0),
      (this.type = 'Mesh'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      t.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary,
        )),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e)
    if (n.length > 0) {
      const i = e[n[0]]
      if (i !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = a)
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry,
      i = n.attributes.position,
      a = n.morphAttributes.position,
      o = n.morphTargetsRelative
    e.fromBufferAttribute(i, t)
    const s = this.morphTargetInfluences
    if (a && s) {
      qv.set(0, 0, 0)
      for (let l = 0, u = a.length; l < u; l++) {
        const c = s[l],
          h = a[l]
        c !== 0 &&
          (Q_.fromBufferAttribute(h, t),
          o ? qv.addScaledVector(Q_, c) : qv.addScaledVector(Q_.sub(e), c))
      }
      e.add(qv)
    }
    return e
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.material,
      a = this.matrixWorld
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      $v.copy(n.boundingSphere),
      $v.applyMatrix4(a),
      Al.copy(t.ray).recast(t.near),
      !(
        $v.containsPoint(Al.origin) === !1 &&
        (Al.intersectSphere($v, m2) === null ||
          Al.origin.distanceToSquared(m2) > (t.far - t.near) ** 2)
      ) &&
        (g2.copy(a).invert(),
        Al.copy(t.ray).applyMatrix4(g2),
        !(n.boundingBox !== null && Al.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(t, e, Al)))
  }
  _computeIntersections(t, e, n) {
    let i
    const a = this.geometry,
      o = this.material,
      s = a.index,
      l = a.attributes.position,
      u = a.attributes.uv,
      c = a.attributes.uv1,
      h = a.attributes.normal,
      f = a.groups,
      d = a.drawRange
    if (s !== null)
      if (Array.isArray(o))
        for (let p = 0, g = f.length; p < g; p++) {
          const v = f[p],
            m = o[v.materialIndex],
            y = Math.max(v.start, d.start),
            _ = Math.min(
              s.count,
              Math.min(v.start + v.count, d.start + d.count),
            )
          for (let x = y, A = _; x < A; x += 3) {
            const S = s.getX(x),
              b = s.getX(x + 1),
              T = s.getX(x + 2)
            ;(i = tg(this, m, t, n, u, c, h, S, b, T)),
              i &&
                ((i.faceIndex = Math.floor(x / 3)),
                (i.face.materialIndex = v.materialIndex),
                e.push(i))
          }
        }
      else {
        const p = Math.max(0, d.start),
          g = Math.min(s.count, d.start + d.count)
        for (let v = p, m = g; v < m; v += 3) {
          const y = s.getX(v),
            _ = s.getX(v + 1),
            x = s.getX(v + 2)
          ;(i = tg(this, o, t, n, u, c, h, y, _, x)),
            i && ((i.faceIndex = Math.floor(v / 3)), e.push(i))
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let p = 0, g = f.length; p < g; p++) {
          const v = f[p],
            m = o[v.materialIndex],
            y = Math.max(v.start, d.start),
            _ = Math.min(
              l.count,
              Math.min(v.start + v.count, d.start + d.count),
            )
          for (let x = y, A = _; x < A; x += 3) {
            const S = x,
              b = x + 1,
              T = x + 2
            ;(i = tg(this, m, t, n, u, c, h, S, b, T)),
              i &&
                ((i.faceIndex = Math.floor(x / 3)),
                (i.face.materialIndex = v.materialIndex),
                e.push(i))
          }
        }
      else {
        const p = Math.max(0, d.start),
          g = Math.min(l.count, d.start + d.count)
        for (let v = p, m = g; v < m; v += 3) {
          const y = v,
            _ = v + 1,
            x = v + 2
          ;(i = tg(this, o, t, n, u, c, h, y, _, x)),
            i && ((i.faceIndex = Math.floor(v / 3)), e.push(i))
        }
      }
  }
}
function Z6(r, t, e, n, i, a, o, s) {
  let l
  if (
    (t.side === Qr
      ? (l = n.intersectTriangle(o, a, i, !0, s))
      : (l = n.intersectTriangle(i, a, o, t.side === $o, s)),
    l === null)
  )
    return null
  Qv.copy(s), Qv.applyMatrix4(r.matrixWorld)
  const u = e.ray.origin.distanceTo(Qv)
  return u < e.near || u > e.far
    ? null
    : {
        distance: u,
        point: Qv.clone(),
        object: r,
      }
}
function tg(r, t, e, n, i, a, o, s, l, u) {
  r.getVertexPosition(s, wc),
    r.getVertexPosition(l, Mc),
    r.getVertexPosition(u, Tc)
  const c = Z6(r, t, e, n, wc, Mc, Tc, Jv)
  if (c) {
    i &&
      (Zv.fromBufferAttribute(i, s),
      Kv.fromBufferAttribute(i, l),
      jv.fromBufferAttribute(i, u),
      (c.uv = Ed.getInterpolation(Jv, wc, Mc, Tc, Zv, Kv, jv, new pt()))),
      a &&
        (Zv.fromBufferAttribute(a, s),
        Kv.fromBufferAttribute(a, l),
        jv.fromBufferAttribute(a, u),
        (c.uv1 = Ed.getInterpolation(Jv, wc, Mc, Tc, Zv, Kv, jv, new pt()))),
      o &&
        (y2.fromBufferAttribute(o, s),
        _2.fromBufferAttribute(o, l),
        x2.fromBufferAttribute(o, u),
        (c.normal = Ed.getInterpolation(Jv, wc, Mc, Tc, y2, _2, x2, new U())),
        c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1))
    const h = {
      a: s,
      b: l,
      c: u,
      normal: new U(),
      materialIndex: 0,
    }
    Ed.getNormal(wc, Mc, Tc, h.normal), (c.face = h)
  }
  return c
}
class fv extends Mn {
  constructor(t = 1, e = 1, n = 1, i = 1, a = 1, o = 1) {
    super(),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: a,
        depthSegments: o,
      })
    const s = this
    ;(i = Math.floor(i)), (a = Math.floor(a)), (o = Math.floor(o))
    const l = [],
      u = [],
      c = [],
      h = []
    let f = 0,
      d = 0
    p('z', 'y', 'x', -1, -1, n, e, t, o, a, 0),
      p('z', 'y', 'x', 1, -1, n, e, -t, o, a, 1),
      p('x', 'z', 'y', 1, 1, t, n, e, i, o, 2),
      p('x', 'z', 'y', 1, -1, t, n, -e, i, o, 3),
      p('x', 'y', 'z', 1, -1, t, e, n, i, a, 4),
      p('x', 'y', 'z', -1, -1, t, e, -n, i, a, 5),
      this.setIndex(l),
      this.setAttribute('position', new nn(u, 3)),
      this.setAttribute('normal', new nn(c, 3)),
      this.setAttribute('uv', new nn(h, 2))
    function p(g, v, m, y, _, x, A, S, b, T, w) {
      const M = x / b,
        C = A / T,
        E = x / 2,
        D = A / 2,
        P = S / 2,
        L = b + 1,
        I = T + 1
      let F = 0,
        k = 0
      const V = new U()
      for (let H = 0; H < I; H++) {
        const Y = H * C - D
        for (let K = 0; K < L; K++) {
          const ut = K * M - E
          ;(V[g] = ut * y),
            (V[v] = Y * _),
            (V[m] = P),
            u.push(V.x, V.y, V.z),
            (V[g] = 0),
            (V[v] = 0),
            (V[m] = S > 0 ? 1 : -1),
            c.push(V.x, V.y, V.z),
            h.push(K / b),
            h.push(1 - H / T),
            (F += 1)
        }
      }
      for (let H = 0; H < T; H++)
        for (let Y = 0; Y < b; Y++) {
          const K = f + Y + L * H,
            ut = f + Y + L * (H + 1),
            W = f + (Y + 1) + L * (H + 1),
            Z = f + (Y + 1) + L * H
          l.push(K, ut, Z), l.push(ut, W, Z), (k += 6)
        }
      s.addGroup(d, k, w), (d += k), (f += F)
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new fv(
      t.width,
      t.height,
      t.depth,
      t.widthSegments,
      t.heightSegments,
      t.depthSegments,
    )
  }
}
function Hh(r) {
  const t = {}
  for (const e in r) {
    t[e] = {}
    for (const n in r[e]) {
      const i = r[e][n]
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().',
            ),
            (t[e][n] = null))
          : (t[e][n] = i.clone())
        : Array.isArray(i)
        ? (t[e][n] = i.slice())
        : (t[e][n] = i)
    }
  }
  return t
}
function Ir(r) {
  const t = {}
  for (let e = 0; e < r.length; e++) {
    const n = Hh(r[e])
    for (const i in n) t[i] = n[i]
  }
  return t
}
function K6(r) {
  const t = []
  for (let e = 0; e < r.length; e++) t.push(r[e].clone())
  return t
}
function eB(r) {
  const t = r.getRenderTarget()
  return t === null
    ? r.outputColorSpace
    : t.isXRRenderTarget === !0
    ? t.texture.colorSpace
    : Be.workingColorSpace
}
const kM = {
  clone: Hh,
  merge: Ir,
}
var j6 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  J6 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
class lo extends ji {
  constructor(t) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = j6),
      (this.fragmentShader = J6),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        clipCullDistance: !1,
        multiDraw: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      t !== void 0 && this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = Hh(t.uniforms)),
      (this.uniformsGroups = K6(t.uniformsGroups)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.fog = t.fog),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    ;(e.glslVersion = this.glslVersion), (e.uniforms = {})
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value
      o && o.isTexture
        ? (e.uniforms[i] = {
            type: 't',
            value: o.toJSON(t).uuid,
          })
        : o && o.isColor
        ? (e.uniforms[i] = {
            type: 'c',
            value: o.getHex(),
          })
        : o && o.isVector2
        ? (e.uniforms[i] = {
            type: 'v2',
            value: o.toArray(),
          })
        : o && o.isVector3
        ? (e.uniforms[i] = {
            type: 'v3',
            value: o.toArray(),
          })
        : o && o.isVector4
        ? (e.uniforms[i] = {
            type: 'v4',
            value: o.toArray(),
          })
        : o && o.isMatrix3
        ? (e.uniforms[i] = {
            type: 'm3',
            value: o.toArray(),
          })
        : o && o.isMatrix4
        ? (e.uniforms[i] = {
            type: 'm4',
            value: o.toArray(),
          })
        : (e.uniforms[i] = {
            value: o,
          })
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader),
      (e.lights = this.lights),
      (e.clipping = this.clipping)
    const n = {}
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0)
    return Object.keys(n).length > 0 && (e.extensions = n), e
  }
}
let nB = class extends Fe {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new ae()),
      (this.projectionMatrix = new ae()),
      (this.projectionMatrixInverse = new ae()),
      (this.coordinateSystem = zo)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      (this.coordinateSystem = t.coordinateSystem),
      this
    )
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate()
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const ps = new U(),
  S2 = new pt(),
  A2 = new pt()
class wr extends nB {
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = 'PerspectiveCamera'),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    )
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t
    ;(this.fov = Gh * 2 * Math.atan(e)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const t = Math.tan(Yd * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / t
  }
  getEffectiveFOV() {
    return Gh * 2 * Math.atan(Math.tan(Yd * 0.5 * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  getViewBounds(t, e, n) {
    ps.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      e.set(ps.x, ps.y).multiplyScalar(-t / ps.z),
      ps.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(ps.x, ps.y).multiplyScalar(-t / ps.z)
  }
  getViewSize(t, e) {
    return this.getViewBounds(t, S2, A2), e.subVectors(A2, S2)
  }
  setViewOffset(t, e, n, i, a, o) {
    ;(this.aspect = t / e),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = this.near
    let e = (t * Math.tan(Yd * 0.5 * this.fov)) / this.zoom,
      n = 2 * e,
      i = this.aspect * n,
      a = -0.5 * i
    const o = this.view
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        u = o.fullHeight
      ;(a += (o.offsetX * i) / l),
        (e -= (o.offsetY * n) / u),
        (i *= o.width / l),
        (n *= o.height / u)
    }
    const s = this.filmOffset
    s !== 0 && (a += (t * s) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        a,
        a + i,
        e,
        e - n,
        t,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    )
  }
}
const Cc = -90,
  Ec = 1
class Q6 extends Fe {
  constructor(t, e, n) {
    super(),
      (this.type = 'CubeCamera'),
      (this.renderTarget = n),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0)
    const i = new wr(Cc, Ec, t, e)
    ;(i.layers = this.layers), this.add(i)
    const a = new wr(Cc, Ec, t, e)
    ;(a.layers = this.layers), this.add(a)
    const o = new wr(Cc, Ec, t, e)
    ;(o.layers = this.layers), this.add(o)
    const s = new wr(Cc, Ec, t, e)
    ;(s.layers = this.layers), this.add(s)
    const l = new wr(Cc, Ec, t, e)
    ;(l.layers = this.layers), this.add(l)
    const u = new wr(Cc, Ec, t, e)
    ;(u.layers = this.layers), this.add(u)
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem,
      e = this.children.concat(),
      [n, i, a, o, s, l] = e
    for (const u of e) this.remove(u)
    if (t === zo)
      n.up.set(0, 1, 0),
        n.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        s.up.set(0, 1, 0),
        s.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1)
    else if (t === yy)
      n.up.set(0, -1, 0),
        n.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        s.up.set(0, -1, 0),
        s.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1)
    else
      throw new Error(
        'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' +
          t,
      )
    for (const u of e) this.add(u), u.updateMatrixWorld()
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld()
    const {renderTarget: n, activeMipmapLevel: i} = this
    this.coordinateSystem !== t.coordinateSystem &&
      ((this.coordinateSystem = t.coordinateSystem),
      this.updateCoordinateSystem())
    const [a, o, s, l, u, c] = this.children,
      h = t.getRenderTarget(),
      f = t.getActiveCubeFace(),
      d = t.getActiveMipmapLevel(),
      p = t.xr.enabled
    t.xr.enabled = !1
    const g = n.texture.generateMipmaps
    ;(n.texture.generateMipmaps = !1),
      t.setRenderTarget(n, 0, i),
      t.render(e, a),
      t.setRenderTarget(n, 1, i),
      t.render(e, o),
      t.setRenderTarget(n, 2, i),
      t.render(e, s),
      t.setRenderTarget(n, 3, i),
      t.render(e, l),
      t.setRenderTarget(n, 4, i),
      t.render(e, u),
      (n.texture.generateMipmaps = g),
      t.setRenderTarget(n, 5, i),
      t.render(e, c),
      t.setRenderTarget(h, f, d),
      (t.xr.enabled = p),
      (n.texture.needsPMREMUpdate = !0)
  }
}
class rB extends Yn {
  constructor(t, e, n, i, a, o, s, l, u, c) {
    ;(t = t !== void 0 ? t : []),
      (e = e !== void 0 ? e : Fh),
      super(t, e, n, i, a, o, s, l, u, c),
      (this.isCubeTexture = !0),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(t) {
    this.image = t
  }
}
class tW extends Vu {
  constructor(t = 1, e = {}) {
    super(t, t, e), (this.isWebGLCubeRenderTarget = !0)
    const n = {
        width: t,
        height: t,
        depth: 1,
      },
      i = [n, n, n, n, n, n]
    ;(this.texture = new rB(
      i,
      e.mapping,
      e.wrapS,
      e.wrapT,
      e.magFilter,
      e.minFilter,
      e.format,
      e.type,
      e.anisotropy,
      e.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        e.generateMipmaps !== void 0 ? e.generateMipmaps : !1),
      (this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : gi)
  }
  fromEquirectangularTexture(t, e) {
    ;(this.texture.type = e.type),
      (this.texture.colorSpace = e.colorSpace),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter)
    const n = {
        uniforms: {
          tEquirect: {
            value: null,
          },
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new fv(5, 5, 5),
      a = new lo({
        name: 'CubemapFromEquirect',
        uniforms: Hh(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: Qr,
        blending: Xs,
      })
    a.uniforms.tEquirect.value = e
    const o = new De(i, a),
      s = e.minFilter
    return (
      e.minFilter === Fo && (e.minFilter = gi),
      new Q6(1, 10, this).update(t, o),
      (e.minFilter = s),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    )
  }
  clear(t, e, n, i) {
    const a = t.getRenderTarget()
    for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, i)
    t.setRenderTarget(a)
  }
}
const tx = new U(),
  eW = new U(),
  nW = new _e()
let Cs = class {
  constructor(t = new U(1, 0, 0), e = 0) {
    ;(this.isPlane = !0), (this.normal = t), (this.constant = e)
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
  }
  setFromCoplanarPoints(t, e, n) {
    const i = tx.subVectors(n, e).cross(eW.subVectors(t, e)).normalize()
    return this.setFromNormalAndCoplanarPoint(i, t), this
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this
  }
  normalize() {
    const t = 1 / this.normal.length()
    return this.normal.multiplyScalar(t), (this.constant *= t), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t))
  }
  intersectLine(t, e) {
    const n = t.delta(tx),
      i = this.normal.dot(n)
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null
    const a = -(t.start.dot(this.normal) + this.constant) / i
    return a < 0 || a > 1 ? null : e.copy(t.start).addScaledVector(n, a)
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end)
    return (e < 0 && n > 0) || (n < 0 && e > 0)
  }
  intersectsBox(t) {
    return t.intersectsPlane(this)
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this)
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(t, e) {
    const n = e || nW.getNormalMatrix(t),
      i = this.coplanarPoint(tx).applyMatrix4(t),
      a = this.normal.applyMatrix3(n).normalize()
    return (this.constant = -i.dot(a)), this
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const bl = new na(),
  eg = new U()
class BM {
  constructor(
    t = new Cs(),
    e = new Cs(),
    n = new Cs(),
    i = new Cs(),
    a = new Cs(),
    o = new Cs(),
  ) {
    this.planes = [t, e, n, i, a, o]
  }
  set(t, e, n, i, a, o) {
    const s = this.planes
    return (
      s[0].copy(t),
      s[1].copy(e),
      s[2].copy(n),
      s[3].copy(i),
      s[4].copy(a),
      s[5].copy(o),
      this
    )
  }
  copy(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n])
    return this
  }
  setFromProjectionMatrix(t, e = zo) {
    const n = this.planes,
      i = t.elements,
      a = i[0],
      o = i[1],
      s = i[2],
      l = i[3],
      u = i[4],
      c = i[5],
      h = i[6],
      f = i[7],
      d = i[8],
      p = i[9],
      g = i[10],
      v = i[11],
      m = i[12],
      y = i[13],
      _ = i[14],
      x = i[15]
    if (
      (n[0].setComponents(l - a, f - u, v - d, x - m).normalize(),
      n[1].setComponents(l + a, f + u, v + d, x + m).normalize(),
      n[2].setComponents(l + o, f + c, v + p, x + y).normalize(),
      n[3].setComponents(l - o, f - c, v - p, x - y).normalize(),
      n[4].setComponents(l - s, f - h, v - g, x - _).normalize(),
      e === zo)
    )
      n[5].setComponents(l + s, f + h, v + g, x + _).normalize()
    else if (e === yy) n[5].setComponents(s, h, g, _).normalize()
    else
      throw new Error(
        'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' +
          e,
      )
    return this
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(),
        bl.copy(t.boundingSphere).applyMatrix4(t.matrixWorld)
    else {
      const e = t.geometry
      e.boundingSphere === null && e.computeBoundingSphere(),
        bl.copy(e.boundingSphere).applyMatrix4(t.matrixWorld)
    }
    return this.intersectsSphere(bl)
  }
  intersectsSprite(t) {
    return (
      bl.center.set(0, 0, 0),
      (bl.radius = 0.7071067811865476),
      bl.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(bl)
    )
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius
    for (let a = 0; a < 6; a++) if (e[a].distanceToPoint(n) < i) return !1
    return !0
  }
  intersectsBox(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) {
      const i = e[n]
      if (
        ((eg.x = i.normal.x > 0 ? t.max.x : t.min.x),
        (eg.y = i.normal.y > 0 ? t.max.y : t.min.y),
        (eg.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint(eg) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(t) {
    const e = this.planes
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function iB() {
  let r = null,
    t = !1,
    e = null,
    n = null
  function i(a, o) {
    e(a, o), (n = r.requestAnimationFrame(i))
  }
  return {
    start: function () {
      t !== !0 && e !== null && ((n = r.requestAnimationFrame(i)), (t = !0))
    },
    stop: function () {
      r.cancelAnimationFrame(n), (t = !1)
    },
    setAnimationLoop: function (a) {
      e = a
    },
    setContext: function (a) {
      r = a
    },
  }
}
function rW(r) {
  const t = new WeakMap()
  function e(s, l) {
    const u = s.array,
      c = s.usage,
      h = u.byteLength,
      f = r.createBuffer()
    r.bindBuffer(l, f), r.bufferData(l, u, c), s.onUploadCallback()
    let d
    if (u instanceof Float32Array) d = r.FLOAT
    else if (u instanceof Uint16Array)
      s.isFloat16BufferAttribute ? (d = r.HALF_FLOAT) : (d = r.UNSIGNED_SHORT)
    else if (u instanceof Int16Array) d = r.SHORT
    else if (u instanceof Uint32Array) d = r.UNSIGNED_INT
    else if (u instanceof Int32Array) d = r.INT
    else if (u instanceof Int8Array) d = r.BYTE
    else if (u instanceof Uint8Array) d = r.UNSIGNED_BYTE
    else if (u instanceof Uint8ClampedArray) d = r.UNSIGNED_BYTE
    else
      throw new Error(
        'THREE.WebGLAttributes: Unsupported buffer data format: ' + u,
      )
    return {
      buffer: f,
      type: d,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: s.version,
      size: h,
    }
  }
  function n(s, l, u) {
    const c = l.array,
      h = l._updateRange,
      f = l.updateRanges
    if (
      (r.bindBuffer(u, s),
      h.count === -1 && f.length === 0 && r.bufferSubData(u, 0, c),
      f.length !== 0)
    ) {
      for (let d = 0, p = f.length; d < p; d++) {
        const g = f[d]
        r.bufferSubData(u, g.start * c.BYTES_PER_ELEMENT, c, g.start, g.count)
      }
      l.clearUpdateRanges()
    }
    h.count !== -1 &&
      (r.bufferSubData(u, h.offset * c.BYTES_PER_ELEMENT, c, h.offset, h.count),
      (h.count = -1)),
      l.onUploadCallback()
  }
  function i(s) {
    return s.isInterleavedBufferAttribute && (s = s.data), t.get(s)
  }
  function a(s) {
    s.isInterleavedBufferAttribute && (s = s.data)
    const l = t.get(s)
    l && (r.deleteBuffer(l.buffer), t.delete(s))
  }
  function o(s, l) {
    if (s.isGLBufferAttribute) {
      const c = t.get(s)
      ;(!c || c.version < s.version) &&
        t.set(s, {
          buffer: s.buffer,
          type: s.type,
          bytesPerElement: s.elementSize,
          version: s.version,
        })
      return
    }
    s.isInterleavedBufferAttribute && (s = s.data)
    const u = t.get(s)
    if (u === void 0) t.set(s, e(s, l))
    else if (u.version < s.version) {
      if (u.size !== s.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        )
      n(u.buffer, s, l), (u.version = s.version)
    }
  }
  return {
    get: i,
    remove: a,
    update: o,
  }
}
class Ti extends Mn {
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super(),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      })
    const a = t / 2,
      o = e / 2,
      s = Math.floor(n),
      l = Math.floor(i),
      u = s + 1,
      c = l + 1,
      h = t / s,
      f = e / l,
      d = [],
      p = [],
      g = [],
      v = []
    for (let m = 0; m < c; m++) {
      const y = m * f - o
      for (let _ = 0; _ < u; _++) {
        const x = _ * h - a
        p.push(x, -y, 0), g.push(0, 0, 1), v.push(_ / s), v.push(1 - m / l)
      }
    }
    for (let m = 0; m < l; m++)
      for (let y = 0; y < s; y++) {
        const _ = y + u * m,
          x = y + u * (m + 1),
          A = y + 1 + u * (m + 1),
          S = y + 1 + u * m
        d.push(_, x, S), d.push(x, A, S)
      }
    this.setIndex(d),
      this.setAttribute('position', new nn(p, 3)),
      this.setAttribute('normal', new nn(g, 3)),
      this.setAttribute('uv', new nn(v, 2))
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new Ti(t.width, t.height, t.widthSegments, t.heightSegments)
  }
}
var iW = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  aW = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  oW = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  sW = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  lW = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  uW = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  cW = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT )
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN )
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  hW = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  fW = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  dW = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  pW = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  vW = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  gW = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  mW = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  yW = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  _W = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  xW = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  SW = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  AW = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  bW = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  wW = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  MW = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  TW = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  CW = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  EW = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  DW = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  LW = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  PW = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  RW = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  IW = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  OW = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
  NW = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  kW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  BW = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif

#endif`,
  FW = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  zW = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  UW = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  VW = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  GW = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  HW = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  WW = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  XW = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  YW = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  $W = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  qW = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  ZW = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  KW = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  jW = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  JW = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  QW = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  t9 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  e9 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  n9 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  r9 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  i9 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  a9 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  o9 = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  s9 = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  l9 = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  u9 = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  c9 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );

	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  h9 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  f9 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  d9 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  p9 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  v9 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  g9 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  m9 = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  y9 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  _9 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  x9 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  S9 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  A9 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  b9 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  w9 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  M9 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  T9 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  C9 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  E9 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  D9 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  L9 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  P9 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  R9 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  I9 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  O9 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  N9 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  k9 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  B9 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  F9 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  z9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;

		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  U9 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  V9 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  G9 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  H9 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  W9 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  X9 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Y9 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  $9 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  q9 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  Z9 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  K9 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  j9 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  J9 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;

		#else

			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );

		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  Q9 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  t7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  e7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  n7 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
const r7 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  i7 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  a7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  o7 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  s7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  l7 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  u7 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  c7 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  h7 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  f7 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  d7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  p7 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  v7 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  g7 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  m7 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  y7 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  _7 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  x7 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  S7 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  A7 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  b7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  w7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  M7 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  T7 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  C7 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  E7 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  D7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  L7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  P7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  R7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  I7 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  O7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  N7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  k7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  me = {
    alphahash_fragment: iW,
    alphahash_pars_fragment: aW,
    alphamap_fragment: oW,
    alphamap_pars_fragment: sW,
    alphatest_fragment: lW,
    alphatest_pars_fragment: uW,
    aomap_fragment: cW,
    aomap_pars_fragment: hW,
    batching_pars_vertex: fW,
    batching_vertex: dW,
    begin_vertex: pW,
    beginnormal_vertex: vW,
    bsdfs: gW,
    iridescence_fragment: mW,
    bumpmap_pars_fragment: yW,
    clipping_planes_fragment: _W,
    clipping_planes_pars_fragment: xW,
    clipping_planes_pars_vertex: SW,
    clipping_planes_vertex: AW,
    color_fragment: bW,
    color_pars_fragment: wW,
    color_pars_vertex: MW,
    color_vertex: TW,
    common: CW,
    cube_uv_reflection_fragment: EW,
    defaultnormal_vertex: DW,
    displacementmap_pars_vertex: LW,
    displacementmap_vertex: PW,
    emissivemap_fragment: RW,
    emissivemap_pars_fragment: IW,
    colorspace_fragment: OW,
    colorspace_pars_fragment: NW,
    envmap_fragment: kW,
    envmap_common_pars_fragment: BW,
    envmap_pars_fragment: FW,
    envmap_pars_vertex: zW,
    envmap_physical_pars_fragment: KW,
    envmap_vertex: UW,
    fog_vertex: VW,
    fog_pars_vertex: GW,
    fog_fragment: HW,
    fog_pars_fragment: WW,
    gradientmap_pars_fragment: XW,
    lightmap_pars_fragment: YW,
    lights_lambert_fragment: $W,
    lights_lambert_pars_fragment: qW,
    lights_pars_begin: ZW,
    lights_toon_fragment: jW,
    lights_toon_pars_fragment: JW,
    lights_phong_fragment: QW,
    lights_phong_pars_fragment: t9,
    lights_physical_fragment: e9,
    lights_physical_pars_fragment: n9,
    lights_fragment_begin: r9,
    lights_fragment_maps: i9,
    lights_fragment_end: a9,
    logdepthbuf_fragment: o9,
    logdepthbuf_pars_fragment: s9,
    logdepthbuf_pars_vertex: l9,
    logdepthbuf_vertex: u9,
    map_fragment: c9,
    map_pars_fragment: h9,
    map_particle_fragment: f9,
    map_particle_pars_fragment: d9,
    metalnessmap_fragment: p9,
    metalnessmap_pars_fragment: v9,
    morphinstance_vertex: g9,
    morphcolor_vertex: m9,
    morphnormal_vertex: y9,
    morphtarget_pars_vertex: _9,
    morphtarget_vertex: x9,
    normal_fragment_begin: S9,
    normal_fragment_maps: A9,
    normal_pars_fragment: b9,
    normal_pars_vertex: w9,
    normal_vertex: M9,
    normalmap_pars_fragment: T9,
    clearcoat_normal_fragment_begin: C9,
    clearcoat_normal_fragment_maps: E9,
    clearcoat_pars_fragment: D9,
    iridescence_pars_fragment: L9,
    opaque_fragment: P9,
    packing: R9,
    premultiplied_alpha_fragment: I9,
    project_vertex: O9,
    dithering_fragment: N9,
    dithering_pars_fragment: k9,
    roughnessmap_fragment: B9,
    roughnessmap_pars_fragment: F9,
    shadowmap_pars_fragment: z9,
    shadowmap_pars_vertex: U9,
    shadowmap_vertex: V9,
    shadowmask_pars_fragment: G9,
    skinbase_vertex: H9,
    skinning_pars_vertex: W9,
    skinning_vertex: X9,
    skinnormal_vertex: Y9,
    specularmap_fragment: $9,
    specularmap_pars_fragment: q9,
    tonemapping_fragment: Z9,
    tonemapping_pars_fragment: K9,
    transmission_fragment: j9,
    transmission_pars_fragment: J9,
    uv_pars_fragment: Q9,
    uv_pars_vertex: t7,
    uv_vertex: e7,
    worldpos_vertex: n7,
    background_vert: r7,
    background_frag: i7,
    backgroundCube_vert: a7,
    backgroundCube_frag: o7,
    cube_vert: s7,
    cube_frag: l7,
    depth_vert: u7,
    depth_frag: c7,
    distanceRGBA_vert: h7,
    distanceRGBA_frag: f7,
    equirect_vert: d7,
    equirect_frag: p7,
    linedashed_vert: v7,
    linedashed_frag: g7,
    meshbasic_vert: m7,
    meshbasic_frag: y7,
    meshlambert_vert: _7,
    meshlambert_frag: x7,
    meshmatcap_vert: S7,
    meshmatcap_frag: A7,
    meshnormal_vert: b7,
    meshnormal_frag: w7,
    meshphong_vert: M7,
    meshphong_frag: T7,
    meshphysical_vert: C7,
    meshphysical_frag: E7,
    meshtoon_vert: D7,
    meshtoon_frag: L7,
    points_vert: P7,
    points_frag: R7,
    shadow_vert: I7,
    shadow_frag: O7,
    sprite_vert: N7,
    sprite_frag: k7,
  },
  Rt = {
    common: {
      diffuse: {
        value: new qt(16777215),
      },
      opacity: {
        value: 1,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new _e(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new _e(),
      },
      alphaTest: {
        value: 0,
      },
    },
    specularmap: {
      specularMap: {
        value: null,
      },
      specularMapTransform: {
        value: new _e(),
      },
    },
    envmap: {
      envMap: {
        value: null,
      },
      envMapRotation: {
        value: new _e(),
      },
      flipEnvMap: {
        value: -1,
      },
      reflectivity: {
        value: 1,
      },
      ior: {
        value: 1.5,
      },
      refractionRatio: {
        value: 0.98,
      },
    },
    aomap: {
      aoMap: {
        value: null,
      },
      aoMapIntensity: {
        value: 1,
      },
      aoMapTransform: {
        value: new _e(),
      },
    },
    lightmap: {
      lightMap: {
        value: null,
      },
      lightMapIntensity: {
        value: 1,
      },
      lightMapTransform: {
        value: new _e(),
      },
    },
    bumpmap: {
      bumpMap: {
        value: null,
      },
      bumpMapTransform: {
        value: new _e(),
      },
      bumpScale: {
        value: 1,
      },
    },
    normalmap: {
      normalMap: {
        value: null,
      },
      normalMapTransform: {
        value: new _e(),
      },
      normalScale: {
        value: new pt(1, 1),
      },
    },
    displacementmap: {
      displacementMap: {
        value: null,
      },
      displacementMapTransform: {
        value: new _e(),
      },
      displacementScale: {
        value: 1,
      },
      displacementBias: {
        value: 0,
      },
    },
    emissivemap: {
      emissiveMap: {
        value: null,
      },
      emissiveMapTransform: {
        value: new _e(),
      },
    },
    metalnessmap: {
      metalnessMap: {
        value: null,
      },
      metalnessMapTransform: {
        value: new _e(),
      },
    },
    roughnessmap: {
      roughnessMap: {
        value: null,
      },
      roughnessMapTransform: {
        value: new _e(),
      },
    },
    gradientmap: {
      gradientMap: {
        value: null,
      },
    },
    fog: {
      fogDensity: {
        value: 25e-5,
      },
      fogNear: {
        value: 1,
      },
      fogFar: {
        value: 2e3,
      },
      fogColor: {
        value: new qt(16777215),
      },
    },
    lights: {
      ambientLightColor: {
        value: [],
      },
      lightProbe: {
        value: [],
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
        },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: {
        value: [],
      },
      directionalShadowMatrix: {
        value: [],
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: {
        value: [],
      },
      spotShadowMap: {
        value: [],
      },
      spotLightMatrix: {
        value: [],
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
        },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: {
        value: [],
      },
      pointShadowMatrix: {
        value: [],
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {},
        },
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {},
        },
      },
      ltc_1: {
        value: null,
      },
      ltc_2: {
        value: null,
      },
    },
    points: {
      diffuse: {
        value: new qt(16777215),
      },
      opacity: {
        value: 1,
      },
      size: {
        value: 1,
      },
      scale: {
        value: 1,
      },
      map: {
        value: null,
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new _e(),
      },
      alphaTest: {
        value: 0,
      },
      uvTransform: {
        value: new _e(),
      },
    },
    sprite: {
      diffuse: {
        value: new qt(16777215),
      },
      opacity: {
        value: 1,
      },
      center: {
        value: new pt(0.5, 0.5),
      },
      rotation: {
        value: 0,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new _e(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new _e(),
      },
      alphaTest: {
        value: 0,
      },
    },
  },
  qr = {
    basic: {
      uniforms: Ir([
        Rt.common,
        Rt.specularmap,
        Rt.envmap,
        Rt.aomap,
        Rt.lightmap,
        Rt.fog,
      ]),
      vertexShader: me.meshbasic_vert,
      fragmentShader: me.meshbasic_frag,
    },
    lambert: {
      uniforms: Ir([
        Rt.common,
        Rt.specularmap,
        Rt.envmap,
        Rt.aomap,
        Rt.lightmap,
        Rt.emissivemap,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        Rt.fog,
        Rt.lights,
        {
          emissive: {
            value: new qt(0),
          },
        },
      ]),
      vertexShader: me.meshlambert_vert,
      fragmentShader: me.meshlambert_frag,
    },
    phong: {
      uniforms: Ir([
        Rt.common,
        Rt.specularmap,
        Rt.envmap,
        Rt.aomap,
        Rt.lightmap,
        Rt.emissivemap,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        Rt.fog,
        Rt.lights,
        {
          emissive: {
            value: new qt(0),
          },
          specular: {
            value: new qt(1118481),
          },
          shininess: {
            value: 30,
          },
        },
      ]),
      vertexShader: me.meshphong_vert,
      fragmentShader: me.meshphong_frag,
    },
    standard: {
      uniforms: Ir([
        Rt.common,
        Rt.envmap,
        Rt.aomap,
        Rt.lightmap,
        Rt.emissivemap,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        Rt.roughnessmap,
        Rt.metalnessmap,
        Rt.fog,
        Rt.lights,
        {
          emissive: {
            value: new qt(0),
          },
          roughness: {
            value: 1,
          },
          metalness: {
            value: 0,
          },
          envMapIntensity: {
            value: 1,
          },
        },
      ]),
      vertexShader: me.meshphysical_vert,
      fragmentShader: me.meshphysical_frag,
    },
    toon: {
      uniforms: Ir([
        Rt.common,
        Rt.aomap,
        Rt.lightmap,
        Rt.emissivemap,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        Rt.gradientmap,
        Rt.fog,
        Rt.lights,
        {
          emissive: {
            value: new qt(0),
          },
        },
      ]),
      vertexShader: me.meshtoon_vert,
      fragmentShader: me.meshtoon_frag,
    },
    matcap: {
      uniforms: Ir([
        Rt.common,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        Rt.fog,
        {
          matcap: {
            value: null,
          },
        },
      ]),
      vertexShader: me.meshmatcap_vert,
      fragmentShader: me.meshmatcap_frag,
    },
    points: {
      uniforms: Ir([Rt.points, Rt.fog]),
      vertexShader: me.points_vert,
      fragmentShader: me.points_frag,
    },
    dashed: {
      uniforms: Ir([
        Rt.common,
        Rt.fog,
        {
          scale: {
            value: 1,
          },
          dashSize: {
            value: 1,
          },
          totalSize: {
            value: 2,
          },
        },
      ]),
      vertexShader: me.linedashed_vert,
      fragmentShader: me.linedashed_frag,
    },
    depth: {
      uniforms: Ir([Rt.common, Rt.displacementmap]),
      vertexShader: me.depth_vert,
      fragmentShader: me.depth_frag,
    },
    normal: {
      uniforms: Ir([
        Rt.common,
        Rt.bumpmap,
        Rt.normalmap,
        Rt.displacementmap,
        {
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: me.meshnormal_vert,
      fragmentShader: me.meshnormal_frag,
    },
    sprite: {
      uniforms: Ir([Rt.sprite, Rt.fog]),
      vertexShader: me.sprite_vert,
      fragmentShader: me.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new _e(),
        },
        t2D: {
          value: null,
        },
        backgroundIntensity: {
          value: 1,
        },
      },
      vertexShader: me.background_vert,
      fragmentShader: me.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null,
        },
        flipEnvMap: {
          value: -1,
        },
        backgroundBlurriness: {
          value: 0,
        },
        backgroundIntensity: {
          value: 1,
        },
        backgroundRotation: {
          value: new _e(),
        },
      },
      vertexShader: me.backgroundCube_vert,
      fragmentShader: me.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: {
          value: null,
        },
        tFlip: {
          value: -1,
        },
        opacity: {
          value: 1,
        },
      },
      vertexShader: me.cube_vert,
      fragmentShader: me.cube_frag,
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null,
        },
      },
      vertexShader: me.equirect_vert,
      fragmentShader: me.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Ir([
        Rt.common,
        Rt.displacementmap,
        {
          referencePosition: {
            value: new U(),
          },
          nearDistance: {
            value: 1,
          },
          farDistance: {
            value: 1e3,
          },
        },
      ]),
      vertexShader: me.distanceRGBA_vert,
      fragmentShader: me.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Ir([
        Rt.lights,
        Rt.fog,
        {
          color: {
            value: new qt(0),
          },
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: me.shadow_vert,
      fragmentShader: me.shadow_frag,
    },
  }
qr.physical = {
  uniforms: Ir([
    qr.standard.uniforms,
    {
      clearcoat: {
        value: 0,
      },
      clearcoatMap: {
        value: null,
      },
      clearcoatMapTransform: {
        value: new _e(),
      },
      clearcoatNormalMap: {
        value: null,
      },
      clearcoatNormalMapTransform: {
        value: new _e(),
      },
      clearcoatNormalScale: {
        value: new pt(1, 1),
      },
      clearcoatRoughness: {
        value: 0,
      },
      clearcoatRoughnessMap: {
        value: null,
      },
      clearcoatRoughnessMapTransform: {
        value: new _e(),
      },
      dispersion: {
        value: 0,
      },
      iridescence: {
        value: 0,
      },
      iridescenceMap: {
        value: null,
      },
      iridescenceMapTransform: {
        value: new _e(),
      },
      iridescenceIOR: {
        value: 1.3,
      },
      iridescenceThicknessMinimum: {
        value: 100,
      },
      iridescenceThicknessMaximum: {
        value: 400,
      },
      iridescenceThicknessMap: {
        value: null,
      },
      iridescenceThicknessMapTransform: {
        value: new _e(),
      },
      sheen: {
        value: 0,
      },
      sheenColor: {
        value: new qt(0),
      },
      sheenColorMap: {
        value: null,
      },
      sheenColorMapTransform: {
        value: new _e(),
      },
      sheenRoughness: {
        value: 1,
      },
      sheenRoughnessMap: {
        value: null,
      },
      sheenRoughnessMapTransform: {
        value: new _e(),
      },
      transmission: {
        value: 0,
      },
      transmissionMap: {
        value: null,
      },
      transmissionMapTransform: {
        value: new _e(),
      },
      transmissionSamplerSize: {
        value: new pt(),
      },
      transmissionSamplerMap: {
        value: null,
      },
      thickness: {
        value: 0,
      },
      thicknessMap: {
        value: null,
      },
      thicknessMapTransform: {
        value: new _e(),
      },
      attenuationDistance: {
        value: 0,
      },
      attenuationColor: {
        value: new qt(0),
      },
      specularColor: {
        value: new qt(1, 1, 1),
      },
      specularColorMap: {
        value: null,
      },
      specularColorMapTransform: {
        value: new _e(),
      },
      specularIntensity: {
        value: 1,
      },
      specularIntensityMap: {
        value: null,
      },
      specularIntensityMapTransform: {
        value: new _e(),
      },
      anisotropyVector: {
        value: new pt(),
      },
      anisotropyMap: {
        value: null,
      },
      anisotropyMapTransform: {
        value: new _e(),
      },
    },
  ]),
  vertexShader: me.meshphysical_vert,
  fragmentShader: me.meshphysical_frag,
}
const ng = {
    r: 0,
    b: 0,
    g: 0,
  },
  wl = new Ma(),
  B7 = new ae()
function F7(r, t, e, n, i, a, o) {
  const s = new qt(0)
  let l = a === !0 ? 0 : 1,
    u,
    c,
    h = null,
    f = 0,
    d = null
  function p(y) {
    let _ = y.isScene === !0 ? y.background : null
    return (
      _ && _.isTexture && (_ = (y.backgroundBlurriness > 0 ? e : t).get(_)), _
    )
  }
  function g(y) {
    let _ = !1
    const x = p(y)
    x === null ? m(s, l) : x && x.isColor && (m(x, 1), (_ = !0))
    const A = r.xr.getEnvironmentBlendMode()
    A === 'additive'
      ? n.buffers.color.setClear(0, 0, 0, 1, o)
      : A === 'alpha-blend' && n.buffers.color.setClear(0, 0, 0, 0, o),
      (r.autoClear || _) &&
        (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
  }
  function v(y, _) {
    const x = p(_)
    x && (x.isCubeTexture || x.mapping === R0)
      ? (c === void 0 &&
          ((c = new De(
            new fv(1, 1, 1),
            new lo({
              name: 'BackgroundCubeMaterial',
              uniforms: Hh(qr.backgroundCube.uniforms),
              vertexShader: qr.backgroundCube.vertexShader,
              fragmentShader: qr.backgroundCube.fragmentShader,
              side: Qr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          c.geometry.deleteAttribute('normal'),
          c.geometry.deleteAttribute('uv'),
          (c.onBeforeRender = function (A, S, b) {
            this.matrixWorld.copyPosition(b.matrixWorld)
          }),
          Object.defineProperty(c.material, 'envMap', {
            get: function () {
              return this.uniforms.envMap.value
            },
          }),
          i.update(c)),
        wl.copy(_.backgroundRotation),
        (wl.x *= -1),
        (wl.y *= -1),
        (wl.z *= -1),
        x.isCubeTexture &&
          x.isRenderTargetTexture === !1 &&
          ((wl.y *= -1), (wl.z *= -1)),
        (c.material.uniforms.envMap.value = x),
        (c.material.uniforms.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (c.material.uniforms.backgroundBlurriness.value =
          _.backgroundBlurriness),
        (c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
        c.material.uniforms.backgroundRotation.value.setFromMatrix4(
          B7.makeRotationFromEuler(wl),
        ),
        (c.material.toneMapped = Be.getTransfer(x.colorSpace) !== an),
        (h !== x || f !== x.version || d !== r.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (h = x),
          (f = x.version),
          (d = r.toneMapping)),
        c.layers.enableAll(),
        y.unshift(c, c.geometry, c.material, 0, 0, null))
      : x &&
        x.isTexture &&
        (u === void 0 &&
          ((u = new De(
            new Ti(2, 2),
            new lo({
              name: 'BackgroundMaterial',
              uniforms: Hh(qr.background.uniforms),
              vertexShader: qr.background.vertexShader,
              fragmentShader: qr.background.fragmentShader,
              side: $o,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
            }),
          )),
          u.geometry.deleteAttribute('normal'),
          Object.defineProperty(u.material, 'map', {
            get: function () {
              return this.uniforms.t2D.value
            },
          }),
          i.update(u)),
        (u.material.uniforms.t2D.value = x),
        (u.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
        (u.material.toneMapped = Be.getTransfer(x.colorSpace) !== an),
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        u.material.uniforms.uvTransform.value.copy(x.matrix),
        (h !== x || f !== x.version || d !== r.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (h = x),
          (f = x.version),
          (d = r.toneMapping)),
        u.layers.enableAll(),
        y.unshift(u, u.geometry, u.material, 0, 0, null))
  }
  function m(y, _) {
    y.getRGB(ng, eB(r)), n.buffers.color.setClear(ng.r, ng.g, ng.b, _, o)
  }
  return {
    getClearColor: function () {
      return s
    },
    setClearColor: function (y, _ = 1) {
      s.set(y), (l = _), m(s, l)
    },
    getClearAlpha: function () {
      return l
    },
    setClearAlpha: function (y) {
      ;(l = y), m(s, l)
    },
    render: g,
    addToRenderList: v,
  }
}
function z7(r, t) {
  const e = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    n = {},
    i = f(null)
  let a = i,
    o = !1
  function s(M, C, E, D, P) {
    let L = !1
    const I = h(D, E, C)
    a !== I && ((a = I), u(a.object)),
      (L = d(M, D, E, P)),
      L && p(M, D, E, P),
      P !== null && t.update(P, r.ELEMENT_ARRAY_BUFFER),
      (L || o) &&
        ((o = !1),
        x(M, C, E, D),
        P !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(P).buffer))
  }
  function l() {
    return r.createVertexArray()
  }
  function u(M) {
    return r.bindVertexArray(M)
  }
  function c(M) {
    return r.deleteVertexArray(M)
  }
  function h(M, C, E) {
    const D = E.wireframe === !0
    let P = n[M.id]
    P === void 0 && ((P = {}), (n[M.id] = P))
    let L = P[C.id]
    L === void 0 && ((L = {}), (P[C.id] = L))
    let I = L[D]
    return I === void 0 && ((I = f(l())), (L[D] = I)), I
  }
  function f(M) {
    const C = [],
      E = [],
      D = []
    for (let P = 0; P < e; P++) (C[P] = 0), (E[P] = 0), (D[P] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: C,
      enabledAttributes: E,
      attributeDivisors: D,
      object: M,
      attributes: {},
      index: null,
    }
  }
  function d(M, C, E, D) {
    const P = a.attributes,
      L = C.attributes
    let I = 0
    const F = E.getAttributes()
    for (const k in F)
      if (F[k].location >= 0) {
        const H = P[k]
        let Y = L[k]
        if (
          (Y === void 0 &&
            (k === 'instanceMatrix' &&
              M.instanceMatrix &&
              (Y = M.instanceMatrix),
            k === 'instanceColor' && M.instanceColor && (Y = M.instanceColor)),
          H === void 0 || H.attribute !== Y || (Y && H.data !== Y.data))
        )
          return !0
        I++
      }
    return a.attributesNum !== I || a.index !== D
  }
  function p(M, C, E, D) {
    const P = {},
      L = C.attributes
    let I = 0
    const F = E.getAttributes()
    for (const k in F)
      if (F[k].location >= 0) {
        let H = L[k]
        H === void 0 &&
          (k === 'instanceMatrix' && M.instanceMatrix && (H = M.instanceMatrix),
          k === 'instanceColor' && M.instanceColor && (H = M.instanceColor))
        const Y = {}
        ;(Y.attribute = H), H && H.data && (Y.data = H.data), (P[k] = Y), I++
      }
    ;(a.attributes = P), (a.attributesNum = I), (a.index = D)
  }
  function g() {
    const M = a.newAttributes
    for (let C = 0, E = M.length; C < E; C++) M[C] = 0
  }
  function v(M) {
    m(M, 0)
  }
  function m(M, C) {
    const E = a.newAttributes,
      D = a.enabledAttributes,
      P = a.attributeDivisors
    ;(E[M] = 1),
      D[M] === 0 && (r.enableVertexAttribArray(M), (D[M] = 1)),
      P[M] !== C && (r.vertexAttribDivisor(M, C), (P[M] = C))
  }
  function y() {
    const M = a.newAttributes,
      C = a.enabledAttributes
    for (let E = 0, D = C.length; E < D; E++)
      C[E] !== M[E] && (r.disableVertexAttribArray(E), (C[E] = 0))
  }
  function _(M, C, E, D, P, L, I) {
    I === !0
      ? r.vertexAttribIPointer(M, C, E, P, L)
      : r.vertexAttribPointer(M, C, E, D, P, L)
  }
  function x(M, C, E, D) {
    g()
    const P = D.attributes,
      L = E.getAttributes(),
      I = C.defaultAttributeValues
    for (const F in L) {
      const k = L[F]
      if (k.location >= 0) {
        let V = P[F]
        if (
          (V === void 0 &&
            (F === 'instanceMatrix' &&
              M.instanceMatrix &&
              (V = M.instanceMatrix),
            F === 'instanceColor' && M.instanceColor && (V = M.instanceColor)),
          V !== void 0)
        ) {
          const H = V.normalized,
            Y = V.itemSize,
            K = t.get(V)
          if (K === void 0) continue
          const ut = K.buffer,
            W = K.type,
            Z = K.bytesPerElement,
            ft = W === r.INT || W === r.UNSIGNED_INT || V.gpuType === bM
          if (V.isInterleavedBufferAttribute) {
            const lt = V.data,
              ct = lt.stride,
              At = V.offset
            if (lt.isInstancedInterleavedBuffer) {
              for (let gt = 0; gt < k.locationSize; gt++)
                m(k.location + gt, lt.meshPerAttribute)
              M.isInstancedMesh !== !0 &&
                D._maxInstanceCount === void 0 &&
                (D._maxInstanceCount = lt.meshPerAttribute * lt.count)
            } else
              for (let gt = 0; gt < k.locationSize; gt++) v(k.location + gt)
            r.bindBuffer(r.ARRAY_BUFFER, ut)
            for (let gt = 0; gt < k.locationSize; gt++)
              _(
                k.location + gt,
                Y / k.locationSize,
                W,
                H,
                ct * Z,
                (At + (Y / k.locationSize) * gt) * Z,
                ft,
              )
          } else {
            if (V.isInstancedBufferAttribute) {
              for (let lt = 0; lt < k.locationSize; lt++)
                m(k.location + lt, V.meshPerAttribute)
              M.isInstancedMesh !== !0 &&
                D._maxInstanceCount === void 0 &&
                (D._maxInstanceCount = V.meshPerAttribute * V.count)
            } else
              for (let lt = 0; lt < k.locationSize; lt++) v(k.location + lt)
            r.bindBuffer(r.ARRAY_BUFFER, ut)
            for (let lt = 0; lt < k.locationSize; lt++)
              _(
                k.location + lt,
                Y / k.locationSize,
                W,
                H,
                Y * Z,
                (Y / k.locationSize) * lt * Z,
                ft,
              )
          }
        } else if (I !== void 0) {
          const H = I[F]
          if (H !== void 0)
            switch (H.length) {
              case 2:
                r.vertexAttrib2fv(k.location, H)
                break
              case 3:
                r.vertexAttrib3fv(k.location, H)
                break
              case 4:
                r.vertexAttrib4fv(k.location, H)
                break
              default:
                r.vertexAttrib1fv(k.location, H)
            }
        }
      }
    }
    y()
  }
  function A() {
    T()
    for (const M in n) {
      const C = n[M]
      for (const E in C) {
        const D = C[E]
        for (const P in D) c(D[P].object), delete D[P]
        delete C[E]
      }
      delete n[M]
    }
  }
  function S(M) {
    if (n[M.id] === void 0) return
    const C = n[M.id]
    for (const E in C) {
      const D = C[E]
      for (const P in D) c(D[P].object), delete D[P]
      delete C[E]
    }
    delete n[M.id]
  }
  function b(M) {
    for (const C in n) {
      const E = n[C]
      if (E[M.id] === void 0) continue
      const D = E[M.id]
      for (const P in D) c(D[P].object), delete D[P]
      delete E[M.id]
    }
  }
  function T() {
    w(), (o = !0), a !== i && ((a = i), u(a.object))
  }
  function w() {
    ;(i.geometry = null), (i.program = null), (i.wireframe = !1)
  }
  return {
    setup: s,
    reset: T,
    resetDefaultState: w,
    dispose: A,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: b,
    initAttributes: g,
    enableAttribute: v,
    disableUnusedAttributes: y,
  }
}
function U7(r, t, e) {
  let n
  function i(u) {
    n = u
  }
  function a(u, c) {
    r.drawArrays(n, u, c), e.update(c, n, 1)
  }
  function o(u, c, h) {
    h !== 0 && (r.drawArraysInstanced(n, u, c, h), e.update(c, n, h))
  }
  function s(u, c, h) {
    if (h === 0) return
    t.get('WEBGL_multi_draw').multiDrawArraysWEBGL(n, u, 0, c, 0, h)
    let d = 0
    for (let p = 0; p < h; p++) d += c[p]
    e.update(d, n, 1)
  }
  function l(u, c, h, f) {
    if (h === 0) return
    const d = t.get('WEBGL_multi_draw')
    if (d === null) for (let p = 0; p < u.length; p++) o(u[p], c[p], f[p])
    else {
      d.multiDrawArraysInstancedWEBGL(n, u, 0, c, 0, f, 0, h)
      let p = 0
      for (let g = 0; g < h; g++) p += c[g]
      for (let g = 0; g < f.length; g++) e.update(p, n, f[g])
    }
  }
  ;(this.setMode = i),
    (this.render = a),
    (this.renderInstances = o),
    (this.renderMultiDraw = s),
    (this.renderMultiDrawInstances = l)
}
function V7(r, t, e, n) {
  let i
  function a() {
    if (i !== void 0) return i
    if (t.has('EXT_texture_filter_anisotropic') === !0) {
      const S = t.get('EXT_texture_filter_anisotropic')
      i = r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else i = 0
    return i
  }
  function o(S) {
    return !(
      S !== Yi &&
      n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)
    )
  }
  function s(S) {
    const b =
      S === hv &&
      (t.has('EXT_color_buffer_half_float') || t.has('EXT_color_buffer_float'))
    return !(
      S !== qo &&
      n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) &&
      S !== ya &&
      !b
    )
  }
  function l(S) {
    if (S === 'highp') {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision >
          0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision >
          0
      )
        return 'highp'
      S = 'mediump'
    }
    return S === 'mediump' &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision >
        0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision >
        0
      ? 'mediump'
      : 'lowp'
  }
  let u = e.precision !== void 0 ? e.precision : 'highp'
  const c = l(u)
  c !== u &&
    (console.warn(
      'THREE.WebGLRenderer:',
      u,
      'not supported, using',
      c,
      'instead.',
    ),
    (u = c))
  const h = e.logarithmicDepthBuffer === !0,
    f = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    d = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = r.getParameter(r.MAX_TEXTURE_SIZE),
    g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    v = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    m = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    y = r.getParameter(r.MAX_VARYING_VECTORS),
    _ = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    x = d > 0,
    A = r.getParameter(r.MAX_SAMPLES)
  return {
    isWebGL2: !0,
    getMaxAnisotropy: a,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: s,
    precision: u,
    logarithmicDepthBuffer: h,
    maxTextures: f,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: g,
    maxAttributes: v,
    maxVertexUniforms: m,
    maxVaryings: y,
    maxFragmentUniforms: _,
    vertexTextures: x,
    maxSamples: A,
  }
}
function G7(r) {
  const t = this
  let e = null,
    n = 0,
    i = !1,
    a = !1
  const o = new Cs(),
    s = new _e(),
    l = {
      value: null,
      needsUpdate: !1,
    }
  ;(this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, f) {
      const d = h.length !== 0 || f || n !== 0 || i
      return (i = f), (n = h.length), d
    }),
    (this.beginShadows = function () {
      ;(a = !0), c(null)
    }),
    (this.endShadows = function () {
      a = !1
    }),
    (this.setGlobalState = function (h, f) {
      e = c(h, f, 0)
    }),
    (this.setState = function (h, f, d) {
      const p = h.clippingPlanes,
        g = h.clipIntersection,
        v = h.clipShadows,
        m = r.get(h)
      if (!i || p === null || p.length === 0 || (a && !v)) a ? c(null) : u()
      else {
        const y = a ? 0 : n,
          _ = y * 4
        let x = m.clippingState || null
        ;(l.value = x), (x = c(p, f, _, d))
        for (let A = 0; A !== _; ++A) x[A] = e[A]
        ;(m.clippingState = x),
          (this.numIntersection = g ? this.numPlanes : 0),
          (this.numPlanes += y)
      }
    })
  function u() {
    l.value !== e && ((l.value = e), (l.needsUpdate = n > 0)),
      (t.numPlanes = n),
      (t.numIntersection = 0)
  }
  function c(h, f, d, p) {
    const g = h !== null ? h.length : 0
    let v = null
    if (g !== 0) {
      if (((v = l.value), p !== !0 || v === null)) {
        const m = d + g * 4,
          y = f.matrixWorldInverse
        s.getNormalMatrix(y),
          (v === null || v.length < m) && (v = new Float32Array(m))
        for (let _ = 0, x = d; _ !== g; ++_, x += 4)
          o.copy(h[_]).applyMatrix4(y, s),
            o.normal.toArray(v, x),
            (v[x + 3] = o.constant)
      }
      ;(l.value = v), (l.needsUpdate = !0)
    }
    return (t.numPlanes = g), (t.numIntersection = 0), v
  }
}
function H7(r) {
  let t = new WeakMap()
  function e(o, s) {
    return s === mA ? (o.mapping = Fh) : s === yA && (o.mapping = zh), o
  }
  function n(o) {
    if (o && o.isTexture) {
      const s = o.mapping
      if (s === mA || s === yA)
        if (t.has(o)) {
          const l = t.get(o).texture
          return e(l, o.mapping)
        } else {
          const l = o.image
          if (l && l.height > 0) {
            const u = new tW(l.height)
            return (
              u.fromEquirectangularTexture(r, o),
              t.set(o, u),
              o.addEventListener('dispose', i),
              e(u.texture, o.mapping)
            )
          } else return null
        }
    }
    return o
  }
  function i(o) {
    const s = o.target
    s.removeEventListener('dispose', i)
    const l = t.get(s)
    l !== void 0 && (t.delete(s), l.dispose())
  }
  function a() {
    t = new WeakMap()
  }
  return {
    get: n,
    dispose: a,
  }
}
class O0 extends nB {
  constructor(t = -1, e = 1, n = 1, i = -1, a = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = n),
      (this.bottom = i),
      (this.near = a),
      (this.far = o),
      this.updateProjectionMatrix()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      this
    )
  }
  setViewOffset(t, e, n, i, a, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = a),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2
    let a = n - t,
      o = n + t,
      s = i + e,
      l = i - e
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom,
        c = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(a += u * this.view.offsetX),
        (o = a + u * this.view.width),
        (s -= c * this.view.offsetY),
        (l = s - c * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(
      a,
      o,
      s,
      l,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      e
    )
  }
}
const ph = 4,
  b2 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  cu = 20,
  ex = new O0(),
  w2 = new qt()
let nx = null,
  rx = 0,
  ix = 0,
  ax = !1
const tu = (1 + Math.sqrt(5)) / 2,
  Dc = 1 / tu,
  M2 = [
    new U(-tu, Dc, 0),
    new U(tu, Dc, 0),
    new U(-Dc, 0, tu),
    new U(Dc, 0, tu),
    new U(0, tu, -Dc),
    new U(0, tu, Dc),
    new U(-1, 1, -1),
    new U(1, 1, -1),
    new U(-1, 1, 1),
    new U(1, 1, 1),
  ]
class T2 {
  constructor(t) {
    ;(this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ;(nx = this._renderer.getRenderTarget()),
      (rx = this._renderer.getActiveCubeFace()),
      (ix = this._renderer.getActiveMipmapLevel()),
      (ax = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(256)
    const a = this._allocateTargets()
    return (
      (a.depthBuffer = !0),
      this._sceneToCubeUV(t, n, i, a),
      e > 0 && this._blur(a, 0, 0, e),
      this._applyPMREM(a),
      this._cleanup(a),
      a
    )
  }
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e)
  }
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e)
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = D2()),
      this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = E2()),
      this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose()
  }
  _setSize(t) {
    ;(this._lodMax = Math.floor(Math.log2(t))),
      (this._cubeSize = Math.pow(2, this._lodMax))
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose()
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose()
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(nx, rx, ix),
      (this._renderer.xr.enabled = ax),
      (t.scissorTest = !1),
      rg(t, 0, 0, t.width, t.height)
  }
  _fromTexture(t, e) {
    t.mapping === Fh || t.mapping === zh
      ? this._setSize(
          t.image.length === 0
            ? 16
            : t.image[0].width || t.image[0].image.width,
        )
      : this._setSize(t.image.width / 4),
      (nx = this._renderer.getRenderTarget()),
      (rx = this._renderer.getActiveCubeFace()),
      (ix = this._renderer.getActiveMipmapLevel()),
      (ax = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1)
    const n = e || this._allocateTargets()
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112),
      e = 4 * this._cubeSize,
      n = {
        magFilter: gi,
        minFilter: gi,
        generateMipmaps: !1,
        type: hv,
        format: Yi,
        colorSpace: ar,
        depthBuffer: !1,
      },
      i = C2(t, e, n)
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== t ||
      this._pingPongRenderTarget.height !== e
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = C2(t, e, n))
      const {_lodMax: a} = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = W7(a)),
        (this._blurMaterial = X7(a, t, e))
    }
    return i
  }
  _compileMaterial(t) {
    const e = new De(this._lodPlanes[0], t)
    this._renderer.compile(e, ex)
  }
  _sceneToCubeUV(t, e, n, i) {
    const s = new wr(90, 1, e, n),
      l = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      c = this._renderer,
      h = c.autoClear,
      f = c.toneMapping
    c.getClearColor(w2), (c.toneMapping = Ys), (c.autoClear = !1)
    const d = new on({
        name: 'PMREM.Background',
        side: Qr,
        depthWrite: !1,
        depthTest: !1,
      }),
      p = new De(new fv(), d)
    let g = !1
    const v = t.background
    v
      ? v.isColor && (d.color.copy(v), (t.background = null), (g = !0))
      : (d.color.copy(w2), (g = !0))
    for (let m = 0; m < 6; m++) {
      const y = m % 3
      y === 0
        ? (s.up.set(0, l[m], 0), s.lookAt(u[m], 0, 0))
        : y === 1
        ? (s.up.set(0, 0, l[m]), s.lookAt(0, u[m], 0))
        : (s.up.set(0, l[m], 0), s.lookAt(0, 0, u[m]))
      const _ = this._cubeSize
      rg(i, y * _, m > 2 ? _ : 0, _, _),
        c.setRenderTarget(i),
        g && c.render(p, s),
        c.render(t, s)
    }
    p.geometry.dispose(),
      p.material.dispose(),
      (c.toneMapping = f),
      (c.autoClear = h),
      (t.background = v)
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer,
      i = t.mapping === Fh || t.mapping === zh
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = D2()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          t.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = E2())
    const a = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new De(this._lodPlanes[0], a),
      s = a.uniforms
    s.envMap.value = t
    const l = this._cubeSize
    rg(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(o, ex)
  }
  _applyPMREM(t) {
    const e = this._renderer,
      n = e.autoClear
    e.autoClear = !1
    const i = this._lodPlanes.length
    for (let a = 1; a < i; a++) {
      const o = Math.sqrt(
          this._sigmas[a] * this._sigmas[a] -
            this._sigmas[a - 1] * this._sigmas[a - 1],
        ),
        s = M2[(i - a - 1) % M2.length]
      this._blur(t, a - 1, a, o, s)
    }
    e.autoClear = n
  }
  _blur(t, e, n, i, a) {
    const o = this._pingPongRenderTarget
    this._halfBlur(t, o, e, n, i, 'latitudinal', a),
      this._halfBlur(o, t, n, n, i, 'longitudinal', a)
  }
  _halfBlur(t, e, n, i, a, o, s) {
    const l = this._renderer,
      u = this._blurMaterial
    o !== 'latitudinal' &&
      o !== 'longitudinal' &&
      console.error(
        'blur direction must be either latitudinal or longitudinal!',
      )
    const c = 3,
      h = new De(this._lodPlanes[i], u),
      f = u.uniforms,
      d = this._sizeLods[n] - 1,
      p = isFinite(a) ? Math.PI / (2 * d) : (2 * Math.PI) / (2 * cu - 1),
      g = a / p,
      v = isFinite(a) ? 1 + Math.floor(c * g) : cu
    v > cu &&
      console.warn(
        `sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${cu}`,
      )
    const m = []
    let y = 0
    for (let b = 0; b < cu; ++b) {
      const T = b / g,
        w = Math.exp((-T * T) / 2)
      m.push(w), b === 0 ? (y += w) : b < v && (y += 2 * w)
    }
    for (let b = 0; b < m.length; b++) m[b] = m[b] / y
    ;(f.envMap.value = t.texture),
      (f.samples.value = v),
      (f.weights.value = m),
      (f.latitudinal.value = o === 'latitudinal'),
      s && (f.poleAxis.value = s)
    const {_lodMax: _} = this
    ;(f.dTheta.value = p), (f.mipInt.value = _ - n)
    const x = this._sizeLods[i],
      A = 3 * x * (i > _ - ph ? i - _ + ph : 0),
      S = 4 * (this._cubeSize - x)
    rg(e, A, S, 3 * x, 2 * x), l.setRenderTarget(e), l.render(h, ex)
  }
}
function W7(r) {
  const t = [],
    e = [],
    n = []
  let i = r
  const a = r - ph + 1 + b2.length
  for (let o = 0; o < a; o++) {
    const s = Math.pow(2, i)
    e.push(s)
    let l = 1 / s
    o > r - ph ? (l = b2[o - r + ph - 1]) : o === 0 && (l = 0), n.push(l)
    const u = 1 / (s - 2),
      c = -u,
      h = 1 + u,
      f = [c, c, h, c, h, h, c, c, h, h, c, h],
      d = 6,
      p = 6,
      g = 3,
      v = 2,
      m = 1,
      y = new Float32Array(g * p * d),
      _ = new Float32Array(v * p * d),
      x = new Float32Array(m * p * d)
    for (let S = 0; S < d; S++) {
      const b = ((S % 3) * 2) / 3 - 1,
        T = S > 2 ? 0 : -1,
        w = [
          b,
          T,
          0,
          b + 2 / 3,
          T,
          0,
          b + 2 / 3,
          T + 1,
          0,
          b,
          T,
          0,
          b + 2 / 3,
          T + 1,
          0,
          b,
          T + 1,
          0,
        ]
      y.set(w, g * p * S), _.set(f, v * p * S)
      const M = [S, S, S, S, S, S]
      x.set(M, m * p * S)
    }
    const A = new Mn()
    A.setAttribute('position', new ir(y, g)),
      A.setAttribute('uv', new ir(_, v)),
      A.setAttribute('faceIndex', new ir(x, m)),
      t.push(A),
      i > ph && i--
  }
  return {
    lodPlanes: t,
    sizeLods: e,
    sigmas: n,
  }
}
function C2(r, t, e) {
  const n = new Vu(r, t, e)
  return (
    (n.texture.mapping = R0),
    (n.texture.name = 'PMREM.cubeUv'),
    (n.scissorTest = !0),
    n
  )
}
function rg(r, t, e, n, i) {
  r.viewport.set(t, e, n, i), r.scissor.set(t, e, n, i)
}
function X7(r, t, e) {
  const n = new Float32Array(cu),
    i = new U(0, 1, 0)
  return new lo({
    name: 'SphericalGaussianBlur',
    defines: {
      n: cu,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: {
        value: null,
      },
      samples: {
        value: 1,
      },
      weights: {
        value: n,
      },
      latitudinal: {
        value: !1,
      },
      dTheta: {
        value: 0,
      },
      mipInt: {
        value: 0,
      },
      poleAxis: {
        value: i,
      },
    },
    vertexShader: FM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  })
}
function E2() {
  return new lo({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      envMap: {
        value: null,
      },
    },
    vertexShader: FM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  })
}
function D2() {
  return new lo({
    name: 'CubemapToCubeUV',
    uniforms: {
      envMap: {
        value: null,
      },
      flipEnvMap: {
        value: -1,
      },
    },
    vertexShader: FM(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Xs,
    depthTest: !1,
    depthWrite: !1,
  })
}
function FM() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function Y7(r) {
  let t = new WeakMap(),
    e = null
  function n(s) {
    if (s && s.isTexture) {
      const l = s.mapping,
        u = l === mA || l === yA,
        c = l === Fh || l === zh
      if (u || c) {
        let h = t.get(s)
        const f = h !== void 0 ? h.texture.pmremVersion : 0
        if (s.isRenderTargetTexture && s.pmremVersion !== f)
          return (
            e === null && (e = new T2(r)),
            (h = u ? e.fromEquirectangular(s, h) : e.fromCubemap(s, h)),
            (h.texture.pmremVersion = s.pmremVersion),
            t.set(s, h),
            h.texture
          )
        if (h !== void 0) return h.texture
        {
          const d = s.image
          return (u && d && d.height > 0) || (c && d && i(d))
            ? (e === null && (e = new T2(r)),
              (h = u ? e.fromEquirectangular(s) : e.fromCubemap(s)),
              (h.texture.pmremVersion = s.pmremVersion),
              t.set(s, h),
              s.addEventListener('dispose', a),
              h.texture)
            : null
        }
      }
    }
    return s
  }
  function i(s) {
    let l = 0
    const u = 6
    for (let c = 0; c < u; c++) s[c] !== void 0 && l++
    return l === u
  }
  function a(s) {
    const l = s.target
    l.removeEventListener('dispose', a)
    const u = t.get(l)
    u !== void 0 && (t.delete(l), u.dispose())
  }
  function o() {
    ;(t = new WeakMap()), e !== null && (e.dispose(), (e = null))
  }
  return {
    get: n,
    dispose: o,
  }
}
function $7(r) {
  const t = {}
  function e(n) {
    if (t[n] !== void 0) return t[n]
    let i
    switch (n) {
      case 'WEBGL_depth_texture':
        i =
          r.getExtension('WEBGL_depth_texture') ||
          r.getExtension('MOZ_WEBGL_depth_texture') ||
          r.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        i =
          r.getExtension('EXT_texture_filter_anisotropic') ||
          r.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          r.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        i =
          r.getExtension('WEBGL_compressed_texture_s3tc') ||
          r.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        i =
          r.getExtension('WEBGL_compressed_texture_pvrtc') ||
          r.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        i = r.getExtension(n)
    }
    return (t[n] = i), i
  }
  return {
    has: function (n) {
      return e(n) !== null
    },
    init: function () {
      e('EXT_color_buffer_float'),
        e('WEBGL_clip_cull_distance'),
        e('OES_texture_float_linear'),
        e('EXT_color_buffer_half_float'),
        e('WEBGL_multisampled_render_to_texture'),
        e('WEBGL_render_shared_exponent')
    },
    get: function (n) {
      const i = e(n)
      return (
        i === null &&
          OM('THREE.WebGLRenderer: ' + n + ' extension not supported.'),
        i
      )
    },
  }
}
function q7(r, t, e, n) {
  const i = {},
    a = new WeakMap()
  function o(h) {
    const f = h.target
    f.index !== null && t.remove(f.index)
    for (const p in f.attributes) t.remove(f.attributes[p])
    for (const p in f.morphAttributes) {
      const g = f.morphAttributes[p]
      for (let v = 0, m = g.length; v < m; v++) t.remove(g[v])
    }
    f.removeEventListener('dispose', o), delete i[f.id]
    const d = a.get(f)
    d && (t.remove(d), a.delete(f)),
      n.releaseStatesOfGeometry(f),
      f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
      e.memory.geometries--
  }
  function s(h, f) {
    return (
      i[f.id] === !0 ||
        (f.addEventListener('dispose', o),
        (i[f.id] = !0),
        e.memory.geometries++),
      f
    )
  }
  function l(h) {
    const f = h.attributes
    for (const p in f) t.update(f[p], r.ARRAY_BUFFER)
    const d = h.morphAttributes
    for (const p in d) {
      const g = d[p]
      for (let v = 0, m = g.length; v < m; v++) t.update(g[v], r.ARRAY_BUFFER)
    }
  }
  function u(h) {
    const f = [],
      d = h.index,
      p = h.attributes.position
    let g = 0
    if (d !== null) {
      const y = d.array
      g = d.version
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const A = y[_ + 0],
          S = y[_ + 1],
          b = y[_ + 2]
        f.push(A, S, S, b, b, A)
      }
    } else if (p !== void 0) {
      const y = p.array
      g = p.version
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const A = _ + 0,
          S = _ + 1,
          b = _ + 2
        f.push(A, S, S, b, b, A)
      }
    } else return
    const v = new (Zk(f) ? tB : Qk)(f, 1)
    v.version = g
    const m = a.get(h)
    m && t.remove(m), a.set(h, v)
  }
  function c(h) {
    const f = a.get(h)
    if (f) {
      const d = h.index
      d !== null && f.version < d.version && u(h)
    } else u(h)
    return a.get(h)
  }
  return {
    get: s,
    update: l,
    getWireframeAttribute: c,
  }
}
function Z7(r, t, e) {
  let n
  function i(f) {
    n = f
  }
  let a, o
  function s(f) {
    ;(a = f.type), (o = f.bytesPerElement)
  }
  function l(f, d) {
    r.drawElements(n, d, a, f * o), e.update(d, n, 1)
  }
  function u(f, d, p) {
    p !== 0 && (r.drawElementsInstanced(n, d, a, f * o, p), e.update(d, n, p))
  }
  function c(f, d, p) {
    if (p === 0) return
    t.get('WEBGL_multi_draw').multiDrawElementsWEBGL(n, d, 0, a, f, 0, p)
    let v = 0
    for (let m = 0; m < p; m++) v += d[m]
    e.update(v, n, 1)
  }
  function h(f, d, p, g) {
    if (p === 0) return
    const v = t.get('WEBGL_multi_draw')
    if (v === null) for (let m = 0; m < f.length; m++) u(f[m] / o, d[m], g[m])
    else {
      v.multiDrawElementsInstancedWEBGL(n, d, 0, a, f, 0, g, 0, p)
      let m = 0
      for (let y = 0; y < p; y++) m += d[y]
      for (let y = 0; y < g.length; y++) e.update(m, n, g[y])
    }
  }
  ;(this.setMode = i),
    (this.setIndex = s),
    (this.render = l),
    (this.renderInstances = u),
    (this.renderMultiDraw = c),
    (this.renderMultiDrawInstances = h)
}
function K7(r) {
  const t = {
      geometries: 0,
      textures: 0,
    },
    e = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
    }
  function n(a, o, s) {
    switch ((e.calls++, o)) {
      case r.TRIANGLES:
        e.triangles += s * (a / 3)
        break
      case r.LINES:
        e.lines += s * (a / 2)
        break
      case r.LINE_STRIP:
        e.lines += s * (a - 1)
        break
      case r.LINE_LOOP:
        e.lines += s * a
        break
      case r.POINTS:
        e.points += s * a
        break
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', o)
        break
    }
  }
  function i() {
    ;(e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0)
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  }
}
function j7(r, t, e) {
  const n = new WeakMap(),
    i = new Oe()
  function a(o, s, l) {
    const u = o.morphTargetInfluences,
      c =
        s.morphAttributes.position ||
        s.morphAttributes.normal ||
        s.morphAttributes.color,
      h = c !== void 0 ? c.length : 0
    let f = n.get(s)
    if (f === void 0 || f.count !== h) {
      let w = function () {
        b.dispose(), n.delete(s), s.removeEventListener('dispose', w)
      }
      f !== void 0 && f.texture.dispose()
      const d = s.morphAttributes.position !== void 0,
        p = s.morphAttributes.normal !== void 0,
        g = s.morphAttributes.color !== void 0,
        v = s.morphAttributes.position || [],
        m = s.morphAttributes.normal || [],
        y = s.morphAttributes.color || []
      let _ = 0
      d === !0 && (_ = 1), p === !0 && (_ = 2), g === !0 && (_ = 3)
      let x = s.attributes.position.count * _,
        A = 1
      x > t.maxTextureSize &&
        ((A = Math.ceil(x / t.maxTextureSize)), (x = t.maxTextureSize))
      const S = new Float32Array(x * A * 4 * h),
        b = new jk(S, x, A, h)
      ;(b.type = ya), (b.needsUpdate = !0)
      const T = _ * 4
      for (let M = 0; M < h; M++) {
        const C = v[M],
          E = m[M],
          D = y[M],
          P = x * A * 4 * M
        for (let L = 0; L < C.count; L++) {
          const I = L * T
          d === !0 &&
            (i.fromBufferAttribute(C, L),
            (S[P + I + 0] = i.x),
            (S[P + I + 1] = i.y),
            (S[P + I + 2] = i.z),
            (S[P + I + 3] = 0)),
            p === !0 &&
              (i.fromBufferAttribute(E, L),
              (S[P + I + 4] = i.x),
              (S[P + I + 5] = i.y),
              (S[P + I + 6] = i.z),
              (S[P + I + 7] = 0)),
            g === !0 &&
              (i.fromBufferAttribute(D, L),
              (S[P + I + 8] = i.x),
              (S[P + I + 9] = i.y),
              (S[P + I + 10] = i.z),
              (S[P + I + 11] = D.itemSize === 4 ? i.w : 1))
        }
      }
      ;(f = {
        count: h,
        texture: b,
        size: new pt(x, A),
      }),
        n.set(s, f),
        s.addEventListener('dispose', w)
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(r, 'morphTexture', o.morphTexture, e)
    else {
      let d = 0
      for (let g = 0; g < u.length; g++) d += u[g]
      const p = s.morphTargetsRelative ? 1 : 1 - d
      l.getUniforms().setValue(r, 'morphTargetBaseInfluence', p),
        l.getUniforms().setValue(r, 'morphTargetInfluences', u)
    }
    l.getUniforms().setValue(r, 'morphTargetsTexture', f.texture, e),
      l.getUniforms().setValue(r, 'morphTargetsTextureSize', f.size)
  }
  return {
    update: a,
  }
}
function J7(r, t, e, n) {
  let i = new WeakMap()
  function a(l) {
    const u = n.render.frame,
      c = l.geometry,
      h = t.get(l, c)
    if (
      (i.get(h) !== u && (t.update(h), i.set(h, u)),
      l.isInstancedMesh &&
        (l.hasEventListener('dispose', s) === !1 &&
          l.addEventListener('dispose', s),
        i.get(l) !== u &&
          (e.update(l.instanceMatrix, r.ARRAY_BUFFER),
          l.instanceColor !== null && e.update(l.instanceColor, r.ARRAY_BUFFER),
          i.set(l, u))),
      l.isSkinnedMesh)
    ) {
      const f = l.skeleton
      i.get(f) !== u && (f.update(), i.set(f, u))
    }
    return h
  }
  function o() {
    i = new WeakMap()
  }
  function s(l) {
    const u = l.target
    u.removeEventListener('dispose', s),
      e.remove(u.instanceMatrix),
      u.instanceColor !== null && e.remove(u.instanceColor)
  }
  return {
    update: a,
    dispose: o,
  }
}
class aB extends Yn {
  constructor(t, e, n, i, a, o, s, l, u, c = wh) {
    if (c !== wh && c !== Vh)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      )
    n === void 0 && c === wh && (n = Uu),
      n === void 0 && c === Vh && (n = Uh),
      super(null, i, a, o, s, l, c, n, u),
      (this.isDepthTexture = !0),
      (this.image = {
        width: t,
        height: e,
      }),
      (this.magFilter = s !== void 0 ? s : Ur),
      (this.minFilter = l !== void 0 ? l : Ur),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null)
  }
  copy(t) {
    return super.copy(t), (this.compareFunction = t.compareFunction), this
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      this.compareFunction !== null &&
        (e.compareFunction = this.compareFunction),
      e
    )
  }
}
const oB = new Yn(),
  L2 = new aB(1, 1),
  sB = new jk(),
  lB = new z6(),
  uB = new rB(),
  P2 = [],
  R2 = [],
  I2 = new Float32Array(16),
  O2 = new Float32Array(9),
  N2 = new Float32Array(4)
function ff(r, t, e) {
  const n = r[0]
  if (n <= 0 || n > 0) return r
  const i = t * e
  let a = P2[i]
  if ((a === void 0 && ((a = new Float32Array(i)), (P2[i] = a)), t !== 0)) {
    n.toArray(a, 0)
    for (let o = 1, s = 0; o !== t; ++o) (s += e), r[o].toArray(a, s)
  }
  return a
}
function $n(r, t) {
  if (r.length !== t.length) return !1
  for (let e = 0, n = r.length; e < n; e++) if (r[e] !== t[e]) return !1
  return !0
}
function qn(r, t) {
  for (let e = 0, n = t.length; e < n; e++) r[e] = t[e]
}
function N0(r, t) {
  let e = R2[t]
  e === void 0 && ((e = new Int32Array(t)), (R2[t] = e))
  for (let n = 0; n !== t; ++n) e[n] = r.allocateTextureUnit()
  return e
}
function Q7(r, t) {
  const e = this.cache
  e[0] !== t && (r.uniform1f(this.addr, t), (e[0] = t))
}
function tX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (r.uniform2f(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y))
  else {
    if ($n(e, t)) return
    r.uniform2fv(this.addr, t), qn(e, t)
  }
}
function eX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (r.uniform3f(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z))
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) &&
      (r.uniform3f(this.addr, t.r, t.g, t.b),
      (e[0] = t.r),
      (e[1] = t.g),
      (e[2] = t.b))
  else {
    if ($n(e, t)) return
    r.uniform3fv(this.addr, t), qn(e, t)
  }
}
function nX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (r.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w))
  else {
    if ($n(e, t)) return
    r.uniform4fv(this.addr, t), qn(e, t)
  }
}
function rX(r, t) {
  const e = this.cache,
    n = t.elements
  if (n === void 0) {
    if ($n(e, t)) return
    r.uniformMatrix2fv(this.addr, !1, t), qn(e, t)
  } else {
    if ($n(e, n)) return
    N2.set(n), r.uniformMatrix2fv(this.addr, !1, N2), qn(e, n)
  }
}
function iX(r, t) {
  const e = this.cache,
    n = t.elements
  if (n === void 0) {
    if ($n(e, t)) return
    r.uniformMatrix3fv(this.addr, !1, t), qn(e, t)
  } else {
    if ($n(e, n)) return
    O2.set(n), r.uniformMatrix3fv(this.addr, !1, O2), qn(e, n)
  }
}
function aX(r, t) {
  const e = this.cache,
    n = t.elements
  if (n === void 0) {
    if ($n(e, t)) return
    r.uniformMatrix4fv(this.addr, !1, t), qn(e, t)
  } else {
    if ($n(e, n)) return
    I2.set(n), r.uniformMatrix4fv(this.addr, !1, I2), qn(e, n)
  }
}
function oX(r, t) {
  const e = this.cache
  e[0] !== t && (r.uniform1i(this.addr, t), (e[0] = t))
}
function sX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (r.uniform2i(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y))
  else {
    if ($n(e, t)) return
    r.uniform2iv(this.addr, t), qn(e, t)
  }
}
function lX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (r.uniform3i(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z))
  else {
    if ($n(e, t)) return
    r.uniform3iv(this.addr, t), qn(e, t)
  }
}
function uX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (r.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w))
  else {
    if ($n(e, t)) return
    r.uniform4iv(this.addr, t), qn(e, t)
  }
}
function cX(r, t) {
  const e = this.cache
  e[0] !== t && (r.uniform1ui(this.addr, t), (e[0] = t))
}
function hX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (r.uniform2ui(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y))
  else {
    if ($n(e, t)) return
    r.uniform2uiv(this.addr, t), qn(e, t)
  }
}
function fX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (r.uniform3ui(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z))
  else {
    if ($n(e, t)) return
    r.uniform3uiv(this.addr, t), qn(e, t)
  }
}
function dX(r, t) {
  const e = this.cache
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (r.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w))
  else {
    if ($n(e, t)) return
    r.uniform4uiv(this.addr, t), qn(e, t)
  }
}
function pX(r, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit()
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i))
  let a
  this.type === r.SAMPLER_2D_SHADOW
    ? ((L2.compareFunction = qk), (a = L2))
    : (a = oB),
    e.setTexture2D(t || a, i)
}
function vX(r, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit()
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    e.setTexture3D(t || lB, i)
}
function gX(r, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit()
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    e.setTextureCube(t || uB, i)
}
function mX(r, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit()
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    e.setTexture2DArray(t || sB, i)
}
function yX(r) {
  switch (r) {
    case 5126:
      return Q7
    case 35664:
      return tX
    case 35665:
      return eX
    case 35666:
      return nX
    case 35674:
      return rX
    case 35675:
      return iX
    case 35676:
      return aX
    case 5124:
    case 35670:
      return oX
    case 35667:
    case 35671:
      return sX
    case 35668:
    case 35672:
      return lX
    case 35669:
    case 35673:
      return uX
    case 5125:
      return cX
    case 36294:
      return hX
    case 36295:
      return fX
    case 36296:
      return dX
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return pX
    case 35679:
    case 36299:
    case 36307:
      return vX
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return gX
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return mX
  }
}
function _X(r, t) {
  r.uniform1fv(this.addr, t)
}
function xX(r, t) {
  const e = ff(t, this.size, 2)
  r.uniform2fv(this.addr, e)
}
function SX(r, t) {
  const e = ff(t, this.size, 3)
  r.uniform3fv(this.addr, e)
}
function AX(r, t) {
  const e = ff(t, this.size, 4)
  r.uniform4fv(this.addr, e)
}
function bX(r, t) {
  const e = ff(t, this.size, 4)
  r.uniformMatrix2fv(this.addr, !1, e)
}
function wX(r, t) {
  const e = ff(t, this.size, 9)
  r.uniformMatrix3fv(this.addr, !1, e)
}
function MX(r, t) {
  const e = ff(t, this.size, 16)
  r.uniformMatrix4fv(this.addr, !1, e)
}
function TX(r, t) {
  r.uniform1iv(this.addr, t)
}
function CX(r, t) {
  r.uniform2iv(this.addr, t)
}
function EX(r, t) {
  r.uniform3iv(this.addr, t)
}
function DX(r, t) {
  r.uniform4iv(this.addr, t)
}
function LX(r, t) {
  r.uniform1uiv(this.addr, t)
}
function PX(r, t) {
  r.uniform2uiv(this.addr, t)
}
function RX(r, t) {
  r.uniform3uiv(this.addr, t)
}
function IX(r, t) {
  r.uniform4uiv(this.addr, t)
}
function OX(r, t, e) {
  const n = this.cache,
    i = t.length,
    a = N0(e, i)
  $n(n, a) || (r.uniform1iv(this.addr, a), qn(n, a))
  for (let o = 0; o !== i; ++o) e.setTexture2D(t[o] || oB, a[o])
}
function NX(r, t, e) {
  const n = this.cache,
    i = t.length,
    a = N0(e, i)
  $n(n, a) || (r.uniform1iv(this.addr, a), qn(n, a))
  for (let o = 0; o !== i; ++o) e.setTexture3D(t[o] || lB, a[o])
}
function kX(r, t, e) {
  const n = this.cache,
    i = t.length,
    a = N0(e, i)
  $n(n, a) || (r.uniform1iv(this.addr, a), qn(n, a))
  for (let o = 0; o !== i; ++o) e.setTextureCube(t[o] || uB, a[o])
}
function BX(r, t, e) {
  const n = this.cache,
    i = t.length,
    a = N0(e, i)
  $n(n, a) || (r.uniform1iv(this.addr, a), qn(n, a))
  for (let o = 0; o !== i; ++o) e.setTexture2DArray(t[o] || sB, a[o])
}
function FX(r) {
  switch (r) {
    case 5126:
      return _X
    case 35664:
      return xX
    case 35665:
      return SX
    case 35666:
      return AX
    case 35674:
      return bX
    case 35675:
      return wX
    case 35676:
      return MX
    case 5124:
    case 35670:
      return TX
    case 35667:
    case 35671:
      return CX
    case 35668:
    case 35672:
      return EX
    case 35669:
    case 35673:
      return DX
    case 5125:
      return LX
    case 36294:
      return PX
    case 36295:
      return RX
    case 36296:
      return IX
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return OX
    case 35679:
    case 36299:
    case 36307:
      return NX
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return kX
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return BX
  }
}
class zX {
  constructor(t, e, n) {
    ;(this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.setValue = yX(e.type))
  }
}
class UX {
  constructor(t, e, n) {
    ;(this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.type = e.type),
      (this.size = e.size),
      (this.setValue = FX(e.type))
  }
}
class VX {
  constructor(t) {
    ;(this.id = t), (this.seq = []), (this.map = {})
  }
  setValue(t, e, n) {
    const i = this.seq
    for (let a = 0, o = i.length; a !== o; ++a) {
      const s = i[a]
      s.setValue(t, e[s.id], n)
    }
  }
}
const ox = /(\w+)(\])?(\[|\.)?/g
function k2(r, t) {
  r.seq.push(t), (r.map[t.id] = t)
}
function GX(r, t, e) {
  const n = r.name,
    i = n.length
  for (ox.lastIndex = 0; ; ) {
    const a = ox.exec(n),
      o = ox.lastIndex
    let s = a[1]
    const l = a[2] === ']',
      u = a[3]
    if ((l && (s = s | 0), u === void 0 || (u === '[' && o + 2 === i))) {
      k2(e, u === void 0 ? new zX(s, r, t) : new UX(s, r, t))
      break
    } else {
      let h = e.map[s]
      h === void 0 && ((h = new VX(s)), k2(e, h)), (e = h)
    }
  }
}
class zm {
  constructor(t, e) {
    ;(this.seq = []), (this.map = {})
    const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS)
    for (let i = 0; i < n; ++i) {
      const a = t.getActiveUniform(e, i),
        o = t.getUniformLocation(e, a.name)
      GX(a, o, this)
    }
  }
  setValue(t, e, n, i) {
    const a = this.map[e]
    a !== void 0 && a.setValue(t, n, i)
  }
  setOptional(t, e, n) {
    const i = e[n]
    i !== void 0 && this.setValue(t, n, i)
  }
  static upload(t, e, n, i) {
    for (let a = 0, o = e.length; a !== o; ++a) {
      const s = e[a],
        l = n[s.id]
      l.needsUpdate !== !1 && s.setValue(t, l.value, i)
    }
  }
  static seqWithValue(t, e) {
    const n = []
    for (let i = 0, a = t.length; i !== a; ++i) {
      const o = t[i]
      o.id in e && n.push(o)
    }
    return n
  }
}
function B2(r, t, e) {
  const n = r.createShader(t)
  return r.shaderSource(n, e), r.compileShader(n), n
}
const HX = 37297
let WX = 0
function XX(r, t) {
  const e = r.split(`
`),
    n = [],
    i = Math.max(t - 6, 0),
    a = Math.min(t + 6, e.length)
  for (let o = i; o < a; o++) {
    const s = o + 1
    n.push(`${s === t ? '>' : ' '} ${s}: ${e[o]}`)
  }
  return n.join(`
`)
}
function YX(r) {
  const t = Be.getPrimaries(Be.workingColorSpace),
    e = Be.getPrimaries(r)
  let n
  switch (
    (t === e
      ? (n = '')
      : t === my && e === gy
      ? (n = 'LinearDisplayP3ToLinearSRGB')
      : t === gy && e === my && (n = 'LinearSRGBToLinearDisplayP3'),
    r)
  ) {
    case ar:
    case I0:
      return [n, 'LinearTransferOETF']
    case cn:
    case PM:
      return [n, 'sRGBTransferOETF']
    default:
      return (
        console.warn('THREE.WebGLProgram: Unsupported color space:', r),
        [n, 'LinearTransferOETF']
      )
  }
}
function F2(r, t, e) {
  const n = r.getShaderParameter(t, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(t).trim()
  if (n && i === '') return ''
  const a = /ERROR: 0:(\d+)/.exec(i)
  if (a) {
    const o = parseInt(a[1])
    return (
      e.toUpperCase() +
      `

` +
      i +
      `

` +
      XX(r.getShaderSource(t), o)
    )
  } else return i
}
function $X(r, t) {
  const e = YX(t)
  return `vec4 ${r}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`
}
function qX(r, t) {
  let e
  switch (t) {
    case K8:
      e = 'Linear'
      break
    case j8:
      e = 'Reinhard'
      break
    case J8:
      e = 'OptimizedCineon'
      break
    case Q8:
      e = 'ACESFilmic'
      break
    case e6:
      e = 'AgX'
      break
    case n6:
      e = 'Neutral'
      break
    case t6:
      e = 'Custom'
      break
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', t),
        (e = 'Linear')
  }
  return (
    'vec3 ' + r + '( vec3 color ) { return ' + e + 'ToneMapping( color ); }'
  )
}
function ZX(r) {
  return [
    r.extensionClipCullDistance
      ? '#extension GL_ANGLE_clip_cull_distance : require'
      : '',
    r.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
  ].filter(Dd).join(`
`)
}
function KX(r) {
  const t = []
  for (const e in r) {
    const n = r[e]
    n !== !1 && t.push('#define ' + e + ' ' + n)
  }
  return t.join(`
`)
}
function jX(r, t) {
  const e = {},
    n = r.getProgramParameter(t, r.ACTIVE_ATTRIBUTES)
  for (let i = 0; i < n; i++) {
    const a = r.getActiveAttrib(t, i),
      o = a.name
    let s = 1
    a.type === r.FLOAT_MAT2 && (s = 2),
      a.type === r.FLOAT_MAT3 && (s = 3),
      a.type === r.FLOAT_MAT4 && (s = 4),
      (e[o] = {
        type: a.type,
        location: r.getAttribLocation(t, o),
        locationSize: s,
      })
  }
  return e
}
function Dd(r) {
  return r !== ''
}
function z2(r, t) {
  const e =
    t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps
  return r
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, e)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}
function U2(r, t) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection,
    )
}
const JX = /^[ \t]*#include +<([\w\d./]+)>/gm
function $A(r) {
  return r.replace(JX, tY)
}
const QX = new Map()
function tY(r, t) {
  let e = me[t]
  if (e === void 0) {
    const n = QX.get(t)
    if (n !== void 0)
      (e = me[n]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          t,
          n,
        )
    else throw new Error('Can not resolve #include <' + t + '>')
  }
  return $A(e)
}
const eY =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function V2(r) {
  return r.replace(eY, nY)
}
function nY(r, t, e, n) {
  let i = ''
  for (let a = parseInt(t); a < parseInt(e); a++)
    i += n
      .replace(/\[\s*i\s*\]/g, '[ ' + a + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, a)
  return i
}
function G2(r) {
  let t = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`
  return (
    r.precision === 'highp'
      ? (t += `
#define HIGH_PRECISION`)
      : r.precision === 'mediump'
      ? (t += `
#define MEDIUM_PRECISION`)
      : r.precision === 'lowp' &&
        (t += `
#define LOW_PRECISION`),
    t
  )
}
function rY(r) {
  let t = 'SHADOWMAP_TYPE_BASIC'
  return (
    r.shadowMapType === Nk
      ? (t = 'SHADOWMAP_TYPE_PCF')
      : r.shadowMapType === A8
      ? (t = 'SHADOWMAP_TYPE_PCF_SOFT')
      : r.shadowMapType === Po && (t = 'SHADOWMAP_TYPE_VSM'),
    t
  )
}
function iY(r) {
  let t = 'ENVMAP_TYPE_CUBE'
  if (r.envMap)
    switch (r.envMapMode) {
      case Fh:
      case zh:
        t = 'ENVMAP_TYPE_CUBE'
        break
      case R0:
        t = 'ENVMAP_TYPE_CUBE_UV'
        break
    }
  return t
}
function aY(r) {
  let t = 'ENVMAP_MODE_REFLECTION'
  if (r.envMap)
    switch (r.envMapMode) {
      case zh:
        t = 'ENVMAP_MODE_REFRACTION'
        break
    }
  return t
}
function oY(r) {
  let t = 'ENVMAP_BLENDING_NONE'
  if (r.envMap)
    switch (r.combine) {
      case AM:
        t = 'ENVMAP_BLENDING_MULTIPLY'
        break
      case q8:
        t = 'ENVMAP_BLENDING_MIX'
        break
      case Z8:
        t = 'ENVMAP_BLENDING_ADD'
        break
    }
  return t
}
function sY(r) {
  const t = r.envMapCubeUVHeight
  if (t === null) return null
  const e = Math.log2(t) - 2,
    n = 1 / t
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)),
    texelHeight: n,
    maxMip: e,
  }
}
function lY(r, t, e, n) {
  const i = r.getContext(),
    a = e.defines
  let o = e.vertexShader,
    s = e.fragmentShader
  const l = rY(e),
    u = iY(e),
    c = aY(e),
    h = oY(e),
    f = sY(e),
    d = ZX(e),
    p = KX(a),
    g = i.createProgram()
  let v,
    m,
    y = e.glslVersion
      ? '#version ' +
        e.glslVersion +
        `
`
      : ''
  e.isRawShaderMaterial
    ? ((v = [
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        p,
      ].filter(Dd).join(`
`)),
      v.length > 0 &&
        (v += `
`),
      (m = [
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        p,
      ].filter(Dd).join(`
`)),
      m.length > 0 &&
        (m += `
`))
    : ((v = [
        G2(e),
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        p,
        e.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
        e.batching ? '#define USE_BATCHING' : '',
        e.batchingColor ? '#define USE_BATCHING_COLOR' : '',
        e.instancing ? '#define USE_INSTANCING' : '',
        e.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
        e.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
        e.useFog && e.fog ? '#define USE_FOG' : '',
        e.useFog && e.fogExp2 ? '#define FOG_EXP2' : '',
        e.map ? '#define USE_MAP' : '',
        e.envMap ? '#define USE_ENVMAP' : '',
        e.envMap ? '#define ' + c : '',
        e.lightMap ? '#define USE_LIGHTMAP' : '',
        e.aoMap ? '#define USE_AOMAP' : '',
        e.bumpMap ? '#define USE_BUMPMAP' : '',
        e.normalMap ? '#define USE_NORMALMAP' : '',
        e.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        e.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        e.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
        e.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        e.anisotropy ? '#define USE_ANISOTROPY' : '',
        e.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        e.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        e.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        e.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        e.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        e.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        e.specularMap ? '#define USE_SPECULARMAP' : '',
        e.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        e.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        e.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        e.metalnessMap ? '#define USE_METALNESSMAP' : '',
        e.alphaMap ? '#define USE_ALPHAMAP' : '',
        e.alphaHash ? '#define USE_ALPHAHASH' : '',
        e.transmission ? '#define USE_TRANSMISSION' : '',
        e.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        e.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        e.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        e.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        e.mapUv ? '#define MAP_UV ' + e.mapUv : '',
        e.alphaMapUv ? '#define ALPHAMAP_UV ' + e.alphaMapUv : '',
        e.lightMapUv ? '#define LIGHTMAP_UV ' + e.lightMapUv : '',
        e.aoMapUv ? '#define AOMAP_UV ' + e.aoMapUv : '',
        e.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + e.emissiveMapUv : '',
        e.bumpMapUv ? '#define BUMPMAP_UV ' + e.bumpMapUv : '',
        e.normalMapUv ? '#define NORMALMAP_UV ' + e.normalMapUv : '',
        e.displacementMapUv
          ? '#define DISPLACEMENTMAP_UV ' + e.displacementMapUv
          : '',
        e.metalnessMapUv ? '#define METALNESSMAP_UV ' + e.metalnessMapUv : '',
        e.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + e.roughnessMapUv : '',
        e.anisotropyMapUv
          ? '#define ANISOTROPYMAP_UV ' + e.anisotropyMapUv
          : '',
        e.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + e.clearcoatMapUv : '',
        e.clearcoatNormalMapUv
          ? '#define CLEARCOAT_NORMALMAP_UV ' + e.clearcoatNormalMapUv
          : '',
        e.clearcoatRoughnessMapUv
          ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + e.clearcoatRoughnessMapUv
          : '',
        e.iridescenceMapUv
          ? '#define IRIDESCENCEMAP_UV ' + e.iridescenceMapUv
          : '',
        e.iridescenceThicknessMapUv
          ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + e.iridescenceThicknessMapUv
          : '',
        e.sheenColorMapUv
          ? '#define SHEEN_COLORMAP_UV ' + e.sheenColorMapUv
          : '',
        e.sheenRoughnessMapUv
          ? '#define SHEEN_ROUGHNESSMAP_UV ' + e.sheenRoughnessMapUv
          : '',
        e.specularMapUv ? '#define SPECULARMAP_UV ' + e.specularMapUv : '',
        e.specularColorMapUv
          ? '#define SPECULAR_COLORMAP_UV ' + e.specularColorMapUv
          : '',
        e.specularIntensityMapUv
          ? '#define SPECULAR_INTENSITYMAP_UV ' + e.specularIntensityMapUv
          : '',
        e.transmissionMapUv
          ? '#define TRANSMISSIONMAP_UV ' + e.transmissionMapUv
          : '',
        e.thicknessMapUv ? '#define THICKNESSMAP_UV ' + e.thicknessMapUv : '',
        e.vertexTangents && e.flatShading === !1 ? '#define USE_TANGENT' : '',
        e.vertexColors ? '#define USE_COLOR' : '',
        e.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        e.vertexUv1s ? '#define USE_UV1' : '',
        e.vertexUv2s ? '#define USE_UV2' : '',
        e.vertexUv3s ? '#define USE_UV3' : '',
        e.pointsUvs ? '#define USE_POINTS_UV' : '',
        e.flatShading ? '#define FLAT_SHADED' : '',
        e.skinning ? '#define USE_SKINNING' : '',
        e.morphTargets ? '#define USE_MORPHTARGETS' : '',
        e.morphNormals && e.flatShading === !1
          ? '#define USE_MORPHNORMALS'
          : '',
        e.morphColors ? '#define USE_MORPHCOLORS' : '',
        e.morphTargetsCount > 0
          ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + e.morphTextureStride
          : '',
        e.morphTargetsCount > 0
          ? '#define MORPHTARGETS_COUNT ' + e.morphTargetsCount
          : '',
        e.doubleSided ? '#define DOUBLE_SIDED' : '',
        e.flipSided ? '#define FLIP_SIDED' : '',
        e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        e.shadowMapEnabled ? '#define ' + l : '',
        e.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        e.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        '#ifdef USE_INSTANCING',
        '	attribute mat4 instanceMatrix;',
        '#endif',
        '#ifdef USE_INSTANCING_COLOR',
        '	attribute vec3 instanceColor;',
        '#endif',
        '#ifdef USE_INSTANCING_MORPH',
        '	uniform sampler2D morphTexture;',
        '#endif',
        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',
        '#ifdef USE_UV1',
        '	attribute vec2 uv1;',
        '#endif',
        '#ifdef USE_UV2',
        '	attribute vec2 uv2;',
        '#endif',
        '#ifdef USE_UV3',
        '	attribute vec2 uv3;',
        '#endif',
        '#ifdef USE_TANGENT',
        '	attribute vec4 tangent;',
        '#endif',
        '#if defined( USE_COLOR_ALPHA )',
        '	attribute vec4 color;',
        '#elif defined( USE_COLOR )',
        '	attribute vec3 color;',
        '#endif',
        '#ifdef USE_SKINNING',
        '	attribute vec4 skinIndex;',
        '	attribute vec4 skinWeight;',
        '#endif',
        `
`,
      ].filter(Dd).join(`
`)),
      (m = [
        G2(e),
        '#define SHADER_TYPE ' + e.shaderType,
        '#define SHADER_NAME ' + e.shaderName,
        p,
        e.useFog && e.fog ? '#define USE_FOG' : '',
        e.useFog && e.fogExp2 ? '#define FOG_EXP2' : '',
        e.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
        e.map ? '#define USE_MAP' : '',
        e.matcap ? '#define USE_MATCAP' : '',
        e.envMap ? '#define USE_ENVMAP' : '',
        e.envMap ? '#define ' + u : '',
        e.envMap ? '#define ' + c : '',
        e.envMap ? '#define ' + h : '',
        f ? '#define CUBEUV_TEXEL_WIDTH ' + f.texelWidth : '',
        f ? '#define CUBEUV_TEXEL_HEIGHT ' + f.texelHeight : '',
        f ? '#define CUBEUV_MAX_MIP ' + f.maxMip + '.0' : '',
        e.lightMap ? '#define USE_LIGHTMAP' : '',
        e.aoMap ? '#define USE_AOMAP' : '',
        e.bumpMap ? '#define USE_BUMPMAP' : '',
        e.normalMap ? '#define USE_NORMALMAP' : '',
        e.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
        e.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
        e.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        e.anisotropy ? '#define USE_ANISOTROPY' : '',
        e.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
        e.clearcoat ? '#define USE_CLEARCOAT' : '',
        e.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
        e.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
        e.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
        e.dispersion ? '#define USE_DISPERSION' : '',
        e.iridescence ? '#define USE_IRIDESCENCE' : '',
        e.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
        e.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
        e.specularMap ? '#define USE_SPECULARMAP' : '',
        e.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
        e.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
        e.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        e.metalnessMap ? '#define USE_METALNESSMAP' : '',
        e.alphaMap ? '#define USE_ALPHAMAP' : '',
        e.alphaTest ? '#define USE_ALPHATEST' : '',
        e.alphaHash ? '#define USE_ALPHAHASH' : '',
        e.sheen ? '#define USE_SHEEN' : '',
        e.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
        e.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
        e.transmission ? '#define USE_TRANSMISSION' : '',
        e.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
        e.thicknessMap ? '#define USE_THICKNESSMAP' : '',
        e.vertexTangents && e.flatShading === !1 ? '#define USE_TANGENT' : '',
        e.vertexColors || e.instancingColor || e.batchingColor
          ? '#define USE_COLOR'
          : '',
        e.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
        e.vertexUv1s ? '#define USE_UV1' : '',
        e.vertexUv2s ? '#define USE_UV2' : '',
        e.vertexUv3s ? '#define USE_UV3' : '',
        e.pointsUvs ? '#define USE_POINTS_UV' : '',
        e.gradientMap ? '#define USE_GRADIENTMAP' : '',
        e.flatShading ? '#define FLAT_SHADED' : '',
        e.doubleSided ? '#define DOUBLE_SIDED' : '',
        e.flipSided ? '#define FLIP_SIDED' : '',
        e.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        e.shadowMapEnabled ? '#define ' + l : '',
        e.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
        e.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
        e.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
        e.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',
        'uniform bool isOrthographic;',
        e.toneMapping !== Ys ? '#define TONE_MAPPING' : '',
        e.toneMapping !== Ys ? me.tonemapping_pars_fragment : '',
        e.toneMapping !== Ys ? qX('toneMapping', e.toneMapping) : '',
        e.dithering ? '#define DITHERING' : '',
        e.opaque ? '#define OPAQUE' : '',
        me.colorspace_pars_fragment,
        $X('linearToOutputTexel', e.outputColorSpace),
        e.useDepthPacking ? '#define DEPTH_PACKING ' + e.depthPacking : '',
        `
`,
      ].filter(Dd).join(`
`))),
    (o = $A(o)),
    (o = z2(o, e)),
    (o = U2(o, e)),
    (s = $A(s)),
    (s = z2(s, e)),
    (s = U2(s, e)),
    (o = V2(o)),
    (s = V2(s)),
    e.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (v =
        [
          d,
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture',
        ].join(`
`) +
        `
` +
        v),
      (m =
        [
          '#define varying in',
          e.glslVersion === n2
            ? ''
            : 'layout(location = 0) out highp vec4 pc_fragColor;',
          e.glslVersion === n2 ? '' : '#define gl_FragColor pc_fragColor',
          '#define gl_FragDepthEXT gl_FragDepth',
          '#define texture2D texture',
          '#define textureCube texture',
          '#define texture2DProj textureProj',
          '#define texture2DLodEXT textureLod',
          '#define texture2DProjLodEXT textureProjLod',
          '#define textureCubeLodEXT textureLod',
          '#define texture2DGradEXT textureGrad',
          '#define texture2DProjGradEXT textureProjGrad',
          '#define textureCubeGradEXT textureGrad',
        ].join(`
`) +
        `
` +
        m))
  const _ = y + v + o,
    x = y + m + s,
    A = B2(i, i.VERTEX_SHADER, _),
    S = B2(i, i.FRAGMENT_SHADER, x)
  i.attachShader(g, A),
    i.attachShader(g, S),
    e.index0AttributeName !== void 0
      ? i.bindAttribLocation(g, 0, e.index0AttributeName)
      : e.morphTargets === !0 && i.bindAttribLocation(g, 0, 'position'),
    i.linkProgram(g)
  function b(C) {
    if (r.debug.checkShaderErrors) {
      const E = i.getProgramInfoLog(g).trim(),
        D = i.getShaderInfoLog(A).trim(),
        P = i.getShaderInfoLog(S).trim()
      let L = !0,
        I = !0
      if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
        if (((L = !1), typeof r.debug.onShaderError == 'function'))
          r.debug.onShaderError(i, g, A, S)
        else {
          const F = F2(i, A, 'vertex'),
            k = F2(i, S, 'fragment')
          console.error(
            'THREE.WebGLProgram: Shader Error ' +
              i.getError() +
              ' - VALIDATE_STATUS ' +
              i.getProgramParameter(g, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              C.name +
              `
Material Type: ` +
              C.type +
              `

Program Info Log: ` +
              E +
              `
` +
              F +
              `
` +
              k,
          )
        }
      else
        E !== ''
          ? console.warn('THREE.WebGLProgram: Program Info Log:', E)
          : (D === '' || P === '') && (I = !1)
      I &&
        (C.diagnostics = {
          runnable: L,
          programLog: E,
          vertexShader: {
            log: D,
            prefix: v,
          },
          fragmentShader: {
            log: P,
            prefix: m,
          },
        })
    }
    i.deleteShader(A), i.deleteShader(S), (T = new zm(i, g)), (w = jX(i, g))
  }
  let T
  this.getUniforms = function () {
    return T === void 0 && b(this), T
  }
  let w
  this.getAttributes = function () {
    return w === void 0 && b(this), w
  }
  let M = e.rendererExtensionParallelShaderCompile === !1
  return (
    (this.isReady = function () {
      return M === !1 && (M = i.getProgramParameter(g, HX)), M
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(g),
        (this.program = void 0)
    }),
    (this.type = e.shaderType),
    (this.name = e.shaderName),
    (this.id = WX++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = g),
    (this.vertexShader = A),
    (this.fragmentShader = S),
    this
  )
}
let uY = 0
class cY {
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(t) {
    const e = t.vertexShader,
      n = t.fragmentShader,
      i = this._getShaderStage(e),
      a = this._getShaderStage(n),
      o = this._getShaderCacheForMaterial(t)
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(a) === !1 && (o.add(a), a.usedTimes++),
      this
    )
  }
  remove(t) {
    const e = this.materialCache.get(t)
    for (const n of e)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code)
    return this.materialCache.delete(t), this
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache
    let n = e.get(t)
    return n === void 0 && ((n = new Set()), e.set(t, n)), n
  }
  _getShaderStage(t) {
    const e = this.shaderCache
    let n = e.get(t)
    return n === void 0 && ((n = new hY(t)), e.set(t, n)), n
  }
}
class hY {
  constructor(t) {
    ;(this.id = uY++), (this.code = t), (this.usedTimes = 0)
  }
}
function fY(r, t, e, n, i, a, o) {
  const s = new NM(),
    l = new cY(),
    u = new Set(),
    c = [],
    h = i.logarithmicDepthBuffer,
    f = i.vertexTextures
  let d = i.precision
  const p = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  }
  function g(w) {
    return u.add(w), w === 0 ? 'uv' : `uv${w}`
  }
  function v(w, M, C, E, D) {
    const P = E.fog,
      L = D.geometry,
      I = w.isMeshStandardMaterial ? E.environment : null,
      F = (w.isMeshStandardMaterial ? e : t).get(w.envMap || I),
      k = F && F.mapping === R0 ? F.image.height : null,
      V = p[w.type]
    w.precision !== null &&
      ((d = i.getMaxPrecision(w.precision)),
      d !== w.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          w.precision,
          'not supported, using',
          d,
          'instead.',
        ))
    const H =
        L.morphAttributes.position ||
        L.morphAttributes.normal ||
        L.morphAttributes.color,
      Y = H !== void 0 ? H.length : 0
    let K = 0
    L.morphAttributes.position !== void 0 && (K = 1),
      L.morphAttributes.normal !== void 0 && (K = 2),
      L.morphAttributes.color !== void 0 && (K = 3)
    let ut, W, Z, ft
    if (V) {
      const Ie = qr[V]
      ;(ut = Ie.vertexShader), (W = Ie.fragmentShader)
    } else
      (ut = w.vertexShader),
        (W = w.fragmentShader),
        l.update(w),
        (Z = l.getVertexShaderID(w)),
        (ft = l.getFragmentShaderID(w))
    const lt = r.getRenderTarget(),
      ct = D.isInstancedMesh === !0,
      At = D.isBatchedMesh === !0,
      gt = !!w.map,
      dt = !!w.matcap,
      B = !!F,
      ht = !!w.aoMap,
      it = !!w.lightMap,
      xt = !!w.bumpMap,
      rt = !!w.normalMap,
      kt = !!w.displacementMap,
      Ct = !!w.emissiveMap,
      Lt = !!w.metalnessMap,
      G = !!w.roughnessMap,
      N = w.anisotropy > 0,
      J = w.clearcoat > 0,
      vt = w.dispersion > 0,
      yt = w.iridescence > 0,
      mt = w.sheen > 0,
      Kt = w.transmission > 0,
      It = N && !!w.anisotropyMap,
      Bt = J && !!w.clearcoatMap,
      fe = J && !!w.clearcoatNormalMap,
      Mt = J && !!w.clearcoatRoughnessMap,
      Ot = yt && !!w.iridescenceMap,
      Te = yt && !!w.iridescenceThicknessMap,
      se = mt && !!w.sheenColorMap,
      Gt = mt && !!w.sheenRoughnessMap,
      ue = !!w.specularMap,
      de = !!w.specularColorMap,
      ln = !!w.specularIntensityMap,
      O = Kt && !!w.transmissionMap,
      j = Kt && !!w.thicknessMap,
      tt = !!w.gradientMap,
      ot = !!w.alphaMap,
      St = w.alphaTest > 0,
      jt = !!w.alphaHash,
      ce = !!w.extensions
    let Tn = Ys
    w.toneMapped &&
      (lt === null || lt.isXRRenderTarget === !0) &&
      (Tn = r.toneMapping)
    const Gn = {
      shaderID: V,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: ut,
      fragmentShader: W,
      defines: w.defines,
      customVertexShaderID: Z,
      customFragmentShaderID: ft,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: d,
      batching: At,
      batchingColor: At && D._colorsTexture !== null,
      instancing: ct,
      instancingColor: ct && D.instanceColor !== null,
      instancingMorph: ct && D.morphTexture !== null,
      supportsVertexTextures: f,
      outputColorSpace:
        lt === null
          ? r.outputColorSpace
          : lt.isXRRenderTarget === !0
          ? lt.texture.colorSpace
          : ar,
      alphaToCoverage: !!w.alphaToCoverage,
      map: gt,
      matcap: dt,
      envMap: B,
      envMapMode: B && F.mapping,
      envMapCubeUVHeight: k,
      aoMap: ht,
      lightMap: it,
      bumpMap: xt,
      normalMap: rt,
      displacementMap: f && kt,
      emissiveMap: Ct,
      normalMapObjectSpace: rt && w.normalMapType === l6,
      normalMapTangentSpace: rt && w.normalMapType === LM,
      metalnessMap: Lt,
      roughnessMap: G,
      anisotropy: N,
      anisotropyMap: It,
      clearcoat: J,
      clearcoatMap: Bt,
      clearcoatNormalMap: fe,
      clearcoatRoughnessMap: Mt,
      dispersion: vt,
      iridescence: yt,
      iridescenceMap: Ot,
      iridescenceThicknessMap: Te,
      sheen: mt,
      sheenColorMap: se,
      sheenRoughnessMap: Gt,
      specularMap: ue,
      specularColorMap: de,
      specularIntensityMap: ln,
      transmission: Kt,
      transmissionMap: O,
      thicknessMap: j,
      gradientMap: tt,
      opaque:
        w.transparent === !1 && w.blending === bh && w.alphaToCoverage === !1,
      alphaMap: ot,
      alphaTest: St,
      alphaHash: jt,
      combine: w.combine,
      mapUv: gt && g(w.map.channel),
      aoMapUv: ht && g(w.aoMap.channel),
      lightMapUv: it && g(w.lightMap.channel),
      bumpMapUv: xt && g(w.bumpMap.channel),
      normalMapUv: rt && g(w.normalMap.channel),
      displacementMapUv: kt && g(w.displacementMap.channel),
      emissiveMapUv: Ct && g(w.emissiveMap.channel),
      metalnessMapUv: Lt && g(w.metalnessMap.channel),
      roughnessMapUv: G && g(w.roughnessMap.channel),
      anisotropyMapUv: It && g(w.anisotropyMap.channel),
      clearcoatMapUv: Bt && g(w.clearcoatMap.channel),
      clearcoatNormalMapUv: fe && g(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Mt && g(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ot && g(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: Te && g(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: se && g(w.sheenColorMap.channel),
      sheenRoughnessMapUv: Gt && g(w.sheenRoughnessMap.channel),
      specularMapUv: ue && g(w.specularMap.channel),
      specularColorMapUv: de && g(w.specularColorMap.channel),
      specularIntensityMapUv: ln && g(w.specularIntensityMap.channel),
      transmissionMapUv: O && g(w.transmissionMap.channel),
      thicknessMapUv: j && g(w.thicknessMap.channel),
      alphaMapUv: ot && g(w.alphaMap.channel),
      vertexTangents: !!L.attributes.tangent && (rt || N),
      vertexColors: w.vertexColors,
      vertexAlphas:
        w.vertexColors === !0 &&
        !!L.attributes.color &&
        L.attributes.color.itemSize === 4,
      pointsUvs: D.isPoints === !0 && !!L.attributes.uv && (gt || ot),
      fog: !!P,
      useFog: w.fog === !0,
      fogExp2: !!P && P.isFogExp2,
      flatShading: w.flatShading === !0,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      skinning: D.isSkinnedMesh === !0,
      morphTargets: L.morphAttributes.position !== void 0,
      morphNormals: L.morphAttributes.normal !== void 0,
      morphColors: L.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: K,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: r.shadowMap.enabled && C.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: Tn,
      decodeVideoTexture:
        gt &&
        w.map.isVideoTexture === !0 &&
        Be.getTransfer(w.map.colorSpace) === an,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === dr,
      flipSided: w.side === Qr,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionClipCullDistance:
        ce &&
        w.extensions.clipCullDistance === !0 &&
        n.has('WEBGL_clip_cull_distance'),
      extensionMultiDraw:
        ((ce && w.extensions.multiDraw === !0) || At) &&
        n.has('WEBGL_multi_draw'),
      rendererExtensionParallelShaderCompile: n.has(
        'KHR_parallel_shader_compile',
      ),
      customProgramCacheKey: w.customProgramCacheKey(),
    }
    return (
      (Gn.vertexUv1s = u.has(1)),
      (Gn.vertexUv2s = u.has(2)),
      (Gn.vertexUv3s = u.has(3)),
      u.clear(),
      Gn
    )
  }
  function m(w) {
    const M = []
    if (
      (w.shaderID
        ? M.push(w.shaderID)
        : (M.push(w.customVertexShaderID), M.push(w.customFragmentShaderID)),
      w.defines !== void 0)
    )
      for (const C in w.defines) M.push(C), M.push(w.defines[C])
    return (
      w.isRawShaderMaterial === !1 &&
        (y(M, w), _(M, w), M.push(r.outputColorSpace)),
      M.push(w.customProgramCacheKey),
      M.join()
    )
  }
  function y(w, M) {
    w.push(M.precision),
      w.push(M.outputColorSpace),
      w.push(M.envMapMode),
      w.push(M.envMapCubeUVHeight),
      w.push(M.mapUv),
      w.push(M.alphaMapUv),
      w.push(M.lightMapUv),
      w.push(M.aoMapUv),
      w.push(M.bumpMapUv),
      w.push(M.normalMapUv),
      w.push(M.displacementMapUv),
      w.push(M.emissiveMapUv),
      w.push(M.metalnessMapUv),
      w.push(M.roughnessMapUv),
      w.push(M.anisotropyMapUv),
      w.push(M.clearcoatMapUv),
      w.push(M.clearcoatNormalMapUv),
      w.push(M.clearcoatRoughnessMapUv),
      w.push(M.iridescenceMapUv),
      w.push(M.iridescenceThicknessMapUv),
      w.push(M.sheenColorMapUv),
      w.push(M.sheenRoughnessMapUv),
      w.push(M.specularMapUv),
      w.push(M.specularColorMapUv),
      w.push(M.specularIntensityMapUv),
      w.push(M.transmissionMapUv),
      w.push(M.thicknessMapUv),
      w.push(M.combine),
      w.push(M.fogExp2),
      w.push(M.sizeAttenuation),
      w.push(M.morphTargetsCount),
      w.push(M.morphAttributeCount),
      w.push(M.numDirLights),
      w.push(M.numPointLights),
      w.push(M.numSpotLights),
      w.push(M.numSpotLightMaps),
      w.push(M.numHemiLights),
      w.push(M.numRectAreaLights),
      w.push(M.numDirLightShadows),
      w.push(M.numPointLightShadows),
      w.push(M.numSpotLightShadows),
      w.push(M.numSpotLightShadowsWithMaps),
      w.push(M.numLightProbes),
      w.push(M.shadowMapType),
      w.push(M.toneMapping),
      w.push(M.numClippingPlanes),
      w.push(M.numClipIntersection),
      w.push(M.depthPacking)
  }
  function _(w, M) {
    s.disableAll(),
      M.supportsVertexTextures && s.enable(0),
      M.instancing && s.enable(1),
      M.instancingColor && s.enable(2),
      M.instancingMorph && s.enable(3),
      M.matcap && s.enable(4),
      M.envMap && s.enable(5),
      M.normalMapObjectSpace && s.enable(6),
      M.normalMapTangentSpace && s.enable(7),
      M.clearcoat && s.enable(8),
      M.iridescence && s.enable(9),
      M.alphaTest && s.enable(10),
      M.vertexColors && s.enable(11),
      M.vertexAlphas && s.enable(12),
      M.vertexUv1s && s.enable(13),
      M.vertexUv2s && s.enable(14),
      M.vertexUv3s && s.enable(15),
      M.vertexTangents && s.enable(16),
      M.anisotropy && s.enable(17),
      M.alphaHash && s.enable(18),
      M.batching && s.enable(19),
      M.dispersion && s.enable(20),
      M.batchingColor && s.enable(21),
      w.push(s.mask),
      s.disableAll(),
      M.fog && s.enable(0),
      M.useFog && s.enable(1),
      M.flatShading && s.enable(2),
      M.logarithmicDepthBuffer && s.enable(3),
      M.skinning && s.enable(4),
      M.morphTargets && s.enable(5),
      M.morphNormals && s.enable(6),
      M.morphColors && s.enable(7),
      M.premultipliedAlpha && s.enable(8),
      M.shadowMapEnabled && s.enable(9),
      M.doubleSided && s.enable(10),
      M.flipSided && s.enable(11),
      M.useDepthPacking && s.enable(12),
      M.dithering && s.enable(13),
      M.transmission && s.enable(14),
      M.sheen && s.enable(15),
      M.opaque && s.enable(16),
      M.pointsUvs && s.enable(17),
      M.decodeVideoTexture && s.enable(18),
      M.alphaToCoverage && s.enable(19),
      w.push(s.mask)
  }
  function x(w) {
    const M = p[w.type]
    let C
    if (M) {
      const E = qr[M]
      C = kM.clone(E.uniforms)
    } else C = w.uniforms
    return C
  }
  function A(w, M) {
    let C
    for (let E = 0, D = c.length; E < D; E++) {
      const P = c[E]
      if (P.cacheKey === M) {
        ;(C = P), ++C.usedTimes
        break
      }
    }
    return C === void 0 && ((C = new lY(r, M, w, a)), c.push(C)), C
  }
  function S(w) {
    if (--w.usedTimes === 0) {
      const M = c.indexOf(w)
      ;(c[M] = c[c.length - 1]), c.pop(), w.destroy()
    }
  }
  function b(w) {
    l.remove(w)
  }
  function T() {
    l.dispose()
  }
  return {
    getParameters: v,
    getProgramCacheKey: m,
    getUniforms: x,
    acquireProgram: A,
    releaseProgram: S,
    releaseShaderCache: b,
    programs: c,
    dispose: T,
  }
}
function dY() {
  let r = new WeakMap()
  function t(a) {
    let o = r.get(a)
    return o === void 0 && ((o = {}), r.set(a, o)), o
  }
  function e(a) {
    r.delete(a)
  }
  function n(a, o, s) {
    r.get(a)[o] = s
  }
  function i() {
    r = new WeakMap()
  }
  return {
    get: t,
    remove: e,
    update: n,
    dispose: i,
  }
}
function pY(r, t) {
  return r.groupOrder !== t.groupOrder
    ? r.groupOrder - t.groupOrder
    : r.renderOrder !== t.renderOrder
    ? r.renderOrder - t.renderOrder
    : r.material.id !== t.material.id
    ? r.material.id - t.material.id
    : r.z !== t.z
    ? r.z - t.z
    : r.id - t.id
}
function H2(r, t) {
  return r.groupOrder !== t.groupOrder
    ? r.groupOrder - t.groupOrder
    : r.renderOrder !== t.renderOrder
    ? r.renderOrder - t.renderOrder
    : r.z !== t.z
    ? t.z - r.z
    : r.id - t.id
}
function W2() {
  const r = []
  let t = 0
  const e = [],
    n = [],
    i = []
  function a() {
    ;(t = 0), (e.length = 0), (n.length = 0), (i.length = 0)
  }
  function o(h, f, d, p, g, v) {
    let m = r[t]
    return (
      m === void 0
        ? ((m = {
            id: h.id,
            object: h,
            geometry: f,
            material: d,
            groupOrder: p,
            renderOrder: h.renderOrder,
            z: g,
            group: v,
          }),
          (r[t] = m))
        : ((m.id = h.id),
          (m.object = h),
          (m.geometry = f),
          (m.material = d),
          (m.groupOrder = p),
          (m.renderOrder = h.renderOrder),
          (m.z = g),
          (m.group = v)),
      t++,
      m
    )
  }
  function s(h, f, d, p, g, v) {
    const m = o(h, f, d, p, g, v)
    d.transmission > 0
      ? n.push(m)
      : d.transparent === !0
      ? i.push(m)
      : e.push(m)
  }
  function l(h, f, d, p, g, v) {
    const m = o(h, f, d, p, g, v)
    d.transmission > 0
      ? n.unshift(m)
      : d.transparent === !0
      ? i.unshift(m)
      : e.unshift(m)
  }
  function u(h, f) {
    e.length > 1 && e.sort(h || pY),
      n.length > 1 && n.sort(f || H2),
      i.length > 1 && i.sort(f || H2)
  }
  function c() {
    for (let h = t, f = r.length; h < f; h++) {
      const d = r[h]
      if (d.id === null) break
      ;(d.id = null),
        (d.object = null),
        (d.geometry = null),
        (d.material = null),
        (d.group = null)
    }
  }
  return {
    opaque: e,
    transmissive: n,
    transparent: i,
    init: a,
    push: s,
    unshift: l,
    finish: c,
    sort: u,
  }
}
function vY() {
  let r = new WeakMap()
  function t(n, i) {
    const a = r.get(n)
    let o
    return (
      a === void 0
        ? ((o = new W2()), r.set(n, [o]))
        : i >= a.length
        ? ((o = new W2()), a.push(o))
        : (o = a[i]),
      o
    )
  }
  function e() {
    r = new WeakMap()
  }
  return {
    get: t,
    dispose: e,
  }
}
function gY() {
  const r = {}
  return {
    get: function (t) {
      if (r[t.id] !== void 0) return r[t.id]
      let e
      switch (t.type) {
        case 'DirectionalLight':
          e = {
            direction: new U(),
            color: new qt(),
          }
          break
        case 'SpotLight':
          e = {
            position: new U(),
            direction: new U(),
            color: new qt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case 'PointLight':
          e = {
            position: new U(),
            color: new qt(),
            distance: 0,
            decay: 0,
          }
          break
        case 'HemisphereLight':
          e = {
            direction: new U(),
            skyColor: new qt(),
            groundColor: new qt(),
          }
          break
        case 'RectAreaLight':
          e = {
            color: new qt(),
            position: new U(),
            halfWidth: new U(),
            halfHeight: new U(),
          }
          break
      }
      return (r[t.id] = e), e
    },
  }
}
function mY() {
  const r = {}
  return {
    get: function (t) {
      if (r[t.id] !== void 0) return r[t.id]
      let e
      switch (t.type) {
        case 'DirectionalLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pt(),
          }
          break
        case 'SpotLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pt(),
          }
          break
        case 'PointLight':
          e = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new pt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      return (r[t.id] = e), e
    },
  }
}
let yY = 0
function _Y(r, t) {
  return (
    (t.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (t.map ? 1 : 0) -
    (r.map ? 1 : 0)
  )
}
function xY(r) {
  const t = new gY(),
    e = mY(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    }
  for (let u = 0; u < 9; u++) n.probe.push(new U())
  const i = new U(),
    a = new ae(),
    o = new ae()
  function s(u) {
    let c = 0,
      h = 0,
      f = 0
    for (let w = 0; w < 9; w++) n.probe[w].set(0, 0, 0)
    let d = 0,
      p = 0,
      g = 0,
      v = 0,
      m = 0,
      y = 0,
      _ = 0,
      x = 0,
      A = 0,
      S = 0,
      b = 0
    u.sort(_Y)
    for (let w = 0, M = u.length; w < M; w++) {
      const C = u[w],
        E = C.color,
        D = C.intensity,
        P = C.distance,
        L = C.shadow && C.shadow.map ? C.shadow.map.texture : null
      if (C.isAmbientLight) (c += E.r * D), (h += E.g * D), (f += E.b * D)
      else if (C.isLightProbe) {
        for (let I = 0; I < 9; I++)
          n.probe[I].addScaledVector(C.sh.coefficients[I], D)
        b++
      } else if (C.isDirectionalLight) {
        const I = t.get(C)
        if ((I.color.copy(C.color).multiplyScalar(C.intensity), C.castShadow)) {
          const F = C.shadow,
            k = e.get(C)
          ;(k.shadowIntensity = F.intensity),
            (k.shadowBias = F.bias),
            (k.shadowNormalBias = F.normalBias),
            (k.shadowRadius = F.radius),
            (k.shadowMapSize = F.mapSize),
            (n.directionalShadow[d] = k),
            (n.directionalShadowMap[d] = L),
            (n.directionalShadowMatrix[d] = C.shadow.matrix),
            y++
        }
        ;(n.directional[d] = I), d++
      } else if (C.isSpotLight) {
        const I = t.get(C)
        I.position.setFromMatrixPosition(C.matrixWorld),
          I.color.copy(E).multiplyScalar(D),
          (I.distance = P),
          (I.coneCos = Math.cos(C.angle)),
          (I.penumbraCos = Math.cos(C.angle * (1 - C.penumbra))),
          (I.decay = C.decay),
          (n.spot[g] = I)
        const F = C.shadow
        if (
          (C.map &&
            ((n.spotLightMap[A] = C.map),
            A++,
            F.updateMatrices(C),
            C.castShadow && S++),
          (n.spotLightMatrix[g] = F.matrix),
          C.castShadow)
        ) {
          const k = e.get(C)
          ;(k.shadowIntensity = F.intensity),
            (k.shadowBias = F.bias),
            (k.shadowNormalBias = F.normalBias),
            (k.shadowRadius = F.radius),
            (k.shadowMapSize = F.mapSize),
            (n.spotShadow[g] = k),
            (n.spotShadowMap[g] = L),
            x++
        }
        g++
      } else if (C.isRectAreaLight) {
        const I = t.get(C)
        I.color.copy(E).multiplyScalar(D),
          I.halfWidth.set(C.width * 0.5, 0, 0),
          I.halfHeight.set(0, C.height * 0.5, 0),
          (n.rectArea[v] = I),
          v++
      } else if (C.isPointLight) {
        const I = t.get(C)
        if (
          (I.color.copy(C.color).multiplyScalar(C.intensity),
          (I.distance = C.distance),
          (I.decay = C.decay),
          C.castShadow)
        ) {
          const F = C.shadow,
            k = e.get(C)
          ;(k.shadowIntensity = F.intensity),
            (k.shadowBias = F.bias),
            (k.shadowNormalBias = F.normalBias),
            (k.shadowRadius = F.radius),
            (k.shadowMapSize = F.mapSize),
            (k.shadowCameraNear = F.camera.near),
            (k.shadowCameraFar = F.camera.far),
            (n.pointShadow[p] = k),
            (n.pointShadowMap[p] = L),
            (n.pointShadowMatrix[p] = C.shadow.matrix),
            _++
        }
        ;(n.point[p] = I), p++
      } else if (C.isHemisphereLight) {
        const I = t.get(C)
        I.skyColor.copy(C.color).multiplyScalar(D),
          I.groundColor.copy(C.groundColor).multiplyScalar(D),
          (n.hemi[m] = I),
          m++
      }
    }
    v > 0 &&
      (r.has('OES_texture_float_linear') === !0
        ? ((n.rectAreaLTC1 = Rt.LTC_FLOAT_1), (n.rectAreaLTC2 = Rt.LTC_FLOAT_2))
        : ((n.rectAreaLTC1 = Rt.LTC_HALF_1), (n.rectAreaLTC2 = Rt.LTC_HALF_2))),
      (n.ambient[0] = c),
      (n.ambient[1] = h),
      (n.ambient[2] = f)
    const T = n.hash
    ;(T.directionalLength !== d ||
      T.pointLength !== p ||
      T.spotLength !== g ||
      T.rectAreaLength !== v ||
      T.hemiLength !== m ||
      T.numDirectionalShadows !== y ||
      T.numPointShadows !== _ ||
      T.numSpotShadows !== x ||
      T.numSpotMaps !== A ||
      T.numLightProbes !== b) &&
      ((n.directional.length = d),
      (n.spot.length = g),
      (n.rectArea.length = v),
      (n.point.length = p),
      (n.hemi.length = m),
      (n.directionalShadow.length = y),
      (n.directionalShadowMap.length = y),
      (n.pointShadow.length = _),
      (n.pointShadowMap.length = _),
      (n.spotShadow.length = x),
      (n.spotShadowMap.length = x),
      (n.directionalShadowMatrix.length = y),
      (n.pointShadowMatrix.length = _),
      (n.spotLightMatrix.length = x + A - S),
      (n.spotLightMap.length = A),
      (n.numSpotLightShadowsWithMaps = S),
      (n.numLightProbes = b),
      (T.directionalLength = d),
      (T.pointLength = p),
      (T.spotLength = g),
      (T.rectAreaLength = v),
      (T.hemiLength = m),
      (T.numDirectionalShadows = y),
      (T.numPointShadows = _),
      (T.numSpotShadows = x),
      (T.numSpotMaps = A),
      (T.numLightProbes = b),
      (n.version = yY++))
  }
  function l(u, c) {
    let h = 0,
      f = 0,
      d = 0,
      p = 0,
      g = 0
    const v = c.matrixWorldInverse
    for (let m = 0, y = u.length; m < y; m++) {
      const _ = u[m]
      if (_.isDirectionalLight) {
        const x = n.directional[h]
        x.direction.setFromMatrixPosition(_.matrixWorld),
          i.setFromMatrixPosition(_.target.matrixWorld),
          x.direction.sub(i),
          x.direction.transformDirection(v),
          h++
      } else if (_.isSpotLight) {
        const x = n.spot[d]
        x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(v),
          x.direction.setFromMatrixPosition(_.matrixWorld),
          i.setFromMatrixPosition(_.target.matrixWorld),
          x.direction.sub(i),
          x.direction.transformDirection(v),
          d++
      } else if (_.isRectAreaLight) {
        const x = n.rectArea[p]
        x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(v),
          o.identity(),
          a.copy(_.matrixWorld),
          a.premultiply(v),
          o.extractRotation(a),
          x.halfWidth.set(_.width * 0.5, 0, 0),
          x.halfHeight.set(0, _.height * 0.5, 0),
          x.halfWidth.applyMatrix4(o),
          x.halfHeight.applyMatrix4(o),
          p++
      } else if (_.isPointLight) {
        const x = n.point[f]
        x.position.setFromMatrixPosition(_.matrixWorld),
          x.position.applyMatrix4(v),
          f++
      } else if (_.isHemisphereLight) {
        const x = n.hemi[g]
        x.direction.setFromMatrixPosition(_.matrixWorld),
          x.direction.transformDirection(v),
          g++
      }
    }
  }
  return {
    setup: s,
    setupView: l,
    state: n,
  }
}
function X2(r) {
  const t = new xY(r),
    e = [],
    n = []
  function i(c) {
    ;(u.camera = c), (e.length = 0), (n.length = 0)
  }
  function a(c) {
    e.push(c)
  }
  function o(c) {
    n.push(c)
  }
  function s() {
    t.setup(e)
  }
  function l(c) {
    t.setupView(e, c)
  }
  const u = {
    lightsArray: e,
    shadowsArray: n,
    camera: null,
    lights: t,
    transmissionRenderTarget: {},
  }
  return {
    init: i,
    state: u,
    setupLights: s,
    setupLightsView: l,
    pushLight: a,
    pushShadow: o,
  }
}
function SY(r) {
  let t = new WeakMap()
  function e(i, a = 0) {
    const o = t.get(i)
    let s
    return (
      o === void 0
        ? ((s = new X2(r)), t.set(i, [s]))
        : a >= o.length
        ? ((s = new X2(r)), o.push(s))
        : (s = o[a]),
      s
    )
  }
  function n() {
    t = new WeakMap()
  }
  return {
    get: e,
    dispose: n,
  }
}
class AY extends ji {
  constructor(t) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = o6),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    )
  }
}
class bY extends ji {
  constructor(t) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = 'MeshDistanceMaterial'),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    )
  }
}
const wY = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  MY = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
function TY(r, t, e) {
  let n = new BM()
  const i = new pt(),
    a = new pt(),
    o = new Oe(),
    s = new AY({
      depthPacking: s6,
    }),
    l = new bY(),
    u = {},
    c = e.maxTextureSize,
    h = {
      [$o]: Qr,
      [Qr]: $o,
      [dr]: dr,
    },
    f = new lo({
      defines: {
        VSM_SAMPLES: 8,
      },
      uniforms: {
        shadow_pass: {
          value: null,
        },
        resolution: {
          value: new pt(),
        },
        radius: {
          value: 4,
        },
      },
      vertexShader: wY,
      fragmentShader: MY,
    }),
    d = f.clone()
  d.defines.HORIZONTAL_PASS = 1
  const p = new Mn()
  p.setAttribute(
    'position',
    new ir(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  )
  const g = new De(p, f),
    v = this
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Nk)
  let m = this.type
  this.render = function (S, b, T) {
    if (
      v.enabled === !1 ||
      (v.autoUpdate === !1 && v.needsUpdate === !1) ||
      S.length === 0
    )
      return
    const w = r.getRenderTarget(),
      M = r.getActiveCubeFace(),
      C = r.getActiveMipmapLevel(),
      E = r.state
    E.setBlending(Xs),
      E.buffers.color.setClear(1, 1, 1, 1),
      E.buffers.depth.setTest(!0),
      E.setScissorTest(!1)
    const D = m !== Po && this.type === Po,
      P = m === Po && this.type !== Po
    for (let L = 0, I = S.length; L < I; L++) {
      const F = S[L],
        k = F.shadow
      if (k === void 0) {
        console.warn('THREE.WebGLShadowMap:', F, 'has no shadow.')
        continue
      }
      if (k.autoUpdate === !1 && k.needsUpdate === !1) continue
      i.copy(k.mapSize)
      const V = k.getFrameExtents()
      if (
        (i.multiply(V),
        a.copy(k.mapSize),
        (i.x > c || i.y > c) &&
          (i.x > c &&
            ((a.x = Math.floor(c / V.x)),
            (i.x = a.x * V.x),
            (k.mapSize.x = a.x)),
          i.y > c &&
            ((a.y = Math.floor(c / V.y)),
            (i.y = a.y * V.y),
            (k.mapSize.y = a.y))),
        k.map === null || D === !0 || P === !0)
      ) {
        const Y =
          this.type !== Po
            ? {
                minFilter: Ur,
                magFilter: Ur,
              }
            : {}
        k.map !== null && k.map.dispose(),
          (k.map = new Vu(i.x, i.y, Y)),
          (k.map.texture.name = F.name + '.shadowMap'),
          k.camera.updateProjectionMatrix()
      }
      r.setRenderTarget(k.map), r.clear()
      const H = k.getViewportCount()
      for (let Y = 0; Y < H; Y++) {
        const K = k.getViewport(Y)
        o.set(a.x * K.x, a.y * K.y, a.x * K.z, a.y * K.w),
          E.viewport(o),
          k.updateMatrices(F, Y),
          (n = k.getFrustum()),
          x(b, T, k.camera, F, this.type)
      }
      k.isPointLightShadow !== !0 && this.type === Po && y(k, T),
        (k.needsUpdate = !1)
    }
    ;(m = this.type), (v.needsUpdate = !1), r.setRenderTarget(w, M, C)
  }
  function y(S, b) {
    const T = t.update(g)
    f.defines.VSM_SAMPLES !== S.blurSamples &&
      ((f.defines.VSM_SAMPLES = S.blurSamples),
      (d.defines.VSM_SAMPLES = S.blurSamples),
      (f.needsUpdate = !0),
      (d.needsUpdate = !0)),
      S.mapPass === null && (S.mapPass = new Vu(i.x, i.y)),
      (f.uniforms.shadow_pass.value = S.map.texture),
      (f.uniforms.resolution.value = S.mapSize),
      (f.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.mapPass),
      r.clear(),
      r.renderBufferDirect(b, null, T, f, g, null),
      (d.uniforms.shadow_pass.value = S.mapPass.texture),
      (d.uniforms.resolution.value = S.mapSize),
      (d.uniforms.radius.value = S.radius),
      r.setRenderTarget(S.map),
      r.clear(),
      r.renderBufferDirect(b, null, T, d, g, null)
  }
  function _(S, b, T, w) {
    let M = null
    const C =
      T.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial
    if (C !== void 0) M = C
    else if (
      ((M = T.isPointLight === !0 ? l : s),
      (r.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const E = M.uuid,
        D = b.uuid
      let P = u[E]
      P === void 0 && ((P = {}), (u[E] = P))
      let L = P[D]
      L === void 0 &&
        ((L = M.clone()), (P[D] = L), b.addEventListener('dispose', A)),
        (M = L)
    }
    if (
      ((M.visible = b.visible),
      (M.wireframe = b.wireframe),
      w === Po
        ? (M.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (M.side = b.shadowSide !== null ? b.shadowSide : h[b.side]),
      (M.alphaMap = b.alphaMap),
      (M.alphaTest = b.alphaTest),
      (M.map = b.map),
      (M.clipShadows = b.clipShadows),
      (M.clippingPlanes = b.clippingPlanes),
      (M.clipIntersection = b.clipIntersection),
      (M.displacementMap = b.displacementMap),
      (M.displacementScale = b.displacementScale),
      (M.displacementBias = b.displacementBias),
      (M.wireframeLinewidth = b.wireframeLinewidth),
      (M.linewidth = b.linewidth),
      T.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const E = r.properties.get(M)
      E.light = T
    }
    return M
  }
  function x(S, b, T, w, M) {
    if (S.visible === !1) return
    if (
      S.layers.test(b.layers) &&
      (S.isMesh || S.isLine || S.isPoints) &&
      (S.castShadow || (S.receiveShadow && M === Po)) &&
      (!S.frustumCulled || n.intersectsObject(S))
    ) {
      S.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, S.matrixWorld)
      const D = t.update(S),
        P = S.material
      if (Array.isArray(P)) {
        const L = D.groups
        for (let I = 0, F = L.length; I < F; I++) {
          const k = L[I],
            V = P[k.materialIndex]
          if (V && V.visible) {
            const H = _(S, V, w, M)
            S.onBeforeShadow(r, S, b, T, D, H, k),
              r.renderBufferDirect(T, null, D, H, S, k),
              S.onAfterShadow(r, S, b, T, D, H, k)
          }
        }
      } else if (P.visible) {
        const L = _(S, P, w, M)
        S.onBeforeShadow(r, S, b, T, D, L, null),
          r.renderBufferDirect(T, null, D, L, S, null),
          S.onAfterShadow(r, S, b, T, D, L, null)
      }
    }
    const E = S.children
    for (let D = 0, P = E.length; D < P; D++) x(E[D], b, T, w, M)
  }
  function A(S) {
    S.target.removeEventListener('dispose', A)
    for (const T in u) {
      const w = u[T],
        M = S.target.uuid
      M in w && (w[M].dispose(), delete w[M])
    }
  }
}
function CY(r) {
  function t() {
    let O = !1
    const j = new Oe()
    let tt = null
    const ot = new Oe(0, 0, 0, 0)
    return {
      setMask: function (St) {
        tt !== St && !O && (r.colorMask(St, St, St, St), (tt = St))
      },
      setLocked: function (St) {
        O = St
      },
      setClear: function (St, jt, ce, Tn, Gn) {
        Gn === !0 && ((St *= Tn), (jt *= Tn), (ce *= Tn)),
          j.set(St, jt, ce, Tn),
          ot.equals(j) === !1 && (r.clearColor(St, jt, ce, Tn), ot.copy(j))
      },
      reset: function () {
        ;(O = !1), (tt = null), ot.set(-1, 0, 0, 0)
      },
    }
  }
  function e() {
    let O = !1,
      j = null,
      tt = null,
      ot = null
    return {
      setTest: function (St) {
        St ? ft(r.DEPTH_TEST) : lt(r.DEPTH_TEST)
      },
      setMask: function (St) {
        j !== St && !O && (r.depthMask(St), (j = St))
      },
      setFunc: function (St) {
        if (tt !== St) {
          switch (St) {
            case V8:
              r.depthFunc(r.NEVER)
              break
            case G8:
              r.depthFunc(r.ALWAYS)
              break
            case H8:
              r.depthFunc(r.LESS)
              break
            case dy:
              r.depthFunc(r.LEQUAL)
              break
            case W8:
              r.depthFunc(r.EQUAL)
              break
            case X8:
              r.depthFunc(r.GEQUAL)
              break
            case Y8:
              r.depthFunc(r.GREATER)
              break
            case $8:
              r.depthFunc(r.NOTEQUAL)
              break
            default:
              r.depthFunc(r.LEQUAL)
          }
          tt = St
        }
      },
      setLocked: function (St) {
        O = St
      },
      setClear: function (St) {
        ot !== St && (r.clearDepth(St), (ot = St))
      },
      reset: function () {
        ;(O = !1), (j = null), (tt = null), (ot = null)
      },
    }
  }
  function n() {
    let O = !1,
      j = null,
      tt = null,
      ot = null,
      St = null,
      jt = null,
      ce = null,
      Tn = null,
      Gn = null
    return {
      setTest: function (Ie) {
        O || (Ie ? ft(r.STENCIL_TEST) : lt(r.STENCIL_TEST))
      },
      setMask: function (Ie) {
        j !== Ie && !O && (r.stencilMask(Ie), (j = Ie))
      },
      setFunc: function (Ie, Hn, On) {
        ;(tt !== Ie || ot !== Hn || St !== On) &&
          (r.stencilFunc(Ie, Hn, On), (tt = Ie), (ot = Hn), (St = On))
      },
      setOp: function (Ie, Hn, On) {
        ;(jt !== Ie || ce !== Hn || Tn !== On) &&
          (r.stencilOp(Ie, Hn, On), (jt = Ie), (ce = Hn), (Tn = On))
      },
      setLocked: function (Ie) {
        O = Ie
      },
      setClear: function (Ie) {
        Gn !== Ie && (r.clearStencil(Ie), (Gn = Ie))
      },
      reset: function () {
        ;(O = !1),
          (j = null),
          (tt = null),
          (ot = null),
          (St = null),
          (jt = null),
          (ce = null),
          (Tn = null),
          (Gn = null)
      },
    }
  }
  const i = new t(),
    a = new e(),
    o = new n(),
    s = new WeakMap(),
    l = new WeakMap()
  let u = {},
    c = {},
    h = new WeakMap(),
    f = [],
    d = null,
    p = !1,
    g = null,
    v = null,
    m = null,
    y = null,
    _ = null,
    x = null,
    A = null,
    S = new qt(0, 0, 0),
    b = 0,
    T = !1,
    w = null,
    M = null,
    C = null,
    E = null,
    D = null
  const P = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
  let L = !1,
    I = 0
  const F = r.getParameter(r.VERSION)
  F.indexOf('WebGL') !== -1
    ? ((I = parseFloat(/^WebGL (\d)/.exec(F)[1])), (L = I >= 1))
    : F.indexOf('OpenGL ES') !== -1 &&
      ((I = parseFloat(/^OpenGL ES (\d)/.exec(F)[1])), (L = I >= 2))
  let k = null,
    V = {}
  const H = r.getParameter(r.SCISSOR_BOX),
    Y = r.getParameter(r.VIEWPORT),
    K = new Oe().fromArray(H),
    ut = new Oe().fromArray(Y)
  function W(O, j, tt, ot) {
    const St = new Uint8Array(4),
      jt = r.createTexture()
    r.bindTexture(O, jt),
      r.texParameteri(O, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(O, r.TEXTURE_MAG_FILTER, r.NEAREST)
    for (let ce = 0; ce < tt; ce++)
      O === r.TEXTURE_3D || O === r.TEXTURE_2D_ARRAY
        ? r.texImage3D(j, 0, r.RGBA, 1, 1, ot, 0, r.RGBA, r.UNSIGNED_BYTE, St)
        : r.texImage2D(j + ce, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, St)
    return jt
  }
  const Z = {}
  ;(Z[r.TEXTURE_2D] = W(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (Z[r.TEXTURE_CUBE_MAP] = W(
      r.TEXTURE_CUBE_MAP,
      r.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (Z[r.TEXTURE_2D_ARRAY] = W(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1)),
    (Z[r.TEXTURE_3D] = W(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1)),
    i.setClear(0, 0, 0, 1),
    a.setClear(1),
    o.setClear(0),
    ft(r.DEPTH_TEST),
    a.setFunc(dy),
    xt(!1),
    rt(qE),
    ft(r.CULL_FACE),
    ht(Xs)
  function ft(O) {
    u[O] !== !0 && (r.enable(O), (u[O] = !0))
  }
  function lt(O) {
    u[O] !== !1 && (r.disable(O), (u[O] = !1))
  }
  function ct(O, j) {
    return c[O] !== j
      ? (r.bindFramebuffer(O, j),
        (c[O] = j),
        O === r.DRAW_FRAMEBUFFER && (c[r.FRAMEBUFFER] = j),
        O === r.FRAMEBUFFER && (c[r.DRAW_FRAMEBUFFER] = j),
        !0)
      : !1
  }
  function At(O, j) {
    let tt = f,
      ot = !1
    if (O) {
      ;(tt = h.get(j)), tt === void 0 && ((tt = []), h.set(j, tt))
      const St = O.textures
      if (tt.length !== St.length || tt[0] !== r.COLOR_ATTACHMENT0) {
        for (let jt = 0, ce = St.length; jt < ce; jt++)
          tt[jt] = r.COLOR_ATTACHMENT0 + jt
        ;(tt.length = St.length), (ot = !0)
      }
    } else tt[0] !== r.BACK && ((tt[0] = r.BACK), (ot = !0))
    ot && r.drawBuffers(tt)
  }
  function gt(O) {
    return d !== O ? (r.useProgram(O), (d = O), !0) : !1
  }
  const dt = {
    [uu]: r.FUNC_ADD,
    [w8]: r.FUNC_SUBTRACT,
    [M8]: r.FUNC_REVERSE_SUBTRACT,
  }
  ;(dt[T8] = r.MIN), (dt[C8] = r.MAX)
  const B = {
    [E8]: r.ZERO,
    [D8]: r.ONE,
    [L8]: r.SRC_COLOR,
    [vA]: r.SRC_ALPHA,
    [k8]: r.SRC_ALPHA_SATURATE,
    [O8]: r.DST_COLOR,
    [R8]: r.DST_ALPHA,
    [P8]: r.ONE_MINUS_SRC_COLOR,
    [gA]: r.ONE_MINUS_SRC_ALPHA,
    [N8]: r.ONE_MINUS_DST_COLOR,
    [I8]: r.ONE_MINUS_DST_ALPHA,
    [B8]: r.CONSTANT_COLOR,
    [F8]: r.ONE_MINUS_CONSTANT_COLOR,
    [z8]: r.CONSTANT_ALPHA,
    [U8]: r.ONE_MINUS_CONSTANT_ALPHA,
  }
  function ht(O, j, tt, ot, St, jt, ce, Tn, Gn, Ie) {
    if (O === Xs) {
      p === !0 && (lt(r.BLEND), (p = !1))
      return
    }
    if ((p === !1 && (ft(r.BLEND), (p = !0)), O !== b8)) {
      if (O !== g || Ie !== T) {
        if (
          ((v !== uu || _ !== uu) &&
            (r.blendEquation(r.FUNC_ADD), (v = uu), (_ = uu)),
          Ie)
        )
          switch (O) {
            case bh:
              r.blendFuncSeparate(
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
              )
              break
            case $r:
              r.blendFunc(r.ONE, r.ONE)
              break
            case ZE:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE)
              break
            case KE:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', O)
              break
          }
        else
          switch (O) {
            case bh:
              r.blendFuncSeparate(
                r.SRC_ALPHA,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
              )
              break
            case $r:
              r.blendFunc(r.SRC_ALPHA, r.ONE)
              break
            case ZE:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE)
              break
            case KE:
              r.blendFunc(r.ZERO, r.SRC_COLOR)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', O)
              break
          }
        ;(m = null),
          (y = null),
          (x = null),
          (A = null),
          S.set(0, 0, 0),
          (b = 0),
          (g = O),
          (T = Ie)
      }
      return
    }
    ;(St = St || j),
      (jt = jt || tt),
      (ce = ce || ot),
      (j !== v || St !== _) &&
        (r.blendEquationSeparate(dt[j], dt[St]), (v = j), (_ = St)),
      (tt !== m || ot !== y || jt !== x || ce !== A) &&
        (r.blendFuncSeparate(B[tt], B[ot], B[jt], B[ce]),
        (m = tt),
        (y = ot),
        (x = jt),
        (A = ce)),
      (Tn.equals(S) === !1 || Gn !== b) &&
        (r.blendColor(Tn.r, Tn.g, Tn.b, Gn), S.copy(Tn), (b = Gn)),
      (g = O),
      (T = !1)
  }
  function it(O, j) {
    O.side === dr ? lt(r.CULL_FACE) : ft(r.CULL_FACE)
    let tt = O.side === Qr
    j && (tt = !tt),
      xt(tt),
      O.blending === bh && O.transparent === !1
        ? ht(Xs)
        : ht(
            O.blending,
            O.blendEquation,
            O.blendSrc,
            O.blendDst,
            O.blendEquationAlpha,
            O.blendSrcAlpha,
            O.blendDstAlpha,
            O.blendColor,
            O.blendAlpha,
            O.premultipliedAlpha,
          ),
      a.setFunc(O.depthFunc),
      a.setTest(O.depthTest),
      a.setMask(O.depthWrite),
      i.setMask(O.colorWrite)
    const ot = O.stencilWrite
    o.setTest(ot),
      ot &&
        (o.setMask(O.stencilWriteMask),
        o.setFunc(O.stencilFunc, O.stencilRef, O.stencilFuncMask),
        o.setOp(O.stencilFail, O.stencilZFail, O.stencilZPass)),
      Ct(O.polygonOffset, O.polygonOffsetFactor, O.polygonOffsetUnits),
      O.alphaToCoverage === !0
        ? ft(r.SAMPLE_ALPHA_TO_COVERAGE)
        : lt(r.SAMPLE_ALPHA_TO_COVERAGE)
  }
  function xt(O) {
    w !== O && (O ? r.frontFace(r.CW) : r.frontFace(r.CCW), (w = O))
  }
  function rt(O) {
    O !== x8
      ? (ft(r.CULL_FACE),
        O !== M &&
          (O === qE
            ? r.cullFace(r.BACK)
            : O === S8
            ? r.cullFace(r.FRONT)
            : r.cullFace(r.FRONT_AND_BACK)))
      : lt(r.CULL_FACE),
      (M = O)
  }
  function kt(O) {
    O !== C && (L && r.lineWidth(O), (C = O))
  }
  function Ct(O, j, tt) {
    O
      ? (ft(r.POLYGON_OFFSET_FILL),
        (E !== j || D !== tt) && (r.polygonOffset(j, tt), (E = j), (D = tt)))
      : lt(r.POLYGON_OFFSET_FILL)
  }
  function Lt(O) {
    O ? ft(r.SCISSOR_TEST) : lt(r.SCISSOR_TEST)
  }
  function G(O) {
    O === void 0 && (O = r.TEXTURE0 + P - 1),
      k !== O && (r.activeTexture(O), (k = O))
  }
  function N(O, j, tt) {
    tt === void 0 && (k === null ? (tt = r.TEXTURE0 + P - 1) : (tt = k))
    let ot = V[tt]
    ot === void 0 &&
      ((ot = {
        type: void 0,
        texture: void 0,
      }),
      (V[tt] = ot)),
      (ot.type !== O || ot.texture !== j) &&
        (k !== tt && (r.activeTexture(tt), (k = tt)),
        r.bindTexture(O, j || Z[O]),
        (ot.type = O),
        (ot.texture = j))
  }
  function J() {
    const O = V[k]
    O !== void 0 &&
      O.type !== void 0 &&
      (r.bindTexture(O.type, null), (O.type = void 0), (O.texture = void 0))
  }
  function vt() {
    try {
      r.compressedTexImage2D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function yt() {
    try {
      r.compressedTexImage3D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function mt() {
    try {
      r.texSubImage2D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function Kt() {
    try {
      r.texSubImage3D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function It() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function Bt() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function fe() {
    try {
      r.texStorage2D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function Mt() {
    try {
      r.texStorage3D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function Ot() {
    try {
      r.texImage2D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function Te() {
    try {
      r.texImage3D.apply(r, arguments)
    } catch (O) {
      console.error('THREE.WebGLState:', O)
    }
  }
  function se(O) {
    K.equals(O) === !1 && (r.scissor(O.x, O.y, O.z, O.w), K.copy(O))
  }
  function Gt(O) {
    ut.equals(O) === !1 && (r.viewport(O.x, O.y, O.z, O.w), ut.copy(O))
  }
  function ue(O, j) {
    let tt = l.get(j)
    tt === void 0 && ((tt = new WeakMap()), l.set(j, tt))
    let ot = tt.get(O)
    ot === void 0 && ((ot = r.getUniformBlockIndex(j, O.name)), tt.set(O, ot))
  }
  function de(O, j) {
    const ot = l.get(j).get(O)
    s.get(j) !== ot &&
      (r.uniformBlockBinding(j, ot, O.__bindingPointIndex), s.set(j, ot))
  }
  function ln() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.blendColor(0, 0, 0, 0),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
      r.bindFramebuffer(r.READ_FRAMEBUFFER, null),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (u = {}),
      (k = null),
      (V = {}),
      (c = {}),
      (h = new WeakMap()),
      (f = []),
      (d = null),
      (p = !1),
      (g = null),
      (v = null),
      (m = null),
      (y = null),
      (_ = null),
      (x = null),
      (A = null),
      (S = new qt(0, 0, 0)),
      (b = 0),
      (T = !1),
      (w = null),
      (M = null),
      (C = null),
      (E = null),
      (D = null),
      K.set(0, 0, r.canvas.width, r.canvas.height),
      ut.set(0, 0, r.canvas.width, r.canvas.height),
      i.reset(),
      a.reset(),
      o.reset()
  }
  return {
    buffers: {
      color: i,
      depth: a,
      stencil: o,
    },
    enable: ft,
    disable: lt,
    bindFramebuffer: ct,
    drawBuffers: At,
    useProgram: gt,
    setBlending: ht,
    setMaterial: it,
    setFlipSided: xt,
    setCullFace: rt,
    setLineWidth: kt,
    setPolygonOffset: Ct,
    setScissorTest: Lt,
    activeTexture: G,
    bindTexture: N,
    unbindTexture: J,
    compressedTexImage2D: vt,
    compressedTexImage3D: yt,
    texImage2D: Ot,
    texImage3D: Te,
    updateUBOMapping: ue,
    uniformBlockBinding: de,
    texStorage2D: fe,
    texStorage3D: Mt,
    texSubImage2D: mt,
    texSubImage3D: Kt,
    compressedTexSubImage2D: It,
    compressedTexSubImage3D: Bt,
    scissor: se,
    viewport: Gt,
    reset: ln,
  }
}
function Y2(r, t, e, n) {
  const i = EY(n)
  switch (e) {
    case Vk:
      return r * t
    case Hk:
      return r * t
    case Wk:
      return r * t * 2
    case TM:
      return ((r * t) / i.components) * i.byteLength
    case CM:
      return ((r * t) / i.components) * i.byteLength
    case Xk:
      return ((r * t * 2) / i.components) * i.byteLength
    case EM:
      return ((r * t * 2) / i.components) * i.byteLength
    case Gk:
      return ((r * t * 3) / i.components) * i.byteLength
    case Yi:
      return ((r * t * 4) / i.components) * i.byteLength
    case DM:
      return ((r * t * 4) / i.components) * i.byteLength
    case Om:
    case Nm:
      return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 8
    case km:
    case Bm:
      return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16
    case xA:
    case AA:
      return (Math.max(r, 16) * Math.max(t, 8)) / 4
    case _A:
    case SA:
      return (Math.max(r, 8) * Math.max(t, 8)) / 2
    case bA:
    case wA:
      return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 8
    case MA:
      return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16
    case TA:
      return Math.floor((r + 3) / 4) * Math.floor((t + 3) / 4) * 16
    case CA:
      return Math.floor((r + 4) / 5) * Math.floor((t + 3) / 4) * 16
    case EA:
      return Math.floor((r + 4) / 5) * Math.floor((t + 4) / 5) * 16
    case DA:
      return Math.floor((r + 5) / 6) * Math.floor((t + 4) / 5) * 16
    case LA:
      return Math.floor((r + 5) / 6) * Math.floor((t + 5) / 6) * 16
    case PA:
      return Math.floor((r + 7) / 8) * Math.floor((t + 4) / 5) * 16
    case RA:
      return Math.floor((r + 7) / 8) * Math.floor((t + 5) / 6) * 16
    case IA:
      return Math.floor((r + 7) / 8) * Math.floor((t + 7) / 8) * 16
    case OA:
      return Math.floor((r + 9) / 10) * Math.floor((t + 4) / 5) * 16
    case NA:
      return Math.floor((r + 9) / 10) * Math.floor((t + 5) / 6) * 16
    case kA:
      return Math.floor((r + 9) / 10) * Math.floor((t + 7) / 8) * 16
    case BA:
      return Math.floor((r + 9) / 10) * Math.floor((t + 9) / 10) * 16
    case FA:
      return Math.floor((r + 11) / 12) * Math.floor((t + 9) / 10) * 16
    case zA:
      return Math.floor((r + 11) / 12) * Math.floor((t + 11) / 12) * 16
    case Fm:
    case UA:
    case VA:
      return Math.ceil(r / 4) * Math.ceil(t / 4) * 16
    case Yk:
    case GA:
      return Math.ceil(r / 4) * Math.ceil(t / 4) * 8
    case HA:
    case WA:
      return Math.ceil(r / 4) * Math.ceil(t / 4) * 16
  }
  throw new Error(`Unable to determine texture byte length for ${e} format.`)
}
function EY(r) {
  switch (r) {
    case qo:
    case Fk:
      return {
        byteLength: 1,
        components: 1,
      }
    case gp:
    case zk:
    case hv:
      return {
        byteLength: 2,
        components: 1,
      }
    case wM:
    case MM:
      return {
        byteLength: 2,
        components: 4,
      }
    case Uu:
    case bM:
    case ya:
      return {
        byteLength: 4,
        components: 1,
      }
    case Uk:
      return {
        byteLength: 4,
        components: 3,
      }
  }
  throw new Error(`Unknown texture type ${r}.`)
}
function DY(r, t, e, n, i, a, o) {
  const s = t.has('WEBGL_multisampled_render_to_texture')
      ? t.get('WEBGL_multisampled_render_to_texture')
      : null,
    l =
      typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new pt(),
    c = new WeakMap()
  let h
  const f = new WeakMap()
  let d = !1
  try {
    d =
      typeof OffscreenCanvas < 'u' &&
      new OffscreenCanvas(1, 1).getContext('2d') !== null
  } catch {}
  function p(G, N) {
    return d ? new OffscreenCanvas(G, N) : _p('canvas')
  }
  function g(G, N, J) {
    let vt = 1
    const yt = Lt(G)
    if (
      ((yt.width > J || yt.height > J) &&
        (vt = J / Math.max(yt.width, yt.height)),
      vt < 1)
    )
      if (
        (typeof HTMLImageElement < 'u' && G instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < 'u' && G instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < 'u' && G instanceof ImageBitmap) ||
        (typeof VideoFrame < 'u' && G instanceof VideoFrame)
      ) {
        const mt = Math.floor(vt * yt.width),
          Kt = Math.floor(vt * yt.height)
        h === void 0 && (h = p(mt, Kt))
        const It = N ? p(mt, Kt) : h
        return (
          (It.width = mt),
          (It.height = Kt),
          It.getContext('2d').drawImage(G, 0, 0, mt, Kt),
          console.warn(
            'THREE.WebGLRenderer: Texture has been resized from (' +
              yt.width +
              'x' +
              yt.height +
              ') to (' +
              mt +
              'x' +
              Kt +
              ').',
          ),
          It
        )
      } else
        return (
          'data' in G &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                yt.width +
                'x' +
                yt.height +
                ').',
            ),
          G
        )
    return G
  }
  function v(G) {
    return G.generateMipmaps && G.minFilter !== Ur && G.minFilter !== gi
  }
  function m(G) {
    r.generateMipmap(G)
  }
  function y(G, N, J, vt, yt = !1) {
    if (G !== null) {
      if (r[G] !== void 0) return r[G]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          G +
          "'",
      )
    }
    let mt = N
    if (
      (N === r.RED &&
        (J === r.FLOAT && (mt = r.R32F),
        J === r.HALF_FLOAT && (mt = r.R16F),
        J === r.UNSIGNED_BYTE && (mt = r.R8)),
      N === r.RED_INTEGER &&
        (J === r.UNSIGNED_BYTE && (mt = r.R8UI),
        J === r.UNSIGNED_SHORT && (mt = r.R16UI),
        J === r.UNSIGNED_INT && (mt = r.R32UI),
        J === r.BYTE && (mt = r.R8I),
        J === r.SHORT && (mt = r.R16I),
        J === r.INT && (mt = r.R32I)),
      N === r.RG &&
        (J === r.FLOAT && (mt = r.RG32F),
        J === r.HALF_FLOAT && (mt = r.RG16F),
        J === r.UNSIGNED_BYTE && (mt = r.RG8)),
      N === r.RG_INTEGER &&
        (J === r.UNSIGNED_BYTE && (mt = r.RG8UI),
        J === r.UNSIGNED_SHORT && (mt = r.RG16UI),
        J === r.UNSIGNED_INT && (mt = r.RG32UI),
        J === r.BYTE && (mt = r.RG8I),
        J === r.SHORT && (mt = r.RG16I),
        J === r.INT && (mt = r.RG32I)),
      N === r.RGB && J === r.UNSIGNED_INT_5_9_9_9_REV && (mt = r.RGB9_E5),
      N === r.RGBA)
    ) {
      const Kt = yt ? vy : Be.getTransfer(vt)
      J === r.FLOAT && (mt = r.RGBA32F),
        J === r.HALF_FLOAT && (mt = r.RGBA16F),
        J === r.UNSIGNED_BYTE && (mt = Kt === an ? r.SRGB8_ALPHA8 : r.RGBA8),
        J === r.UNSIGNED_SHORT_4_4_4_4 && (mt = r.RGBA4),
        J === r.UNSIGNED_SHORT_5_5_5_1 && (mt = r.RGB5_A1)
    }
    return (
      (mt === r.R16F ||
        mt === r.R32F ||
        mt === r.RG16F ||
        mt === r.RG32F ||
        mt === r.RGBA16F ||
        mt === r.RGBA32F) &&
        t.get('EXT_color_buffer_float'),
      mt
    )
  }
  function _(G, N) {
    let J
    return (
      G
        ? N === null || N === Uu || N === Uh
          ? (J = r.DEPTH24_STENCIL8)
          : N === ya
          ? (J = r.DEPTH32F_STENCIL8)
          : N === gp &&
            ((J = r.DEPTH24_STENCIL8),
            console.warn(
              'DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.',
            ))
        : N === null || N === Uu || N === Uh
        ? (J = r.DEPTH_COMPONENT24)
        : N === ya
        ? (J = r.DEPTH_COMPONENT32F)
        : N === gp && (J = r.DEPTH_COMPONENT16),
      J
    )
  }
  function x(G, N) {
    return v(G) === !0 ||
      (G.isFramebufferTexture && G.minFilter !== Ur && G.minFilter !== gi)
      ? Math.log2(Math.max(N.width, N.height)) + 1
      : G.mipmaps !== void 0 && G.mipmaps.length > 0
      ? G.mipmaps.length
      : G.isCompressedTexture && Array.isArray(G.image)
      ? N.mipmaps.length
      : 1
  }
  function A(G) {
    const N = G.target
    N.removeEventListener('dispose', A), b(N), N.isVideoTexture && c.delete(N)
  }
  function S(G) {
    const N = G.target
    N.removeEventListener('dispose', S), w(N)
  }
  function b(G) {
    const N = n.get(G)
    if (N.__webglInit === void 0) return
    const J = G.source,
      vt = f.get(J)
    if (vt) {
      const yt = vt[N.__cacheKey]
      yt.usedTimes--,
        yt.usedTimes === 0 && T(G),
        Object.keys(vt).length === 0 && f.delete(J)
    }
    n.remove(G)
  }
  function T(G) {
    const N = n.get(G)
    r.deleteTexture(N.__webglTexture)
    const J = G.source,
      vt = f.get(J)
    delete vt[N.__cacheKey], o.memory.textures--
  }
  function w(G) {
    const N = n.get(G)
    if ((G.depthTexture && G.depthTexture.dispose(), G.isWebGLCubeRenderTarget))
      for (let vt = 0; vt < 6; vt++) {
        if (Array.isArray(N.__webglFramebuffer[vt]))
          for (let yt = 0; yt < N.__webglFramebuffer[vt].length; yt++)
            r.deleteFramebuffer(N.__webglFramebuffer[vt][yt])
        else r.deleteFramebuffer(N.__webglFramebuffer[vt])
        N.__webglDepthbuffer && r.deleteRenderbuffer(N.__webglDepthbuffer[vt])
      }
    else {
      if (Array.isArray(N.__webglFramebuffer))
        for (let vt = 0; vt < N.__webglFramebuffer.length; vt++)
          r.deleteFramebuffer(N.__webglFramebuffer[vt])
      else r.deleteFramebuffer(N.__webglFramebuffer)
      if (
        (N.__webglDepthbuffer && r.deleteRenderbuffer(N.__webglDepthbuffer),
        N.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer(N.__webglMultisampledFramebuffer),
        N.__webglColorRenderbuffer)
      )
        for (let vt = 0; vt < N.__webglColorRenderbuffer.length; vt++)
          N.__webglColorRenderbuffer[vt] &&
            r.deleteRenderbuffer(N.__webglColorRenderbuffer[vt])
      N.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer(N.__webglDepthRenderbuffer)
    }
    const J = G.textures
    for (let vt = 0, yt = J.length; vt < yt; vt++) {
      const mt = n.get(J[vt])
      mt.__webglTexture &&
        (r.deleteTexture(mt.__webglTexture), o.memory.textures--),
        n.remove(J[vt])
    }
    n.remove(G)
  }
  let M = 0
  function C() {
    M = 0
  }
  function E() {
    const G = M
    return (
      G >= i.maxTextures &&
        console.warn(
          'THREE.WebGLTextures: Trying to use ' +
            G +
            ' texture units while this GPU supports only ' +
            i.maxTextures,
        ),
      (M += 1),
      G
    )
  }
  function D(G) {
    const N = []
    return (
      N.push(G.wrapS),
      N.push(G.wrapT),
      N.push(G.wrapR || 0),
      N.push(G.magFilter),
      N.push(G.minFilter),
      N.push(G.anisotropy),
      N.push(G.internalFormat),
      N.push(G.format),
      N.push(G.type),
      N.push(G.generateMipmaps),
      N.push(G.premultiplyAlpha),
      N.push(G.flipY),
      N.push(G.unpackAlignment),
      N.push(G.colorSpace),
      N.join()
    )
  }
  function P(G, N) {
    const J = n.get(G)
    if (
      (G.isVideoTexture && kt(G),
      G.isRenderTargetTexture === !1 &&
        G.version > 0 &&
        J.__version !== G.version)
    ) {
      const vt = G.image
      if (vt === null)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but no image data found.',
        )
      else if (vt.complete === !1)
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
        )
      else {
        ut(J, G, N)
        return
      }
    }
    e.bindTexture(r.TEXTURE_2D, J.__webglTexture, r.TEXTURE0 + N)
  }
  function L(G, N) {
    const J = n.get(G)
    if (G.version > 0 && J.__version !== G.version) {
      ut(J, G, N)
      return
    }
    e.bindTexture(r.TEXTURE_2D_ARRAY, J.__webglTexture, r.TEXTURE0 + N)
  }
  function I(G, N) {
    const J = n.get(G)
    if (G.version > 0 && J.__version !== G.version) {
      ut(J, G, N)
      return
    }
    e.bindTexture(r.TEXTURE_3D, J.__webglTexture, r.TEXTURE0 + N)
  }
  function F(G, N) {
    const J = n.get(G)
    if (G.version > 0 && J.__version !== G.version) {
      W(J, G, N)
      return
    }
    e.bindTexture(r.TEXTURE_CUBE_MAP, J.__webglTexture, r.TEXTURE0 + N)
  }
  const k = {
      [Jn]: r.REPEAT,
      [Ps]: r.CLAMP_TO_EDGE,
      [py]: r.MIRRORED_REPEAT,
    },
    V = {
      [Ur]: r.NEAREST,
      [Bk]: r.NEAREST_MIPMAP_NEAREST,
      [Cd]: r.NEAREST_MIPMAP_LINEAR,
      [gi]: r.LINEAR,
      [Im]: r.LINEAR_MIPMAP_NEAREST,
      [Fo]: r.LINEAR_MIPMAP_LINEAR,
    },
    H = {
      [u6]: r.NEVER,
      [v6]: r.ALWAYS,
      [c6]: r.LESS,
      [qk]: r.LEQUAL,
      [h6]: r.EQUAL,
      [p6]: r.GEQUAL,
      [f6]: r.GREATER,
      [d6]: r.NOTEQUAL,
    }
  function Y(G, N) {
    if (
      (N.type === ya &&
        t.has('OES_texture_float_linear') === !1 &&
        (N.magFilter === gi ||
          N.magFilter === Im ||
          N.magFilter === Cd ||
          N.magFilter === Fo ||
          N.minFilter === gi ||
          N.minFilter === Im ||
          N.minFilter === Cd ||
          N.minFilter === Fo) &&
        console.warn(
          'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.',
        ),
      r.texParameteri(G, r.TEXTURE_WRAP_S, k[N.wrapS]),
      r.texParameteri(G, r.TEXTURE_WRAP_T, k[N.wrapT]),
      (G === r.TEXTURE_3D || G === r.TEXTURE_2D_ARRAY) &&
        r.texParameteri(G, r.TEXTURE_WRAP_R, k[N.wrapR]),
      r.texParameteri(G, r.TEXTURE_MAG_FILTER, V[N.magFilter]),
      r.texParameteri(G, r.TEXTURE_MIN_FILTER, V[N.minFilter]),
      N.compareFunction &&
        (r.texParameteri(G, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE),
        r.texParameteri(G, r.TEXTURE_COMPARE_FUNC, H[N.compareFunction])),
      t.has('EXT_texture_filter_anisotropic') === !0)
    ) {
      if (
        N.magFilter === Ur ||
        (N.minFilter !== Cd && N.minFilter !== Fo) ||
        (N.type === ya && t.has('OES_texture_float_linear') === !1)
      )
        return
      if (N.anisotropy > 1 || n.get(N).__currentAnisotropy) {
        const J = t.get('EXT_texture_filter_anisotropic')
        r.texParameterf(
          G,
          J.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(N.anisotropy, i.getMaxAnisotropy()),
        ),
          (n.get(N).__currentAnisotropy = N.anisotropy)
      }
    }
  }
  function K(G, N) {
    let J = !1
    G.__webglInit === void 0 &&
      ((G.__webglInit = !0), N.addEventListener('dispose', A))
    const vt = N.source
    let yt = f.get(vt)
    yt === void 0 && ((yt = {}), f.set(vt, yt))
    const mt = D(N)
    if (mt !== G.__cacheKey) {
      yt[mt] === void 0 &&
        ((yt[mt] = {
          texture: r.createTexture(),
          usedTimes: 0,
        }),
        o.memory.textures++,
        (J = !0)),
        yt[mt].usedTimes++
      const Kt = yt[G.__cacheKey]
      Kt !== void 0 &&
        (yt[G.__cacheKey].usedTimes--, Kt.usedTimes === 0 && T(N)),
        (G.__cacheKey = mt),
        (G.__webglTexture = yt[mt].texture)
    }
    return J
  }
  function ut(G, N, J) {
    let vt = r.TEXTURE_2D
    ;(N.isDataArrayTexture || N.isCompressedArrayTexture) &&
      (vt = r.TEXTURE_2D_ARRAY),
      N.isData3DTexture && (vt = r.TEXTURE_3D)
    const yt = K(G, N),
      mt = N.source
    e.bindTexture(vt, G.__webglTexture, r.TEXTURE0 + J)
    const Kt = n.get(mt)
    if (mt.version !== Kt.__version || yt === !0) {
      e.activeTexture(r.TEXTURE0 + J)
      const It = Be.getPrimaries(Be.workingColorSpace),
        Bt = N.colorSpace === Ls ? null : Be.getPrimaries(N.colorSpace),
        fe = N.colorSpace === Ls || It === Bt ? r.NONE : r.BROWSER_DEFAULT_WEBGL
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, N.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, N.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, fe)
      let Mt = g(N.image, !1, i.maxTextureSize)
      Mt = Ct(N, Mt)
      const Ot = a.convert(N.format, N.colorSpace),
        Te = a.convert(N.type)
      let se = y(N.internalFormat, Ot, Te, N.colorSpace, N.isVideoTexture)
      Y(vt, N)
      let Gt
      const ue = N.mipmaps,
        de = N.isVideoTexture !== !0,
        ln = Kt.__version === void 0 || yt === !0,
        O = mt.dataReady,
        j = x(N, Mt)
      if (N.isDepthTexture)
        (se = _(N.format === Vh, N.type)),
          ln &&
            (de
              ? e.texStorage2D(r.TEXTURE_2D, 1, se, Mt.width, Mt.height)
              : e.texImage2D(
                  r.TEXTURE_2D,
                  0,
                  se,
                  Mt.width,
                  Mt.height,
                  0,
                  Ot,
                  Te,
                  null,
                ))
      else if (N.isDataTexture)
        if (ue.length > 0) {
          de &&
            ln &&
            e.texStorage2D(r.TEXTURE_2D, j, se, ue[0].width, ue[0].height)
          for (let tt = 0, ot = ue.length; tt < ot; tt++)
            (Gt = ue[tt]),
              de
                ? O &&
                  e.texSubImage2D(
                    r.TEXTURE_2D,
                    tt,
                    0,
                    0,
                    Gt.width,
                    Gt.height,
                    Ot,
                    Te,
                    Gt.data,
                  )
                : e.texImage2D(
                    r.TEXTURE_2D,
                    tt,
                    se,
                    Gt.width,
                    Gt.height,
                    0,
                    Ot,
                    Te,
                    Gt.data,
                  )
          N.generateMipmaps = !1
        } else
          de
            ? (ln && e.texStorage2D(r.TEXTURE_2D, j, se, Mt.width, Mt.height),
              O &&
                e.texSubImage2D(
                  r.TEXTURE_2D,
                  0,
                  0,
                  0,
                  Mt.width,
                  Mt.height,
                  Ot,
                  Te,
                  Mt.data,
                ))
            : e.texImage2D(
                r.TEXTURE_2D,
                0,
                se,
                Mt.width,
                Mt.height,
                0,
                Ot,
                Te,
                Mt.data,
              )
      else if (N.isCompressedTexture)
        if (N.isCompressedArrayTexture) {
          de &&
            ln &&
            e.texStorage3D(
              r.TEXTURE_2D_ARRAY,
              j,
              se,
              ue[0].width,
              ue[0].height,
              Mt.depth,
            )
          for (let tt = 0, ot = ue.length; tt < ot; tt++)
            if (((Gt = ue[tt]), N.format !== Yi))
              if (Ot !== null)
                if (de) {
                  if (O)
                    if (N.layerUpdates.size > 0) {
                      const St = Y2(Gt.width, Gt.height, N.format, N.type)
                      for (const jt of N.layerUpdates) {
                        const ce = Gt.data.subarray(
                          (jt * St) / Gt.data.BYTES_PER_ELEMENT,
                          ((jt + 1) * St) / Gt.data.BYTES_PER_ELEMENT,
                        )
                        e.compressedTexSubImage3D(
                          r.TEXTURE_2D_ARRAY,
                          tt,
                          0,
                          0,
                          jt,
                          Gt.width,
                          Gt.height,
                          1,
                          Ot,
                          ce,
                          0,
                          0,
                        )
                      }
                      N.clearLayerUpdates()
                    } else
                      e.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        tt,
                        0,
                        0,
                        0,
                        Gt.width,
                        Gt.height,
                        Mt.depth,
                        Ot,
                        Gt.data,
                        0,
                        0,
                      )
                } else
                  e.compressedTexImage3D(
                    r.TEXTURE_2D_ARRAY,
                    tt,
                    se,
                    Gt.width,
                    Gt.height,
                    Mt.depth,
                    0,
                    Gt.data,
                    0,
                    0,
                  )
              else
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                )
            else
              de
                ? O &&
                  e.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    tt,
                    0,
                    0,
                    0,
                    Gt.width,
                    Gt.height,
                    Mt.depth,
                    Ot,
                    Te,
                    Gt.data,
                  )
                : e.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    tt,
                    se,
                    Gt.width,
                    Gt.height,
                    Mt.depth,
                    0,
                    Ot,
                    Te,
                    Gt.data,
                  )
        } else {
          de &&
            ln &&
            e.texStorage2D(r.TEXTURE_2D, j, se, ue[0].width, ue[0].height)
          for (let tt = 0, ot = ue.length; tt < ot; tt++)
            (Gt = ue[tt]),
              N.format !== Yi
                ? Ot !== null
                  ? de
                    ? O &&
                      e.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        tt,
                        0,
                        0,
                        Gt.width,
                        Gt.height,
                        Ot,
                        Gt.data,
                      )
                    : e.compressedTexImage2D(
                        r.TEXTURE_2D,
                        tt,
                        se,
                        Gt.width,
                        Gt.height,
                        0,
                        Gt.data,
                      )
                  : console.warn(
                      'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                    )
                : de
                ? O &&
                  e.texSubImage2D(
                    r.TEXTURE_2D,
                    tt,
                    0,
                    0,
                    Gt.width,
                    Gt.height,
                    Ot,
                    Te,
                    Gt.data,
                  )
                : e.texImage2D(
                    r.TEXTURE_2D,
                    tt,
                    se,
                    Gt.width,
                    Gt.height,
                    0,
                    Ot,
                    Te,
                    Gt.data,
                  )
        }
      else if (N.isDataArrayTexture)
        if (de) {
          if (
            (ln &&
              e.texStorage3D(
                r.TEXTURE_2D_ARRAY,
                j,
                se,
                Mt.width,
                Mt.height,
                Mt.depth,
              ),
            O)
          )
            if (N.layerUpdates.size > 0) {
              const tt = Y2(Mt.width, Mt.height, N.format, N.type)
              for (const ot of N.layerUpdates) {
                const St = Mt.data.subarray(
                  (ot * tt) / Mt.data.BYTES_PER_ELEMENT,
                  ((ot + 1) * tt) / Mt.data.BYTES_PER_ELEMENT,
                )
                e.texSubImage3D(
                  r.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  ot,
                  Mt.width,
                  Mt.height,
                  1,
                  Ot,
                  Te,
                  St,
                )
              }
              N.clearLayerUpdates()
            } else
              e.texSubImage3D(
                r.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Mt.width,
                Mt.height,
                Mt.depth,
                Ot,
                Te,
                Mt.data,
              )
        } else
          e.texImage3D(
            r.TEXTURE_2D_ARRAY,
            0,
            se,
            Mt.width,
            Mt.height,
            Mt.depth,
            0,
            Ot,
            Te,
            Mt.data,
          )
      else if (N.isData3DTexture)
        de
          ? (ln &&
              e.texStorage3D(
                r.TEXTURE_3D,
                j,
                se,
                Mt.width,
                Mt.height,
                Mt.depth,
              ),
            O &&
              e.texSubImage3D(
                r.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Mt.width,
                Mt.height,
                Mt.depth,
                Ot,
                Te,
                Mt.data,
              ))
          : e.texImage3D(
              r.TEXTURE_3D,
              0,
              se,
              Mt.width,
              Mt.height,
              Mt.depth,
              0,
              Ot,
              Te,
              Mt.data,
            )
      else if (N.isFramebufferTexture) {
        if (ln)
          if (de) e.texStorage2D(r.TEXTURE_2D, j, se, Mt.width, Mt.height)
          else {
            let tt = Mt.width,
              ot = Mt.height
            for (let St = 0; St < j; St++)
              e.texImage2D(r.TEXTURE_2D, St, se, tt, ot, 0, Ot, Te, null),
                (tt >>= 1),
                (ot >>= 1)
          }
      } else if (ue.length > 0) {
        if (de && ln) {
          const tt = Lt(ue[0])
          e.texStorage2D(r.TEXTURE_2D, j, se, tt.width, tt.height)
        }
        for (let tt = 0, ot = ue.length; tt < ot; tt++)
          (Gt = ue[tt]),
            de
              ? O && e.texSubImage2D(r.TEXTURE_2D, tt, 0, 0, Ot, Te, Gt)
              : e.texImage2D(r.TEXTURE_2D, tt, se, Ot, Te, Gt)
        N.generateMipmaps = !1
      } else if (de) {
        if (ln) {
          const tt = Lt(Mt)
          e.texStorage2D(r.TEXTURE_2D, j, se, tt.width, tt.height)
        }
        O && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ot, Te, Mt)
      } else e.texImage2D(r.TEXTURE_2D, 0, se, Ot, Te, Mt)
      v(N) && m(vt), (Kt.__version = mt.version), N.onUpdate && N.onUpdate(N)
    }
    G.__version = N.version
  }
  function W(G, N, J) {
    if (N.image.length !== 6) return
    const vt = K(G, N),
      yt = N.source
    e.bindTexture(r.TEXTURE_CUBE_MAP, G.__webglTexture, r.TEXTURE0 + J)
    const mt = n.get(yt)
    if (yt.version !== mt.__version || vt === !0) {
      e.activeTexture(r.TEXTURE0 + J)
      const Kt = Be.getPrimaries(Be.workingColorSpace),
        It = N.colorSpace === Ls ? null : Be.getPrimaries(N.colorSpace),
        Bt = N.colorSpace === Ls || Kt === It ? r.NONE : r.BROWSER_DEFAULT_WEBGL
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, N.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, N.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Bt)
      const fe = N.isCompressedTexture || N.image[0].isCompressedTexture,
        Mt = N.image[0] && N.image[0].isDataTexture,
        Ot = []
      for (let ot = 0; ot < 6; ot++)
        !fe && !Mt
          ? (Ot[ot] = g(N.image[ot], !0, i.maxCubemapSize))
          : (Ot[ot] = Mt ? N.image[ot].image : N.image[ot]),
          (Ot[ot] = Ct(N, Ot[ot]))
      const Te = Ot[0],
        se = a.convert(N.format, N.colorSpace),
        Gt = a.convert(N.type),
        ue = y(N.internalFormat, se, Gt, N.colorSpace),
        de = N.isVideoTexture !== !0,
        ln = mt.__version === void 0 || vt === !0,
        O = yt.dataReady
      let j = x(N, Te)
      Y(r.TEXTURE_CUBE_MAP, N)
      let tt
      if (fe) {
        de &&
          ln &&
          e.texStorage2D(r.TEXTURE_CUBE_MAP, j, ue, Te.width, Te.height)
        for (let ot = 0; ot < 6; ot++) {
          tt = Ot[ot].mipmaps
          for (let St = 0; St < tt.length; St++) {
            const jt = tt[St]
            N.format !== Yi
              ? se !== null
                ? de
                  ? O &&
                    e.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                      St,
                      0,
                      0,
                      jt.width,
                      jt.height,
                      se,
                      jt.data,
                    )
                  : e.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                      St,
                      ue,
                      jt.width,
                      jt.height,
                      0,
                      jt.data,
                    )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                  )
              : de
              ? O &&
                e.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  St,
                  0,
                  0,
                  jt.width,
                  jt.height,
                  se,
                  Gt,
                  jt.data,
                )
              : e.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  St,
                  ue,
                  jt.width,
                  jt.height,
                  0,
                  se,
                  Gt,
                  jt.data,
                )
          }
        }
      } else {
        if (((tt = N.mipmaps), de && ln)) {
          tt.length > 0 && j++
          const ot = Lt(Ot[0])
          e.texStorage2D(r.TEXTURE_CUBE_MAP, j, ue, ot.width, ot.height)
        }
        for (let ot = 0; ot < 6; ot++)
          if (Mt) {
            de
              ? O &&
                e.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  0,
                  0,
                  0,
                  Ot[ot].width,
                  Ot[ot].height,
                  se,
                  Gt,
                  Ot[ot].data,
                )
              : e.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  0,
                  ue,
                  Ot[ot].width,
                  Ot[ot].height,
                  0,
                  se,
                  Gt,
                  Ot[ot].data,
                )
            for (let St = 0; St < tt.length; St++) {
              const ce = tt[St].image[ot].image
              de
                ? O &&
                  e.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                    St + 1,
                    0,
                    0,
                    ce.width,
                    ce.height,
                    se,
                    Gt,
                    ce.data,
                  )
                : e.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                    St + 1,
                    ue,
                    ce.width,
                    ce.height,
                    0,
                    se,
                    Gt,
                    ce.data,
                  )
            }
          } else {
            de
              ? O &&
                e.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  0,
                  0,
                  0,
                  se,
                  Gt,
                  Ot[ot],
                )
              : e.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                  0,
                  ue,
                  se,
                  Gt,
                  Ot[ot],
                )
            for (let St = 0; St < tt.length; St++) {
              const jt = tt[St]
              de
                ? O &&
                  e.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                    St + 1,
                    0,
                    0,
                    se,
                    Gt,
                    jt.image[ot],
                  )
                : e.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + ot,
                    St + 1,
                    ue,
                    se,
                    Gt,
                    jt.image[ot],
                  )
            }
          }
      }
      v(N) && m(r.TEXTURE_CUBE_MAP),
        (mt.__version = yt.version),
        N.onUpdate && N.onUpdate(N)
    }
    G.__version = N.version
  }
  function Z(G, N, J, vt, yt, mt) {
    const Kt = a.convert(J.format, J.colorSpace),
      It = a.convert(J.type),
      Bt = y(J.internalFormat, Kt, It, J.colorSpace)
    if (!n.get(N).__hasExternalTextures) {
      const Mt = Math.max(1, N.width >> mt),
        Ot = Math.max(1, N.height >> mt)
      yt === r.TEXTURE_3D || yt === r.TEXTURE_2D_ARRAY
        ? e.texImage3D(yt, mt, Bt, Mt, Ot, N.depth, 0, Kt, It, null)
        : e.texImage2D(yt, mt, Bt, Mt, Ot, 0, Kt, It, null)
    }
    e.bindFramebuffer(r.FRAMEBUFFER, G),
      rt(N)
        ? s.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            vt,
            yt,
            n.get(J).__webglTexture,
            0,
            xt(N),
          )
        : (yt === r.TEXTURE_2D ||
            (yt >= r.TEXTURE_CUBE_MAP_POSITIVE_X &&
              yt <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            vt,
            yt,
            n.get(J).__webglTexture,
            mt,
          ),
      e.bindFramebuffer(r.FRAMEBUFFER, null)
  }
  function ft(G, N, J) {
    if ((r.bindRenderbuffer(r.RENDERBUFFER, G), N.depthBuffer)) {
      const vt = N.depthTexture,
        yt = vt && vt.isDepthTexture ? vt.type : null,
        mt = _(N.stencilBuffer, yt),
        Kt = N.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        It = xt(N)
      rt(N)
        ? s.renderbufferStorageMultisampleEXT(
            r.RENDERBUFFER,
            It,
            mt,
            N.width,
            N.height,
          )
        : J
        ? r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            It,
            mt,
            N.width,
            N.height,
          )
        : r.renderbufferStorage(r.RENDERBUFFER, mt, N.width, N.height),
        r.framebufferRenderbuffer(r.FRAMEBUFFER, Kt, r.RENDERBUFFER, G)
    } else {
      const vt = N.textures
      for (let yt = 0; yt < vt.length; yt++) {
        const mt = vt[yt],
          Kt = a.convert(mt.format, mt.colorSpace),
          It = a.convert(mt.type),
          Bt = y(mt.internalFormat, Kt, It, mt.colorSpace),
          fe = xt(N)
        J && rt(N) === !1
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              fe,
              Bt,
              N.width,
              N.height,
            )
          : rt(N)
          ? s.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              fe,
              Bt,
              N.width,
              N.height,
            )
          : r.renderbufferStorage(r.RENDERBUFFER, Bt, N.width, N.height)
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null)
  }
  function lt(G, N) {
    if (N && N.isWebGLCubeRenderTarget)
      throw new Error('Depth Texture with cube render targets is not supported')
    if (
      (e.bindFramebuffer(r.FRAMEBUFFER, G),
      !(N.depthTexture && N.depthTexture.isDepthTexture))
    )
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
      )
    ;(!n.get(N.depthTexture).__webglTexture ||
      N.depthTexture.image.width !== N.width ||
      N.depthTexture.image.height !== N.height) &&
      ((N.depthTexture.image.width = N.width),
      (N.depthTexture.image.height = N.height),
      (N.depthTexture.needsUpdate = !0)),
      P(N.depthTexture, 0)
    const vt = n.get(N.depthTexture).__webglTexture,
      yt = xt(N)
    if (N.depthTexture.format === wh)
      rt(N)
        ? s.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            vt,
            0,
            yt,
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            vt,
            0,
          )
    else if (N.depthTexture.format === Vh)
      rt(N)
        ? s.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            vt,
            0,
            yt,
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            vt,
            0,
          )
    else throw new Error('Unknown depthTexture format')
  }
  function ct(G) {
    const N = n.get(G),
      J = G.isWebGLCubeRenderTarget === !0
    if (G.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (J)
        throw new Error(
          'target.depthTexture not supported in Cube render targets',
        )
      lt(N.__webglFramebuffer, G)
    } else if (J) {
      N.__webglDepthbuffer = []
      for (let vt = 0; vt < 6; vt++)
        e.bindFramebuffer(r.FRAMEBUFFER, N.__webglFramebuffer[vt]),
          (N.__webglDepthbuffer[vt] = r.createRenderbuffer()),
          ft(N.__webglDepthbuffer[vt], G, !1)
    } else
      e.bindFramebuffer(r.FRAMEBUFFER, N.__webglFramebuffer),
        (N.__webglDepthbuffer = r.createRenderbuffer()),
        ft(N.__webglDepthbuffer, G, !1)
    e.bindFramebuffer(r.FRAMEBUFFER, null)
  }
  function At(G, N, J) {
    const vt = n.get(G)
    N !== void 0 &&
      Z(
        vt.__webglFramebuffer,
        G,
        G.texture,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D,
        0,
      ),
      J !== void 0 && ct(G)
  }
  function gt(G) {
    const N = G.texture,
      J = n.get(G),
      vt = n.get(N)
    G.addEventListener('dispose', S)
    const yt = G.textures,
      mt = G.isWebGLCubeRenderTarget === !0,
      Kt = yt.length > 1
    if (
      (Kt ||
        (vt.__webglTexture === void 0 &&
          (vt.__webglTexture = r.createTexture()),
        (vt.__version = N.version),
        o.memory.textures++),
      mt)
    ) {
      J.__webglFramebuffer = []
      for (let It = 0; It < 6; It++)
        if (N.mipmaps && N.mipmaps.length > 0) {
          J.__webglFramebuffer[It] = []
          for (let Bt = 0; Bt < N.mipmaps.length; Bt++)
            J.__webglFramebuffer[It][Bt] = r.createFramebuffer()
        } else J.__webglFramebuffer[It] = r.createFramebuffer()
    } else {
      if (N.mipmaps && N.mipmaps.length > 0) {
        J.__webglFramebuffer = []
        for (let It = 0; It < N.mipmaps.length; It++)
          J.__webglFramebuffer[It] = r.createFramebuffer()
      } else J.__webglFramebuffer = r.createFramebuffer()
      if (Kt)
        for (let It = 0, Bt = yt.length; It < Bt; It++) {
          const fe = n.get(yt[It])
          fe.__webglTexture === void 0 &&
            ((fe.__webglTexture = r.createTexture()), o.memory.textures++)
        }
      if (G.samples > 0 && rt(G) === !1) {
        ;(J.__webglMultisampledFramebuffer = r.createFramebuffer()),
          (J.__webglColorRenderbuffer = []),
          e.bindFramebuffer(r.FRAMEBUFFER, J.__webglMultisampledFramebuffer)
        for (let It = 0; It < yt.length; It++) {
          const Bt = yt[It]
          ;(J.__webglColorRenderbuffer[It] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, J.__webglColorRenderbuffer[It])
          const fe = a.convert(Bt.format, Bt.colorSpace),
            Mt = a.convert(Bt.type),
            Ot = y(
              Bt.internalFormat,
              fe,
              Mt,
              Bt.colorSpace,
              G.isXRRenderTarget === !0,
            ),
            Te = xt(G)
          r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            Te,
            Ot,
            G.width,
            G.height,
          ),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + It,
              r.RENDERBUFFER,
              J.__webglColorRenderbuffer[It],
            )
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          G.depthBuffer &&
            ((J.__webglDepthRenderbuffer = r.createRenderbuffer()),
            ft(J.__webglDepthRenderbuffer, G, !0)),
          e.bindFramebuffer(r.FRAMEBUFFER, null)
      }
    }
    if (mt) {
      e.bindTexture(r.TEXTURE_CUBE_MAP, vt.__webglTexture),
        Y(r.TEXTURE_CUBE_MAP, N)
      for (let It = 0; It < 6; It++)
        if (N.mipmaps && N.mipmaps.length > 0)
          for (let Bt = 0; Bt < N.mipmaps.length; Bt++)
            Z(
              J.__webglFramebuffer[It][Bt],
              G,
              N,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_CUBE_MAP_POSITIVE_X + It,
              Bt,
            )
        else
          Z(
            J.__webglFramebuffer[It],
            G,
            N,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_CUBE_MAP_POSITIVE_X + It,
            0,
          )
      v(N) && m(r.TEXTURE_CUBE_MAP), e.unbindTexture()
    } else if (Kt) {
      for (let It = 0, Bt = yt.length; It < Bt; It++) {
        const fe = yt[It],
          Mt = n.get(fe)
        e.bindTexture(r.TEXTURE_2D, Mt.__webglTexture),
          Y(r.TEXTURE_2D, fe),
          Z(
            J.__webglFramebuffer,
            G,
            fe,
            r.COLOR_ATTACHMENT0 + It,
            r.TEXTURE_2D,
            0,
          ),
          v(fe) && m(r.TEXTURE_2D)
      }
      e.unbindTexture()
    } else {
      let It = r.TEXTURE_2D
      if (
        ((G.isWebGL3DRenderTarget || G.isWebGLArrayRenderTarget) &&
          (It = G.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY),
        e.bindTexture(It, vt.__webglTexture),
        Y(It, N),
        N.mipmaps && N.mipmaps.length > 0)
      )
        for (let Bt = 0; Bt < N.mipmaps.length; Bt++)
          Z(J.__webglFramebuffer[Bt], G, N, r.COLOR_ATTACHMENT0, It, Bt)
      else Z(J.__webglFramebuffer, G, N, r.COLOR_ATTACHMENT0, It, 0)
      v(N) && m(It), e.unbindTexture()
    }
    G.depthBuffer && ct(G)
  }
  function dt(G) {
    const N = G.textures
    for (let J = 0, vt = N.length; J < vt; J++) {
      const yt = N[J]
      if (v(yt)) {
        const mt = G.isWebGLCubeRenderTarget
            ? r.TEXTURE_CUBE_MAP
            : r.TEXTURE_2D,
          Kt = n.get(yt).__webglTexture
        e.bindTexture(mt, Kt), m(mt), e.unbindTexture()
      }
    }
  }
  const B = [],
    ht = []
  function it(G) {
    if (G.samples > 0) {
      if (rt(G) === !1) {
        const N = G.textures,
          J = G.width,
          vt = G.height
        let yt = r.COLOR_BUFFER_BIT
        const mt = G.stencilBuffer
            ? r.DEPTH_STENCIL_ATTACHMENT
            : r.DEPTH_ATTACHMENT,
          Kt = n.get(G),
          It = N.length > 1
        if (It)
          for (let Bt = 0; Bt < N.length; Bt++)
            e.bindFramebuffer(r.FRAMEBUFFER, Kt.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + Bt,
                r.RENDERBUFFER,
                null,
              ),
              e.bindFramebuffer(r.FRAMEBUFFER, Kt.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + Bt,
                r.TEXTURE_2D,
                null,
                0,
              )
        e.bindFramebuffer(
          r.READ_FRAMEBUFFER,
          Kt.__webglMultisampledFramebuffer,
        ),
          e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Kt.__webglFramebuffer)
        for (let Bt = 0; Bt < N.length; Bt++) {
          if (
            (G.resolveDepthBuffer &&
              (G.depthBuffer && (yt |= r.DEPTH_BUFFER_BIT),
              G.stencilBuffer &&
                G.resolveStencilBuffer &&
                (yt |= r.STENCIL_BUFFER_BIT)),
            It)
          ) {
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              Kt.__webglColorRenderbuffer[Bt],
            )
            const fe = n.get(N[Bt]).__webglTexture
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.TEXTURE_2D,
              fe,
              0,
            )
          }
          r.blitFramebuffer(0, 0, J, vt, 0, 0, J, vt, yt, r.NEAREST),
            l === !0 &&
              ((B.length = 0),
              (ht.length = 0),
              B.push(r.COLOR_ATTACHMENT0 + Bt),
              G.depthBuffer &&
                G.resolveDepthBuffer === !1 &&
                (B.push(mt),
                ht.push(mt),
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, ht)),
              r.invalidateFramebuffer(r.READ_FRAMEBUFFER, B))
        }
        if (
          (e.bindFramebuffer(r.READ_FRAMEBUFFER, null),
          e.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
          It)
        )
          for (let Bt = 0; Bt < N.length; Bt++) {
            e.bindFramebuffer(r.FRAMEBUFFER, Kt.__webglMultisampledFramebuffer),
              r.framebufferRenderbuffer(
                r.FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + Bt,
                r.RENDERBUFFER,
                Kt.__webglColorRenderbuffer[Bt],
              )
            const fe = n.get(N[Bt]).__webglTexture
            e.bindFramebuffer(r.FRAMEBUFFER, Kt.__webglFramebuffer),
              r.framebufferTexture2D(
                r.DRAW_FRAMEBUFFER,
                r.COLOR_ATTACHMENT0 + Bt,
                r.TEXTURE_2D,
                fe,
                0,
              )
          }
        e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Kt.__webglMultisampledFramebuffer)
      } else if (G.depthBuffer && G.resolveDepthBuffer === !1 && l) {
        const N = G.stencilBuffer
          ? r.DEPTH_STENCIL_ATTACHMENT
          : r.DEPTH_ATTACHMENT
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [N])
      }
    }
  }
  function xt(G) {
    return Math.min(i.maxSamples, G.samples)
  }
  function rt(G) {
    const N = n.get(G)
    return (
      G.samples > 0 &&
      t.has('WEBGL_multisampled_render_to_texture') === !0 &&
      N.__useRenderToTexture !== !1
    )
  }
  function kt(G) {
    const N = o.render.frame
    c.get(G) !== N && (c.set(G, N), G.update())
  }
  function Ct(G, N) {
    const J = G.colorSpace,
      vt = G.format,
      yt = G.type
    return (
      G.isCompressedTexture === !0 ||
        G.isVideoTexture === !0 ||
        (J !== ar &&
          J !== Ls &&
          (Be.getTransfer(J) === an
            ? (vt !== Yi || yt !== qo) &&
              console.warn(
                'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.',
              )
            : console.error(
                'THREE.WebGLTextures: Unsupported texture color space:',
                J,
              ))),
      N
    )
  }
  function Lt(G) {
    return (
      typeof HTMLImageElement < 'u' && G instanceof HTMLImageElement
        ? ((u.width = G.naturalWidth || G.width),
          (u.height = G.naturalHeight || G.height))
        : typeof VideoFrame < 'u' && G instanceof VideoFrame
        ? ((u.width = G.displayWidth), (u.height = G.displayHeight))
        : ((u.width = G.width), (u.height = G.height)),
      u
    )
  }
  ;(this.allocateTextureUnit = E),
    (this.resetTextureUnits = C),
    (this.setTexture2D = P),
    (this.setTexture2DArray = L),
    (this.setTexture3D = I),
    (this.setTextureCube = F),
    (this.rebindTextures = At),
    (this.setupRenderTarget = gt),
    (this.updateRenderTargetMipmap = dt),
    (this.updateMultisampleRenderTarget = it),
    (this.setupDepthRenderbuffer = ct),
    (this.setupFrameBufferTexture = Z),
    (this.useMultisampledRTT = rt)
}
function LY(r, t) {
  function e(n, i = Ls) {
    let a
    const o = Be.getTransfer(i)
    if (n === qo) return r.UNSIGNED_BYTE
    if (n === wM) return r.UNSIGNED_SHORT_4_4_4_4
    if (n === MM) return r.UNSIGNED_SHORT_5_5_5_1
    if (n === Uk) return r.UNSIGNED_INT_5_9_9_9_REV
    if (n === Fk) return r.BYTE
    if (n === zk) return r.SHORT
    if (n === gp) return r.UNSIGNED_SHORT
    if (n === bM) return r.INT
    if (n === Uu) return r.UNSIGNED_INT
    if (n === ya) return r.FLOAT
    if (n === hv) return r.HALF_FLOAT
    if (n === Vk) return r.ALPHA
    if (n === Gk) return r.RGB
    if (n === Yi) return r.RGBA
    if (n === Hk) return r.LUMINANCE
    if (n === Wk) return r.LUMINANCE_ALPHA
    if (n === wh) return r.DEPTH_COMPONENT
    if (n === Vh) return r.DEPTH_STENCIL
    if (n === TM) return r.RED
    if (n === CM) return r.RED_INTEGER
    if (n === Xk) return r.RG
    if (n === EM) return r.RG_INTEGER
    if (n === DM) return r.RGBA_INTEGER
    if (n === Om || n === Nm || n === km || n === Bm)
      if (o === an)
        if (((a = t.get('WEBGL_compressed_texture_s3tc_srgb')), a !== null)) {
          if (n === Om) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (n === Nm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (n === km) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (n === Bm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null
      else if (((a = t.get('WEBGL_compressed_texture_s3tc')), a !== null)) {
        if (n === Om) return a.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (n === Nm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (n === km) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (n === Bm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null
    if (n === _A || n === xA || n === SA || n === AA)
      if (((a = t.get('WEBGL_compressed_texture_pvrtc')), a !== null)) {
        if (n === _A) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (n === xA) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (n === SA) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (n === AA) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else return null
    if (n === bA || n === wA || n === MA)
      if (((a = t.get('WEBGL_compressed_texture_etc')), a !== null)) {
        if (n === bA || n === wA)
          return o === an ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2
        if (n === MA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC
      } else return null
    if (
      n === TA ||
      n === CA ||
      n === EA ||
      n === DA ||
      n === LA ||
      n === PA ||
      n === RA ||
      n === IA ||
      n === OA ||
      n === NA ||
      n === kA ||
      n === BA ||
      n === FA ||
      n === zA
    )
      if (((a = t.get('WEBGL_compressed_texture_astc')), a !== null)) {
        if (n === TA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (n === CA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (n === EA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (n === DA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (n === LA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (n === PA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (n === RA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (n === IA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (n === OA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (n === NA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (n === kA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (n === BA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (n === FA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (n === zA)
          return o === an
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else return null
    if (n === Fm || n === UA || n === VA)
      if (((a = t.get('EXT_texture_compression_bptc')), a !== null)) {
        if (n === Fm)
          return o === an
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
        if (n === UA) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT
        if (n === VA) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
      } else return null
    if (n === Yk || n === GA || n === HA || n === WA)
      if (((a = t.get('EXT_texture_compression_rgtc')), a !== null)) {
        if (n === Fm) return a.COMPRESSED_RED_RGTC1_EXT
        if (n === GA) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT
        if (n === HA) return a.COMPRESSED_RED_GREEN_RGTC2_EXT
        if (n === WA) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } else return null
    return n === Uh ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
  }
  return {
    convert: e,
  }
}
class PY extends wr {
  constructor(t = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = t)
  }
}
let un = class extends Fe {
  constructor() {
    super(), (this.isGroup = !0), (this.type = 'Group')
  }
}
const RY = {
  type: 'move',
}
class sx {
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new un()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = {
          pinching: !1,
        })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new un()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new U()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new U())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new un()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new U()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new U())),
      this._grip
    )
  }
  dispatchEvent(t) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(t),
      this._grip !== null && this._grip.dispatchEvent(t),
      this._hand !== null && this._hand.dispatchEvent(t),
      this
    )
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand
      if (e) for (const n of t.hand.values()) this._getHandJoint(e, n)
    }
    return (
      this.dispatchEvent({
        type: 'connected',
        data: t,
      }),
      this
    )
  }
  disconnect(t) {
    return (
      this.dispatchEvent({
        type: 'disconnected',
        data: t,
      }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    )
  }
  update(t, e, n) {
    let i = null,
      a = null,
      o = null
    const s = this._targetRay,
      l = this._grip,
      u = this._hand
    if (t && e.session.visibilityState !== 'visible-blurred') {
      if (u && t.hand) {
        o = !0
        for (const g of t.hand.values()) {
          const v = e.getJointPose(g, n),
            m = this._getHandJoint(u, g)
          v !== null &&
            (m.matrix.fromArray(v.transform.matrix),
            m.matrix.decompose(m.position, m.rotation, m.scale),
            (m.matrixWorldNeedsUpdate = !0),
            (m.jointRadius = v.radius)),
            (m.visible = v !== null)
        }
        const c = u.joints['index-finger-tip'],
          h = u.joints['thumb-tip'],
          f = c.position.distanceTo(h.position),
          d = 0.02,
          p = 0.005
        u.inputState.pinching && f > d + p
          ? ((u.inputState.pinching = !1),
            this.dispatchEvent({
              type: 'pinchend',
              handedness: t.handedness,
              target: this,
            }))
          : !u.inputState.pinching &&
            f <= d - p &&
            ((u.inputState.pinching = !0),
            this.dispatchEvent({
              type: 'pinchstart',
              handedness: t.handedness,
              target: this,
            }))
      } else
        l !== null &&
          t.gripSpace &&
          ((a = e.getPose(t.gripSpace, n)),
          a !== null &&
            (l.matrix.fromArray(a.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            a.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(a.linearVelocity))
              : (l.hasLinearVelocity = !1),
            a.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(a.angularVelocity))
              : (l.hasAngularVelocity = !1)))
      s !== null &&
        ((i = e.getPose(t.targetRaySpace, n)),
        i === null && a !== null && (i = a),
        i !== null &&
          (s.matrix.fromArray(i.transform.matrix),
          s.matrix.decompose(s.position, s.rotation, s.scale),
          (s.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((s.hasLinearVelocity = !0),
              s.linearVelocity.copy(i.linearVelocity))
            : (s.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((s.hasAngularVelocity = !0),
              s.angularVelocity.copy(i.angularVelocity))
            : (s.hasAngularVelocity = !1),
          this.dispatchEvent(RY)))
    }
    return (
      s !== null && (s.visible = i !== null),
      l !== null && (l.visible = a !== null),
      u !== null && (u.visible = o !== null),
      this
    )
  }
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const n = new un()
      ;(n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (t.joints[e.jointName] = n),
        t.add(n)
    }
    return t.joints[e.jointName]
  }
}
const IY = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  OY = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`
class NY {
  constructor() {
    ;(this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0)
  }
  init(t, e, n) {
    if (this.texture === null) {
      const i = new Yn(),
        a = t.properties.get(i)
      ;(a.__webglTexture = e.texture),
        (e.depthNear != n.depthNear || e.depthFar != n.depthFar) &&
          ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = i)
    }
  }
  getMesh(t) {
    if (this.texture !== null && this.mesh === null) {
      const e = t.cameras[0].viewport,
        n = new lo({
          vertexShader: IY,
          fragmentShader: OY,
          uniforms: {
            depthColor: {
              value: this.texture,
            },
            depthWidth: {
              value: e.z,
            },
            depthHeight: {
              value: e.w,
            },
          },
        })
      this.mesh = new De(new Ti(20, 20), n)
    }
    return this.mesh
  }
  reset() {
    ;(this.texture = null), (this.mesh = null)
  }
  getDepthTexture() {
    return this.texture
  }
}
class kY extends Ju {
  constructor(t, e) {
    super()
    const n = this
    let i = null,
      a = 1,
      o = null,
      s = 'local-floor',
      l = 1,
      u = null,
      c = null,
      h = null,
      f = null,
      d = null,
      p = null
    const g = new NY(),
      v = e.getContextAttributes()
    let m = null,
      y = null
    const _ = [],
      x = [],
      A = new pt()
    let S = null
    const b = new wr()
    b.layers.enable(1), (b.viewport = new Oe())
    const T = new wr()
    T.layers.enable(2), (T.viewport = new Oe())
    const w = [b, T],
      M = new PY()
    M.layers.enable(1), M.layers.enable(2)
    let C = null,
      E = null
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (W) {
        let Z = _[W]
        return (
          Z === void 0 && ((Z = new sx()), (_[W] = Z)), Z.getTargetRaySpace()
        )
      }),
      (this.getControllerGrip = function (W) {
        let Z = _[W]
        return Z === void 0 && ((Z = new sx()), (_[W] = Z)), Z.getGripSpace()
      }),
      (this.getHand = function (W) {
        let Z = _[W]
        return Z === void 0 && ((Z = new sx()), (_[W] = Z)), Z.getHandSpace()
      })
    function D(W) {
      const Z = x.indexOf(W.inputSource)
      if (Z === -1) return
      const ft = _[Z]
      ft !== void 0 &&
        (ft.update(W.inputSource, W.frame, u || o),
        ft.dispatchEvent({
          type: W.type,
          data: W.inputSource,
        }))
    }
    function P() {
      i.removeEventListener('select', D),
        i.removeEventListener('selectstart', D),
        i.removeEventListener('selectend', D),
        i.removeEventListener('squeeze', D),
        i.removeEventListener('squeezestart', D),
        i.removeEventListener('squeezeend', D),
        i.removeEventListener('end', P),
        i.removeEventListener('inputsourceschange', L)
      for (let W = 0; W < _.length; W++) {
        const Z = x[W]
        Z !== null && ((x[W] = null), _[W].disconnect(Z))
      }
      ;(C = null),
        (E = null),
        g.reset(),
        t.setRenderTarget(m),
        (d = null),
        (f = null),
        (h = null),
        (i = null),
        (y = null),
        ut.stop(),
        (n.isPresenting = !1),
        t.setPixelRatio(S),
        t.setSize(A.width, A.height, !1),
        n.dispatchEvent({
          type: 'sessionend',
        })
    }
    ;(this.setFramebufferScaleFactor = function (W) {
      ;(a = W),
        n.isPresenting === !0 &&
          console.warn(
            'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
          )
    }),
      (this.setReferenceSpaceType = function (W) {
        ;(s = W),
          n.isPresenting === !0 &&
            console.warn(
              'THREE.WebXRManager: Cannot change reference space type while presenting.',
            )
      }),
      (this.getReferenceSpace = function () {
        return u || o
      }),
      (this.setReferenceSpace = function (W) {
        u = W
      }),
      (this.getBaseLayer = function () {
        return f !== null ? f : d
      }),
      (this.getBinding = function () {
        return h
      }),
      (this.getFrame = function () {
        return p
      }),
      (this.getSession = function () {
        return i
      }),
      (this.setSession = async function (W) {
        if (((i = W), i !== null)) {
          if (
            ((m = t.getRenderTarget()),
            i.addEventListener('select', D),
            i.addEventListener('selectstart', D),
            i.addEventListener('selectend', D),
            i.addEventListener('squeeze', D),
            i.addEventListener('squeezestart', D),
            i.addEventListener('squeezeend', D),
            i.addEventListener('end', P),
            i.addEventListener('inputsourceschange', L),
            v.xrCompatible !== !0 && (await e.makeXRCompatible()),
            (S = t.getPixelRatio()),
            t.getSize(A),
            i.renderState.layers === void 0)
          ) {
            const Z = {
              antialias: v.antialias,
              alpha: !0,
              depth: v.depth,
              stencil: v.stencil,
              framebufferScaleFactor: a,
            }
            ;(d = new XRWebGLLayer(i, e, Z)),
              i.updateRenderState({
                baseLayer: d,
              }),
              t.setPixelRatio(1),
              t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
              (y = new Vu(d.framebufferWidth, d.framebufferHeight, {
                format: Yi,
                type: qo,
                colorSpace: t.outputColorSpace,
                stencilBuffer: v.stencil,
              }))
          } else {
            let Z = null,
              ft = null,
              lt = null
            v.depth &&
              ((lt = v.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
              (Z = v.stencil ? Vh : wh),
              (ft = v.stencil ? Uh : Uu))
            const ct = {
              colorFormat: e.RGBA8,
              depthFormat: lt,
              scaleFactor: a,
            }
            ;(h = new XRWebGLBinding(i, e)),
              (f = h.createProjectionLayer(ct)),
              i.updateRenderState({
                layers: [f],
              }),
              t.setPixelRatio(1),
              t.setSize(f.textureWidth, f.textureHeight, !1),
              (y = new Vu(f.textureWidth, f.textureHeight, {
                format: Yi,
                type: qo,
                depthTexture: new aB(
                  f.textureWidth,
                  f.textureHeight,
                  ft,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Z,
                ),
                stencilBuffer: v.stencil,
                colorSpace: t.outputColorSpace,
                samples: v.antialias ? 4 : 0,
                resolveDepthBuffer: f.ignoreDepthValues === !1,
              }))
          }
          ;(y.isXRRenderTarget = !0),
            this.setFoveation(l),
            (u = null),
            (o = await i.requestReferenceSpace(s)),
            ut.setContext(i),
            ut.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({
              type: 'sessionstart',
            })
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode
      }),
      (this.getDepthTexture = function () {
        return g.getDepthTexture()
      })
    function L(W) {
      for (let Z = 0; Z < W.removed.length; Z++) {
        const ft = W.removed[Z],
          lt = x.indexOf(ft)
        lt >= 0 && ((x[lt] = null), _[lt].disconnect(ft))
      }
      for (let Z = 0; Z < W.added.length; Z++) {
        const ft = W.added[Z]
        let lt = x.indexOf(ft)
        if (lt === -1) {
          for (let At = 0; At < _.length; At++)
            if (At >= x.length) {
              x.push(ft), (lt = At)
              break
            } else if (x[At] === null) {
              ;(x[At] = ft), (lt = At)
              break
            }
          if (lt === -1) break
        }
        const ct = _[lt]
        ct && ct.connect(ft)
      }
    }
    const I = new U(),
      F = new U()
    function k(W, Z, ft) {
      I.setFromMatrixPosition(Z.matrixWorld),
        F.setFromMatrixPosition(ft.matrixWorld)
      const lt = I.distanceTo(F),
        ct = Z.projectionMatrix.elements,
        At = ft.projectionMatrix.elements,
        gt = ct[14] / (ct[10] - 1),
        dt = ct[14] / (ct[10] + 1),
        B = (ct[9] + 1) / ct[5],
        ht = (ct[9] - 1) / ct[5],
        it = (ct[8] - 1) / ct[0],
        xt = (At[8] + 1) / At[0],
        rt = gt * it,
        kt = gt * xt,
        Ct = lt / (-it + xt),
        Lt = Ct * -it
      Z.matrixWorld.decompose(W.position, W.quaternion, W.scale),
        W.translateX(Lt),
        W.translateZ(Ct),
        W.matrixWorld.compose(W.position, W.quaternion, W.scale),
        W.matrixWorldInverse.copy(W.matrixWorld).invert()
      const G = gt + Ct,
        N = dt + Ct,
        J = rt - Lt,
        vt = kt + (lt - Lt),
        yt = ((B * dt) / N) * G,
        mt = ((ht * dt) / N) * G
      W.projectionMatrix.makePerspective(J, vt, yt, mt, G, N),
        W.projectionMatrixInverse.copy(W.projectionMatrix).invert()
    }
    function V(W, Z) {
      Z === null
        ? W.matrixWorld.copy(W.matrix)
        : W.matrixWorld.multiplyMatrices(Z.matrixWorld, W.matrix),
        W.matrixWorldInverse.copy(W.matrixWorld).invert()
    }
    this.updateCamera = function (W) {
      if (i === null) return
      g.texture !== null && ((W.near = g.depthNear), (W.far = g.depthFar)),
        (M.near = T.near = b.near = W.near),
        (M.far = T.far = b.far = W.far),
        (C !== M.near || E !== M.far) &&
          (i.updateRenderState({
            depthNear: M.near,
            depthFar: M.far,
          }),
          (C = M.near),
          (E = M.far),
          (b.near = C),
          (b.far = E),
          (T.near = C),
          (T.far = E),
          b.updateProjectionMatrix(),
          T.updateProjectionMatrix(),
          W.updateProjectionMatrix())
      const Z = W.parent,
        ft = M.cameras
      V(M, Z)
      for (let lt = 0; lt < ft.length; lt++) V(ft[lt], Z)
      ft.length === 2
        ? k(M, b, T)
        : M.projectionMatrix.copy(b.projectionMatrix),
        H(W, M, Z)
    }
    function H(W, Z, ft) {
      ft === null
        ? W.matrix.copy(Z.matrixWorld)
        : (W.matrix.copy(ft.matrixWorld),
          W.matrix.invert(),
          W.matrix.multiply(Z.matrixWorld)),
        W.matrix.decompose(W.position, W.quaternion, W.scale),
        W.updateMatrixWorld(!0),
        W.projectionMatrix.copy(Z.projectionMatrix),
        W.projectionMatrixInverse.copy(Z.projectionMatrixInverse),
        W.isPerspectiveCamera &&
          ((W.fov = Gh * 2 * Math.atan(1 / W.projectionMatrix.elements[5])),
          (W.zoom = 1))
    }
    ;(this.getCamera = function () {
      return M
    }),
      (this.getFoveation = function () {
        if (!(f === null && d === null)) return l
      }),
      (this.setFoveation = function (W) {
        ;(l = W),
          f !== null && (f.fixedFoveation = W),
          d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = W)
      }),
      (this.hasDepthSensing = function () {
        return g.texture !== null
      }),
      (this.getDepthSensingMesh = function () {
        return g.getMesh(M)
      })
    let Y = null
    function K(W, Z) {
      if (((c = Z.getViewerPose(u || o)), (p = Z), c !== null)) {
        const ft = c.views
        d !== null &&
          (t.setRenderTargetFramebuffer(y, d.framebuffer), t.setRenderTarget(y))
        let lt = !1
        ft.length !== M.cameras.length && ((M.cameras.length = 0), (lt = !0))
        for (let At = 0; At < ft.length; At++) {
          const gt = ft[At]
          let dt = null
          if (d !== null) dt = d.getViewport(gt)
          else {
            const ht = h.getViewSubImage(f, gt)
            ;(dt = ht.viewport),
              At === 0 &&
                (t.setRenderTargetTextures(
                  y,
                  ht.colorTexture,
                  f.ignoreDepthValues ? void 0 : ht.depthStencilTexture,
                ),
                t.setRenderTarget(y))
          }
          let B = w[At]
          B === void 0 &&
            ((B = new wr()),
            B.layers.enable(At),
            (B.viewport = new Oe()),
            (w[At] = B)),
            B.matrix.fromArray(gt.transform.matrix),
            B.matrix.decompose(B.position, B.quaternion, B.scale),
            B.projectionMatrix.fromArray(gt.projectionMatrix),
            B.projectionMatrixInverse.copy(B.projectionMatrix).invert(),
            B.viewport.set(dt.x, dt.y, dt.width, dt.height),
            At === 0 &&
              (M.matrix.copy(B.matrix),
              M.matrix.decompose(M.position, M.quaternion, M.scale)),
            lt === !0 && M.cameras.push(B)
        }
        const ct = i.enabledFeatures
        if (ct && ct.includes('depth-sensing')) {
          const At = h.getDepthInformation(ft[0])
          At && At.isValid && At.texture && g.init(t, At, i.renderState)
        }
      }
      for (let ft = 0; ft < _.length; ft++) {
        const lt = x[ft],
          ct = _[ft]
        lt !== null && ct !== void 0 && ct.update(lt, Z, u || o)
      }
      Y && Y(W, Z),
        Z.detectedPlanes &&
          n.dispatchEvent({
            type: 'planesdetected',
            data: Z,
          }),
        (p = null)
    }
    const ut = new iB()
    ut.setAnimationLoop(K),
      (this.setAnimationLoop = function (W) {
        Y = W
      }),
      (this.dispose = function () {})
  }
}
const Ml = new Ma(),
  BY = new ae()
function FY(r, t) {
  function e(v, m) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), m.value.copy(v.matrix)
  }
  function n(v, m) {
    m.color.getRGB(v.fogColor.value, eB(r)),
      m.isFog
        ? ((v.fogNear.value = m.near), (v.fogFar.value = m.far))
        : m.isFogExp2 && (v.fogDensity.value = m.density)
  }
  function i(v, m, y, _, x) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial
      ? a(v, m)
      : m.isMeshToonMaterial
      ? (a(v, m), h(v, m))
      : m.isMeshPhongMaterial
      ? (a(v, m), c(v, m))
      : m.isMeshStandardMaterial
      ? (a(v, m), f(v, m), m.isMeshPhysicalMaterial && d(v, m, x))
      : m.isMeshMatcapMaterial
      ? (a(v, m), p(v, m))
      : m.isMeshDepthMaterial
      ? a(v, m)
      : m.isMeshDistanceMaterial
      ? (a(v, m), g(v, m))
      : m.isMeshNormalMaterial
      ? a(v, m)
      : m.isLineBasicMaterial
      ? (o(v, m), m.isLineDashedMaterial && s(v, m))
      : m.isPointsMaterial
      ? l(v, m, y, _)
      : m.isSpriteMaterial
      ? u(v, m)
      : m.isShadowMaterial
      ? (v.color.value.copy(m.color), (v.opacity.value = m.opacity))
      : m.isShaderMaterial && (m.uniformsNeedUpdate = !1)
  }
  function a(v, m) {
    ;(v.opacity.value = m.opacity),
      m.color && v.diffuse.value.copy(m.color),
      m.emissive &&
        v.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),
      m.map && ((v.map.value = m.map), e(m.map, v.mapTransform)),
      m.alphaMap &&
        ((v.alphaMap.value = m.alphaMap), e(m.alphaMap, v.alphaMapTransform)),
      m.bumpMap &&
        ((v.bumpMap.value = m.bumpMap),
        e(m.bumpMap, v.bumpMapTransform),
        (v.bumpScale.value = m.bumpScale),
        m.side === Qr && (v.bumpScale.value *= -1)),
      m.normalMap &&
        ((v.normalMap.value = m.normalMap),
        e(m.normalMap, v.normalMapTransform),
        v.normalScale.value.copy(m.normalScale),
        m.side === Qr && v.normalScale.value.negate()),
      m.displacementMap &&
        ((v.displacementMap.value = m.displacementMap),
        e(m.displacementMap, v.displacementMapTransform),
        (v.displacementScale.value = m.displacementScale),
        (v.displacementBias.value = m.displacementBias)),
      m.emissiveMap &&
        ((v.emissiveMap.value = m.emissiveMap),
        e(m.emissiveMap, v.emissiveMapTransform)),
      m.specularMap &&
        ((v.specularMap.value = m.specularMap),
        e(m.specularMap, v.specularMapTransform)),
      m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest)
    const y = t.get(m),
      _ = y.envMap,
      x = y.envMapRotation
    _ &&
      ((v.envMap.value = _),
      Ml.copy(x),
      (Ml.x *= -1),
      (Ml.y *= -1),
      (Ml.z *= -1),
      _.isCubeTexture &&
        _.isRenderTargetTexture === !1 &&
        ((Ml.y *= -1), (Ml.z *= -1)),
      v.envMapRotation.value.setFromMatrix4(BY.makeRotationFromEuler(Ml)),
      (v.flipEnvMap.value =
        _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
      (v.reflectivity.value = m.reflectivity),
      (v.ior.value = m.ior),
      (v.refractionRatio.value = m.refractionRatio)),
      m.lightMap &&
        ((v.lightMap.value = m.lightMap),
        (v.lightMapIntensity.value = m.lightMapIntensity),
        e(m.lightMap, v.lightMapTransform)),
      m.aoMap &&
        ((v.aoMap.value = m.aoMap),
        (v.aoMapIntensity.value = m.aoMapIntensity),
        e(m.aoMap, v.aoMapTransform))
  }
  function o(v, m) {
    v.diffuse.value.copy(m.color),
      (v.opacity.value = m.opacity),
      m.map && ((v.map.value = m.map), e(m.map, v.mapTransform))
  }
  function s(v, m) {
    ;(v.dashSize.value = m.dashSize),
      (v.totalSize.value = m.dashSize + m.gapSize),
      (v.scale.value = m.scale)
  }
  function l(v, m, y, _) {
    v.diffuse.value.copy(m.color),
      (v.opacity.value = m.opacity),
      (v.size.value = m.size * y),
      (v.scale.value = _ * 0.5),
      m.map && ((v.map.value = m.map), e(m.map, v.uvTransform)),
      m.alphaMap &&
        ((v.alphaMap.value = m.alphaMap), e(m.alphaMap, v.alphaMapTransform)),
      m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest)
  }
  function u(v, m) {
    v.diffuse.value.copy(m.color),
      (v.opacity.value = m.opacity),
      (v.rotation.value = m.rotation),
      m.map && ((v.map.value = m.map), e(m.map, v.mapTransform)),
      m.alphaMap &&
        ((v.alphaMap.value = m.alphaMap), e(m.alphaMap, v.alphaMapTransform)),
      m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest)
  }
  function c(v, m) {
    v.specular.value.copy(m.specular),
      (v.shininess.value = Math.max(m.shininess, 1e-4))
  }
  function h(v, m) {
    m.gradientMap && (v.gradientMap.value = m.gradientMap)
  }
  function f(v, m) {
    ;(v.metalness.value = m.metalness),
      m.metalnessMap &&
        ((v.metalnessMap.value = m.metalnessMap),
        e(m.metalnessMap, v.metalnessMapTransform)),
      (v.roughness.value = m.roughness),
      m.roughnessMap &&
        ((v.roughnessMap.value = m.roughnessMap),
        e(m.roughnessMap, v.roughnessMapTransform)),
      m.envMap && (v.envMapIntensity.value = m.envMapIntensity)
  }
  function d(v, m, y) {
    ;(v.ior.value = m.ior),
      m.sheen > 0 &&
        (v.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),
        (v.sheenRoughness.value = m.sheenRoughness),
        m.sheenColorMap &&
          ((v.sheenColorMap.value = m.sheenColorMap),
          e(m.sheenColorMap, v.sheenColorMapTransform)),
        m.sheenRoughnessMap &&
          ((v.sheenRoughnessMap.value = m.sheenRoughnessMap),
          e(m.sheenRoughnessMap, v.sheenRoughnessMapTransform))),
      m.clearcoat > 0 &&
        ((v.clearcoat.value = m.clearcoat),
        (v.clearcoatRoughness.value = m.clearcoatRoughness),
        m.clearcoatMap &&
          ((v.clearcoatMap.value = m.clearcoatMap),
          e(m.clearcoatMap, v.clearcoatMapTransform)),
        m.clearcoatRoughnessMap &&
          ((v.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap),
          e(m.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)),
        m.clearcoatNormalMap &&
          ((v.clearcoatNormalMap.value = m.clearcoatNormalMap),
          e(m.clearcoatNormalMap, v.clearcoatNormalMapTransform),
          v.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),
          m.side === Qr && v.clearcoatNormalScale.value.negate())),
      m.dispersion > 0 && (v.dispersion.value = m.dispersion),
      m.iridescence > 0 &&
        ((v.iridescence.value = m.iridescence),
        (v.iridescenceIOR.value = m.iridescenceIOR),
        (v.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0]),
        (v.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1]),
        m.iridescenceMap &&
          ((v.iridescenceMap.value = m.iridescenceMap),
          e(m.iridescenceMap, v.iridescenceMapTransform)),
        m.iridescenceThicknessMap &&
          ((v.iridescenceThicknessMap.value = m.iridescenceThicknessMap),
          e(m.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))),
      m.transmission > 0 &&
        ((v.transmission.value = m.transmission),
        (v.transmissionSamplerMap.value = y.texture),
        v.transmissionSamplerSize.value.set(y.width, y.height),
        m.transmissionMap &&
          ((v.transmissionMap.value = m.transmissionMap),
          e(m.transmissionMap, v.transmissionMapTransform)),
        (v.thickness.value = m.thickness),
        m.thicknessMap &&
          ((v.thicknessMap.value = m.thicknessMap),
          e(m.thicknessMap, v.thicknessMapTransform)),
        (v.attenuationDistance.value = m.attenuationDistance),
        v.attenuationColor.value.copy(m.attenuationColor)),
      m.anisotropy > 0 &&
        (v.anisotropyVector.value.set(
          m.anisotropy * Math.cos(m.anisotropyRotation),
          m.anisotropy * Math.sin(m.anisotropyRotation),
        ),
        m.anisotropyMap &&
          ((v.anisotropyMap.value = m.anisotropyMap),
          e(m.anisotropyMap, v.anisotropyMapTransform))),
      (v.specularIntensity.value = m.specularIntensity),
      v.specularColor.value.copy(m.specularColor),
      m.specularColorMap &&
        ((v.specularColorMap.value = m.specularColorMap),
        e(m.specularColorMap, v.specularColorMapTransform)),
      m.specularIntensityMap &&
        ((v.specularIntensityMap.value = m.specularIntensityMap),
        e(m.specularIntensityMap, v.specularIntensityMapTransform))
  }
  function p(v, m) {
    m.matcap && (v.matcap.value = m.matcap)
  }
  function g(v, m) {
    const y = t.get(m).light
    v.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (v.nearDistance.value = y.shadow.camera.near),
      (v.farDistance.value = y.shadow.camera.far)
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i,
  }
}
function zY(r, t, e, n) {
  let i = {},
    a = {},
    o = []
  const s = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS)
  function l(y, _) {
    const x = _.program
    n.uniformBlockBinding(y, x)
  }
  function u(y, _) {
    let x = i[y.id]
    x === void 0 &&
      (p(y), (x = c(y)), (i[y.id] = x), y.addEventListener('dispose', v))
    const A = _.program
    n.updateUBOMapping(y, A)
    const S = t.render.frame
    a[y.id] !== S && (f(y), (a[y.id] = S))
  }
  function c(y) {
    const _ = h()
    y.__bindingPointIndex = _
    const x = r.createBuffer(),
      A = y.__size,
      S = y.usage
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, x),
      r.bufferData(r.UNIFORM_BUFFER, A, S),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, _, x),
      x
    )
  }
  function h() {
    for (let y = 0; y < s; y++) if (o.indexOf(y) === -1) return o.push(y), y
    return (
      console.error(
        'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.',
      ),
      0
    )
  }
  function f(y) {
    const _ = i[y.id],
      x = y.uniforms,
      A = y.__cache
    r.bindBuffer(r.UNIFORM_BUFFER, _)
    for (let S = 0, b = x.length; S < b; S++) {
      const T = Array.isArray(x[S]) ? x[S] : [x[S]]
      for (let w = 0, M = T.length; w < M; w++) {
        const C = T[w]
        if (d(C, S, w, A) === !0) {
          const E = C.__offset,
            D = Array.isArray(C.value) ? C.value : [C.value]
          let P = 0
          for (let L = 0; L < D.length; L++) {
            const I = D[L],
              F = g(I)
            typeof I == 'number' || typeof I == 'boolean'
              ? ((C.__data[0] = I),
                r.bufferSubData(r.UNIFORM_BUFFER, E + P, C.__data))
              : I.isMatrix3
              ? ((C.__data[0] = I.elements[0]),
                (C.__data[1] = I.elements[1]),
                (C.__data[2] = I.elements[2]),
                (C.__data[3] = 0),
                (C.__data[4] = I.elements[3]),
                (C.__data[5] = I.elements[4]),
                (C.__data[6] = I.elements[5]),
                (C.__data[7] = 0),
                (C.__data[8] = I.elements[6]),
                (C.__data[9] = I.elements[7]),
                (C.__data[10] = I.elements[8]),
                (C.__data[11] = 0))
              : (I.toArray(C.__data, P),
                (P += F.storage / Float32Array.BYTES_PER_ELEMENT))
          }
          r.bufferSubData(r.UNIFORM_BUFFER, E, C.__data)
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null)
  }
  function d(y, _, x, A) {
    const S = y.value,
      b = _ + '_' + x
    if (A[b] === void 0)
      return (
        typeof S == 'number' || typeof S == 'boolean'
          ? (A[b] = S)
          : (A[b] = S.clone()),
        !0
      )
    {
      const T = A[b]
      if (typeof S == 'number' || typeof S == 'boolean') {
        if (T !== S) return (A[b] = S), !0
      } else if (T.equals(S) === !1) return T.copy(S), !0
    }
    return !1
  }
  function p(y) {
    const _ = y.uniforms
    let x = 0
    const A = 16
    for (let b = 0, T = _.length; b < T; b++) {
      const w = Array.isArray(_[b]) ? _[b] : [_[b]]
      for (let M = 0, C = w.length; M < C; M++) {
        const E = w[M],
          D = Array.isArray(E.value) ? E.value : [E.value]
        for (let P = 0, L = D.length; P < L; P++) {
          const I = D[P],
            F = g(I),
            k = x % A
          k !== 0 && A - k < F.boundary && (x += A - k),
            (E.__data = new Float32Array(
              F.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (E.__offset = x),
            (x += F.storage)
        }
      }
    }
    const S = x % A
    return S > 0 && (x += A - S), (y.__size = x), (y.__cache = {}), this
  }
  function g(y) {
    const _ = {
      boundary: 0,
      storage: 0,
    }
    return (
      typeof y == 'number' || typeof y == 'boolean'
        ? ((_.boundary = 4), (_.storage = 4))
        : y.isVector2
        ? ((_.boundary = 8), (_.storage = 8))
        : y.isVector3 || y.isColor
        ? ((_.boundary = 16), (_.storage = 12))
        : y.isVector4
        ? ((_.boundary = 16), (_.storage = 16))
        : y.isMatrix3
        ? ((_.boundary = 48), (_.storage = 48))
        : y.isMatrix4
        ? ((_.boundary = 64), (_.storage = 64))
        : y.isTexture
        ? console.warn(
            'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.',
          )
        : console.warn(
            'THREE.WebGLRenderer: Unsupported uniform value type.',
            y,
          ),
      _
    )
  }
  function v(y) {
    const _ = y.target
    _.removeEventListener('dispose', v)
    const x = o.indexOf(_.__bindingPointIndex)
    o.splice(x, 1), r.deleteBuffer(i[_.id]), delete i[_.id], delete a[_.id]
  }
  function m() {
    for (const y in i) r.deleteBuffer(i[y])
    ;(o = []), (i = {}), (a = {})
  }
  return {
    bind: l,
    update: u,
    dispose: m,
  }
}
class cB {
  constructor(t = {}) {
    const {
      canvas: e = R6(),
      context: n = null,
      depth: i = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: s = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: c = 'default',
      failIfMajorPerformanceCaveat: h = !1,
    } = t
    this.isWebGLRenderer = !0
    let f
    if (n !== null) {
      if (
        typeof WebGLRenderingContext < 'u' &&
        n instanceof WebGLRenderingContext
      )
        throw new Error(
          'THREE.WebGLRenderer: WebGL 1 is not supported since r163.',
        )
      f = n.getContextAttributes().alpha
    } else f = o
    const d = new Uint32Array(4),
      p = new Int32Array(4)
    let g = null,
      v = null
    const m = [],
      y = []
    ;(this.domElement = e),
      (this.debug = {
        checkShaderErrors: !0,
        onShaderError: null,
      }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = cn),
      (this.toneMapping = Ys),
      (this.toneMappingExposure = 1)
    const _ = this
    let x = !1,
      A = 0,
      S = 0,
      b = null,
      T = -1,
      w = null
    const M = new Oe(),
      C = new Oe()
    let E = null
    const D = new qt(0)
    let P = 0,
      L = e.width,
      I = e.height,
      F = 1,
      k = null,
      V = null
    const H = new Oe(0, 0, L, I),
      Y = new Oe(0, 0, L, I)
    let K = !1
    const ut = new BM()
    let W = !1,
      Z = !1
    const ft = new ae(),
      lt = new U(),
      ct = new Oe(),
      At = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      }
    let gt = !1
    function dt() {
      return b === null ? F : 1
    }
    let B = n
    function ht(z, $) {
      return e.getContext(z, $)
    }
    try {
      const z = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: s,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: c,
        failIfMajorPerformanceCaveat: h,
      }
      if (
        ('setAttribute' in e &&
          e.setAttribute('data-engine', `three.js r${SM}`),
        e.addEventListener('webglcontextlost', tt, !1),
        e.addEventListener('webglcontextrestored', ot, !1),
        e.addEventListener('webglcontextcreationerror', St, !1),
        B === null)
      ) {
        const $ = 'webgl2'
        if (((B = ht($, z)), B === null))
          throw ht($)
            ? new Error(
                'Error creating WebGL context with your selected attributes.',
              )
            : new Error('Error creating WebGL context.')
      }
    } catch (z) {
      throw (console.error('THREE.WebGLRenderer: ' + z.message), z)
    }
    let it,
      xt,
      rt,
      kt,
      Ct,
      Lt,
      G,
      N,
      J,
      vt,
      yt,
      mt,
      Kt,
      It,
      Bt,
      fe,
      Mt,
      Ot,
      Te,
      se,
      Gt,
      ue,
      de,
      ln
    function O() {
      ;(it = new $7(B)),
        it.init(),
        (ue = new LY(B, it)),
        (xt = new V7(B, it, t, ue)),
        (rt = new CY(B)),
        (kt = new K7(B)),
        (Ct = new dY()),
        (Lt = new DY(B, it, rt, Ct, xt, ue, kt)),
        (G = new H7(_)),
        (N = new Y7(_)),
        (J = new rW(B)),
        (de = new z7(B, J)),
        (vt = new q7(B, J, kt, de)),
        (yt = new J7(B, vt, J, kt)),
        (Te = new j7(B, xt, Lt)),
        (fe = new G7(Ct)),
        (mt = new fY(_, G, N, it, xt, de, fe)),
        (Kt = new FY(_, Ct)),
        (It = new vY()),
        (Bt = new SY(it)),
        (Ot = new F7(_, G, N, rt, yt, f, l)),
        (Mt = new TY(_, yt, xt)),
        (ln = new zY(B, kt, xt, rt)),
        (se = new U7(B, it, kt)),
        (Gt = new Z7(B, it, kt)),
        (kt.programs = mt.programs),
        (_.capabilities = xt),
        (_.extensions = it),
        (_.properties = Ct),
        (_.renderLists = It),
        (_.shadowMap = Mt),
        (_.state = rt),
        (_.info = kt)
    }
    O()
    const j = new kY(_, B)
    ;(this.xr = j),
      (this.getContext = function () {
        return B
      }),
      (this.getContextAttributes = function () {
        return B.getContextAttributes()
      }),
      (this.forceContextLoss = function () {
        const z = it.get('WEBGL_lose_context')
        z && z.loseContext()
      }),
      (this.forceContextRestore = function () {
        const z = it.get('WEBGL_lose_context')
        z && z.restoreContext()
      }),
      (this.getPixelRatio = function () {
        return F
      }),
      (this.setPixelRatio = function (z) {
        z !== void 0 && ((F = z), this.setSize(L, I, !1))
      }),
      (this.getSize = function (z) {
        return z.set(L, I)
      }),
      (this.setSize = function (z, $, et = !0) {
        if (j.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          )
          return
        }
        ;(L = z),
          (I = $),
          (e.width = Math.floor(z * F)),
          (e.height = Math.floor($ * F)),
          et === !0 &&
            ((e.style.width = z + 'px'), (e.style.height = $ + 'px')),
          this.setViewport(0, 0, z, $)
      }),
      (this.getDrawingBufferSize = function (z) {
        return z.set(L * F, I * F).floor()
      }),
      (this.setDrawingBufferSize = function (z, $, et) {
        ;(L = z),
          (I = $),
          (F = et),
          (e.width = Math.floor(z * et)),
          (e.height = Math.floor($ * et)),
          this.setViewport(0, 0, z, $)
      }),
      (this.getCurrentViewport = function (z) {
        return z.copy(M)
      }),
      (this.getViewport = function (z) {
        return z.copy(H)
      }),
      (this.setViewport = function (z, $, et, nt) {
        z.isVector4 ? H.set(z.x, z.y, z.z, z.w) : H.set(z, $, et, nt),
          rt.viewport(M.copy(H).multiplyScalar(F).round())
      }),
      (this.getScissor = function (z) {
        return z.copy(Y)
      }),
      (this.setScissor = function (z, $, et, nt) {
        z.isVector4 ? Y.set(z.x, z.y, z.z, z.w) : Y.set(z, $, et, nt),
          rt.scissor(C.copy(Y).multiplyScalar(F).round())
      }),
      (this.getScissorTest = function () {
        return K
      }),
      (this.setScissorTest = function (z) {
        rt.setScissorTest((K = z))
      }),
      (this.setOpaqueSort = function (z) {
        k = z
      }),
      (this.setTransparentSort = function (z) {
        V = z
      }),
      (this.getClearColor = function (z) {
        return z.copy(Ot.getClearColor())
      }),
      (this.setClearColor = function () {
        Ot.setClearColor.apply(Ot, arguments)
      }),
      (this.getClearAlpha = function () {
        return Ot.getClearAlpha()
      }),
      (this.setClearAlpha = function () {
        Ot.setClearAlpha.apply(Ot, arguments)
      }),
      (this.clear = function (z = !0, $ = !0, et = !0) {
        let nt = 0
        if (z) {
          let q = !1
          if (b !== null) {
            const Dt = b.texture.format
            q = Dt === DM || Dt === EM || Dt === CM
          }
          if (q) {
            const Dt = b.texture.type,
              Ft =
                Dt === qo ||
                Dt === Uu ||
                Dt === gp ||
                Dt === Uh ||
                Dt === wM ||
                Dt === MM,
              Xt = Ot.getClearColor(),
              Yt = Ot.getClearAlpha(),
              le = Xt.r,
              he = Xt.g,
              ne = Xt.b
            Ft
              ? ((d[0] = le),
                (d[1] = he),
                (d[2] = ne),
                (d[3] = Yt),
                B.clearBufferuiv(B.COLOR, 0, d))
              : ((p[0] = le),
                (p[1] = he),
                (p[2] = ne),
                (p[3] = Yt),
                B.clearBufferiv(B.COLOR, 0, p))
          } else nt |= B.COLOR_BUFFER_BIT
        }
        $ && (nt |= B.DEPTH_BUFFER_BIT),
          et &&
            ((nt |= B.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          B.clear(nt)
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1)
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }),
      (this.dispose = function () {
        e.removeEventListener('webglcontextlost', tt, !1),
          e.removeEventListener('webglcontextrestored', ot, !1),
          e.removeEventListener('webglcontextcreationerror', St, !1),
          It.dispose(),
          Bt.dispose(),
          Ct.dispose(),
          G.dispose(),
          N.dispose(),
          yt.dispose(),
          de.dispose(),
          ln.dispose(),
          mt.dispose(),
          j.dispose(),
          j.removeEventListener('sessionstart', On),
          j.removeEventListener('sessionend', ss),
          sr.stop()
      })
    function tt(z) {
      z.preventDefault(),
        console.log('THREE.WebGLRenderer: Context Lost.'),
        (x = !0)
    }
    function ot() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (x = !1)
      const z = kt.autoReset,
        $ = Mt.enabled,
        et = Mt.autoUpdate,
        nt = Mt.needsUpdate,
        q = Mt.type
      O(),
        (kt.autoReset = z),
        (Mt.enabled = $),
        (Mt.autoUpdate = et),
        (Mt.needsUpdate = nt),
        (Mt.type = q)
    }
    function St(z) {
      console.error(
        'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
        z.statusMessage,
      )
    }
    function jt(z) {
      const $ = z.target
      $.removeEventListener('dispose', jt), ce($)
    }
    function ce(z) {
      Tn(z), Ct.remove(z)
    }
    function Tn(z) {
      const $ = Ct.get(z).programs
      $ !== void 0 &&
        ($.forEach(function (et) {
          mt.releaseProgram(et)
        }),
        z.isShaderMaterial && mt.releaseShaderCache(z))
    }
    this.renderBufferDirect = function (z, $, et, nt, q, Dt) {
      $ === null && ($ = At)
      const Ft = q.isMesh && q.matrixWorld.determinant() < 0,
        Xt = u8(z, $, et, nt, q)
      rt.setMaterial(nt, Ft)
      let Yt = et.index,
        le = 1
      if (nt.wireframe === !0) {
        if (((Yt = vt.getWireframeAttribute(et)), Yt === void 0)) return
        le = 2
      }
      const he = et.drawRange,
        ne = et.attributes.position
      let ze = he.start * le,
        yn = (he.start + he.count) * le
      Dt !== null &&
        ((ze = Math.max(ze, Dt.start * le)),
        (yn = Math.min(yn, (Dt.start + Dt.count) * le))),
        Yt !== null
          ? ((ze = Math.max(ze, 0)), (yn = Math.min(yn, Yt.count)))
          : ne != null &&
            ((ze = Math.max(ze, 0)), (yn = Math.min(yn, ne.count)))
      const _n = yn - ze
      if (_n < 0 || _n === 1 / 0) return
      de.setup(q, nt, Xt, et, Yt)
      let ui,
        Ue = se
      if (
        (Yt !== null && ((ui = J.get(Yt)), (Ue = Gt), Ue.setIndex(ui)),
        q.isMesh)
      )
        nt.wireframe === !0
          ? (rt.setLineWidth(nt.wireframeLinewidth * dt()), Ue.setMode(B.LINES))
          : Ue.setMode(B.TRIANGLES)
      else if (q.isLine) {
        let Jt = nt.linewidth
        Jt === void 0 && (Jt = 1),
          rt.setLineWidth(Jt * dt()),
          q.isLineSegments
            ? Ue.setMode(B.LINES)
            : q.isLineLoop
            ? Ue.setMode(B.LINE_LOOP)
            : Ue.setMode(B.LINE_STRIP)
      } else
        q.isPoints
          ? Ue.setMode(B.POINTS)
          : q.isSprite && Ue.setMode(B.TRIANGLES)
      if (q.isBatchedMesh)
        if (q._multiDrawInstances !== null)
          Ue.renderMultiDrawInstances(
            q._multiDrawStarts,
            q._multiDrawCounts,
            q._multiDrawCount,
            q._multiDrawInstances,
          )
        else if (it.get('WEBGL_multi_draw'))
          Ue.renderMultiDraw(
            q._multiDrawStarts,
            q._multiDrawCounts,
            q._multiDrawCount,
          )
        else {
          const Jt = q._multiDrawStarts,
            lr = q._multiDrawCounts,
            Ve = q._multiDrawCount,
            oa = Yt ? J.get(Yt).bytesPerElement : 1,
            cc = Ct.get(nt).currentProgram.getUniforms()
          for (let ci = 0; ci < Ve; ci++)
            cc.setValue(B, '_gl_DrawID', ci), Ue.render(Jt[ci] / oa, lr[ci])
        }
      else if (q.isInstancedMesh) Ue.renderInstances(ze, _n, q.count)
      else if (et.isInstancedBufferGeometry) {
        const Jt =
            et._maxInstanceCount !== void 0 ? et._maxInstanceCount : 1 / 0,
          lr = Math.min(et.instanceCount, Jt)
        Ue.renderInstances(ze, _n, lr)
      } else Ue.render(ze, _n)
    }
    function Gn(z, $, et) {
      z.transparent === !0 && z.side === dr && z.forceSinglePass === !1
        ? ((z.side = Qr),
          (z.needsUpdate = !0),
          kv(z, $, et),
          (z.side = $o),
          (z.needsUpdate = !0),
          kv(z, $, et),
          (z.side = dr))
        : kv(z, $, et)
    }
    ;(this.compile = function (z, $, et = null) {
      et === null && (et = z),
        (v = Bt.get(et)),
        v.init($),
        y.push(v),
        et.traverseVisible(function (q) {
          q.isLight &&
            q.layers.test($.layers) &&
            (v.pushLight(q), q.castShadow && v.pushShadow(q))
        }),
        z !== et &&
          z.traverseVisible(function (q) {
            q.isLight &&
              q.layers.test($.layers) &&
              (v.pushLight(q), q.castShadow && v.pushShadow(q))
          }),
        v.setupLights()
      const nt = new Set()
      return (
        z.traverse(function (q) {
          const Dt = q.material
          if (Dt)
            if (Array.isArray(Dt))
              for (let Ft = 0; Ft < Dt.length; Ft++) {
                const Xt = Dt[Ft]
                Gn(Xt, et, q), nt.add(Xt)
              }
            else Gn(Dt, et, q), nt.add(Dt)
        }),
        y.pop(),
        (v = null),
        nt
      )
    }),
      (this.compileAsync = function (z, $, et = null) {
        const nt = this.compile(z, $, et)
        return new Promise(q => {
          function Dt() {
            if (
              (nt.forEach(function (Ft) {
                Ct.get(Ft).currentProgram.isReady() && nt.delete(Ft)
              }),
              nt.size === 0)
            ) {
              q(z)
              return
            }
            setTimeout(Dt, 10)
          }
          it.get('KHR_parallel_shader_compile') !== null
            ? Dt()
            : setTimeout(Dt, 10)
        })
      })
    let Ie = null
    function Hn(z) {
      Ie && Ie(z)
    }
    function On() {
      sr.stop()
    }
    function ss() {
      sr.start()
    }
    const sr = new iB()
    sr.setAnimationLoop(Hn),
      typeof self < 'u' && sr.setContext(self),
      (this.setAnimationLoop = function (z) {
        ;(Ie = z), j.setAnimationLoop(z), z === null ? sr.stop() : sr.start()
      }),
      j.addEventListener('sessionstart', On),
      j.addEventListener('sessionend', ss),
      (this.render = function (z, $) {
        if ($ !== void 0 && $.isCamera !== !0) {
          console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
          )
          return
        }
        if (x === !0) return
        if (
          (z.matrixWorldAutoUpdate === !0 && z.updateMatrixWorld(),
          $.parent === null &&
            $.matrixWorldAutoUpdate === !0 &&
            $.updateMatrixWorld(),
          j.enabled === !0 &&
            j.isPresenting === !0 &&
            (j.cameraAutoUpdate === !0 && j.updateCamera($),
            ($ = j.getCamera())),
          z.isScene === !0 && z.onBeforeRender(_, z, $, b),
          (v = Bt.get(z, y.length)),
          v.init($),
          y.push(v),
          ft.multiplyMatrices($.projectionMatrix, $.matrixWorldInverse),
          ut.setFromProjectionMatrix(ft),
          (Z = this.localClippingEnabled),
          (W = fe.init(this.clippingPlanes, Z)),
          (g = It.get(z, m.length)),
          g.init(),
          m.push(g),
          j.enabled === !0 && j.isPresenting === !0)
        ) {
          const Dt = _.xr.getDepthSensingMesh()
          Dt !== null && So(Dt, $, -1 / 0, _.sortObjects)
        }
        So(z, $, 0, _.sortObjects),
          g.finish(),
          _.sortObjects === !0 && g.sort(k, V),
          (gt =
            j.enabled === !1 ||
            j.isPresenting === !1 ||
            j.hasDepthSensing() === !1),
          gt && Ot.addToRenderList(g, z),
          this.info.render.frame++,
          W === !0 && fe.beginShadows()
        const et = v.state.shadowsArray
        Mt.render(et, z, $),
          W === !0 && fe.endShadows(),
          this.info.autoReset === !0 && this.info.reset()
        const nt = g.opaque,
          q = g.transmissive
        if ((v.setupLights(), $.isArrayCamera)) {
          const Dt = $.cameras
          if (q.length > 0)
            for (let Ft = 0, Xt = Dt.length; Ft < Xt; Ft++) {
              const Yt = Dt[Ft]
              If(nt, q, z, Yt)
            }
          gt && Ot.render(z)
          for (let Ft = 0, Xt = Dt.length; Ft < Xt; Ft++) {
            const Yt = Dt[Ft]
            _l(g, z, Yt, Yt.viewport)
          }
        } else q.length > 0 && If(nt, q, z, $), gt && Ot.render(z), _l(g, z, $)
        b !== null &&
          (Lt.updateMultisampleRenderTarget(b), Lt.updateRenderTargetMipmap(b)),
          z.isScene === !0 && z.onAfterRender(_, z, $),
          de.resetDefaultState(),
          (T = -1),
          (w = null),
          y.pop(),
          y.length > 0
            ? ((v = y[y.length - 1]),
              W === !0 && fe.setGlobalState(_.clippingPlanes, v.state.camera))
            : (v = null),
          m.pop(),
          m.length > 0 ? (g = m[m.length - 1]) : (g = null)
      })
    function So(z, $, et, nt) {
      if (z.visible === !1) return
      if (z.layers.test($.layers)) {
        if (z.isGroup) et = z.renderOrder
        else if (z.isLOD) z.autoUpdate === !0 && z.update($)
        else if (z.isLight) v.pushLight(z), z.castShadow && v.pushShadow(z)
        else if (z.isSprite) {
          if (!z.frustumCulled || ut.intersectsSprite(z)) {
            nt && ct.setFromMatrixPosition(z.matrixWorld).applyMatrix4(ft)
            const Ft = yt.update(z),
              Xt = z.material
            Xt.visible && g.push(z, Ft, Xt, et, ct.z, null)
          }
        } else if (
          (z.isMesh || z.isLine || z.isPoints) &&
          (!z.frustumCulled || ut.intersectsObject(z))
        ) {
          const Ft = yt.update(z),
            Xt = z.material
          if (
            (nt &&
              (z.boundingSphere !== void 0
                ? (z.boundingSphere === null && z.computeBoundingSphere(),
                  ct.copy(z.boundingSphere.center))
                : (Ft.boundingSphere === null && Ft.computeBoundingSphere(),
                  ct.copy(Ft.boundingSphere.center)),
              ct.applyMatrix4(z.matrixWorld).applyMatrix4(ft)),
            Array.isArray(Xt))
          ) {
            const Yt = Ft.groups
            for (let le = 0, he = Yt.length; le < he; le++) {
              const ne = Yt[le],
                ze = Xt[ne.materialIndex]
              ze && ze.visible && g.push(z, Ft, ze, et, ct.z, ne)
            }
          } else Xt.visible && g.push(z, Ft, Xt, et, ct.z, null)
        }
      }
      const Dt = z.children
      for (let Ft = 0, Xt = Dt.length; Ft < Xt; Ft++) So(Dt[Ft], $, et, nt)
    }
    function _l(z, $, et, nt) {
      const q = z.opaque,
        Dt = z.transmissive,
        Ft = z.transparent
      v.setupLightsView(et),
        W === !0 && fe.setGlobalState(_.clippingPlanes, et),
        nt && rt.viewport(M.copy(nt)),
        q.length > 0 && Nv(q, $, et),
        Dt.length > 0 && Nv(Dt, $, et),
        Ft.length > 0 && Nv(Ft, $, et),
        rt.buffers.depth.setTest(!0),
        rt.buffers.depth.setMask(!0),
        rt.buffers.color.setMask(!0),
        rt.setPolygonOffset(!1)
    }
    function If(z, $, et, nt) {
      if ((et.isScene === !0 ? et.overrideMaterial : null) !== null) return
      v.state.transmissionRenderTarget[nt.id] === void 0 &&
        (v.state.transmissionRenderTarget[nt.id] = new Vu(1, 1, {
          generateMipmaps: !0,
          type:
            it.has('EXT_color_buffer_half_float') ||
            it.has('EXT_color_buffer_float')
              ? hv
              : qo,
          minFilter: Fo,
          samples: 4,
          stencilBuffer: a,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Be.workingColorSpace,
        }))
      const Dt = v.state.transmissionRenderTarget[nt.id],
        Ft = nt.viewport || M
      Dt.setSize(Ft.z, Ft.w)
      const Xt = _.getRenderTarget()
      _.setRenderTarget(Dt),
        _.getClearColor(D),
        (P = _.getClearAlpha()),
        P < 1 && _.setClearColor(16777215, 0.5),
        gt ? Ot.render(et) : _.clear()
      const Yt = _.toneMapping
      _.toneMapping = Ys
      const le = nt.viewport
      if (
        (nt.viewport !== void 0 && (nt.viewport = void 0),
        v.setupLightsView(nt),
        W === !0 && fe.setGlobalState(_.clippingPlanes, nt),
        Nv(z, et, nt),
        Lt.updateMultisampleRenderTarget(Dt),
        Lt.updateRenderTargetMipmap(Dt),
        it.has('WEBGL_multisampled_render_to_texture') === !1)
      ) {
        let he = !1
        for (let ne = 0, ze = $.length; ne < ze; ne++) {
          const yn = $[ne],
            _n = yn.object,
            ui = yn.geometry,
            Ue = yn.material,
            Jt = yn.group
          if (Ue.side === dr && _n.layers.test(nt.layers)) {
            const lr = Ue.side
            ;(Ue.side = Qr),
              (Ue.needsUpdate = !0),
              zE(_n, et, nt, ui, Ue, Jt),
              (Ue.side = lr),
              (Ue.needsUpdate = !0),
              (he = !0)
          }
        }
        he === !0 &&
          (Lt.updateMultisampleRenderTarget(Dt),
          Lt.updateRenderTargetMipmap(Dt))
      }
      _.setRenderTarget(Xt),
        _.setClearColor(D, P),
        le !== void 0 && (nt.viewport = le),
        (_.toneMapping = Yt)
    }
    function Nv(z, $, et) {
      const nt = $.isScene === !0 ? $.overrideMaterial : null
      for (let q = 0, Dt = z.length; q < Dt; q++) {
        const Ft = z[q],
          Xt = Ft.object,
          Yt = Ft.geometry,
          le = nt === null ? Ft.material : nt,
          he = Ft.group
        Xt.layers.test(et.layers) && zE(Xt, $, et, Yt, le, he)
      }
    }
    function zE(z, $, et, nt, q, Dt) {
      z.onBeforeRender(_, $, et, nt, q, Dt),
        z.modelViewMatrix.multiplyMatrices(
          et.matrixWorldInverse,
          z.matrixWorld,
        ),
        z.normalMatrix.getNormalMatrix(z.modelViewMatrix),
        q.transparent === !0 && q.side === dr && q.forceSinglePass === !1
          ? ((q.side = Qr),
            (q.needsUpdate = !0),
            _.renderBufferDirect(et, $, nt, q, z, Dt),
            (q.side = $o),
            (q.needsUpdate = !0),
            _.renderBufferDirect(et, $, nt, q, z, Dt),
            (q.side = dr))
          : _.renderBufferDirect(et, $, nt, q, z, Dt),
        z.onAfterRender(_, $, et, nt, q, Dt)
    }
    function kv(z, $, et) {
      $.isScene !== !0 && ($ = At)
      const nt = Ct.get(z),
        q = v.state.lights,
        Dt = v.state.shadowsArray,
        Ft = q.state.version,
        Xt = mt.getParameters(z, q.state, Dt, $, et),
        Yt = mt.getProgramCacheKey(Xt)
      let le = nt.programs
      ;(nt.environment = z.isMeshStandardMaterial ? $.environment : null),
        (nt.fog = $.fog),
        (nt.envMap = (z.isMeshStandardMaterial ? N : G).get(
          z.envMap || nt.environment,
        )),
        (nt.envMapRotation =
          nt.environment !== null && z.envMap === null
            ? $.environmentRotation
            : z.envMapRotation),
        le === void 0 &&
          (z.addEventListener('dispose', jt),
          (le = new Map()),
          (nt.programs = le))
      let he = le.get(Yt)
      if (he !== void 0) {
        if (nt.currentProgram === he && nt.lightsStateVersion === Ft)
          return VE(z, Xt), he
      } else
        (Xt.uniforms = mt.getUniforms(z)),
          z.onBeforeCompile(Xt, _),
          (he = mt.acquireProgram(Xt, Yt)),
          le.set(Yt, he),
          (nt.uniforms = Xt.uniforms)
      const ne = nt.uniforms
      return (
        ((!z.isShaderMaterial && !z.isRawShaderMaterial) ||
          z.clipping === !0) &&
          (ne.clippingPlanes = fe.uniform),
        VE(z, Xt),
        (nt.needsLights = h8(z)),
        (nt.lightsStateVersion = Ft),
        nt.needsLights &&
          ((ne.ambientLightColor.value = q.state.ambient),
          (ne.lightProbe.value = q.state.probe),
          (ne.directionalLights.value = q.state.directional),
          (ne.directionalLightShadows.value = q.state.directionalShadow),
          (ne.spotLights.value = q.state.spot),
          (ne.spotLightShadows.value = q.state.spotShadow),
          (ne.rectAreaLights.value = q.state.rectArea),
          (ne.ltc_1.value = q.state.rectAreaLTC1),
          (ne.ltc_2.value = q.state.rectAreaLTC2),
          (ne.pointLights.value = q.state.point),
          (ne.pointLightShadows.value = q.state.pointShadow),
          (ne.hemisphereLights.value = q.state.hemi),
          (ne.directionalShadowMap.value = q.state.directionalShadowMap),
          (ne.directionalShadowMatrix.value = q.state.directionalShadowMatrix),
          (ne.spotShadowMap.value = q.state.spotShadowMap),
          (ne.spotLightMatrix.value = q.state.spotLightMatrix),
          (ne.spotLightMap.value = q.state.spotLightMap),
          (ne.pointShadowMap.value = q.state.pointShadowMap),
          (ne.pointShadowMatrix.value = q.state.pointShadowMatrix)),
        (nt.currentProgram = he),
        (nt.uniformsList = null),
        he
      )
    }
    function UE(z) {
      if (z.uniformsList === null) {
        const $ = z.currentProgram.getUniforms()
        z.uniformsList = zm.seqWithValue($.seq, z.uniforms)
      }
      return z.uniformsList
    }
    function VE(z, $) {
      const et = Ct.get(z)
      ;(et.outputColorSpace = $.outputColorSpace),
        (et.batching = $.batching),
        (et.batchingColor = $.batchingColor),
        (et.instancing = $.instancing),
        (et.instancingColor = $.instancingColor),
        (et.instancingMorph = $.instancingMorph),
        (et.skinning = $.skinning),
        (et.morphTargets = $.morphTargets),
        (et.morphNormals = $.morphNormals),
        (et.morphColors = $.morphColors),
        (et.morphTargetsCount = $.morphTargetsCount),
        (et.numClippingPlanes = $.numClippingPlanes),
        (et.numIntersection = $.numClipIntersection),
        (et.vertexAlphas = $.vertexAlphas),
        (et.vertexTangents = $.vertexTangents),
        (et.toneMapping = $.toneMapping)
    }
    function u8(z, $, et, nt, q) {
      $.isScene !== !0 && ($ = At), Lt.resetTextureUnits()
      const Dt = $.fog,
        Ft = nt.isMeshStandardMaterial ? $.environment : null,
        Xt =
          b === null
            ? _.outputColorSpace
            : b.isXRRenderTarget === !0
            ? b.texture.colorSpace
            : ar,
        Yt = (nt.isMeshStandardMaterial ? N : G).get(nt.envMap || Ft),
        le =
          nt.vertexColors === !0 &&
          !!et.attributes.color &&
          et.attributes.color.itemSize === 4,
        he = !!et.attributes.tangent && (!!nt.normalMap || nt.anisotropy > 0),
        ne = !!et.morphAttributes.position,
        ze = !!et.morphAttributes.normal,
        yn = !!et.morphAttributes.color
      let _n = Ys
      nt.toneMapped &&
        (b === null || b.isXRRenderTarget === !0) &&
        (_n = _.toneMapping)
      const ui =
          et.morphAttributes.position ||
          et.morphAttributes.normal ||
          et.morphAttributes.color,
        Ue = ui !== void 0 ? ui.length : 0,
        Jt = Ct.get(nt),
        lr = v.state.lights
      if (W === !0 && (Z === !0 || z !== w)) {
        const Di = z === w && nt.id === T
        fe.setState(nt, z, Di)
      }
      let Ve = !1
      nt.version === Jt.__version
        ? ((Jt.needsLights && Jt.lightsStateVersion !== lr.state.version) ||
            Jt.outputColorSpace !== Xt ||
            (q.isBatchedMesh && Jt.batching === !1) ||
            (!q.isBatchedMesh && Jt.batching === !0) ||
            (q.isBatchedMesh &&
              Jt.batchingColor === !0 &&
              q.colorTexture === null) ||
            (q.isBatchedMesh &&
              Jt.batchingColor === !1 &&
              q.colorTexture !== null) ||
            (q.isInstancedMesh && Jt.instancing === !1) ||
            (!q.isInstancedMesh && Jt.instancing === !0) ||
            (q.isSkinnedMesh && Jt.skinning === !1) ||
            (!q.isSkinnedMesh && Jt.skinning === !0) ||
            (q.isInstancedMesh &&
              Jt.instancingColor === !0 &&
              q.instanceColor === null) ||
            (q.isInstancedMesh &&
              Jt.instancingColor === !1 &&
              q.instanceColor !== null) ||
            (q.isInstancedMesh &&
              Jt.instancingMorph === !0 &&
              q.morphTexture === null) ||
            (q.isInstancedMesh &&
              Jt.instancingMorph === !1 &&
              q.morphTexture !== null) ||
            Jt.envMap !== Yt ||
            (nt.fog === !0 && Jt.fog !== Dt) ||
            (Jt.numClippingPlanes !== void 0 &&
              (Jt.numClippingPlanes !== fe.numPlanes ||
                Jt.numIntersection !== fe.numIntersection)) ||
            Jt.vertexAlphas !== le ||
            Jt.vertexTangents !== he ||
            Jt.morphTargets !== ne ||
            Jt.morphNormals !== ze ||
            Jt.morphColors !== yn ||
            Jt.toneMapping !== _n ||
            Jt.morphTargetsCount !== Ue) &&
          (Ve = !0)
        : ((Ve = !0), (Jt.__version = nt.version))
      let oa = Jt.currentProgram
      Ve === !0 && (oa = kv(nt, $, q))
      let cc = !1,
        ci = !1,
        I_ = !1
      const Nn = oa.getUniforms(),
        ls = Jt.uniforms
      if (
        (rt.useProgram(oa.program) && ((cc = !0), (ci = !0), (I_ = !0)),
        nt.id !== T && ((T = nt.id), (ci = !0)),
        cc || w !== z)
      ) {
        Nn.setValue(B, 'projectionMatrix', z.projectionMatrix),
          Nn.setValue(B, 'viewMatrix', z.matrixWorldInverse)
        const Di = Nn.map.cameraPosition
        Di !== void 0 &&
          Di.setValue(B, lt.setFromMatrixPosition(z.matrixWorld)),
          xt.logarithmicDepthBuffer &&
            Nn.setValue(
              B,
              'logDepthBufFC',
              2 / (Math.log(z.far + 1) / Math.LN2),
            ),
          (nt.isMeshPhongMaterial ||
            nt.isMeshToonMaterial ||
            nt.isMeshLambertMaterial ||
            nt.isMeshBasicMaterial ||
            nt.isMeshStandardMaterial ||
            nt.isShaderMaterial) &&
            Nn.setValue(B, 'isOrthographic', z.isOrthographicCamera === !0),
          w !== z && ((w = z), (ci = !0), (I_ = !0))
      }
      if (q.isSkinnedMesh) {
        Nn.setOptional(B, q, 'bindMatrix'),
          Nn.setOptional(B, q, 'bindMatrixInverse')
        const Di = q.skeleton
        Di &&
          (Di.boneTexture === null && Di.computeBoneTexture(),
          Nn.setValue(B, 'boneTexture', Di.boneTexture, Lt))
      }
      q.isBatchedMesh &&
        (Nn.setOptional(B, q, 'batchingTexture'),
        Nn.setValue(B, 'batchingTexture', q._matricesTexture, Lt),
        Nn.setOptional(B, q, 'batchingIdTexture'),
        Nn.setValue(B, 'batchingIdTexture', q._indirectTexture, Lt),
        Nn.setOptional(B, q, 'batchingColorTexture'),
        q._colorsTexture !== null &&
          Nn.setValue(B, 'batchingColorTexture', q._colorsTexture, Lt))
      const O_ = et.morphAttributes
      if (
        ((O_.position !== void 0 ||
          O_.normal !== void 0 ||
          O_.color !== void 0) &&
          Te.update(q, et, oa),
        (ci || Jt.receiveShadow !== q.receiveShadow) &&
          ((Jt.receiveShadow = q.receiveShadow),
          Nn.setValue(B, 'receiveShadow', q.receiveShadow)),
        nt.isMeshGouraudMaterial &&
          nt.envMap !== null &&
          ((ls.envMap.value = Yt),
          (ls.flipEnvMap.value =
            Yt.isCubeTexture && Yt.isRenderTargetTexture === !1 ? -1 : 1)),
        nt.isMeshStandardMaterial &&
          nt.envMap === null &&
          $.environment !== null &&
          (ls.envMapIntensity.value = $.environmentIntensity),
        ci &&
          (Nn.setValue(B, 'toneMappingExposure', _.toneMappingExposure),
          Jt.needsLights && c8(ls, I_),
          Dt && nt.fog === !0 && Kt.refreshFogUniforms(ls, Dt),
          Kt.refreshMaterialUniforms(
            ls,
            nt,
            F,
            I,
            v.state.transmissionRenderTarget[z.id],
          ),
          zm.upload(B, UE(Jt), ls, Lt)),
        nt.isShaderMaterial &&
          nt.uniformsNeedUpdate === !0 &&
          (zm.upload(B, UE(Jt), ls, Lt), (nt.uniformsNeedUpdate = !1)),
        nt.isSpriteMaterial && Nn.setValue(B, 'center', q.center),
        Nn.setValue(B, 'modelViewMatrix', q.modelViewMatrix),
        Nn.setValue(B, 'normalMatrix', q.normalMatrix),
        Nn.setValue(B, 'modelMatrix', q.matrixWorld),
        nt.isShaderMaterial || nt.isRawShaderMaterial)
      ) {
        const Di = nt.uniformsGroups
        for (let N_ = 0, f8 = Di.length; N_ < f8; N_++) {
          const GE = Di[N_]
          ln.update(GE, oa), ln.bind(GE, oa)
        }
      }
      return oa
    }
    function c8(z, $) {
      ;(z.ambientLightColor.needsUpdate = $),
        (z.lightProbe.needsUpdate = $),
        (z.directionalLights.needsUpdate = $),
        (z.directionalLightShadows.needsUpdate = $),
        (z.pointLights.needsUpdate = $),
        (z.pointLightShadows.needsUpdate = $),
        (z.spotLights.needsUpdate = $),
        (z.spotLightShadows.needsUpdate = $),
        (z.rectAreaLights.needsUpdate = $),
        (z.hemisphereLights.needsUpdate = $)
    }
    function h8(z) {
      return (
        z.isMeshLambertMaterial ||
        z.isMeshToonMaterial ||
        z.isMeshPhongMaterial ||
        z.isMeshStandardMaterial ||
        z.isShadowMaterial ||
        (z.isShaderMaterial && z.lights === !0)
      )
    }
    ;(this.getActiveCubeFace = function () {
      return A
    }),
      (this.getActiveMipmapLevel = function () {
        return S
      }),
      (this.getRenderTarget = function () {
        return b
      }),
      (this.setRenderTargetTextures = function (z, $, et) {
        ;(Ct.get(z.texture).__webglTexture = $),
          (Ct.get(z.depthTexture).__webglTexture = et)
        const nt = Ct.get(z)
        ;(nt.__hasExternalTextures = !0),
          (nt.__autoAllocateDepthBuffer = et === void 0),
          nt.__autoAllocateDepthBuffer ||
            (it.has('WEBGL_multisampled_render_to_texture') === !0 &&
              (console.warn(
                'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided',
              ),
              (nt.__useRenderToTexture = !1)))
      }),
      (this.setRenderTargetFramebuffer = function (z, $) {
        const et = Ct.get(z)
        ;(et.__webglFramebuffer = $),
          (et.__useDefaultFramebuffer = $ === void 0)
      }),
      (this.setRenderTarget = function (z, $ = 0, et = 0) {
        ;(b = z), (A = $), (S = et)
        let nt = !0,
          q = null,
          Dt = !1,
          Ft = !1
        if (z) {
          const Yt = Ct.get(z)
          Yt.__useDefaultFramebuffer !== void 0
            ? (rt.bindFramebuffer(B.FRAMEBUFFER, null), (nt = !1))
            : Yt.__webglFramebuffer === void 0
            ? Lt.setupRenderTarget(z)
            : Yt.__hasExternalTextures &&
              Lt.rebindTextures(
                z,
                Ct.get(z.texture).__webglTexture,
                Ct.get(z.depthTexture).__webglTexture,
              )
          const le = z.texture
          ;(le.isData3DTexture ||
            le.isDataArrayTexture ||
            le.isCompressedArrayTexture) &&
            (Ft = !0)
          const he = Ct.get(z).__webglFramebuffer
          z.isWebGLCubeRenderTarget
            ? (Array.isArray(he[$]) ? (q = he[$][et]) : (q = he[$]), (Dt = !0))
            : z.samples > 0 && Lt.useMultisampledRTT(z) === !1
            ? (q = Ct.get(z).__webglMultisampledFramebuffer)
            : Array.isArray(he)
            ? (q = he[et])
            : (q = he),
            M.copy(z.viewport),
            C.copy(z.scissor),
            (E = z.scissorTest)
        } else
          M.copy(H).multiplyScalar(F).floor(),
            C.copy(Y).multiplyScalar(F).floor(),
            (E = K)
        if (
          (rt.bindFramebuffer(B.FRAMEBUFFER, q) && nt && rt.drawBuffers(z, q),
          rt.viewport(M),
          rt.scissor(C),
          rt.setScissorTest(E),
          Dt)
        ) {
          const Yt = Ct.get(z.texture)
          B.framebufferTexture2D(
            B.FRAMEBUFFER,
            B.COLOR_ATTACHMENT0,
            B.TEXTURE_CUBE_MAP_POSITIVE_X + $,
            Yt.__webglTexture,
            et,
          )
        } else if (Ft) {
          const Yt = Ct.get(z.texture),
            le = $ || 0
          B.framebufferTextureLayer(
            B.FRAMEBUFFER,
            B.COLOR_ATTACHMENT0,
            Yt.__webglTexture,
            et || 0,
            le,
          )
        }
        T = -1
      }),
      (this.readRenderTargetPixels = function (z, $, et, nt, q, Dt, Ft) {
        if (!(z && z.isWebGLRenderTarget)) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          )
          return
        }
        let Xt = Ct.get(z).__webglFramebuffer
        if ((z.isWebGLCubeRenderTarget && Ft !== void 0 && (Xt = Xt[Ft]), Xt)) {
          rt.bindFramebuffer(B.FRAMEBUFFER, Xt)
          try {
            const Yt = z.texture,
              le = Yt.format,
              he = Yt.type
            if (!xt.textureFormatReadable(le)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
              )
              return
            }
            if (!xt.textureTypeReadable(he)) {
              console.error(
                'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
              )
              return
            }
            $ >= 0 &&
              $ <= z.width - nt &&
              et >= 0 &&
              et <= z.height - q &&
              B.readPixels($, et, nt, q, ue.convert(le), ue.convert(he), Dt)
          } finally {
            const Yt = b !== null ? Ct.get(b).__webglFramebuffer : null
            rt.bindFramebuffer(B.FRAMEBUFFER, Yt)
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        z,
        $,
        et,
        nt,
        q,
        Dt,
        Ft,
      ) {
        if (!(z && z.isWebGLRenderTarget))
          throw new Error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          )
        let Xt = Ct.get(z).__webglFramebuffer
        if ((z.isWebGLCubeRenderTarget && Ft !== void 0 && (Xt = Xt[Ft]), Xt)) {
          rt.bindFramebuffer(B.FRAMEBUFFER, Xt)
          try {
            const Yt = z.texture,
              le = Yt.format,
              he = Yt.type
            if (!xt.textureFormatReadable(le))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.',
              )
            if (!xt.textureTypeReadable(he))
              throw new Error(
                'THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.',
              )
            if ($ >= 0 && $ <= z.width - nt && et >= 0 && et <= z.height - q) {
              const ne = B.createBuffer()
              B.bindBuffer(B.PIXEL_PACK_BUFFER, ne),
                B.bufferData(B.PIXEL_PACK_BUFFER, Dt.byteLength, B.STREAM_READ),
                B.readPixels($, et, nt, q, ue.convert(le), ue.convert(he), 0),
                B.flush()
              const ze = B.fenceSync(B.SYNC_GPU_COMMANDS_COMPLETE, 0)
              await I6(B, ze, 4)
              try {
                B.bindBuffer(B.PIXEL_PACK_BUFFER, ne),
                  B.getBufferSubData(B.PIXEL_PACK_BUFFER, 0, Dt)
              } finally {
                B.deleteBuffer(ne), B.deleteSync(ze)
              }
              return Dt
            }
          } finally {
            const Yt = b !== null ? Ct.get(b).__webglFramebuffer : null
            rt.bindFramebuffer(B.FRAMEBUFFER, Yt)
          }
        }
      }),
      (this.copyFramebufferToTexture = function (z, $ = null, et = 0) {
        z.isTexture !== !0 &&
          (console.warn(
            'WebGLRenderer: copyFramebufferToTexture function signature has changed.',
          ),
          ($ = arguments[0] || null),
          (z = arguments[1]))
        const nt = Math.pow(2, -et),
          q = Math.floor(z.image.width * nt),
          Dt = Math.floor(z.image.height * nt),
          Ft = $ !== null ? $.x : 0,
          Xt = $ !== null ? $.y : 0
        Lt.setTexture2D(z, 0),
          B.copyTexSubImage2D(B.TEXTURE_2D, et, 0, 0, Ft, Xt, q, Dt),
          rt.unbindTexture()
      }),
      (this.copyTextureToTexture = function (
        z,
        $,
        et = null,
        nt = null,
        q = 0,
      ) {
        z.isTexture !== !0 &&
          (console.warn(
            'WebGLRenderer: copyTextureToTexture function signature has changed.',
          ),
          (nt = arguments[0] || null),
          (z = arguments[1]),
          ($ = arguments[2]),
          (q = arguments[3] || 0),
          (et = null))
        let Dt, Ft, Xt, Yt, le, he
        et !== null
          ? ((Dt = et.max.x - et.min.x),
            (Ft = et.max.y - et.min.y),
            (Xt = et.min.x),
            (Yt = et.min.y))
          : ((Dt = z.image.width), (Ft = z.image.height), (Xt = 0), (Yt = 0)),
          nt !== null ? ((le = nt.x), (he = nt.y)) : ((le = 0), (he = 0))
        const ne = ue.convert($.format),
          ze = ue.convert($.type)
        Lt.setTexture2D($, 0),
          B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL, $.flipY),
          B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha),
          B.pixelStorei(B.UNPACK_ALIGNMENT, $.unpackAlignment)
        const yn = B.getParameter(B.UNPACK_ROW_LENGTH),
          _n = B.getParameter(B.UNPACK_IMAGE_HEIGHT),
          ui = B.getParameter(B.UNPACK_SKIP_PIXELS),
          Ue = B.getParameter(B.UNPACK_SKIP_ROWS),
          Jt = B.getParameter(B.UNPACK_SKIP_IMAGES),
          lr = z.isCompressedTexture ? z.mipmaps[q] : z.image
        B.pixelStorei(B.UNPACK_ROW_LENGTH, lr.width),
          B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, lr.height),
          B.pixelStorei(B.UNPACK_SKIP_PIXELS, Xt),
          B.pixelStorei(B.UNPACK_SKIP_ROWS, Yt),
          z.isDataTexture
            ? B.texSubImage2D(B.TEXTURE_2D, q, le, he, Dt, Ft, ne, ze, lr.data)
            : z.isCompressedTexture
            ? B.compressedTexSubImage2D(
                B.TEXTURE_2D,
                q,
                le,
                he,
                lr.width,
                lr.height,
                ne,
                lr.data,
              )
            : B.texSubImage2D(B.TEXTURE_2D, q, le, he, Dt, Ft, ne, ze, lr),
          B.pixelStorei(B.UNPACK_ROW_LENGTH, yn),
          B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, _n),
          B.pixelStorei(B.UNPACK_SKIP_PIXELS, ui),
          B.pixelStorei(B.UNPACK_SKIP_ROWS, Ue),
          B.pixelStorei(B.UNPACK_SKIP_IMAGES, Jt),
          q === 0 && $.generateMipmaps && B.generateMipmap(B.TEXTURE_2D),
          rt.unbindTexture()
      }),
      (this.copyTextureToTexture3D = function (
        z,
        $,
        et = null,
        nt = null,
        q = 0,
      ) {
        z.isTexture !== !0 &&
          (console.warn(
            'WebGLRenderer: copyTextureToTexture3D function signature has changed.',
          ),
          (et = arguments[0] || null),
          (nt = arguments[1] || null),
          (z = arguments[2]),
          ($ = arguments[3]),
          (q = arguments[4] || 0))
        let Dt, Ft, Xt, Yt, le, he, ne, ze, yn
        const _n = z.isCompressedTexture ? z.mipmaps[q] : z.image
        et !== null
          ? ((Dt = et.max.x - et.min.x),
            (Ft = et.max.y - et.min.y),
            (Xt = et.max.z - et.min.z),
            (Yt = et.min.x),
            (le = et.min.y),
            (he = et.min.z))
          : ((Dt = _n.width),
            (Ft = _n.height),
            (Xt = _n.depth),
            (Yt = 0),
            (le = 0),
            (he = 0)),
          nt !== null
            ? ((ne = nt.x), (ze = nt.y), (yn = nt.z))
            : ((ne = 0), (ze = 0), (yn = 0))
        const ui = ue.convert($.format),
          Ue = ue.convert($.type)
        let Jt
        if ($.isData3DTexture) Lt.setTexture3D($, 0), (Jt = B.TEXTURE_3D)
        else if ($.isDataArrayTexture || $.isCompressedArrayTexture)
          Lt.setTexture2DArray($, 0), (Jt = B.TEXTURE_2D_ARRAY)
        else {
          console.warn(
            'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',
          )
          return
        }
        B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL, $.flipY),
          B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL, $.premultiplyAlpha),
          B.pixelStorei(B.UNPACK_ALIGNMENT, $.unpackAlignment)
        const lr = B.getParameter(B.UNPACK_ROW_LENGTH),
          Ve = B.getParameter(B.UNPACK_IMAGE_HEIGHT),
          oa = B.getParameter(B.UNPACK_SKIP_PIXELS),
          cc = B.getParameter(B.UNPACK_SKIP_ROWS),
          ci = B.getParameter(B.UNPACK_SKIP_IMAGES)
        B.pixelStorei(B.UNPACK_ROW_LENGTH, _n.width),
          B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, _n.height),
          B.pixelStorei(B.UNPACK_SKIP_PIXELS, Yt),
          B.pixelStorei(B.UNPACK_SKIP_ROWS, le),
          B.pixelStorei(B.UNPACK_SKIP_IMAGES, he),
          z.isDataTexture || z.isData3DTexture
            ? B.texSubImage3D(Jt, q, ne, ze, yn, Dt, Ft, Xt, ui, Ue, _n.data)
            : $.isCompressedArrayTexture
            ? B.compressedTexSubImage3D(
                Jt,
                q,
                ne,
                ze,
                yn,
                Dt,
                Ft,
                Xt,
                ui,
                _n.data,
              )
            : B.texSubImage3D(Jt, q, ne, ze, yn, Dt, Ft, Xt, ui, Ue, _n),
          B.pixelStorei(B.UNPACK_ROW_LENGTH, lr),
          B.pixelStorei(B.UNPACK_IMAGE_HEIGHT, Ve),
          B.pixelStorei(B.UNPACK_SKIP_PIXELS, oa),
          B.pixelStorei(B.UNPACK_SKIP_ROWS, cc),
          B.pixelStorei(B.UNPACK_SKIP_IMAGES, ci),
          q === 0 && $.generateMipmaps && B.generateMipmap(Jt),
          rt.unbindTexture()
      }),
      (this.initRenderTarget = function (z) {
        Ct.get(z).__webglFramebuffer === void 0 && Lt.setupRenderTarget(z)
      }),
      (this.initTexture = function (z) {
        z.isCubeTexture
          ? Lt.setTextureCube(z, 0)
          : z.isData3DTexture
          ? Lt.setTexture3D(z, 0)
          : z.isDataArrayTexture || z.isCompressedArrayTexture
          ? Lt.setTexture2DArray(z, 0)
          : Lt.setTexture2D(z, 0),
          rt.unbindTexture()
      }),
      (this.resetState = function () {
        ;(A = 0), (S = 0), (b = null), rt.reset(), de.reset()
      }),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', {
            detail: this,
          }),
        )
  }
  get coordinateSystem() {
    return zo
  }
  get outputColorSpace() {
    return this._outputColorSpace
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t
    const e = this.getContext()
    ;(e.drawingBufferColorSpace = t === PM ? 'display-p3' : 'srgb'),
      (e.unpackColorSpace = Be.workingColorSpace === I0 ? 'display-p3' : 'srgb')
  }
}
class zM {
  constructor(t, e = 1, n = 1e3) {
    ;(this.isFog = !0),
      (this.name = ''),
      (this.color = new qt(t)),
      (this.near = e),
      (this.far = n)
  }
  clone() {
    return new zM(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: 'Fog',
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    }
  }
}
class hB extends Fe {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Ma()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Ma()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < 'u' &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', {
            detail: this,
          }),
        )
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.background !== null && (this.background = t.background.clone()),
      t.environment !== null && (this.environment = t.environment.clone()),
      t.fog !== null && (this.fog = t.fog.clone()),
      (this.backgroundBlurriness = t.backgroundBlurriness),
      (this.backgroundIntensity = t.backgroundIntensity),
      this.backgroundRotation.copy(t.backgroundRotation),
      (this.environmentIntensity = t.environmentIntensity),
      this.environmentRotation.copy(t.environmentRotation),
      t.overrideMaterial !== null &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      this.fog !== null && (e.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (e.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (e.object.backgroundIntensity = this.backgroundIntensity),
      (e.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (e.object.environmentIntensity = this.environmentIntensity),
      (e.object.environmentRotation = this.environmentRotation.toArray()),
      e
    )
  }
}
class UM {
  constructor(t, e) {
    ;(this.isInterleavedBuffer = !0),
      (this.array = t),
      (this.stride = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.usage = YA),
      (this._updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Ki())
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++
  }
  get updateRange() {
    return (
      OM(
        'THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.',
      ),
      this._updateRange
    )
  }
  setUsage(t) {
    return (this.usage = t), this
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({
      start: t,
      count: e,
    })
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    )
  }
  copyAt(t, e, n) {
    ;(t *= this.stride), (n *= e.stride)
    for (let i = 0, a = this.stride; i < a; i++)
      this.array[t + i] = e.array[n + i]
    return this
  }
  set(t, e = 0) {
    return this.array.set(t, e), this
  }
  clone(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ki()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid],
      ),
      n = new this.constructor(e, this.stride)
    return n.setUsage(this.usage), n
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this
  }
  toJSON(t) {
    return (
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ki()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    )
  }
}
const Lr = new U()
class _a {
  constructor(t, e, n, i = !1) {
    ;(this.isInterleavedBufferAttribute = !0),
      (this.name = ''),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = i)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      Lr.fromBufferAttribute(this, e),
        Lr.applyMatrix4(t),
        this.setXYZ(e, Lr.x, Lr.y, Lr.z)
    return this
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Lr.fromBufferAttribute(this, e),
        Lr.applyNormalMatrix(t),
        this.setXYZ(e, Lr.x, Lr.y, Lr.z)
    return this
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      Lr.fromBufferAttribute(this, e),
        Lr.transformDirection(t),
        this.setXYZ(e, Lr.x, Lr.y, Lr.z)
    return this
  }
  getComponent(t, e) {
    let n = this.array[t * this.data.stride + this.offset + e]
    return this.normalized && (n = ma(n, this.array)), n
  }
  setComponent(t, e, n) {
    return (
      this.normalized && (n = We(n, this.array)),
      (this.data.array[t * this.data.stride + this.offset + e] = n),
      this
    )
  }
  setX(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset] = e),
      this
    )
  }
  setY(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 1] = e),
      this
    )
  }
  setZ(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 2] = e),
      this
    )
  }
  setW(t, e) {
    return (
      this.normalized && (e = We(e, this.array)),
      (this.data.array[t * this.data.stride + this.offset + 3] = e),
      this
    )
  }
  getX(t) {
    let e = this.data.array[t * this.data.stride + this.offset]
    return this.normalized && (e = ma(e, this.array)), e
  }
  getY(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 1]
    return this.normalized && (e = ma(e, this.array)), e
  }
  getZ(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 2]
    return this.normalized && (e = ma(e, this.array)), e
  }
  getW(t) {
    let e = this.data.array[t * this.data.stride + this.offset + 3]
    return this.normalized && (e = ma(e, this.array)), e
  }
  setXY(t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized && ((e = We(e, this.array)), (n = We(n, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    )
  }
  setXYZ(t, e, n, i) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = We(e, this.array)),
        (n = We(n, this.array)),
        (i = We(i, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      this
    )
  }
  setXYZW(t, e, n, i, a) {
    return (
      (t = t * this.data.stride + this.offset),
      this.normalized &&
        ((e = We(e, this.array)),
        (n = We(n, this.array)),
        (i = We(i, this.array)),
        (a = We(a, this.array))),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      (this.data.array[t + 3] = a),
      this
    )
  }
  clone(t) {
    if (t === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.',
      )
      const e = []
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset
        for (let a = 0; a < this.itemSize; a++) e.push(this.data.array[i + a])
      }
      return new ir(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized,
      )
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new _a(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      )
  }
  toJSON(t) {
    if (t === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.',
      )
      const e = []
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset
        for (let a = 0; a < this.itemSize; a++) e.push(this.data.array[i + a])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      }
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      )
  }
}
class fB extends ji {
  constructor(t) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = 'SpriteMaterial'),
      (this.color = new qt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    )
  }
}
let Lc
const Uf = new U(),
  Pc = new U(),
  Rc = new U(),
  Ic = new pt(),
  Vf = new pt(),
  dB = new ae(),
  ig = new U(),
  Gf = new U(),
  ag = new U(),
  $2 = new pt(),
  lx = new pt(),
  q2 = new pt()
class UY extends Fe {
  constructor(t = new fB()) {
    if (
      (super(), (this.isSprite = !0), (this.type = 'Sprite'), Lc === void 0)
    ) {
      Lc = new Mn()
      const e = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new UM(e, 5)
      Lc.setIndex([0, 1, 2, 0, 2, 3]),
        Lc.setAttribute('position', new _a(n, 3, 0, !1)),
        Lc.setAttribute('uv', new _a(n, 2, 3, !1))
    }
    ;(this.geometry = Lc), (this.material = t), (this.center = new pt(0.5, 0.5))
  }
  raycast(t, e) {
    t.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      ),
      Pc.setFromMatrixScale(this.matrixWorld),
      dB.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld,
      ),
      Rc.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Pc.multiplyScalar(-Rc.z)
    const n = this.material.rotation
    let i, a
    n !== 0 && ((a = Math.cos(n)), (i = Math.sin(n)))
    const o = this.center
    og(ig.set(-0.5, -0.5, 0), Rc, o, Pc, i, a),
      og(Gf.set(0.5, -0.5, 0), Rc, o, Pc, i, a),
      og(ag.set(0.5, 0.5, 0), Rc, o, Pc, i, a),
      $2.set(0, 0),
      lx.set(1, 0),
      q2.set(1, 1)
    let s = t.ray.intersectTriangle(ig, Gf, ag, !1, Uf)
    if (
      s === null &&
      (og(Gf.set(-0.5, 0.5, 0), Rc, o, Pc, i, a),
      lx.set(0, 1),
      (s = t.ray.intersectTriangle(ig, ag, Gf, !1, Uf)),
      s === null)
    )
      return
    const l = t.ray.origin.distanceTo(Uf)
    l < t.near ||
      l > t.far ||
      e.push({
        distance: l,
        point: Uf.clone(),
        uv: Ed.getInterpolation(Uf, ig, Gf, ag, $2, lx, q2, new pt()),
        face: null,
        object: this,
      })
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.center !== void 0 && this.center.copy(t.center),
      (this.material = t.material),
      this
    )
  }
}
function og(r, t, e, n, i, a) {
  Ic.subVectors(r, e).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((Vf.x = a * Ic.x - i * Ic.y), (Vf.y = i * Ic.x + a * Ic.y))
      : Vf.copy(Ic),
    r.copy(t),
    (r.x += Vf.x),
    (r.y += Vf.y),
    r.applyMatrix4(dB)
}
const Z2 = new U(),
  K2 = new Oe(),
  j2 = new Oe(),
  VY = new U(),
  J2 = new ae(),
  sg = new U(),
  ux = new na(),
  Q2 = new ae(),
  cx = new hf()
class GY extends De {
  constructor(t, e) {
    super(t, e),
      (this.isSkinnedMesh = !0),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = jE),
      (this.bindMatrix = new ae()),
      (this.bindMatrixInverse = new ae()),
      (this.boundingBox = null),
      (this.boundingSphere = null)
  }
  computeBoundingBox() {
    const t = this.geometry
    this.boundingBox === null && (this.boundingBox = new Ei()),
      this.boundingBox.makeEmpty()
    const e = t.getAttribute('position')
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, sg), this.boundingBox.expandByPoint(sg)
  }
  computeBoundingSphere() {
    const t = this.geometry
    this.boundingSphere === null && (this.boundingSphere = new na()),
      this.boundingSphere.makeEmpty()
    const e = t.getAttribute('position')
    for (let n = 0; n < e.count; n++)
      this.getVertexPosition(n, sg), this.boundingSphere.expandByPoint(sg)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    )
  }
  raycast(t, e) {
    const n = this.material,
      i = this.matrixWorld
    n !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      ux.copy(this.boundingSphere),
      ux.applyMatrix4(i),
      t.ray.intersectsSphere(ux) !== !1 &&
        (Q2.copy(i).invert(),
        cx.copy(t.ray).applyMatrix4(Q2),
        !(
          this.boundingBox !== null && cx.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(t, e, cx)))
  }
  getVertexPosition(t, e) {
    return super.getVertexPosition(t, e), this.applyBoneTransform(t, e), e
  }
  bind(t, e) {
    ;(this.skeleton = t),
      e === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.copy(e).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const t = new Oe(),
      e = this.geometry.attributes.skinWeight
    for (let n = 0, i = e.count; n < i; n++) {
      t.fromBufferAttribute(e, n)
      const a = 1 / t.manhattanLength()
      a !== 1 / 0 ? t.multiplyScalar(a) : t.set(1, 0, 0, 0),
        e.setXYZW(n, t.x, t.y, t.z, t.w)
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.bindMode === jE
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === r6
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode,
          )
  }
  applyBoneTransform(t, e) {
    const n = this.skeleton,
      i = this.geometry
    K2.fromBufferAttribute(i.attributes.skinIndex, t),
      j2.fromBufferAttribute(i.attributes.skinWeight, t),
      Z2.copy(e).applyMatrix4(this.bindMatrix),
      e.set(0, 0, 0)
    for (let a = 0; a < 4; a++) {
      const o = j2.getComponent(a)
      if (o !== 0) {
        const s = K2.getComponent(a)
        J2.multiplyMatrices(n.bones[s].matrixWorld, n.boneInverses[s]),
          e.addScaledVector(VY.copy(Z2).applyMatrix4(J2), o)
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse)
  }
}
class pB extends Fe {
  constructor() {
    super(), (this.isBone = !0), (this.type = 'Bone')
  }
}
class vB extends Yn {
  constructor(t = null, e = 1, n = 1, i, a, o, s, l, u = Ur, c = Ur, h, f) {
    super(null, o, s, l, u, c, i, a, h, f),
      (this.isDataTexture = !0),
      (this.image = {
        data: t,
        width: e,
        height: n,
      }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
const tD = new ae(),
  HY = new ae()
class VM {
  constructor(t = [], e = []) {
    ;(this.uuid = Ki()),
      (this.bones = t.slice(0)),
      (this.boneInverses = e),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init()
  }
  init() {
    const t = this.bones,
      e = this.boneInverses
    if (((this.boneMatrices = new Float32Array(t.length * 16)), e.length === 0))
      this.calculateInverses()
    else if (t.length !== e.length) {
      console.warn(
        'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
      ),
        (this.boneInverses = [])
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new ae())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = new ae()
      this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(),
        this.boneInverses.push(n)
    }
  }
  pose() {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t]
      n && n.matrixWorld.copy(this.boneInverses[t]).invert()
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const n = this.bones[t]
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale))
    }
  }
  update() {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture
    for (let a = 0, o = t.length; a < o; a++) {
      const s = t[a] ? t[a].matrixWorld : HY
      tD.multiplyMatrices(s, e[a]), tD.toArray(n, a * 16)
    }
    i !== null && (i.needsUpdate = !0)
  }
  clone() {
    return new VM(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let t = Math.sqrt(this.bones.length * 4)
    ;(t = Math.ceil(t / 4) * 4), (t = Math.max(t, 4))
    const e = new Float32Array(t * t * 4)
    e.set(this.boneMatrices)
    const n = new vB(e, t, t, Yi, ya)
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = e),
      (this.boneTexture = n),
      this
    )
  }
  getBoneByName(t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const i = this.bones[e]
      if (i.name === t) return i
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(t, e) {
    this.uuid = t.uuid
    for (let n = 0, i = t.bones.length; n < i; n++) {
      const a = t.bones[n]
      let o = e[a]
      o === void 0 &&
        (console.warn('THREE.Skeleton: No bone found with UUID:', a),
        (o = new pB())),
        this.bones.push(o),
        this.boneInverses.push(new ae().fromArray(t.boneInverses[n]))
    }
    return this.init(), this
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON',
      },
      bones: [],
      boneInverses: [],
    }
    t.uuid = this.uuid
    const e = this.bones,
      n = this.boneInverses
    for (let i = 0, a = e.length; i < a; i++) {
      const o = e[i]
      t.bones.push(o.uuid)
      const s = n[i]
      t.boneInverses.push(s.toArray())
    }
    return t
  }
}
class qA extends ir {
  constructor(t, e, n, i = 1) {
    super(t, e, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    )
  }
}
const Oc = new ae(),
  eD = new ae(),
  lg = [],
  nD = new Ei(),
  WY = new ae(),
  Hf = new De(),
  Wf = new na()
class XY extends De {
  constructor(t, e, n) {
    super(t, e),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new qA(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    for (let i = 0; i < n; i++) this.setMatrixAt(i, WY)
  }
  computeBoundingBox() {
    const t = this.geometry,
      e = this.count
    this.boundingBox === null && (this.boundingBox = new Ei()),
      t.boundingBox === null && t.computeBoundingBox(),
      this.boundingBox.makeEmpty()
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Oc),
        nD.copy(t.boundingBox).applyMatrix4(Oc),
        this.boundingBox.union(nD)
  }
  computeBoundingSphere() {
    const t = this.geometry,
      e = this.count
    this.boundingSphere === null && (this.boundingSphere = new na()),
      t.boundingSphere === null && t.computeBoundingSphere(),
      this.boundingSphere.makeEmpty()
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, Oc),
        Wf.copy(t.boundingSphere).applyMatrix4(Oc),
        this.boundingSphere.union(Wf)
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.instanceMatrix.copy(t.instanceMatrix),
      t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()),
      t.instanceColor !== null &&
        (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()),
      t.boundingSphere !== null &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    )
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3)
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16)
  }
  getMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      a = n.length + 1,
      o = t * a + 1
    for (let s = 0; s < n.length; s++) n[s] = i[o + s]
  }
  raycast(t, e) {
    const n = this.matrixWorld,
      i = this.count
    if (
      ((Hf.geometry = this.geometry),
      (Hf.material = this.material),
      Hf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Wf.copy(this.boundingSphere),
        Wf.applyMatrix4(n),
        t.ray.intersectsSphere(Wf) !== !1))
    )
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, Oc),
          eD.multiplyMatrices(n, Oc),
          (Hf.matrixWorld = eD),
          Hf.raycast(t, lg)
        for (let o = 0, s = lg.length; o < s; o++) {
          const l = lg[o]
          ;(l.instanceId = a), (l.object = this), e.push(l)
        }
        lg.length = 0
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null &&
      (this.instanceColor = new qA(
        new Float32Array(this.instanceMatrix.count * 3),
        3,
      )),
      e.toArray(this.instanceColor.array, t * 3)
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16)
  }
  setMorphAt(t, e) {
    const n = e.morphTargetInfluences,
      i = n.length + 1
    this.morphTexture === null &&
      (this.morphTexture = new vB(
        new Float32Array(i * this.count),
        i,
        this.count,
        TM,
        ya,
      ))
    const a = this.morphTexture.source.data.data
    let o = 0
    for (let u = 0; u < n.length; u++) o += n[u]
    const s = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = i * t
    ;(a[l] = s), a.set(n, l + 1)
  }
  updateMorphTargets() {}
  dispose() {
    return (
      this.dispatchEvent({
        type: 'dispose',
      }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)),
      this
    )
  }
}
class dv extends ji {
  constructor(t) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = 'LineBasicMaterial'),
      (this.color = new qt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      (this.fog = t.fog),
      this
    )
  }
}
const _y = new U(),
  xy = new U(),
  rD = new ae(),
  Xf = new hf(),
  ug = new na(),
  hx = new U(),
  iD = new U()
let GM = class extends Fe {
  constructor(t = new Mn(), e = new dv()) {
    super(),
      (this.isLine = !0),
      (this.type = 'Line'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  computeLineDistances() {
    const t = this.geometry
    if (t.index === null) {
      const e = t.attributes.position,
        n = [0]
      for (let i = 1, a = e.count; i < a; i++)
        _y.fromBufferAttribute(e, i - 1),
          xy.fromBufferAttribute(e, i),
          (n[i] = n[i - 1]),
          (n[i] += _y.distanceTo(xy))
      t.setAttribute('lineDistance', new nn(n, 1))
    } else
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    return this
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      a = t.params.Line.threshold,
      o = n.drawRange
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      ug.copy(n.boundingSphere),
      ug.applyMatrix4(i),
      (ug.radius += a),
      t.ray.intersectsSphere(ug) === !1)
    )
      return
    rD.copy(i).invert(), Xf.copy(t.ray).applyMatrix4(rD)
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = s * s,
      u = this.isLineSegments ? 2 : 1,
      c = n.index,
      f = n.attributes.position
    if (c !== null) {
      const d = Math.max(0, o.start),
        p = Math.min(c.count, o.start + o.count)
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = c.getX(g),
          y = c.getX(g + 1),
          _ = cg(this, t, Xf, l, m, y)
        _ && e.push(_)
      }
      if (this.isLineLoop) {
        const g = c.getX(p - 1),
          v = c.getX(d),
          m = cg(this, t, Xf, l, g, v)
        m && e.push(m)
      }
    } else {
      const d = Math.max(0, o.start),
        p = Math.min(f.count, o.start + o.count)
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = cg(this, t, Xf, l, g, g + 1)
        m && e.push(m)
      }
      if (this.isLineLoop) {
        const g = cg(this, t, Xf, l, p - 1, d)
        g && e.push(g)
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e)
    if (n.length > 0) {
      const i = e[n[0]]
      if (i !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = a)
        }
      }
    }
  }
}
function cg(r, t, e, n, i, a) {
  const o = r.geometry.attributes.position
  if (
    (_y.fromBufferAttribute(o, i),
    xy.fromBufferAttribute(o, a),
    e.distanceSqToSegment(_y, xy, hx, iD) > n)
  )
    return
  hx.applyMatrix4(r.matrixWorld)
  const l = t.ray.origin.distanceTo(hx)
  if (!(l < t.near || l > t.far))
    return {
      distance: l,
      point: iD.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: r,
    }
}
const aD = new U(),
  oD = new U()
class gB extends GM {
  constructor(t, e) {
    super(t, e), (this.isLineSegments = !0), (this.type = 'LineSegments')
  }
  computeLineDistances() {
    const t = this.geometry
    if (t.index === null) {
      const e = t.attributes.position,
        n = []
      for (let i = 0, a = e.count; i < a; i += 2)
        aD.fromBufferAttribute(e, i),
          oD.fromBufferAttribute(e, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + aD.distanceTo(oD))
      t.setAttribute('lineDistance', new nn(n, 1))
    } else
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    return this
  }
}
class mB extends GM {
  constructor(t, e) {
    super(t, e), (this.isLineLoop = !0), (this.type = 'LineLoop')
  }
}
class HM extends ji {
  constructor(t) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = 'PointsMaterial'),
      (this.color = new qt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.fog = t.fog),
      this
    )
  }
}
const sD = new ae(),
  ZA = new hf(),
  hg = new na(),
  fg = new U()
class yB extends Fe {
  constructor(t = new Mn(), e = new HM()) {
    super(),
      (this.isPoints = !0),
      (this.type = 'Points'),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.material = Array.isArray(t.material)
        ? t.material.slice()
        : t.material),
      (this.geometry = t.geometry),
      this
    )
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      a = t.params.Points.threshold,
      o = n.drawRange
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      hg.copy(n.boundingSphere),
      hg.applyMatrix4(i),
      (hg.radius += a),
      t.ray.intersectsSphere(hg) === !1)
    )
      return
    sD.copy(i).invert(), ZA.copy(t.ray).applyMatrix4(sD)
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = s * s,
      u = n.index,
      h = n.attributes.position
    if (u !== null) {
      const f = Math.max(0, o.start),
        d = Math.min(u.count, o.start + o.count)
      for (let p = f, g = d; p < g; p++) {
        const v = u.getX(p)
        fg.fromBufferAttribute(h, v), lD(fg, v, l, i, t, e, this)
      }
    } else {
      const f = Math.max(0, o.start),
        d = Math.min(h.count, o.start + o.count)
      for (let p = f, g = d; p < g; p++)
        fg.fromBufferAttribute(h, p), lD(fg, p, l, i, t, e, this)
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      n = Object.keys(e)
    if (n.length > 0) {
      const i = e[n[0]]
      if (i !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[s] = a)
        }
      }
    }
  }
}
function lD(r, t, e, n, i, a, o) {
  const s = ZA.distanceSqToPoint(r)
  if (s < e) {
    const l = new U()
    ZA.closestPointToPoint(r, l), l.applyMatrix4(n)
    const u = i.ray.origin.distanceTo(l)
    if (u < i.near || u > i.far) return
    a.push({
      distance: u,
      distanceToRay: Math.sqrt(s),
      point: l,
      index: t,
      face: null,
      object: o,
    })
  }
}
class go {
  constructor() {
    ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn('THREE.Curve: .getPoint() not implemented.'), null
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getPoint(n, e)
  }
  getPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return e
  }
  getSpacedPoints(t = 5) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t))
    return e
  }
  getLength() {
    const t = this.getLengths()
    return t[t.length - 1]
  }
  getLengths(t = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === t + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths
    this.needsUpdate = !1
    const e = []
    let n,
      i = this.getPoint(0),
      a = 0
    e.push(0)
    for (let o = 1; o <= t; o++)
      (n = this.getPoint(o / t)), (a += n.distanceTo(i)), e.push(a), (i = n)
    return (this.cacheArcLengths = e), e
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(t, e) {
    const n = this.getLengths()
    let i = 0
    const a = n.length
    let o
    e ? (o = e) : (o = t * n[a - 1])
    let s = 0,
      l = a - 1,
      u
    for (; s <= l; )
      if (((i = Math.floor(s + (l - s) / 2)), (u = n[i] - o), u < 0)) s = i + 1
      else if (u > 0) l = i - 1
      else {
        l = i
        break
      }
    if (((i = l), n[i] === o)) return i / (a - 1)
    const c = n[i],
      f = n[i + 1] - c,
      d = (o - c) / f
    return (i + d) / (a - 1)
  }
  getTangent(t, e) {
    let i = t - 1e-4,
      a = t + 1e-4
    i < 0 && (i = 0), a > 1 && (a = 1)
    const o = this.getPoint(i),
      s = this.getPoint(a),
      l = e || (o.isVector2 ? new pt() : new U())
    return l.copy(s).sub(o).normalize(), l
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t)
    return this.getTangent(n, e)
  }
  computeFrenetFrames(t, e) {
    const n = new U(),
      i = [],
      a = [],
      o = [],
      s = new U(),
      l = new ae()
    for (let d = 0; d <= t; d++) {
      const p = d / t
      i[d] = this.getTangentAt(p, new U())
    }
    ;(a[0] = new U()), (o[0] = new U())
    let u = Number.MAX_VALUE
    const c = Math.abs(i[0].x),
      h = Math.abs(i[0].y),
      f = Math.abs(i[0].z)
    c <= u && ((u = c), n.set(1, 0, 0)),
      h <= u && ((u = h), n.set(0, 1, 0)),
      f <= u && n.set(0, 0, 1),
      s.crossVectors(i[0], n).normalize(),
      a[0].crossVectors(i[0], s),
      o[0].crossVectors(i[0], a[0])
    for (let d = 1; d <= t; d++) {
      if (
        ((a[d] = a[d - 1].clone()),
        (o[d] = o[d - 1].clone()),
        s.crossVectors(i[d - 1], i[d]),
        s.length() > Number.EPSILON)
      ) {
        s.normalize()
        const p = Math.acos(zn(i[d - 1].dot(i[d]), -1, 1))
        a[d].applyMatrix4(l.makeRotationAxis(s, p))
      }
      o[d].crossVectors(i[d], a[d])
    }
    if (e === !0) {
      let d = Math.acos(zn(a[0].dot(a[t]), -1, 1))
      ;(d /= t), i[0].dot(s.crossVectors(a[0], a[t])) > 0 && (d = -d)
      for (let p = 1; p <= t; p++)
        a[p].applyMatrix4(l.makeRotationAxis(i[p], d * p)),
          o[p].crossVectors(i[p], a[p])
    }
    return {
      tangents: i,
      normals: a,
      binormals: o,
    }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: 'Curve',
        generator: 'Curve.toJSON',
      },
    }
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    )
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this
  }
}
class WM extends go {
  constructor(
    t = 0,
    e = 0,
    n = 1,
    i = 1,
    a = 0,
    o = Math.PI * 2,
    s = !1,
    l = 0,
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = 'EllipseCurve'),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = a),
      (this.aEndAngle = o),
      (this.aClockwise = s),
      (this.aRotation = l)
  }
  getPoint(t, e = new pt()) {
    const n = e,
      i = Math.PI * 2
    let a = this.aEndAngle - this.aStartAngle
    const o = Math.abs(a) < Number.EPSILON
    for (; a < 0; ) a += i
    for (; a > i; ) a -= i
    a < Number.EPSILON && (o ? (a = 0) : (a = i)),
      this.aClockwise === !0 && !o && (a === i ? (a = -i) : (a = a - i))
    const s = this.aStartAngle + t * a
    let l = this.aX + this.xRadius * Math.cos(s),
      u = this.aY + this.yRadius * Math.sin(s)
    if (this.aRotation !== 0) {
      const c = Math.cos(this.aRotation),
        h = Math.sin(this.aRotation),
        f = l - this.aX,
        d = u - this.aY
      ;(l = f * c - d * h + this.aX), (u = f * h + d * c + this.aY)
    }
    return n.set(l, u)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    )
  }
}
class YY extends WM {
  constructor(t, e, n, i, a, o) {
    super(t, e, n, n, i, a, o), (this.isArcCurve = !0), (this.type = 'ArcCurve')
  }
}
function XM() {
  let r = 0,
    t = 0,
    e = 0,
    n = 0
  function i(a, o, s, l) {
    ;(r = a),
      (t = s),
      (e = -3 * a + 3 * o - 2 * s - l),
      (n = 2 * a - 2 * o + s + l)
  }
  return {
    initCatmullRom: function (a, o, s, l, u) {
      i(o, s, u * (s - a), u * (l - o))
    },
    initNonuniformCatmullRom: function (a, o, s, l, u, c, h) {
      let f = (o - a) / u - (s - a) / (u + c) + (s - o) / c,
        d = (s - o) / c - (l - o) / (c + h) + (l - s) / h
      ;(f *= c), (d *= c), i(o, s, f, d)
    },
    calc: function (a) {
      const o = a * a,
        s = o * a
      return r + t * a + e * o + n * s
    },
  }
}
const dg = new U(),
  fx = new XM(),
  dx = new XM(),
  px = new XM()
class _B extends go {
  constructor(t = [], e = !1, n = 'centripetal', i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t),
      (this.closed = e),
      (this.curveType = n),
      (this.tension = i)
  }
  getPoint(t, e = new U()) {
    const n = e,
      i = this.points,
      a = i.length,
      o = (a - (this.closed ? 0 : 1)) * t
    let s = Math.floor(o),
      l = o - s
    this.closed
      ? (s += s > 0 ? 0 : (Math.floor(Math.abs(s) / a) + 1) * a)
      : l === 0 && s === a - 1 && ((s = a - 2), (l = 1))
    let u, c
    this.closed || s > 0
      ? (u = i[(s - 1) % a])
      : (dg.subVectors(i[0], i[1]).add(i[0]), (u = dg))
    const h = i[s % a],
      f = i[(s + 1) % a]
    if (
      (this.closed || s + 2 < a
        ? (c = i[(s + 2) % a])
        : (dg.subVectors(i[a - 1], i[a - 2]).add(i[a - 1]), (c = dg)),
      this.curveType === 'centripetal' || this.curveType === 'chordal')
    ) {
      const d = this.curveType === 'chordal' ? 0.5 : 0.25
      let p = Math.pow(u.distanceToSquared(h), d),
        g = Math.pow(h.distanceToSquared(f), d),
        v = Math.pow(f.distanceToSquared(c), d)
      g < 1e-4 && (g = 1),
        p < 1e-4 && (p = g),
        v < 1e-4 && (v = g),
        fx.initNonuniformCatmullRom(u.x, h.x, f.x, c.x, p, g, v),
        dx.initNonuniformCatmullRom(u.y, h.y, f.y, c.y, p, g, v),
        px.initNonuniformCatmullRom(u.z, h.z, f.z, c.z, p, g, v)
    } else
      this.curveType === 'catmullrom' &&
        (fx.initCatmullRom(u.x, h.x, f.x, c.x, this.tension),
        dx.initCatmullRom(u.y, h.y, f.y, c.y, this.tension),
        px.initCatmullRom(u.z, h.z, f.z, c.z, this.tension))
    return n.set(fx.calc(l), dx.calc(l), px.calc(l)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e]
      this.points.push(i.clone())
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const i = this.points[e]
      t.points.push(i.toArray())
    }
    return (
      (t.closed = this.closed),
      (t.curveType = this.curveType),
      (t.tension = this.tension),
      t
    )
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e]
      this.points.push(new U().fromArray(i))
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    )
  }
}
function uD(r, t, e, n, i) {
  const a = (n - t) * 0.5,
    o = (i - e) * 0.5,
    s = r * r,
    l = r * s
  return (
    (2 * e - 2 * n + a + o) * l + (-3 * e + 3 * n - 2 * a - o) * s + a * r + e
  )
}
function $Y(r, t) {
  const e = 1 - r
  return e * e * t
}
function qY(r, t) {
  return 2 * (1 - r) * r * t
}
function ZY(r, t) {
  return r * r * t
}
function qd(r, t, e, n) {
  return $Y(r, t) + qY(r, e) + ZY(r, n)
}
function KY(r, t) {
  const e = 1 - r
  return e * e * e * t
}
function jY(r, t) {
  const e = 1 - r
  return 3 * e * e * r * t
}
function JY(r, t) {
  return 3 * (1 - r) * r * r * t
}
function QY(r, t) {
  return r * r * r * t
}
function Zd(r, t, e, n, i) {
  return KY(r, t) + jY(r, e) + JY(r, n) + QY(r, i)
}
class xB extends go {
  constructor(t = new pt(), e = new pt(), n = new pt(), i = new pt()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new pt()) {
    const n = e,
      i = this.v0,
      a = this.v1,
      o = this.v2,
      s = this.v3
    return n.set(Zd(t, i.x, a.x, o.x, s.x), Zd(t, i.y, a.y, o.y, s.y)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
class t$ extends go {
  constructor(t = new U(), e = new U(), n = new U(), i = new U()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i)
  }
  getPoint(t, e = new U()) {
    const n = e,
      i = this.v0,
      a = this.v1,
      o = this.v2,
      s = this.v3
    return (
      n.set(
        Zd(t, i.x, a.x, o.x, s.x),
        Zd(t, i.y, a.y, o.y, s.y),
        Zd(t, i.z, a.z, o.z, s.z),
      ),
      n
    )
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    )
  }
}
class SB extends go {
  constructor(t = new pt(), e = new pt()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = 'LineCurve'),
      (this.v1 = t),
      (this.v2 = e)
  }
  getPoint(t, e = new pt()) {
    const n = e
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    )
  }
  getPointAt(t, e) {
    return this.getPoint(t, e)
  }
  getTangent(t, e = new pt()) {
    return e.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e)
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    )
  }
}
class e$ extends go {
  constructor(t = new U(), e = new U()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = 'LineCurve3'),
      (this.v1 = t),
      (this.v2 = e)
  }
  getPoint(t, e = new U()) {
    const n = e
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    )
  }
  getPointAt(t, e) {
    return this.getPoint(t, e)
  }
  getTangent(t, e = new U()) {
    return e.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(t, e) {
    return this.getTangent(t, e)
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    )
  }
}
class AB extends go {
  constructor(t = new pt(), e = new pt(), n = new pt()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n)
  }
  getPoint(t, e = new pt()) {
    const n = e,
      i = this.v0,
      a = this.v1,
      o = this.v2
    return n.set(qd(t, i.x, a.x, o.x), qd(t, i.y, a.y, o.y)), n
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
class YM extends go {
  constructor(t = new U(), e = new U(), n = new U()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n)
  }
  getPoint(t, e = new U()) {
    const n = e,
      i = this.v0,
      a = this.v1,
      o = this.v2
    return (
      n.set(qd(t, i.x, a.x, o.x), qd(t, i.y, a.y, o.y), qd(t, i.z, a.z, o.z)), n
    )
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    )
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    )
  }
}
class bB extends go {
  constructor(t = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = 'SplineCurve'),
      (this.points = t)
  }
  getPoint(t, e = new pt()) {
    const n = e,
      i = this.points,
      a = (i.length - 1) * t,
      o = Math.floor(a),
      s = a - o,
      l = i[o === 0 ? o : o - 1],
      u = i[o],
      c = i[o > i.length - 2 ? i.length - 1 : o + 1],
      h = i[o > i.length - 3 ? i.length - 1 : o + 2]
    return n.set(uD(s, l.x, u.x, c.x, h.x), uD(s, l.y, u.y, c.y, h.y)), n
  }
  copy(t) {
    super.copy(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e]
      this.points.push(i.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    t.points = []
    for (let e = 0, n = this.points.length; e < n; e++) {
      const i = this.points[e]
      t.points.push(i.toArray())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = [])
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e]
      this.points.push(new pt().fromArray(i))
    }
    return this
  }
}
var Sy = Object.freeze({
  __proto__: null,
  ArcCurve: YY,
  CatmullRomCurve3: _B,
  CubicBezierCurve: xB,
  CubicBezierCurve3: t$,
  EllipseCurve: WM,
  LineCurve: SB,
  LineCurve3: e$,
  QuadraticBezierCurve: AB,
  QuadraticBezierCurve3: YM,
  SplineCurve: bB,
})
class n$ extends go {
  constructor() {
    super(),
      (this.type = 'CurvePath'),
      (this.curves = []),
      (this.autoClose = !1)
  }
  add(t) {
    this.curves.push(t)
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1)
    if (!t.equals(e)) {
      const n = t.isVector2 === !0 ? 'LineCurve' : 'LineCurve3'
      this.curves.push(new Sy[n](e, t))
    }
    return this
  }
  getPoint(t, e) {
    const n = t * this.getLength(),
      i = this.getCurveLengths()
    let a = 0
    for (; a < i.length; ) {
      if (i[a] >= n) {
        const o = i[a] - n,
          s = this.curves[a],
          l = s.getLength(),
          u = l === 0 ? 0 : 1 - o / l
        return s.getPointAt(u, e)
      }
      a++
    }
    return null
  }
  getLength() {
    const t = this.getCurveLengths()
    return t[t.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const t = []
    let e = 0
    for (let n = 0, i = this.curves.length; n < i; n++)
      (e += this.curves[n].getLength()), t.push(e)
    return (this.cacheLengths = t), t
  }
  getSpacedPoints(t = 40) {
    const e = []
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t))
    return this.autoClose && e.push(e[0]), e
  }
  getPoints(t = 12) {
    const e = []
    let n
    for (let i = 0, a = this.curves; i < a.length; i++) {
      const o = a[i],
        s = o.isEllipseCurve
          ? t * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? t * o.points.length
          : t,
        l = o.getPoints(s)
      for (let u = 0; u < l.length; u++) {
        const c = l[u]
        ;(n && n.equals(c)) || (e.push(c), (n = c))
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    )
  }
  copy(t) {
    super.copy(t), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e]
      this.curves.push(i.clone())
    }
    return (this.autoClose = t.autoClose), this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.autoClose = this.autoClose), (t.curves = [])
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const i = this.curves[e]
      t.curves.push(i.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = [])
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e]
      this.curves.push(new Sy[i.type]().fromJSON(i))
    }
    return this
  }
}
let cD = class extends n$ {
  constructor(t) {
    super(),
      (this.type = 'Path'),
      (this.currentPoint = new pt()),
      t && this.setFromPoints(t)
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y)
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
    return this
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this
  }
  lineTo(t, e) {
    const n = new SB(this.currentPoint.clone(), new pt(t, e))
    return this.curves.push(n), this.currentPoint.set(t, e), this
  }
  quadraticCurveTo(t, e, n, i) {
    const a = new AB(this.currentPoint.clone(), new pt(t, e), new pt(n, i))
    return this.curves.push(a), this.currentPoint.set(n, i), this
  }
  bezierCurveTo(t, e, n, i, a, o) {
    const s = new xB(
      this.currentPoint.clone(),
      new pt(t, e),
      new pt(n, i),
      new pt(a, o),
    )
    return this.curves.push(s), this.currentPoint.set(a, o), this
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new bB(e)
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
  }
  arc(t, e, n, i, a, o) {
    const s = this.currentPoint.x,
      l = this.currentPoint.y
    return this.absarc(t + s, e + l, n, i, a, o), this
  }
  absarc(t, e, n, i, a, o) {
    return this.absellipse(t, e, n, n, i, a, o), this
  }
  ellipse(t, e, n, i, a, o, s, l) {
    const u = this.currentPoint.x,
      c = this.currentPoint.y
    return this.absellipse(t + u, e + c, n, i, a, o, s, l), this
  }
  absellipse(t, e, n, i, a, o, s, l) {
    const u = new WM(t, e, n, i, a, o, s, l)
    if (this.curves.length > 0) {
      const h = u.getPoint(0)
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
    }
    this.curves.push(u)
    const c = u.getPoint(1)
    return this.currentPoint.copy(c), this
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
  }
  toJSON() {
    const t = super.toJSON()
    return (t.currentPoint = this.currentPoint.toArray()), t
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
  }
}
class $M extends Mn {
  constructor(
    t = 1,
    e = 1,
    n = 1,
    i = 32,
    a = 1,
    o = !1,
    s = 0,
    l = Math.PI * 2,
  ) {
    super(),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: a,
        openEnded: o,
        thetaStart: s,
        thetaLength: l,
      })
    const u = this
    ;(i = Math.floor(i)), (a = Math.floor(a))
    const c = [],
      h = [],
      f = [],
      d = []
    let p = 0
    const g = [],
      v = n / 2
    let m = 0
    y(),
      o === !1 && (t > 0 && _(!0), e > 0 && _(!1)),
      this.setIndex(c),
      this.setAttribute('position', new nn(h, 3)),
      this.setAttribute('normal', new nn(f, 3)),
      this.setAttribute('uv', new nn(d, 2))
    function y() {
      const x = new U(),
        A = new U()
      let S = 0
      const b = (e - t) / n
      for (let T = 0; T <= a; T++) {
        const w = [],
          M = T / a,
          C = M * (e - t) + t
        for (let E = 0; E <= i; E++) {
          const D = E / i,
            P = D * l + s,
            L = Math.sin(P),
            I = Math.cos(P)
          ;(A.x = C * L),
            (A.y = -M * n + v),
            (A.z = C * I),
            h.push(A.x, A.y, A.z),
            x.set(L, b, I).normalize(),
            f.push(x.x, x.y, x.z),
            d.push(D, 1 - M),
            w.push(p++)
        }
        g.push(w)
      }
      for (let T = 0; T < i; T++)
        for (let w = 0; w < a; w++) {
          const M = g[w][T],
            C = g[w + 1][T],
            E = g[w + 1][T + 1],
            D = g[w][T + 1]
          c.push(M, C, D), c.push(C, E, D), (S += 6)
        }
      u.addGroup(m, S, 0), (m += S)
    }
    function _(x) {
      const A = p,
        S = new pt(),
        b = new U()
      let T = 0
      const w = x === !0 ? t : e,
        M = x === !0 ? 1 : -1
      for (let E = 1; E <= i; E++)
        h.push(0, v * M, 0), f.push(0, M, 0), d.push(0.5, 0.5), p++
      const C = p
      for (let E = 0; E <= i; E++) {
        const P = (E / i) * l + s,
          L = Math.cos(P),
          I = Math.sin(P)
        ;(b.x = w * I),
          (b.y = v * M),
          (b.z = w * L),
          h.push(b.x, b.y, b.z),
          f.push(0, M, 0),
          (S.x = L * 0.5 + 0.5),
          (S.y = I * 0.5 * M + 0.5),
          d.push(S.x, S.y),
          p++
      }
      for (let E = 0; E < i; E++) {
        const D = A + E,
          P = C + E
        x === !0 ? c.push(P, P + 1, D) : c.push(P + 1, P, D), (T += 3)
      }
      u.addGroup(m, T, x === !0 ? 1 : 2), (m += T)
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  static fromJSON(t) {
    return new $M(
      t.radiusTop,
      t.radiusBottom,
      t.height,
      t.radialSegments,
      t.heightSegments,
      t.openEnded,
      t.thetaStart,
      t.thetaLength,
    )
  }
}
class wu extends cD {
  constructor(t) {
    super(t), (this.uuid = Ki()), (this.type = 'Shape'), (this.holes = [])
  }
  getPointsHoles(t) {
    const e = []
    for (let n = 0, i = this.holes.length; n < i; n++)
      e[n] = this.holes[n].getPoints(t)
    return e
  }
  extractPoints(t) {
    return {
      shape: this.getPoints(t),
      holes: this.getPointsHoles(t),
    }
  }
  copy(t) {
    super.copy(t), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e]
      this.holes.push(i.clone())
    }
    return this
  }
  toJSON() {
    const t = super.toJSON()
    ;(t.uuid = this.uuid), (t.holes = [])
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const i = this.holes[e]
      t.holes.push(i.toJSON())
    }
    return t
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = [])
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e]
      this.holes.push(new cD().fromJSON(i))
    }
    return this
  }
}
const r$ = {
  triangulate: function (r, t, e = 2) {
    const n = t && t.length,
      i = n ? t[0] * e : r.length
    let a = wB(r, 0, i, e, !0)
    const o = []
    if (!a || a.next === a.prev) return o
    let s, l, u, c, h, f, d
    if ((n && (a = l$(r, t, a, e)), r.length > 80 * e)) {
      ;(s = u = r[0]), (l = c = r[1])
      for (let p = e; p < i; p += e)
        (h = r[p]),
          (f = r[p + 1]),
          h < s && (s = h),
          f < l && (l = f),
          h > u && (u = h),
          f > c && (c = f)
      ;(d = Math.max(u - s, c - l)), (d = d !== 0 ? 32767 / d : 0)
    }
    return xp(a, o, e, s, l, d, 0), o
  },
}
function wB(r, t, e, n, i) {
  let a, o
  if (i === _$(r, t, e, n) > 0)
    for (a = t; a < e; a += n) o = hD(a, r[a], r[a + 1], o)
  else for (a = e - n; a >= t; a -= n) o = hD(a, r[a], r[a + 1], o)
  return o && k0(o, o.next) && (Ap(o), (o = o.next)), o
}
function Gu(r, t) {
  if (!r) return r
  t || (t = r)
  let e = r,
    n
  do
    if (
      ((n = !1), !e.steiner && (k0(e, e.next) || vn(e.prev, e, e.next) === 0))
    ) {
      if ((Ap(e), (e = t = e.prev), e === e.next)) break
      n = !0
    } else e = e.next
  while (n || e !== t)
  return t
}
function xp(r, t, e, n, i, a, o) {
  if (!r) return
  !o && a && d$(r, n, i, a)
  let s = r,
    l,
    u
  for (; r.prev !== r.next; ) {
    if (((l = r.prev), (u = r.next), a ? a$(r, n, i, a) : i$(r))) {
      t.push((l.i / e) | 0),
        t.push((r.i / e) | 0),
        t.push((u.i / e) | 0),
        Ap(r),
        (r = u.next),
        (s = u.next)
      continue
    }
    if (((r = u), r === s)) {
      o
        ? o === 1
          ? ((r = o$(Gu(r), t, e)), xp(r, t, e, n, i, a, 2))
          : o === 2 && s$(r, t, e, n, i, a)
        : xp(Gu(r), t, e, n, i, a, 1)
      break
    }
  }
}
function i$(r) {
  const t = r.prev,
    e = r,
    n = r.next
  if (vn(t, e, n) >= 0) return !1
  const i = t.x,
    a = e.x,
    o = n.x,
    s = t.y,
    l = e.y,
    u = n.y,
    c = i < a ? (i < o ? i : o) : a < o ? a : o,
    h = s < l ? (s < u ? s : u) : l < u ? l : u,
    f = i > a ? (i > o ? i : o) : a > o ? a : o,
    d = s > l ? (s > u ? s : u) : l > u ? l : u
  let p = n.next
  for (; p !== t; ) {
    if (
      p.x >= c &&
      p.x <= f &&
      p.y >= h &&
      p.y <= d &&
      vh(i, s, a, l, o, u, p.x, p.y) &&
      vn(p.prev, p, p.next) >= 0
    )
      return !1
    p = p.next
  }
  return !0
}
function a$(r, t, e, n) {
  const i = r.prev,
    a = r,
    o = r.next
  if (vn(i, a, o) >= 0) return !1
  const s = i.x,
    l = a.x,
    u = o.x,
    c = i.y,
    h = a.y,
    f = o.y,
    d = s < l ? (s < u ? s : u) : l < u ? l : u,
    p = c < h ? (c < f ? c : f) : h < f ? h : f,
    g = s > l ? (s > u ? s : u) : l > u ? l : u,
    v = c > h ? (c > f ? c : f) : h > f ? h : f,
    m = KA(d, p, t, e, n),
    y = KA(g, v, t, e, n)
  let _ = r.prevZ,
    x = r.nextZ
  for (; _ && _.z >= m && x && x.z <= y; ) {
    if (
      (_.x >= d &&
        _.x <= g &&
        _.y >= p &&
        _.y <= v &&
        _ !== i &&
        _ !== o &&
        vh(s, c, l, h, u, f, _.x, _.y) &&
        vn(_.prev, _, _.next) >= 0) ||
      ((_ = _.prevZ),
      x.x >= d &&
        x.x <= g &&
        x.y >= p &&
        x.y <= v &&
        x !== i &&
        x !== o &&
        vh(s, c, l, h, u, f, x.x, x.y) &&
        vn(x.prev, x, x.next) >= 0)
    )
      return !1
    x = x.nextZ
  }
  for (; _ && _.z >= m; ) {
    if (
      _.x >= d &&
      _.x <= g &&
      _.y >= p &&
      _.y <= v &&
      _ !== i &&
      _ !== o &&
      vh(s, c, l, h, u, f, _.x, _.y) &&
      vn(_.prev, _, _.next) >= 0
    )
      return !1
    _ = _.prevZ
  }
  for (; x && x.z <= y; ) {
    if (
      x.x >= d &&
      x.x <= g &&
      x.y >= p &&
      x.y <= v &&
      x !== i &&
      x !== o &&
      vh(s, c, l, h, u, f, x.x, x.y) &&
      vn(x.prev, x, x.next) >= 0
    )
      return !1
    x = x.nextZ
  }
  return !0
}
function o$(r, t, e) {
  let n = r
  do {
    const i = n.prev,
      a = n.next.next
    !k0(i, a) &&
      MB(i, n, n.next, a) &&
      Sp(i, a) &&
      Sp(a, i) &&
      (t.push((i.i / e) | 0),
      t.push((n.i / e) | 0),
      t.push((a.i / e) | 0),
      Ap(n),
      Ap(n.next),
      (n = r = a)),
      (n = n.next)
  } while (n !== r)
  return Gu(n)
}
function s$(r, t, e, n, i, a) {
  let o = r
  do {
    let s = o.next.next
    for (; s !== o.prev; ) {
      if (o.i !== s.i && g$(o, s)) {
        let l = TB(o, s)
        ;(o = Gu(o, o.next)),
          (l = Gu(l, l.next)),
          xp(o, t, e, n, i, a, 0),
          xp(l, t, e, n, i, a, 0)
        return
      }
      s = s.next
    }
    o = o.next
  } while (o !== r)
}
function l$(r, t, e, n) {
  const i = []
  let a, o, s, l, u
  for (a = 0, o = t.length; a < o; a++)
    (s = t[a] * n),
      (l = a < o - 1 ? t[a + 1] * n : r.length),
      (u = wB(r, s, l, n, !1)),
      u === u.next && (u.steiner = !0),
      i.push(v$(u))
  for (i.sort(u$), a = 0; a < i.length; a++) e = c$(i[a], e)
  return e
}
function u$(r, t) {
  return r.x - t.x
}
function c$(r, t) {
  const e = h$(r, t)
  if (!e) return t
  const n = TB(e, r)
  return Gu(n, n.next), Gu(e, e.next)
}
function h$(r, t) {
  let e = t,
    n = -1 / 0,
    i
  const a = r.x,
    o = r.y
  do {
    if (o <= e.y && o >= e.next.y && e.next.y !== e.y) {
      const f = e.x + ((o - e.y) * (e.next.x - e.x)) / (e.next.y - e.y)
      if (
        f <= a &&
        f > n &&
        ((n = f), (i = e.x < e.next.x ? e : e.next), f === a)
      )
        return i
    }
    e = e.next
  } while (e !== t)
  if (!i) return null
  const s = i,
    l = i.x,
    u = i.y
  let c = 1 / 0,
    h
  e = i
  do
    a >= e.x &&
      e.x >= l &&
      a !== e.x &&
      vh(o < u ? a : n, o, l, u, o < u ? n : a, o, e.x, e.y) &&
      ((h = Math.abs(o - e.y) / (a - e.x)),
      Sp(e, r) &&
        (h < c || (h === c && (e.x > i.x || (e.x === i.x && f$(i, e))))) &&
        ((i = e), (c = h))),
      (e = e.next)
  while (e !== s)
  return i
}
function f$(r, t) {
  return vn(r.prev, r, t.prev) < 0 && vn(t.next, r, r.next) < 0
}
function d$(r, t, e, n) {
  let i = r
  do
    i.z === 0 && (i.z = KA(i.x, i.y, t, e, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next)
  while (i !== r)
  ;(i.prevZ.nextZ = null), (i.prevZ = null), p$(i)
}
function p$(r) {
  let t,
    e,
    n,
    i,
    a,
    o,
    s,
    l,
    u = 1
  do {
    for (e = r, r = null, a = null, o = 0; e; ) {
      for (o++, n = e, s = 0, t = 0; t < u && (s++, (n = n.nextZ), !!n); t++);
      for (l = u; s > 0 || (l > 0 && n); )
        s !== 0 && (l === 0 || !n || e.z <= n.z)
          ? ((i = e), (e = e.nextZ), s--)
          : ((i = n), (n = n.nextZ), l--),
          a ? (a.nextZ = i) : (r = i),
          (i.prevZ = a),
          (a = i)
      e = n
    }
    ;(a.nextZ = null), (u *= 2)
  } while (o > 1)
  return r
}
function KA(r, t, e, n, i) {
  return (
    (r = ((r - e) * i) | 0),
    (t = ((t - n) * i) | 0),
    (r = (r | (r << 8)) & 16711935),
    (r = (r | (r << 4)) & 252645135),
    (r = (r | (r << 2)) & 858993459),
    (r = (r | (r << 1)) & 1431655765),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    r | (t << 1)
  )
}
function v$(r) {
  let t = r,
    e = r
  do (t.x < e.x || (t.x === e.x && t.y < e.y)) && (e = t), (t = t.next)
  while (t !== r)
  return e
}
function vh(r, t, e, n, i, a, o, s) {
  return (
    (i - o) * (t - s) >= (r - o) * (a - s) &&
    (r - o) * (n - s) >= (e - o) * (t - s) &&
    (e - o) * (a - s) >= (i - o) * (n - s)
  )
}
function g$(r, t) {
  return (
    r.next.i !== t.i &&
    r.prev.i !== t.i &&
    !m$(r, t) &&
    ((Sp(r, t) &&
      Sp(t, r) &&
      y$(r, t) &&
      (vn(r.prev, r, t.prev) || vn(r, t.prev, t))) ||
      (k0(r, t) && vn(r.prev, r, r.next) > 0 && vn(t.prev, t, t.next) > 0))
  )
}
function vn(r, t, e) {
  return (t.y - r.y) * (e.x - t.x) - (t.x - r.x) * (e.y - t.y)
}
function k0(r, t) {
  return r.x === t.x && r.y === t.y
}
function MB(r, t, e, n) {
  const i = vg(vn(r, t, e)),
    a = vg(vn(r, t, n)),
    o = vg(vn(e, n, r)),
    s = vg(vn(e, n, t))
  return !!(
    (i !== a && o !== s) ||
    (i === 0 && pg(r, e, t)) ||
    (a === 0 && pg(r, n, t)) ||
    (o === 0 && pg(e, r, n)) ||
    (s === 0 && pg(e, t, n))
  )
}
function pg(r, t, e) {
  return (
    t.x <= Math.max(r.x, e.x) &&
    t.x >= Math.min(r.x, e.x) &&
    t.y <= Math.max(r.y, e.y) &&
    t.y >= Math.min(r.y, e.y)
  )
}
function vg(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0
}
function m$(r, t) {
  let e = r
  do {
    if (
      e.i !== r.i &&
      e.next.i !== r.i &&
      e.i !== t.i &&
      e.next.i !== t.i &&
      MB(e, e.next, r, t)
    )
      return !0
    e = e.next
  } while (e !== r)
  return !1
}
function Sp(r, t) {
  return vn(r.prev, r, r.next) < 0
    ? vn(r, t, r.next) >= 0 && vn(r, r.prev, t) >= 0
    : vn(r, t, r.prev) < 0 || vn(r, r.next, t) < 0
}
function y$(r, t) {
  let e = r,
    n = !1
  const i = (r.x + t.x) / 2,
    a = (r.y + t.y) / 2
  do
    e.y > a != e.next.y > a &&
      e.next.y !== e.y &&
      i < ((e.next.x - e.x) * (a - e.y)) / (e.next.y - e.y) + e.x &&
      (n = !n),
      (e = e.next)
  while (e !== r)
  return n
}
function TB(r, t) {
  const e = new jA(r.i, r.x, r.y),
    n = new jA(t.i, t.x, t.y),
    i = r.next,
    a = t.prev
  return (
    (r.next = t),
    (t.prev = r),
    (e.next = i),
    (i.prev = e),
    (n.next = e),
    (e.prev = n),
    (a.next = n),
    (n.prev = a),
    n
  )
}
function hD(r, t, e, n) {
  const i = new jA(r, t, e)
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  )
}
function Ap(r) {
  ;(r.next.prev = r.prev),
    (r.prev.next = r.next),
    r.prevZ && (r.prevZ.nextZ = r.nextZ),
    r.nextZ && (r.nextZ.prevZ = r.prevZ)
}
function jA(r, t, e) {
  ;(this.i = r),
    (this.x = t),
    (this.y = e),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
function _$(r, t, e, n) {
  let i = 0
  for (let a = t, o = e - n; a < e; a += n)
    (i += (r[o] - r[a]) * (r[a + 1] + r[o + 1])), (o = a)
  return i
}
class $s {
  static area(t) {
    const e = t.length
    let n = 0
    for (let i = e - 1, a = 0; a < e; i = a++)
      n += t[i].x * t[a].y - t[a].x * t[i].y
    return n * 0.5
  }
  static isClockWise(t) {
    return $s.area(t) < 0
  }
  static triangulateShape(t, e) {
    const n = [],
      i = [],
      a = []
    fD(t), dD(n, t)
    let o = t.length
    e.forEach(fD)
    for (let l = 0; l < e.length; l++)
      i.push(o), (o += e[l].length), dD(n, e[l])
    const s = r$.triangulate(n, i)
    for (let l = 0; l < s.length; l += 3) a.push(s.slice(l, l + 3))
    return a
  }
}
function fD(r) {
  const t = r.length
  t > 2 && r[t - 1].equals(r[0]) && r.pop()
}
function dD(r, t) {
  for (let e = 0; e < t.length; e++) r.push(t[e].x), r.push(t[e].y)
}
class B0 extends Mn {
  constructor(
    t = new wu([
      new pt(0.5, 0.5),
      new pt(-0.5, 0.5),
      new pt(-0.5, -0.5),
      new pt(0.5, -0.5),
    ]),
    e = {},
  ) {
    super(),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = {
        shapes: t,
        options: e,
      }),
      (t = Array.isArray(t) ? t : [t])
    const n = this,
      i = [],
      a = []
    for (let s = 0, l = t.length; s < l; s++) {
      const u = t[s]
      o(u)
    }
    this.setAttribute('position', new nn(i, 3)),
      this.setAttribute('uv', new nn(a, 2)),
      this.computeVertexNormals()
    function o(s) {
      const l = [],
        u = e.curveSegments !== void 0 ? e.curveSegments : 12,
        c = e.steps !== void 0 ? e.steps : 1,
        h = e.depth !== void 0 ? e.depth : 1
      let f = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
        d = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2,
        p = e.bevelSize !== void 0 ? e.bevelSize : d - 0.1,
        g = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
        v = e.bevelSegments !== void 0 ? e.bevelSegments : 3
      const m = e.extrudePath,
        y = e.UVGenerator !== void 0 ? e.UVGenerator : x$
      let _,
        x = !1,
        A,
        S,
        b,
        T
      m &&
        ((_ = m.getSpacedPoints(c)),
        (x = !0),
        (f = !1),
        (A = m.computeFrenetFrames(c, !1)),
        (S = new U()),
        (b = new U()),
        (T = new U())),
        f || ((v = 0), (d = 0), (p = 0), (g = 0))
      const w = s.extractPoints(u)
      let M = w.shape
      const C = w.holes
      if (!$s.isClockWise(M)) {
        M = M.reverse()
        for (let B = 0, ht = C.length; B < ht; B++) {
          const it = C[B]
          $s.isClockWise(it) && (C[B] = it.reverse())
        }
      }
      const D = $s.triangulateShape(M, C),
        P = M
      for (let B = 0, ht = C.length; B < ht; B++) {
        const it = C[B]
        M = M.concat(it)
      }
      function L(B, ht, it) {
        return (
          ht || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          B.clone().addScaledVector(ht, it)
        )
      }
      const I = M.length,
        F = D.length
      function k(B, ht, it) {
        let xt, rt, kt
        const Ct = B.x - ht.x,
          Lt = B.y - ht.y,
          G = it.x - B.x,
          N = it.y - B.y,
          J = Ct * Ct + Lt * Lt,
          vt = Ct * N - Lt * G
        if (Math.abs(vt) > Number.EPSILON) {
          const yt = Math.sqrt(J),
            mt = Math.sqrt(G * G + N * N),
            Kt = ht.x - Lt / yt,
            It = ht.y + Ct / yt,
            Bt = it.x - N / mt,
            fe = it.y + G / mt,
            Mt = ((Bt - Kt) * N - (fe - It) * G) / (Ct * N - Lt * G)
          ;(xt = Kt + Ct * Mt - B.x), (rt = It + Lt * Mt - B.y)
          const Ot = xt * xt + rt * rt
          if (Ot <= 2) return new pt(xt, rt)
          kt = Math.sqrt(Ot / 2)
        } else {
          let yt = !1
          Ct > Number.EPSILON
            ? G > Number.EPSILON && (yt = !0)
            : Ct < -Number.EPSILON
            ? G < -Number.EPSILON && (yt = !0)
            : Math.sign(Lt) === Math.sign(N) && (yt = !0),
            yt
              ? ((xt = -Lt), (rt = Ct), (kt = Math.sqrt(J)))
              : ((xt = Ct), (rt = Lt), (kt = Math.sqrt(J / 2)))
        }
        return new pt(xt / kt, rt / kt)
      }
      const V = []
      for (
        let B = 0, ht = P.length, it = ht - 1, xt = B + 1;
        B < ht;
        B++, it++, xt++
      )
        it === ht && (it = 0),
          xt === ht && (xt = 0),
          (V[B] = k(P[B], P[it], P[xt]))
      const H = []
      let Y,
        K = V.concat()
      for (let B = 0, ht = C.length; B < ht; B++) {
        const it = C[B]
        Y = []
        for (
          let xt = 0, rt = it.length, kt = rt - 1, Ct = xt + 1;
          xt < rt;
          xt++, kt++, Ct++
        )
          kt === rt && (kt = 0),
            Ct === rt && (Ct = 0),
            (Y[xt] = k(it[xt], it[kt], it[Ct]))
        H.push(Y), (K = K.concat(Y))
      }
      for (let B = 0; B < v; B++) {
        const ht = B / v,
          it = d * Math.cos((ht * Math.PI) / 2),
          xt = p * Math.sin((ht * Math.PI) / 2) + g
        for (let rt = 0, kt = P.length; rt < kt; rt++) {
          const Ct = L(P[rt], V[rt], xt)
          lt(Ct.x, Ct.y, -it)
        }
        for (let rt = 0, kt = C.length; rt < kt; rt++) {
          const Ct = C[rt]
          Y = H[rt]
          for (let Lt = 0, G = Ct.length; Lt < G; Lt++) {
            const N = L(Ct[Lt], Y[Lt], xt)
            lt(N.x, N.y, -it)
          }
        }
      }
      const ut = p + g
      for (let B = 0; B < I; B++) {
        const ht = f ? L(M[B], K[B], ut) : M[B]
        x
          ? (b.copy(A.normals[0]).multiplyScalar(ht.x),
            S.copy(A.binormals[0]).multiplyScalar(ht.y),
            T.copy(_[0]).add(b).add(S),
            lt(T.x, T.y, T.z))
          : lt(ht.x, ht.y, 0)
      }
      for (let B = 1; B <= c; B++)
        for (let ht = 0; ht < I; ht++) {
          const it = f ? L(M[ht], K[ht], ut) : M[ht]
          x
            ? (b.copy(A.normals[B]).multiplyScalar(it.x),
              S.copy(A.binormals[B]).multiplyScalar(it.y),
              T.copy(_[B]).add(b).add(S),
              lt(T.x, T.y, T.z))
            : lt(it.x, it.y, (h / c) * B)
        }
      for (let B = v - 1; B >= 0; B--) {
        const ht = B / v,
          it = d * Math.cos((ht * Math.PI) / 2),
          xt = p * Math.sin((ht * Math.PI) / 2) + g
        for (let rt = 0, kt = P.length; rt < kt; rt++) {
          const Ct = L(P[rt], V[rt], xt)
          lt(Ct.x, Ct.y, h + it)
        }
        for (let rt = 0, kt = C.length; rt < kt; rt++) {
          const Ct = C[rt]
          Y = H[rt]
          for (let Lt = 0, G = Ct.length; Lt < G; Lt++) {
            const N = L(Ct[Lt], Y[Lt], xt)
            x
              ? lt(N.x, N.y + _[c - 1].y, _[c - 1].x + it)
              : lt(N.x, N.y, h + it)
          }
        }
      }
      W(), Z()
      function W() {
        const B = i.length / 3
        if (f) {
          let ht = 0,
            it = I * ht
          for (let xt = 0; xt < F; xt++) {
            const rt = D[xt]
            ct(rt[2] + it, rt[1] + it, rt[0] + it)
          }
          ;(ht = c + v * 2), (it = I * ht)
          for (let xt = 0; xt < F; xt++) {
            const rt = D[xt]
            ct(rt[0] + it, rt[1] + it, rt[2] + it)
          }
        } else {
          for (let ht = 0; ht < F; ht++) {
            const it = D[ht]
            ct(it[2], it[1], it[0])
          }
          for (let ht = 0; ht < F; ht++) {
            const it = D[ht]
            ct(it[0] + I * c, it[1] + I * c, it[2] + I * c)
          }
        }
        n.addGroup(B, i.length / 3 - B, 0)
      }
      function Z() {
        const B = i.length / 3
        let ht = 0
        ft(P, ht), (ht += P.length)
        for (let it = 0, xt = C.length; it < xt; it++) {
          const rt = C[it]
          ft(rt, ht), (ht += rt.length)
        }
        n.addGroup(B, i.length / 3 - B, 1)
      }
      function ft(B, ht) {
        let it = B.length
        for (; --it >= 0; ) {
          const xt = it
          let rt = it - 1
          rt < 0 && (rt = B.length - 1)
          for (let kt = 0, Ct = c + v * 2; kt < Ct; kt++) {
            const Lt = I * kt,
              G = I * (kt + 1),
              N = ht + xt + Lt,
              J = ht + rt + Lt,
              vt = ht + rt + G,
              yt = ht + xt + G
            At(N, J, vt, yt)
          }
        }
      }
      function lt(B, ht, it) {
        l.push(B), l.push(ht), l.push(it)
      }
      function ct(B, ht, it) {
        gt(B), gt(ht), gt(it)
        const xt = i.length / 3,
          rt = y.generateTopUV(n, i, xt - 3, xt - 2, xt - 1)
        dt(rt[0]), dt(rt[1]), dt(rt[2])
      }
      function At(B, ht, it, xt) {
        gt(B), gt(ht), gt(xt), gt(ht), gt(it), gt(xt)
        const rt = i.length / 3,
          kt = y.generateSideWallUV(n, i, rt - 6, rt - 3, rt - 2, rt - 1)
        dt(kt[0]), dt(kt[1]), dt(kt[3]), dt(kt[1]), dt(kt[2]), dt(kt[3])
      }
      function gt(B) {
        i.push(l[B * 3 + 0]), i.push(l[B * 3 + 1]), i.push(l[B * 3 + 2])
      }
      function dt(B) {
        a.push(B.x), a.push(B.y)
      }
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes,
      n = this.parameters.options
    return S$(e, n, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let a = 0, o = t.shapes.length; a < o; a++) {
      const s = e[t.shapes[a]]
      n.push(s)
    }
    const i = t.options.extrudePath
    return (
      i !== void 0 && (t.options.extrudePath = new Sy[i.type]().fromJSON(i)),
      new B0(n, t.options)
    )
  }
}
const x$ = {
  generateTopUV: function (r, t, e, n, i) {
    const a = t[e * 3],
      o = t[e * 3 + 1],
      s = t[n * 3],
      l = t[n * 3 + 1],
      u = t[i * 3],
      c = t[i * 3 + 1]
    return [new pt(a, o), new pt(s, l), new pt(u, c)]
  },
  generateSideWallUV: function (r, t, e, n, i, a) {
    const o = t[e * 3],
      s = t[e * 3 + 1],
      l = t[e * 3 + 2],
      u = t[n * 3],
      c = t[n * 3 + 1],
      h = t[n * 3 + 2],
      f = t[i * 3],
      d = t[i * 3 + 1],
      p = t[i * 3 + 2],
      g = t[a * 3],
      v = t[a * 3 + 1],
      m = t[a * 3 + 2]
    return Math.abs(s - c) < Math.abs(o - u)
      ? [new pt(o, 1 - l), new pt(u, 1 - h), new pt(f, 1 - p), new pt(g, 1 - m)]
      : [new pt(s, 1 - l), new pt(c, 1 - h), new pt(d, 1 - p), new pt(v, 1 - m)]
  },
}
function S$(r, t, e) {
  if (((e.shapes = []), Array.isArray(r)))
    for (let n = 0, i = r.length; n < i; n++) {
      const a = r[n]
      e.shapes.push(a.uuid)
    }
  else e.shapes.push(r.uuid)
  return (
    (e.options = Object.assign({}, t)),
    t.extrudePath !== void 0 &&
      (e.options.extrudePath = t.extrudePath.toJSON()),
    e
  )
}
class qM extends Mn {
  constructor(
    t = new wu([new pt(0, 0.5), new pt(-0.5, -0.5), new pt(0.5, -0.5)]),
    e = 12,
  ) {
    super(),
      (this.type = 'ShapeGeometry'),
      (this.parameters = {
        shapes: t,
        curveSegments: e,
      })
    const n = [],
      i = [],
      a = [],
      o = []
    let s = 0,
      l = 0
    if (Array.isArray(t) === !1) u(t)
    else
      for (let c = 0; c < t.length; c++)
        u(t[c]), this.addGroup(s, l, c), (s += l), (l = 0)
    this.setIndex(n),
      this.setAttribute('position', new nn(i, 3)),
      this.setAttribute('normal', new nn(a, 3)),
      this.setAttribute('uv', new nn(o, 2))
    function u(c) {
      const h = i.length / 3,
        f = c.extractPoints(e)
      let d = f.shape
      const p = f.holes
      $s.isClockWise(d) === !1 && (d = d.reverse())
      for (let v = 0, m = p.length; v < m; v++) {
        const y = p[v]
        $s.isClockWise(y) === !0 && (p[v] = y.reverse())
      }
      const g = $s.triangulateShape(d, p)
      for (let v = 0, m = p.length; v < m; v++) {
        const y = p[v]
        d = d.concat(y)
      }
      for (let v = 0, m = d.length; v < m; v++) {
        const y = d[v]
        i.push(y.x, y.y, 0), a.push(0, 0, 1), o.push(y.x, y.y)
      }
      for (let v = 0, m = g.length; v < m; v++) {
        const y = g[v],
          _ = y[0] + h,
          x = y[1] + h,
          A = y[2] + h
        n.push(_, x, A), (l += 3)
      }
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes
    return A$(e, t)
  }
  static fromJSON(t, e) {
    const n = []
    for (let i = 0, a = t.shapes.length; i < a; i++) {
      const o = e[t.shapes[i]]
      n.push(o)
    }
    return new qM(n, t.curveSegments)
  }
}
function A$(r, t) {
  if (((t.shapes = []), Array.isArray(r)))
    for (let e = 0, n = r.length; e < n; e++) {
      const i = r[e]
      t.shapes.push(i.uuid)
    }
  else t.shapes.push(r.uuid)
  return t
}
class bp extends Mn {
  constructor(
    t = new YM(new U(-1, -1, 0), new U(-1, 1, 0), new U(1, 1, 0)),
    e = 64,
    n = 1,
    i = 8,
    a = !1,
  ) {
    super(),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: i,
        closed: a,
      })
    const o = t.computeFrenetFrames(e, a)
    ;(this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals)
    const s = new U(),
      l = new U(),
      u = new pt()
    let c = new U()
    const h = [],
      f = [],
      d = [],
      p = []
    g(),
      this.setIndex(p),
      this.setAttribute('position', new nn(h, 3)),
      this.setAttribute('normal', new nn(f, 3)),
      this.setAttribute('uv', new nn(d, 2))
    function g() {
      for (let _ = 0; _ < e; _++) v(_)
      v(a === !1 ? e : 0), y(), m()
    }
    function v(_) {
      c = t.getPointAt(_ / e, c)
      const x = o.normals[_],
        A = o.binormals[_]
      for (let S = 0; S <= i; S++) {
        const b = (S / i) * Math.PI * 2,
          T = Math.sin(b),
          w = -Math.cos(b)
        ;(l.x = w * x.x + T * A.x),
          (l.y = w * x.y + T * A.y),
          (l.z = w * x.z + T * A.z),
          l.normalize(),
          f.push(l.x, l.y, l.z),
          (s.x = c.x + n * l.x),
          (s.y = c.y + n * l.y),
          (s.z = c.z + n * l.z),
          h.push(s.x, s.y, s.z)
      }
    }
    function m() {
      for (let _ = 1; _ <= e; _++)
        for (let x = 1; x <= i; x++) {
          const A = (i + 1) * (_ - 1) + (x - 1),
            S = (i + 1) * _ + (x - 1),
            b = (i + 1) * _ + x,
            T = (i + 1) * (_ - 1) + x
          p.push(A, S, T), p.push(S, b, T)
        }
    }
    function y() {
      for (let _ = 0; _ <= e; _++)
        for (let x = 0; x <= i; x++)
          (u.x = _ / e), (u.y = x / i), d.push(u.x, u.y)
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
  toJSON() {
    const t = super.toJSON()
    return (t.path = this.parameters.path.toJSON()), t
  }
  static fromJSON(t) {
    return new bp(
      new Sy[t.path.type]().fromJSON(t.path),
      t.tubularSegments,
      t.radius,
      t.radialSegments,
      t.closed,
    )
  }
}
class b$ extends Mn {
  constructor(t = null) {
    if (
      (super(),
      (this.type = 'WireframeGeometry'),
      (this.parameters = {
        geometry: t,
      }),
      t !== null)
    ) {
      const e = [],
        n = new Set(),
        i = new U(),
        a = new U()
      if (t.index !== null) {
        const o = t.attributes.position,
          s = t.index
        let l = t.groups
        l.length === 0 &&
          (l = [
            {
              start: 0,
              count: s.count,
              materialIndex: 0,
            },
          ])
        for (let u = 0, c = l.length; u < c; ++u) {
          const h = l[u],
            f = h.start,
            d = h.count
          for (let p = f, g = f + d; p < g; p += 3)
            for (let v = 0; v < 3; v++) {
              const m = s.getX(p + v),
                y = s.getX(p + ((v + 1) % 3))
              i.fromBufferAttribute(o, m),
                a.fromBufferAttribute(o, y),
                pD(i, a, n) === !0 &&
                  (e.push(i.x, i.y, i.z), e.push(a.x, a.y, a.z))
            }
        }
      } else {
        const o = t.attributes.position
        for (let s = 0, l = o.count / 3; s < l; s++)
          for (let u = 0; u < 3; u++) {
            const c = 3 * s + u,
              h = 3 * s + ((u + 1) % 3)
            i.fromBufferAttribute(o, c),
              a.fromBufferAttribute(o, h),
              pD(i, a, n) === !0 &&
                (e.push(i.x, i.y, i.z), e.push(a.x, a.y, a.z))
          }
      }
      this.setAttribute('position', new nn(e, 3))
    }
  }
  copy(t) {
    return (
      super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
    )
  }
}
function pD(r, t, e) {
  const n = `${r.x},${r.y},${r.z}-${t.x},${t.y},${t.z}`,
    i = `${t.x},${t.y},${t.z}-${r.x},${r.y},${r.z}`
  return e.has(n) === !0 || e.has(i) === !0 ? !1 : (e.add(n), e.add(i), !0)
}
class Th extends ji {
  constructor(t) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = {
        STANDARD: '',
      }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new qt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = LM),
      (this.normalScale = new pt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Ma()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = {
        STANDARD: '',
      }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.envMapIntensity = t.envMapIntensity),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
class mo extends Th {
  constructor(t) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = {
        STANDARD: '',
        PHYSICAL: '',
      }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new pt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, 'reflectivity', {
        get: function () {
          return zn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e)
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new qt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new qt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new qt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(t)
  }
  get anisotropy() {
    return this._anisotropy
  }
  set anisotropy(t) {
    this._anisotropy > 0 != t > 0 && this.version++, (this._anisotropy = t)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t)
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(t) {
    this._iridescence > 0 != t > 0 && this.version++, (this._iridescence = t)
  }
  get dispersion() {
    return this._dispersion
  }
  set dispersion(t) {
    this._dispersion > 0 != t > 0 && this.version++, (this._dispersion = t)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t)
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = {
        STANDARD: '',
        PHYSICAL: '',
      }),
      (this.anisotropy = t.anisotropy),
      (this.anisotropyRotation = t.anisotropyRotation),
      (this.anisotropyMap = t.anisotropyMap),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.dispersion = t.dispersion),
      (this.ior = t.ior),
      (this.iridescence = t.iridescence),
      (this.iridescenceMap = t.iridescenceMap),
      (this.iridescenceIOR = t.iridescenceIOR),
      (this.iridescenceThicknessRange = [...t.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = t.iridescenceThicknessMap),
      (this.sheen = t.sheen),
      this.sheenColor.copy(t.sheenColor),
      (this.sheenColorMap = t.sheenColorMap),
      (this.sheenRoughness = t.sheenRoughness),
      (this.sheenRoughnessMap = t.sheenRoughnessMap),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      (this.thickness = t.thickness),
      (this.thicknessMap = t.thicknessMap),
      (this.attenuationDistance = t.attenuationDistance),
      this.attenuationColor.copy(t.attenuationColor),
      (this.specularIntensity = t.specularIntensity),
      (this.specularIntensityMap = t.specularIntensityMap),
      this.specularColor.copy(t.specularColor),
      (this.specularColorMap = t.specularColorMap),
      this
    )
  }
}
class CB extends ji {
  constructor(t) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new qt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new qt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = LM),
      (this.normalScale = new pt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Ma()),
      (this.combine = AM),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(t)
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      this.envMapRotation.copy(t.envMapRotation),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      (this.fog = t.fog),
      this
    )
  }
}
function gg(r, t, e) {
  return !r || (!e && r.constructor === t)
    ? r
    : typeof t.BYTES_PER_ELEMENT == 'number'
    ? new t(r)
    : Array.prototype.slice.call(r)
}
function w$(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView)
}
function M$(r) {
  function t(i, a) {
    return r[i] - r[a]
  }
  const e = r.length,
    n = new Array(e)
  for (let i = 0; i !== e; ++i) n[i] = i
  return n.sort(t), n
}
function vD(r, t, e) {
  const n = r.length,
    i = new r.constructor(n)
  for (let a = 0, o = 0; o !== n; ++a) {
    const s = e[a] * t
    for (let l = 0; l !== t; ++l) i[o++] = r[s + l]
  }
  return i
}
function EB(r, t, e, n) {
  let i = 1,
    a = r[0]
  for (; a !== void 0 && a[n] === void 0; ) a = r[i++]
  if (a === void 0) return
  let o = a[n]
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = a[n]),
          o !== void 0 && (t.push(a.time), e.push.apply(e, o)),
          (a = r[i++])
      while (a !== void 0)
    else if (o.toArray !== void 0)
      do
        (o = a[n]),
          o !== void 0 && (t.push(a.time), o.toArray(e, e.length)),
          (a = r[i++])
      while (a !== void 0)
    else
      do (o = a[n]), o !== void 0 && (t.push(a.time), e.push(o)), (a = r[i++])
      while (a !== void 0)
}
class pv {
  constructor(t, e, n, i) {
    ;(this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(t) {
    const e = this.parameterPositions
    let n = this._cachedIndex,
      i = e[n],
      a = e[n - 1]
    t: {
      e: {
        let o
        n: {
          r: if (!(t < i)) {
            for (let s = n + 2; ; ) {
              if (i === void 0) {
                if (t < a) break r
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                )
              }
              if (n === s) break
              if (((a = i), (i = e[++n]), t < i)) break e
            }
            o = e.length
            break n
          }
          if (!(t >= a)) {
            const s = e[1]
            t < s && ((n = 2), (a = s))
            for (let l = n - 2; ; ) {
              if (a === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0)
              if (n === l) break
              if (((i = a), (a = e[--n - 1]), t >= a)) break e
            }
            ;(o = n), (n = 0)
            break n
          }
          break t
        }
        for (; n < o; ) {
          const s = (n + o) >>> 1
          t < e[s] ? (o = s) : (n = s + 1)
        }
        if (((i = e[n]), (a = e[n - 1]), a === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0)
        if (i === void 0)
          return (
            (n = e.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          )
      }
      ;(this._cachedIndex = n), this.intervalChanged_(n, a, i)
    }
    return this.interpolate_(n, a, t, i)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      a = t * i
    for (let o = 0; o !== i; ++o) e[o] = n[a + o]
    return e
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
class T$ extends pv {
  constructor(t, e, n, i) {
    super(t, e, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: JE,
        endingEnd: JE,
      })
  }
  intervalChanged_(t, e, n) {
    const i = this.parameterPositions
    let a = t - 2,
      o = t + 1,
      s = i[a],
      l = i[o]
    if (s === void 0)
      switch (this.getSettings_().endingStart) {
        case QE:
          ;(a = t), (s = 2 * e - n)
          break
        case t2:
          ;(a = i.length - 2), (s = e + i[a] - i[a + 1])
          break
        default:
          ;(a = t), (s = n)
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case QE:
          ;(o = t), (l = 2 * n - e)
          break
        case t2:
          ;(o = 1), (l = n + i[1] - i[0])
          break
        default:
          ;(o = t - 1), (l = e)
      }
    const u = (n - e) * 0.5,
      c = this.valueSize
    ;(this._weightPrev = u / (e - s)),
      (this._weightNext = u / (l - n)),
      (this._offsetPrev = a * c),
      (this._offsetNext = o * c)
  }
  interpolate_(t, e, n, i) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      s = this.valueSize,
      l = t * s,
      u = l - s,
      c = this._offsetPrev,
      h = this._offsetNext,
      f = this._weightPrev,
      d = this._weightNext,
      p = (n - e) / (i - e),
      g = p * p,
      v = g * p,
      m = -f * v + 2 * f * g - f * p,
      y = (1 + f) * v + (-1.5 - 2 * f) * g + (-0.5 + f) * p + 1,
      _ = (-1 - d) * v + (1.5 + d) * g + 0.5 * p,
      x = d * v - d * g
    for (let A = 0; A !== s; ++A)
      a[A] = m * o[c + A] + y * o[u + A] + _ * o[l + A] + x * o[h + A]
    return a
  }
}
class C$ extends pv {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      s = this.valueSize,
      l = t * s,
      u = l - s,
      c = (n - e) / (i - e),
      h = 1 - c
    for (let f = 0; f !== s; ++f) a[f] = o[u + f] * h + o[l + f] * c
    return a
  }
}
class E$ extends pv {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1)
  }
}
class yo {
  constructor(t, e, n, i) {
    if (t === void 0)
      throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (e === void 0 || e.length === 0)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t)
    ;(this.name = t),
      (this.times = gg(e, this.TimeBufferType)),
      (this.values = gg(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation)
  }
  static toJSON(t) {
    const e = t.constructor
    let n
    if (e.toJSON !== this.toJSON) n = e.toJSON(t)
    else {
      n = {
        name: t.name,
        times: gg(t.times, Array),
        values: gg(t.values, Array),
      }
      const i = t.getInterpolation()
      i !== t.DefaultInterpolation && (n.interpolation = i)
    }
    return (n.type = t.ValueTypeName), n
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new E$(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodLinear(t) {
    return new C$(this.times, this.values, this.getValueSize(), t)
  }
  InterpolantFactoryMethodSmooth(t) {
    return new T$(this.times, this.values, this.getValueSize(), t)
  }
  setInterpolation(t) {
    let e
    switch (t) {
      case mp:
        e = this.InterpolantFactoryMethodDiscrete
        break
      case yp:
        e = this.InterpolantFactoryMethodLinear
        break
      case k_:
        e = this.InterpolantFactoryMethodSmooth
        break
    }
    if (e === void 0) {
      const n =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation)
        else throw new Error(n)
      return console.warn('THREE.KeyframeTrack:', n), this
    }
    return (this.createInterpolant = e), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return mp
      case this.InterpolantFactoryMethodLinear:
        return yp
      case this.InterpolantFactoryMethodSmooth:
        return k_
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(t) {
    if (t !== 0) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
    }
    return this
  }
  scale(t) {
    if (t !== 1) {
      const e = this.times
      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
    }
    return this
  }
  trim(t, e) {
    const n = this.times,
      i = n.length
    let a = 0,
      o = i - 1
    for (; a !== i && n[a] < t; ) ++a
    for (; o !== -1 && n[o] > e; ) --o
    if ((++o, a !== 0 || o !== i)) {
      a >= o && ((o = Math.max(o, 1)), (a = o - 1))
      const s = this.getValueSize()
      ;(this.times = n.slice(a, o)),
        (this.values = this.values.slice(a * s, o * s))
    }
    return this
  }
  validate() {
    let t = !0
    const e = this.getValueSize()
    e - Math.floor(e) !== 0 &&
      (console.error('THREE.KeyframeTrack: Invalid value size in track.', this),
      (t = !1))
    const n = this.times,
      i = this.values,
      a = n.length
    a === 0 &&
      (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1))
    let o = null
    for (let s = 0; s !== a; s++) {
      const l = n[s]
      if (typeof l == 'number' && isNaN(l)) {
        console.error(
          'THREE.KeyframeTrack: Time is not a valid number.',
          this,
          s,
          l,
        ),
          (t = !1)
        break
      }
      if (o !== null && o > l) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, s, l, o),
          (t = !1)
        break
      }
      o = l
    }
    if (i !== void 0 && w$(i))
      for (let s = 0, l = i.length; s !== l; ++s) {
        const u = i[s]
        if (isNaN(u)) {
          console.error(
            'THREE.KeyframeTrack: Value is not a valid number.',
            this,
            s,
            u,
          ),
            (t = !1)
          break
        }
      }
    return t
  }
  optimize() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = this.getValueSize(),
      i = this.getInterpolation() === k_,
      a = t.length - 1
    let o = 1
    for (let s = 1; s < a; ++s) {
      let l = !1
      const u = t[s],
        c = t[s + 1]
      if (u !== c && (s !== 1 || u !== t[0]))
        if (i) l = !0
        else {
          const h = s * n,
            f = h - n,
            d = h + n
          for (let p = 0; p !== n; ++p) {
            const g = e[h + p]
            if (g !== e[f + p] || g !== e[d + p]) {
              l = !0
              break
            }
          }
        }
      if (l) {
        if (s !== o) {
          t[o] = t[s]
          const h = s * n,
            f = o * n
          for (let d = 0; d !== n; ++d) e[f + d] = e[h + d]
        }
        ++o
      }
    }
    if (a > 0) {
      t[o] = t[a]
      for (let s = a * n, l = o * n, u = 0; u !== n; ++u) e[l + u] = e[s + u]
      ++o
    }
    return (
      o !== t.length
        ? ((this.times = t.slice(0, o)), (this.values = e.slice(0, o * n)))
        : ((this.times = t), (this.values = e)),
      this
    )
  }
  clone() {
    const t = this.times.slice(),
      e = this.values.slice(),
      n = this.constructor,
      i = new n(this.name, t, e)
    return (i.createInterpolant = this.createInterpolant), i
  }
}
yo.prototype.TimeBufferType = Float32Array
yo.prototype.ValueBufferType = Float32Array
yo.prototype.DefaultInterpolation = yp
class df extends yo {
  constructor(t, e, n) {
    super(t, e, n)
  }
}
df.prototype.ValueTypeName = 'bool'
df.prototype.ValueBufferType = Array
df.prototype.DefaultInterpolation = mp
df.prototype.InterpolantFactoryMethodLinear = void 0
df.prototype.InterpolantFactoryMethodSmooth = void 0
class DB extends yo {}
DB.prototype.ValueTypeName = 'color'
class Wh extends yo {}
Wh.prototype.ValueTypeName = 'number'
class D$ extends pv {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  interpolate_(t, e, n, i) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      s = this.valueSize,
      l = (n - e) / (i - e)
    let u = t * s
    for (let c = u + s; u !== c; u += 4) wa.slerpFlat(a, 0, o, u - s, o, u, l)
    return a
  }
}
class Xh extends yo {
  InterpolantFactoryMethodLinear(t) {
    return new D$(this.times, this.values, this.getValueSize(), t)
  }
}
Xh.prototype.ValueTypeName = 'quaternion'
Xh.prototype.InterpolantFactoryMethodSmooth = void 0
class pf extends yo {
  constructor(t, e, n) {
    super(t, e, n)
  }
}
pf.prototype.ValueTypeName = 'string'
pf.prototype.ValueBufferType = Array
pf.prototype.DefaultInterpolation = mp
pf.prototype.InterpolantFactoryMethodLinear = void 0
pf.prototype.InterpolantFactoryMethodSmooth = void 0
class Yh extends yo {}
Yh.prototype.ValueTypeName = 'vector'
class L$ {
  constructor(t = '', e = -1, n = [], i = i6) {
    ;(this.name = t),
      (this.tracks = n),
      (this.duration = e),
      (this.blendMode = i),
      (this.uuid = Ki()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(t) {
    const e = [],
      n = t.tracks,
      i = 1 / (t.fps || 1)
    for (let o = 0, s = n.length; o !== s; ++o) e.push(R$(n[o]).scale(i))
    const a = new this(t.name, t.duration, e, t.blendMode)
    return (a.uuid = t.uuid), a
  }
  static toJSON(t) {
    const e = [],
      n = t.tracks,
      i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode,
      }
    for (let a = 0, o = n.length; a !== o; ++a) e.push(yo.toJSON(n[a]))
    return i
  }
  static CreateFromMorphTargetSequence(t, e, n, i) {
    const a = e.length,
      o = []
    for (let s = 0; s < a; s++) {
      let l = [],
        u = []
      l.push((s + a - 1) % a, s, (s + 1) % a), u.push(0, 1, 0)
      const c = M$(l)
      ;(l = vD(l, 1, c)),
        (u = vD(u, 1, c)),
        !i && l[0] === 0 && (l.push(a), u.push(u[0])),
        o.push(
          new Wh('.morphTargetInfluences[' + e[s].name + ']', l, u).scale(
            1 / n,
          ),
        )
    }
    return new this(t, -1, o)
  }
  static findByName(t, e) {
    let n = t
    if (!Array.isArray(t)) {
      const i = t
      n = (i.geometry && i.geometry.animations) || i.animations
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i]
    return null
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const i = {},
      a = /^([\w-]*?)([\d]+)$/
    for (let s = 0, l = t.length; s < l; s++) {
      const u = t[s],
        c = u.name.match(a)
      if (c && c.length > 1) {
        const h = c[1]
        let f = i[h]
        f || (i[h] = f = []), f.push(u)
      }
    }
    const o = []
    for (const s in i) o.push(this.CreateFromMorphTargetSequence(s, i[s], e, n))
    return o
  }
  static parseAnimation(t, e) {
    if (!t)
      return (
        console.error('THREE.AnimationClip: No animation in JSONLoader data.'),
        null
      )
    const n = function (h, f, d, p, g) {
        if (d.length !== 0) {
          const v = [],
            m = []
          EB(d, v, m, p), v.length !== 0 && g.push(new h(f, v, m))
        }
      },
      i = [],
      a = t.name || 'default',
      o = t.fps || 30,
      s = t.blendMode
    let l = t.length || -1
    const u = t.hierarchy || []
    for (let h = 0; h < u.length; h++) {
      const f = u[h].keys
      if (!(!f || f.length === 0))
        if (f[0].morphTargets) {
          const d = {}
          let p
          for (p = 0; p < f.length; p++)
            if (f[p].morphTargets)
              for (let g = 0; g < f[p].morphTargets.length; g++)
                d[f[p].morphTargets[g]] = -1
          for (const g in d) {
            const v = [],
              m = []
            for (let y = 0; y !== f[p].morphTargets.length; ++y) {
              const _ = f[p]
              v.push(_.time), m.push(_.morphTarget === g ? 1 : 0)
            }
            i.push(new Wh('.morphTargetInfluence[' + g + ']', v, m))
          }
          l = d.length * o
        } else {
          const d = '.bones[' + e[h].name + ']'
          n(Yh, d + '.position', f, 'pos', i),
            n(Xh, d + '.quaternion', f, 'rot', i),
            n(Yh, d + '.scale', f, 'scl', i)
        }
    }
    return i.length === 0 ? null : new this(a, l, i, s)
  }
  resetDuration() {
    const t = this.tracks
    let e = 0
    for (let n = 0, i = t.length; n !== i; ++n) {
      const a = this.tracks[n]
      e = Math.max(e, a.times[a.times.length - 1])
    }
    return (this.duration = e), this
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration)
    return this
  }
  validate() {
    let t = !0
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate()
    return t
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize()
    return this
  }
  clone() {
    const t = []
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone())
    return new this.constructor(this.name, this.duration, t, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function P$(r) {
  switch (r.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return Wh
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return Yh
    case 'color':
      return DB
    case 'quaternion':
      return Xh
    case 'bool':
    case 'boolean':
      return df
    case 'string':
      return pf
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + r)
}
function R$(r) {
  if (r.type === void 0)
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  const t = P$(r.type)
  if (r.times === void 0) {
    const e = [],
      n = []
    EB(r.keys, e, n, 'value'), (r.times = e), (r.values = n)
  }
  return t.parse !== void 0
    ? t.parse(r)
    : new t(r.name, r.times, r.values, r.interpolation)
}
const Rs = {
  enabled: !1,
  files: {},
  add: function (r, t) {
    this.enabled !== !1 && (this.files[r] = t)
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r]
  },
  remove: function (r) {
    delete this.files[r]
  },
  clear: function () {
    this.files = {}
  },
}
class LB {
  constructor(t, e, n) {
    const i = this
    let a = !1,
      o = 0,
      s = 0,
      l
    const u = []
    ;(this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (c) {
        s++, a === !1 && i.onStart !== void 0 && i.onStart(c, o, s), (a = !0)
      }),
      (this.itemEnd = function (c) {
        o++,
          i.onProgress !== void 0 && i.onProgress(c, o, s),
          o === s && ((a = !1), i.onLoad !== void 0 && i.onLoad())
      }),
      (this.itemError = function (c) {
        i.onError !== void 0 && i.onError(c)
      }),
      (this.resolveURL = function (c) {
        return l ? l(c) : c
      }),
      (this.setURLModifier = function (c) {
        return (l = c), this
      }),
      (this.addHandler = function (c, h) {
        return u.push(c, h), this
      }),
      (this.removeHandler = function (c) {
        const h = u.indexOf(c)
        return h !== -1 && u.splice(h, 2), this
      }),
      (this.getHandler = function (c) {
        for (let h = 0, f = u.length; h < f; h += 2) {
          const d = u[h],
            p = u[h + 1]
          if ((d.global && (d.lastIndex = 0), d.test(c))) return p
        }
        return null
      })
  }
}
const I$ = new LB()
class fl {
  constructor(t) {
    ;(this.manager = t !== void 0 ? t : I$),
      (this.crossOrigin = 'anonymous'),
      (this.withCredentials = !1),
      (this.path = ''),
      (this.resourcePath = ''),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(t, e) {
    const n = this
    return new Promise(function (i, a) {
      n.load(t, i, e, a)
    })
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this
  }
  setPath(t) {
    return (this.path = t), this
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this
  }
}
fl.DEFAULT_MATERIAL_NAME = '__DEFAULT'
const Co = {}
class O$ extends Error {
  constructor(t, e) {
    super(t), (this.response = e)
  }
}
class wp extends fl {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    t === void 0 && (t = ''),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const a = Rs.get(t)
    if (a !== void 0)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          e && e(a), this.manager.itemEnd(t)
        }, 0),
        a
      )
    if (Co[t] !== void 0) {
      Co[t].push({
        onLoad: e,
        onProgress: n,
        onError: i,
      })
      return
    }
    ;(Co[t] = []),
      Co[t].push({
        onLoad: e,
        onProgress: n,
        onError: i,
      })
    const o = new Request(t, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? 'include' : 'same-origin',
      }),
      s = this.mimeType,
      l = this.responseType
    fetch(o)
      .then(u => {
        if (u.status === 200 || u.status === 0) {
          if (
            (u.status === 0 &&
              console.warn('THREE.FileLoader: HTTP Status 0 received.'),
            typeof ReadableStream > 'u' ||
              u.body === void 0 ||
              u.body.getReader === void 0)
          )
            return u
          const c = Co[t],
            h = u.body.getReader(),
            f = u.headers.get('X-File-Size') || u.headers.get('Content-Length'),
            d = f ? parseInt(f) : 0,
            p = d !== 0
          let g = 0
          const v = new ReadableStream({
            start(m) {
              y()
              function y() {
                h.read().then(
                  ({done: _, value: x}) => {
                    if (_) m.close()
                    else {
                      g += x.byteLength
                      const A = new ProgressEvent('progress', {
                        lengthComputable: p,
                        loaded: g,
                        total: d,
                      })
                      for (let S = 0, b = c.length; S < b; S++) {
                        const T = c[S]
                        T.onProgress && T.onProgress(A)
                      }
                      m.enqueue(x), y()
                    }
                  },
                  _ => {
                    m.error(_)
                  },
                )
              }
            },
          })
          return new Response(v)
        } else
          throw new O$(
            `fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,
            u,
          )
      })
      .then(u => {
        switch (l) {
          case 'arraybuffer':
            return u.arrayBuffer()
          case 'blob':
            return u.blob()
          case 'document':
            return u.text().then(c => new DOMParser().parseFromString(c, s))
          case 'json':
            return u.json()
          default:
            if (s === void 0) return u.text()
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(s),
                f = h && h[1] ? h[1].toLowerCase() : void 0,
                d = new TextDecoder(f)
              return u.arrayBuffer().then(p => d.decode(p))
            }
        }
      })
      .then(u => {
        Rs.add(t, u)
        const c = Co[t]
        delete Co[t]
        for (let h = 0, f = c.length; h < f; h++) {
          const d = c[h]
          d.onLoad && d.onLoad(u)
        }
      })
      .catch(u => {
        const c = Co[t]
        if (c === void 0) throw (this.manager.itemError(t), u)
        delete Co[t]
        for (let h = 0, f = c.length; h < f; h++) {
          const d = c[h]
          d.onError && d.onError(u)
        }
        this.manager.itemError(t)
      })
      .finally(() => {
        this.manager.itemEnd(t)
      }),
      this.manager.itemStart(t)
  }
  setResponseType(t) {
    return (this.responseType = t), this
  }
  setMimeType(t) {
    return (this.mimeType = t), this
  }
}
class N$ extends fl {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const a = this,
      o = Rs.get(t)
    if (o !== void 0)
      return (
        a.manager.itemStart(t),
        setTimeout(function () {
          e && e(o), a.manager.itemEnd(t)
        }, 0),
        o
      )
    const s = _p('img')
    function l() {
      c(), Rs.add(t, this), e && e(this), a.manager.itemEnd(t)
    }
    function u(h) {
      c(), i && i(h), a.manager.itemError(t), a.manager.itemEnd(t)
    }
    function c() {
      s.removeEventListener('load', l, !1),
        s.removeEventListener('error', u, !1)
    }
    return (
      s.addEventListener('load', l, !1),
      s.addEventListener('error', u, !1),
      t.slice(0, 5) !== 'data:' &&
        this.crossOrigin !== void 0 &&
        (s.crossOrigin = this.crossOrigin),
      a.manager.itemStart(t),
      (s.src = t),
      s
    )
  }
}
class ZM extends fl {
  constructor(t) {
    super(t)
  }
  load(t, e, n, i) {
    const a = new Yn(),
      o = new N$(this.manager)
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        t,
        function (s) {
          ;(a.image = s), (a.needsUpdate = !0), e !== void 0 && e(a)
        },
        n,
        i,
      ),
      a
    )
  }
}
class F0 extends Fe {
  constructor(t, e = 1) {
    super(),
      (this.isLight = !0),
      (this.type = 'Light'),
      (this.color = new qt(t)),
      (this.intensity = e)
  }
  dispose() {}
  copy(t, e) {
    return (
      super.copy(t, e),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    )
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (e.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (e.object.distance = this.distance),
      this.angle !== void 0 && (e.object.angle = this.angle),
      this.decay !== void 0 && (e.object.decay = this.decay),
      this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (e.object.target = this.target.uuid),
      e
    )
  }
}
const vx = new ae(),
  gD = new U(),
  mD = new U()
class KM {
  constructor(t) {
    ;(this.camera = t),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new pt(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ae()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new BM()),
      (this._frameExtents = new pt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Oe(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(t) {
    const e = this.camera,
      n = this.matrix
    gD.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(gD),
      mD.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(mD),
      e.updateMatrixWorld(),
      vx.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(vx),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(vx)
  }
  getViewport(t) {
    return this._viewports[t]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.intensity = t.intensity),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const t = {}
    return (
      this.intensity !== 1 && (t.intensity = this.intensity),
      this.bias !== 0 && (t.bias = this.bias),
      this.normalBias !== 0 && (t.normalBias = this.normalBias),
      this.radius !== 1 && (t.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    )
  }
}
class k$ extends KM {
  constructor() {
    super(new wr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1)
  }
  updateMatrices(t) {
    const e = this.camera,
      n = Gh * 2 * t.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      a = t.distance || e.far
    ;(n !== e.fov || i !== e.aspect || a !== e.far) &&
      ((e.fov = n), (e.aspect = i), (e.far = a), e.updateProjectionMatrix()),
      super.updateMatrices(t)
  }
  copy(t) {
    return super.copy(t), (this.focus = t.focus), this
  }
}
class B$ extends F0 {
  constructor(t, e, n = 0, i = Math.PI / 3, a = 0, o = 2) {
    super(t, e),
      (this.isSpotLight = !0),
      (this.type = 'SpotLight'),
      this.position.copy(Fe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Fe()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = a),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new k$())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(t) {
    this.intensity = t / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
const yD = new ae(),
  Yf = new U(),
  gx = new U()
class F$ extends KM {
  constructor() {
    super(new wr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new pt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Oe(2, 1, 1, 1),
        new Oe(0, 1, 1, 1),
        new Oe(3, 1, 1, 1),
        new Oe(1, 1, 1, 1),
        new Oe(3, 0, 1, 1),
        new Oe(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new U(1, 0, 0),
        new U(-1, 0, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
        new U(0, 1, 0),
        new U(0, -1, 0),
      ]),
      (this._cubeUps = [
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 1, 0),
        new U(0, 0, 1),
        new U(0, 0, -1),
      ])
  }
  updateMatrices(t, e = 0) {
    const n = this.camera,
      i = this.matrix,
      a = t.distance || n.far
    a !== n.far && ((n.far = a), n.updateProjectionMatrix()),
      Yf.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(Yf),
      gx.copy(n.position),
      gx.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(gx),
      n.updateMatrixWorld(),
      i.makeTranslation(-Yf.x, -Yf.y, -Yf.z),
      yD.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(yD)
  }
}
class z$ extends F0 {
  constructor(t, e, n = 0, i = 2) {
    super(t, e),
      (this.isPointLight = !0),
      (this.type = 'PointLight'),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new F$())
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
class U$ extends KM {
  constructor() {
    super(new O0(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0)
  }
}
class Ay extends F0 {
  constructor(t, e) {
    super(t, e),
      (this.isDirectionalLight = !0),
      (this.type = 'DirectionalLight'),
      this.position.copy(Fe.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Fe()),
      (this.shadow = new U$())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(t) {
    return (
      super.copy(t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    )
  }
}
class PB extends F0 {
  constructor(t, e) {
    super(t, e), (this.isAmbientLight = !0), (this.type = 'AmbientLight')
  }
}
class Kd {
  static decodeText(t) {
    if (
      (console.warn(
        'THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.',
      ),
      typeof TextDecoder < 'u')
    )
      return new TextDecoder().decode(t)
    let e = ''
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n])
    try {
      return decodeURIComponent(escape(e))
    } catch {
      return e
    }
  }
  static extractUrlBase(t) {
    const e = t.lastIndexOf('/')
    return e === -1 ? './' : t.slice(0, e + 1)
  }
  static resolveURL(t, e) {
    return typeof t != 'string' || t === ''
      ? ''
      : (/^https?:\/\//i.test(e) &&
          /^\//.test(t) &&
          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
        /^(https?:)?\/\//i.test(t) ||
        /^data:.*,.*$/i.test(t) ||
        /^blob:.*$/i.test(t)
          ? t
          : e + t)
  }
}
class V$ extends Mn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = 'InstancedBufferGeometry'),
      (this.instanceCount = 1 / 0)
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this
  }
  toJSON() {
    const t = super.toJSON()
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    )
  }
}
class G$ extends fl {
  constructor(t) {
    super(t),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > 'u' &&
        console.warn(
          'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
        ),
      typeof fetch > 'u' &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.options = {
        premultiplyAlpha: 'none',
      })
  }
  setOptions(t) {
    return (this.options = t), this
  }
  load(t, e, n, i) {
    t === void 0 && (t = ''),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t))
    const a = this,
      o = Rs.get(t)
    if (o !== void 0) {
      if ((a.manager.itemStart(t), o.then)) {
        o.then(u => {
          e && e(u), a.manager.itemEnd(t)
        }).catch(u => {
          i && i(u)
        })
        return
      }
      return (
        setTimeout(function () {
          e && e(o), a.manager.itemEnd(t)
        }, 0),
        o
      )
    }
    const s = {}
    ;(s.credentials =
      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'),
      (s.headers = this.requestHeader)
    const l = fetch(t, s)
      .then(function (u) {
        return u.blob()
      })
      .then(function (u) {
        return createImageBitmap(
          u,
          Object.assign(a.options, {
            colorSpaceConversion: 'none',
          }),
        )
      })
      .then(function (u) {
        return Rs.add(t, u), e && e(u), a.manager.itemEnd(t), u
      })
      .catch(function (u) {
        i && i(u), Rs.remove(t), a.manager.itemError(t), a.manager.itemEnd(t)
      })
    Rs.add(t, l), a.manager.itemStart(t)
  }
}
class H$ {
  constructor(t = !0) {
    ;(this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = _D()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let t = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const e = _D()
      ;(t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t)
    }
    return t
  }
}
function _D() {
  return (typeof performance > 'u' ? Date : performance).now()
}
const jM = '\\[\\]\\.:\\/',
  W$ = new RegExp('[' + jM + ']', 'g'),
  JM = '[^' + jM + ']',
  X$ = '[^' + jM.replace('\\.', '') + ']',
  Y$ = /((?:WC+[\/:])*)/.source.replace('WC', JM),
  $$ = /(WCOD+)?/.source.replace('WCOD', X$),
  q$ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', JM),
  Z$ = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', JM),
  K$ = new RegExp('^' + Y$ + $$ + q$ + Z$ + '$'),
  j$ = ['material', 'materials', 'bones', 'map']
class J$ {
  constructor(t, e, n) {
    const i = n || Xe.parseTrackName(e)
    ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, i))
  }
  getValue(t, e) {
    this.bind()
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n]
    i !== void 0 && i.getValue(t, e)
  }
  setValue(t, e) {
    const n = this._bindings
    for (let i = this._targetGroup.nCachedObjects_, a = n.length; i !== a; ++i)
      n[i].setValue(t, e)
  }
  bind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind()
  }
  unbind() {
    const t = this._bindings
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind()
  }
}
class Xe {
  constructor(t, e, n) {
    ;(this.path = e),
      (this.parsedPath = n || Xe.parseTrackName(e)),
      (this.node = Xe.findNode(t, this.parsedPath.nodeName)),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup
      ? new Xe.Composite(t, e, n)
      : new Xe(t, e, n)
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, '_').replace(W$, '')
  }
  static parseTrackName(t) {
    const e = K$.exec(t)
    if (e === null)
      throw new Error('PropertyBinding: Cannot parse trackName: ' + t)
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf('.')
    if (i !== void 0 && i !== -1) {
      const a = n.nodeName.substring(i + 1)
      j$.indexOf(a) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = a))
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' + t,
      )
    return n
  }
  static findNode(t, e) {
    if (
      e === void 0 ||
      e === '' ||
      e === '.' ||
      e === -1 ||
      e === t.name ||
      e === t.uuid
    )
      return t
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e)
      if (n !== void 0) return n
    }
    if (t.children) {
      const n = function (a) {
          for (let o = 0; o < a.length; o++) {
            const s = a[o]
            if (s.name === e || s.uuid === e) return s
            const l = n(s.children)
            if (l) return l
          }
          return null
        },
        i = n(t.children)
      if (i) return i
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName]
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, a = n.length; i !== a; ++i) t[e++] = n[i]
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e)
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e]
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = t[e++]
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = t[e++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty
    for (let i = 0, a = n.length; i !== a; ++i) n[i] = t[e++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e]
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    ;(this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e)
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e)
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e)
  }
  bind() {
    let t = this.node
    const e = this.parsedPath,
      n = e.objectName,
      i = e.propertyName
    let a = e.propertyIndex
    if (
      (t || ((t = Xe.findNode(this.rootNode, e.nodeName)), (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    ) {
      console.warn(
        'THREE.PropertyBinding: No target node found for track: ' +
          this.path +
          '.',
      )
      return
    }
    if (n) {
      let u = e.objectIndex
      switch (n) {
        case 'materials':
          if (!t.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            )
            return
          }
          if (!t.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this,
            )
            return
          }
          t = t.material.materials
          break
        case 'bones':
          if (!t.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this,
            )
            return
          }
          t = t.skeleton.bones
          for (let c = 0; c < t.length; c++)
            if (t[c].name === u) {
              u = c
              break
            }
          break
        case 'map':
          if ('map' in t) {
            t = t.map
            break
          }
          if (!t.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            )
            return
          }
          if (!t.material.map) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.',
              this,
            )
            return
          }
          t = t.material.map
          break
        default:
          if (t[n] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this,
            )
            return
          }
          t = t[n]
      }
      if (u !== void 0) {
        if (t[u] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            t,
          )
          return
        }
        t = t[u]
      }
    }
    const o = t[i]
    if (o === void 0) {
      const u = e.nodeName
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          u +
          '.' +
          i +
          " but it wasn't found.",
        t,
      )
      return
    }
    let s = this.Versioning.None
    ;(this.targetObject = t),
      t.needsUpdate !== void 0
        ? (s = this.Versioning.NeedsUpdate)
        : t.matrixWorldNeedsUpdate !== void 0 &&
          (s = this.Versioning.MatrixWorldNeedsUpdate)
    let l = this.BindingType.Direct
    if (a !== void 0) {
      if (i === 'morphTargetInfluences') {
        if (!t.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this,
          )
          return
        }
        if (!t.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this,
          )
          return
        }
        t.morphTargetDictionary[a] !== void 0 &&
          (a = t.morphTargetDictionary[a])
      }
      ;(l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = a)
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i)
    ;(this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][s])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
Xe.Composite = J$
Xe.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
}
Xe.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
}
Xe.prototype.GetterByBindingType = [
  Xe.prototype._getValue_direct,
  Xe.prototype._getValue_array,
  Xe.prototype._getValue_arrayElement,
  Xe.prototype._getValue_toArray,
]
Xe.prototype.SetterByBindingTypeAndVersioning = [
  [
    Xe.prototype._setValue_direct,
    Xe.prototype._setValue_direct_setNeedsUpdate,
    Xe.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Xe.prototype._setValue_array,
    Xe.prototype._setValue_array_setNeedsUpdate,
    Xe.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Xe.prototype._setValue_arrayElement,
    Xe.prototype._setValue_arrayElement_setNeedsUpdate,
    Xe.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Xe.prototype._setValue_fromArray,
    Xe.prototype._setValue_fromArray_setNeedsUpdate,
    Xe.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class JA extends UM {
  constructor(t, e, n = 1) {
    super(t, e),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = n)
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
  }
  clone(t) {
    const e = super.clone(t)
    return (e.meshPerAttribute = this.meshPerAttribute), e
  }
  toJSON(t) {
    const e = super.toJSON(t)
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    )
  }
}
const xD = new ae()
class Q$ {
  constructor(t, e, n = 0, i = 1 / 0) {
    ;(this.ray = new hf(t, e)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new NM()),
      (this.params = {
        Mesh: {},
        Line: {
          threshold: 1,
        },
        LOD: {},
        Points: {
          threshold: 1,
        },
        Sprite: {},
      })
  }
  set(t, e) {
    this.ray.set(t, e)
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e.isOrthographicCamera
      ? (this.ray.origin
          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
        (this.camera = e))
      : console.error('THREE.Raycaster: Unsupported camera type: ' + e.type)
  }
  setFromXRController(t) {
    return (
      xD.identity().extractRotation(t.matrixWorld),
      this.ray.origin.setFromMatrixPosition(t.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(xD),
      this
    )
  }
  intersectObject(t, e = !0, n = []) {
    return QA(t, this, n, e), n.sort(SD), n
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, a = t.length; i < a; i++) QA(t[i], this, n, e)
    return n.sort(SD), n
  }
}
function SD(r, t) {
  return r.distance - t.distance
}
function QA(r, t, e, n) {
  let i = !0
  if (
    (r.layers.test(t.layers) && r.raycast(t, e) === !1 && (i = !1),
    i === !0 && n === !0)
  ) {
    const a = r.children
    for (let o = 0, s = a.length; o < s; o++) QA(a[o], t, e, !0)
  }
}
class AD {
  constructor(t = 1, e = 0, n = 0) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  set(t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    )
  }
  makeSafe() {
    return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z)
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)),
          (this.phi = Math.acos(zn(e / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const bD = new U(),
  mg = new U()
class tq {
  constructor(t = new U(), e = new U()) {
    ;(this.start = t), (this.end = e)
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this
  }
  getCenter(t) {
    return t.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(t) {
    return t.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(t, e) {
    return this.delta(e).multiplyScalar(t).add(this.start)
  }
  closestPointToPointParameter(t, e) {
    bD.subVectors(t, this.start), mg.subVectors(this.end, this.start)
    const n = mg.dot(mg)
    let a = mg.dot(bD) / n
    return e && (a = zn(a, 0, 1)), a
  }
  closestPointToPoint(t, e, n) {
    const i = this.closestPointToPointParameter(t, e)
    return this.delta(n).multiplyScalar(i).add(this.start)
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class RB extends gB {
  constructor(t = 1) {
    const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new Mn()
    i.setAttribute('position', new nn(e, 3)),
      i.setAttribute('color', new nn(n, 3))
    const a = new dv({
      vertexColors: !0,
      toneMapped: !1,
    })
    super(i, a), (this.type = 'AxesHelper')
  }
  setColors(t, e, n) {
    const i = new qt(),
      a = this.geometry.attributes.color.array
    return (
      i.set(t),
      i.toArray(a, 0),
      i.toArray(a, 3),
      i.set(e),
      i.toArray(a, 6),
      i.toArray(a, 9),
      i.set(n),
      i.toArray(a, 12),
      i.toArray(a, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    )
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
typeof __THREE_DEVTOOLS__ < 'u' &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', {
      detail: {
        revision: SM,
      },
    }),
  )
typeof window < 'u' &&
  (window.__THREE__
    ? console.warn('WARNING: Multiple instances of Three.js being imported.')
    : (window.__THREE__ = SM))
function eq(r) {
  let t = null,
    e = !1,
    n = !1
  function i() {
    !e || n || (r(), (t = requestAnimationFrame(i)))
  }
  function a() {
    e || ((e = !0), i())
  }
  function o() {
    e && ((e = !1), (n = !0), cancelAnimationFrame(t))
  }
  function s() {
    !e && n && ((e = !0), (n = !1), i())
  }
  return {
    start: a,
    pause: o,
    resume: s,
    isActive: () => e,
  }
}
class z0 {
  constructor() {
    this.events = new Map()
  }
  on(t, e) {
    let n = this.events.get(t)
    n || ((n = new Set()), this.events.set(t, n)), n.add(e)
  }
  off(t, e) {
    const n = this.events.get(t)
    n && (e ? n.delete(e) : this.events.delete(t))
  }
  emit(t, ...e) {
    const n = this.events.get(t)
    n &&
      n.forEach(i => {
        i(...e)
      })
  }
  once(t, e) {
    const n = (...i) => {
      e(...i), this.off(t, n)
    }
    this.on(t, n)
  }
}
class nq extends z0 {
  constructor({canvas: t}) {
    super(),
      (this.canvas = t),
      (this.pixelRatio = 0),
      this.init(),
      window.addEventListener('resize', () => {
        this.init(), this.emit('resize')
      })
  }
  init() {
    ;(this.width = this.canvas.parentNode.offsetWidth),
      (this.height = this.canvas.parentNode.offsetHeight),
      (this.pixelRatio =
        this.pixelRatio || Math.min(window.devicePixelRatio, 2))
  }
  destroy() {
    this.off('resize')
  }
}
class rq extends z0 {
  constructor() {
    super(),
      (this.start = Date.now()),
      (this.current = this.start),
      (this.elapsed = 0),
      (this.delta = 16),
      (this.clock = new H$()),
      (this.raf = eq(() => this.tick())),
      this.raf.start()
  }
  tick() {
    const t = Date.now()
    ;(this.delta = t - this.current),
      (this.current = t),
      (this.elapsed = this.current - this.start)
    const e = this.clock.getDelta(),
      n = this.clock.getElapsedTime()
    this.emit('tick', e, n)
  }
  destroy() {
    this.pause(), this.off('tick')
  }
  pause() {
    this.raf.pause()
  }
  resume() {
    this.raf.resume()
  }
  isActive() {
    this.raf.isActive()
  }
}
function iq(r, t = !1) {
  const e = r[0].index !== null,
    n = new Set(Object.keys(r[0].attributes)),
    i = new Set(Object.keys(r[0].morphAttributes)),
    a = {},
    o = {},
    s = r[0].morphTargetsRelative,
    l = new Mn()
  let u = 0
  for (let c = 0; c < r.length; ++c) {
    const h = r[c]
    let f = 0
    if (e !== (h.index !== null))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
            c +
            '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',
        ),
        null
      )
    for (const d in h.attributes) {
      if (!n.has(d))
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              c +
              '. All geometries must have compatible attributes; make sure "' +
              d +
              '" attribute exists among all geometries, or in none of them.',
          ),
          null
        )
      a[d] === void 0 && (a[d] = []), a[d].push(h.attributes[d]), f++
    }
    if (f !== n.size)
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
            c +
            '. Make sure all geometries have the same number of attributes.',
        ),
        null
      )
    if (s !== h.morphTargetsRelative)
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
            c +
            '. .morphTargetsRelative must be consistent throughout all geometries.',
        ),
        null
      )
    for (const d in h.morphAttributes) {
      if (!i.has(d))
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              c +
              '.  .morphAttributes must be consistent throughout all geometries.',
          ),
          null
        )
      o[d] === void 0 && (o[d] = []), o[d].push(h.morphAttributes[d])
    }
    if (t) {
      let d
      if (e) d = h.index.count
      else if (h.attributes.position !== void 0) d = h.attributes.position.count
      else
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' +
              c +
              '. The geometry must have either an index or a position attribute',
          ),
          null
        )
      l.addGroup(u, d, c), (u += d)
    }
  }
  if (e) {
    let c = 0
    const h = []
    for (let f = 0; f < r.length; ++f) {
      const d = r[f].index
      for (let p = 0; p < d.count; ++p) h.push(d.getX(p) + c)
      c += r[f].attributes.position.count
    }
    l.setIndex(h)
  }
  for (const c in a) {
    const h = wD(a[c])
    if (!h)
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' +
            c +
            ' attribute.',
        ),
        null
      )
    l.setAttribute(c, h)
  }
  for (const c in o) {
    const h = o[c][0].length
    if (h === 0) break
    ;(l.morphAttributes = l.morphAttributes || {}), (l.morphAttributes[c] = [])
    for (let f = 0; f < h; ++f) {
      const d = []
      for (let g = 0; g < o[c].length; ++g) d.push(o[c][g][f])
      const p = wD(d)
      if (!p)
        return (
          console.error(
            'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' +
              c +
              ' morphAttribute.',
          ),
          null
        )
      l.morphAttributes[c].push(p)
    }
  }
  return l
}
function wD(r) {
  let t,
    e,
    n,
    i = -1,
    a = 0
  for (let u = 0; u < r.length; ++u) {
    const c = r[u]
    if ((t === void 0 && (t = c.array.constructor), t !== c.array.constructor))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',
        ),
        null
      )
    if ((e === void 0 && (e = c.itemSize), e !== c.itemSize))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',
        ),
        null
      )
    if ((n === void 0 && (n = c.normalized), n !== c.normalized))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',
        ),
        null
      )
    if ((i === -1 && (i = c.gpuType), i !== c.gpuType))
      return (
        console.error(
          'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.',
        ),
        null
      )
    a += c.count * e
  }
  const o = new t(a),
    s = new ir(o, e, n)
  let l = 0
  for (let u = 0; u < r.length; ++u) {
    const c = r[u]
    if (c.isInterleavedBufferAttribute) {
      const h = l / e
      for (let f = 0, d = c.count; f < d; f++)
        for (let p = 0; p < e; p++) {
          const g = c.getComponent(f, p)
          s.setComponent(f + h, p, g)
        }
    } else o.set(c.array, l)
    l += c.count * e
  }
  return i !== void 0 && (s.gpuType = i), s
}
function MD(r, t) {
  if (t === a6)
    return (
      console.warn(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.',
      ),
      r
    )
  if (t === XA || t === $k) {
    let e = r.getIndex()
    if (e === null) {
      const o = [],
        s = r.getAttribute('position')
      if (s !== void 0) {
        for (let l = 0; l < s.count; l++) o.push(l)
        r.setIndex(o), (e = r.getIndex())
      } else
        return (
          console.error(
            'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
          ),
          r
        )
    }
    const n = e.count - 2,
      i = []
    if (t === XA)
      for (let o = 1; o <= n; o++)
        i.push(e.getX(0)), i.push(e.getX(o)), i.push(e.getX(o + 1))
    else
      for (let o = 0; o < n; o++)
        o % 2 === 0
          ? (i.push(e.getX(o)), i.push(e.getX(o + 1)), i.push(e.getX(o + 2)))
          : (i.push(e.getX(o + 2)), i.push(e.getX(o + 1)), i.push(e.getX(o)))
    i.length / 3 !== n &&
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
      )
    const a = r.clone()
    return a.setIndex(i), a.clearGroups(), a
  } else
    return (
      console.error(
        'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:',
        t,
      ),
      r
    )
}
class aq extends fl {
  constructor(t) {
    super(t),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new cq(e)
      }),
      this.register(function (e) {
        return new hq(e)
      }),
      this.register(function (e) {
        return new xq(e)
      }),
      this.register(function (e) {
        return new Sq(e)
      }),
      this.register(function (e) {
        return new Aq(e)
      }),
      this.register(function (e) {
        return new dq(e)
      }),
      this.register(function (e) {
        return new pq(e)
      }),
      this.register(function (e) {
        return new vq(e)
      }),
      this.register(function (e) {
        return new gq(e)
      }),
      this.register(function (e) {
        return new uq(e)
      }),
      this.register(function (e) {
        return new mq(e)
      }),
      this.register(function (e) {
        return new fq(e)
      }),
      this.register(function (e) {
        return new _q(e)
      }),
      this.register(function (e) {
        return new yq(e)
      }),
      this.register(function (e) {
        return new sq(e)
      }),
      this.register(function (e) {
        return new bq(e)
      }),
      this.register(function (e) {
        return new wq(e)
      })
  }
  load(t, e, n, i) {
    const a = this
    let o
    if (this.resourcePath !== '') o = this.resourcePath
    else if (this.path !== '') {
      const u = Kd.extractUrlBase(t)
      o = Kd.resolveURL(u, this.path)
    } else o = Kd.extractUrlBase(t)
    this.manager.itemStart(t)
    const s = function (u) {
        i ? i(u) : console.error(u),
          a.manager.itemError(t),
          a.manager.itemEnd(t)
      },
      l = new wp(this.manager)
    l.setPath(this.path),
      l.setResponseType('arraybuffer'),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        t,
        function (u) {
          try {
            a.parse(
              u,
              o,
              function (c) {
                e(c), a.manager.itemEnd(t)
              },
              s,
            )
          } catch (c) {
            s(c)
          }
        },
        n,
        s,
      )
  }
  setDRACOLoader(t) {
    return (this.dracoLoader = t), this
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
    )
  }
  setKTX2Loader(t) {
    return (this.ktx2Loader = t), this
  }
  setMeshoptDecoder(t) {
    return (this.meshoptDecoder = t), this
  }
  register(t) {
    return (
      this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t),
      this
    )
  }
  unregister(t) {
    return (
      this.pluginCallbacks.indexOf(t) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1),
      this
    )
  }
  parse(t, e, n, i) {
    let a
    const o = {},
      s = {},
      l = new TextDecoder()
    if (typeof t == 'string') a = JSON.parse(t)
    else if (t instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(t, 0, 4)) === IB) {
        try {
          o[Me.KHR_BINARY_GLTF] = new Mq(t)
        } catch (h) {
          i && i(h)
          return
        }
        a = JSON.parse(o[Me.KHR_BINARY_GLTF].content)
      } else a = JSON.parse(l.decode(t))
    else a = t
    if (a.asset === void 0 || a.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.',
          ),
        )
      return
    }
    const u = new Fq(a, {
      path: e || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    })
    u.fileLoader.setRequestHeader(this.requestHeader)
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const h = this.pluginCallbacks[c](u)
      h.name ||
        console.error('THREE.GLTFLoader: Invalid plugin found: missing name'),
        (s[h.name] = h),
        (o[h.name] = !0)
    }
    if (a.extensionsUsed)
      for (let c = 0; c < a.extensionsUsed.length; ++c) {
        const h = a.extensionsUsed[c],
          f = a.extensionsRequired || []
        switch (h) {
          case Me.KHR_MATERIALS_UNLIT:
            o[h] = new lq()
            break
          case Me.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new Tq(a, this.dracoLoader)
            break
          case Me.KHR_TEXTURE_TRANSFORM:
            o[h] = new Cq()
            break
          case Me.KHR_MESH_QUANTIZATION:
            o[h] = new Eq()
            break
          default:
            f.indexOf(h) >= 0 &&
              s[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".')
        }
      }
    u.setExtensions(o), u.setPlugins(s), u.parse(n, i)
  }
  parseAsync(t, e) {
    const n = this
    return new Promise(function (i, a) {
      n.parse(t, e, i, a)
    })
  }
}
function oq() {
  let r = {}
  return {
    get: function (t) {
      return r[t]
    },
    add: function (t, e) {
      r[t] = e
    },
    remove: function (t) {
      delete r[t]
    },
    removeAll: function () {
      r = {}
    },
  }
}
const Me = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_MATERIALS_BUMP: 'EXT_materials_bump',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_TEXTURE_AVIF: 'EXT_texture_avif',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',
}
class sq {
  constructor(t) {
    ;(this.parser = t),
      (this.name = Me.KHR_LIGHTS_PUNCTUAL),
      (this.cache = {
        refs: {},
        uses: {},
      })
  }
  _markDefs() {
    const t = this.parser,
      e = this.parser.json.nodes || []
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n]
      a.extensions &&
        a.extensions[this.name] &&
        a.extensions[this.name].light !== void 0 &&
        t._addNodeRef(this.cache, a.extensions[this.name].light)
    }
  }
  _loadLight(t) {
    const e = this.parser,
      n = 'light:' + t
    let i = e.cache.get(n)
    if (i) return i
    const a = e.json,
      l = (((a.extensions && a.extensions[this.name]) || {}).lights || [])[t]
    let u
    const c = new qt(16777215)
    l.color !== void 0 && c.setRGB(l.color[0], l.color[1], l.color[2], ar)
    const h = l.range !== void 0 ? l.range : 0
    switch (l.type) {
      case 'directional':
        ;(u = new Ay(c)), u.target.position.set(0, 0, -1), u.add(u.target)
        break
      case 'point':
        ;(u = new z$(c)), (u.distance = h)
        break
      case 'spot':
        ;(u = new B$(c)),
          (u.distance = h),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (u.angle = l.spot.outerConeAngle),
          (u.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          u.target.position.set(0, 0, -1),
          u.add(u.target)
        break
      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + l.type)
    }
    return (
      u.position.set(0, 0, 0),
      (u.decay = 2),
      Ro(u, l),
      l.intensity !== void 0 && (u.intensity = l.intensity),
      (u.name = e.createUniqueName(l.name || 'light_' + t)),
      (i = Promise.resolve(u)),
      e.cache.add(n, i),
      i
    )
  }
  getDependency(t, e) {
    if (t === 'light') return this._loadLight(e)
  }
  createNodeAttachment(t) {
    const e = this,
      n = this.parser,
      a = n.json.nodes[t],
      s = ((a.extensions && a.extensions[this.name]) || {}).light
    return s === void 0
      ? null
      : this._loadLight(s).then(function (l) {
          return n._getNodeRef(e.cache, s, l)
        })
  }
}
class lq {
  constructor() {
    this.name = Me.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return on
  }
  extendParams(t, e, n) {
    const i = []
    ;(t.color = new qt(1, 1, 1)), (t.opacity = 1)
    const a = e.pbrMetallicRoughness
    if (a) {
      if (Array.isArray(a.baseColorFactor)) {
        const o = a.baseColorFactor
        t.color.setRGB(o[0], o[1], o[2], ar), (t.opacity = o[3])
      }
      a.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(t, 'map', a.baseColorTexture, cn))
    }
    return Promise.all(i)
  }
}
class uq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_EMISSIVE_STRENGTH)
  }
  extendMaterialParams(t, e) {
    const i = this.parser.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = i.extensions[this.name].emissiveStrength
    return a !== void 0 && (e.emissiveIntensity = a), Promise.resolve()
  }
}
class cq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_CLEARCOAT)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    if (
      (o.clearcoatFactor !== void 0 && (e.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        a.push(n.assignTexture(e, 'clearcoatMap', o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (e.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        a.push(
          n.assignTexture(
            e,
            'clearcoatRoughnessMap',
            o.clearcoatRoughnessTexture,
          ),
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (a.push(
          n.assignTexture(e, 'clearcoatNormalMap', o.clearcoatNormalTexture),
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const s = o.clearcoatNormalTexture.scale
      e.clearcoatNormalScale = new pt(s, s)
    }
    return Promise.all(a)
  }
}
class hq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_DISPERSION)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const i = this.parser.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = i.extensions[this.name]
    return (
      (e.dispersion = a.dispersion !== void 0 ? a.dispersion : 0),
      Promise.resolve()
    )
  }
}
class fq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_IRIDESCENCE)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    return (
      o.iridescenceFactor !== void 0 && (e.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        a.push(n.assignTexture(e, 'iridescenceMap', o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (e.iridescenceIOR = o.iridescenceIor),
      e.iridescenceThicknessRange === void 0 &&
        (e.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (e.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (e.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        a.push(
          n.assignTexture(
            e,
            'iridescenceThicknessMap',
            o.iridescenceThicknessTexture,
          ),
        ),
      Promise.all(a)
    )
  }
}
class dq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_SHEEN)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = []
    ;(e.sheenColor = new qt(0, 0, 0)), (e.sheenRoughness = 0), (e.sheen = 1)
    const o = i.extensions[this.name]
    if (o.sheenColorFactor !== void 0) {
      const s = o.sheenColorFactor
      e.sheenColor.setRGB(s[0], s[1], s[2], ar)
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (e.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        a.push(n.assignTexture(e, 'sheenColorMap', o.sheenColorTexture, cn)),
      o.sheenRoughnessTexture !== void 0 &&
        a.push(
          n.assignTexture(e, 'sheenRoughnessMap', o.sheenRoughnessTexture),
        ),
      Promise.all(a)
    )
  }
}
class pq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_TRANSMISSION)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    return (
      o.transmissionFactor !== void 0 &&
        (e.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        a.push(n.assignTexture(e, 'transmissionMap', o.transmissionTexture)),
      Promise.all(a)
    )
  }
}
class vq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_VOLUME)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    ;(e.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        a.push(n.assignTexture(e, 'thicknessMap', o.thicknessTexture)),
      (e.attenuationDistance = o.attenuationDistance || 1 / 0)
    const s = o.attenuationColor || [1, 1, 1]
    return (
      (e.attenuationColor = new qt().setRGB(s[0], s[1], s[2], ar)),
      Promise.all(a)
    )
  }
}
class gq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_IOR)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const i = this.parser.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = i.extensions[this.name]
    return (e.ior = a.ior !== void 0 ? a.ior : 1.5), Promise.resolve()
  }
}
class mq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_SPECULAR)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    ;(e.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        a.push(n.assignTexture(e, 'specularIntensityMap', o.specularTexture))
    const s = o.specularColorFactor || [1, 1, 1]
    return (
      (e.specularColor = new qt().setRGB(s[0], s[1], s[2], ar)),
      o.specularColorTexture !== void 0 &&
        a.push(
          n.assignTexture(e, 'specularColorMap', o.specularColorTexture, cn),
        ),
      Promise.all(a)
    )
  }
}
class yq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.EXT_MATERIALS_BUMP)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    return (
      (e.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 &&
        a.push(n.assignTexture(e, 'bumpMap', o.bumpTexture)),
      Promise.all(a)
    )
  }
}
class _q {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_MATERIALS_ANISOTROPY)
  }
  getMaterialType(t) {
    const n = this.parser.json.materials[t]
    return !n.extensions || !n.extensions[this.name] ? null : mo
  }
  extendMaterialParams(t, e) {
    const n = this.parser,
      i = n.json.materials[t]
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve()
    const a = [],
      o = i.extensions[this.name]
    return (
      o.anisotropyStrength !== void 0 && (e.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (e.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        a.push(n.assignTexture(e, 'anisotropyMap', o.anisotropyTexture)),
      Promise.all(a)
    )
  }
}
class xq {
  constructor(t) {
    ;(this.parser = t), (this.name = Me.KHR_TEXTURE_BASISU)
  }
  loadTexture(t) {
    const e = this.parser,
      n = e.json,
      i = n.textures[t]
    if (!i.extensions || !i.extensions[this.name]) return null
    const a = i.extensions[this.name],
      o = e.options.ktx2Loader
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
        )
      return null
    }
    return e.loadTextureImage(t, a.source, o)
  }
}
class Sq {
  constructor(t) {
    ;(this.parser = t),
      (this.name = Me.EXT_TEXTURE_WEBP),
      (this.isSupported = null)
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      i = n.json,
      a = i.textures[t]
    if (!a.extensions || !a.extensions[e]) return null
    const o = a.extensions[e],
      s = i.images[o.source]
    let l = n.textureLoader
    if (s.uri) {
      const u = n.options.manager.getHandler(s.uri)
      u !== null && (l = u)
    }
    return this.detectSupport().then(function (u) {
      if (u) return n.loadTextureImage(t, o.source, l)
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          'THREE.GLTFLoader: WebP required by asset but unsupported.',
        )
      return n.loadTexture(t)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image()
          ;(e.src =
            'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
            (e.onload = e.onerror =
              function () {
                t(e.height === 1)
              })
        })),
      this.isSupported
    )
  }
}
class Aq {
  constructor(t) {
    ;(this.parser = t),
      (this.name = Me.EXT_TEXTURE_AVIF),
      (this.isSupported = null)
  }
  loadTexture(t) {
    const e = this.name,
      n = this.parser,
      i = n.json,
      a = i.textures[t]
    if (!a.extensions || !a.extensions[e]) return null
    const o = a.extensions[e],
      s = i.images[o.source]
    let l = n.textureLoader
    if (s.uri) {
      const u = n.options.manager.getHandler(s.uri)
      u !== null && (l = u)
    }
    return this.detectSupport().then(function (u) {
      if (u) return n.loadTextureImage(t, o.source, l)
      if (i.extensionsRequired && i.extensionsRequired.indexOf(e) >= 0)
        throw new Error(
          'THREE.GLTFLoader: AVIF required by asset but unsupported.',
        )
      return n.loadTexture(t)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (t) {
          const e = new Image()
          ;(e.src =
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
            (e.onload = e.onerror =
              function () {
                t(e.height === 1)
              })
        })),
      this.isSupported
    )
  }
}
class bq {
  constructor(t) {
    ;(this.name = Me.EXT_MESHOPT_COMPRESSION), (this.parser = t)
  }
  loadBufferView(t) {
    const e = this.parser.json,
      n = e.bufferViews[t]
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        a = this.parser.getDependency('buffer', i.buffer),
        o = this.parser.options.meshoptDecoder
      if (!o || !o.supported) {
        if (
          e.extensionsRequired &&
          e.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
          )
        return null
      }
      return a.then(function (s) {
        const l = i.byteOffset || 0,
          u = i.byteLength || 0,
          c = i.count,
          h = i.byteStride,
          f = new Uint8Array(s, l, u)
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(c, h, f, i.mode, i.filter)
              .then(function (d) {
                return d.buffer
              })
          : o.ready.then(function () {
              const d = new ArrayBuffer(c * h)
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(d),
                  c,
                  h,
                  f,
                  i.mode,
                  i.filter,
                ),
                d
              )
            })
      })
    } else return null
  }
}
class wq {
  constructor(t) {
    ;(this.name = Me.EXT_MESH_GPU_INSTANCING), (this.parser = t)
  }
  createNodeMesh(t) {
    const e = this.parser.json,
      n = e.nodes[t]
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null
    const i = e.meshes[n.mesh]
    for (const u of i.primitives)
      if (
        u.mode !== Bi.TRIANGLES &&
        u.mode !== Bi.TRIANGLE_STRIP &&
        u.mode !== Bi.TRIANGLE_FAN &&
        u.mode !== void 0
      )
        return null
    const o = n.extensions[this.name].attributes,
      s = [],
      l = {}
    for (const u in o)
      s.push(
        this.parser
          .getDependency('accessor', o[u])
          .then(c => ((l[u] = c), l[u])),
      )
    return s.length < 1
      ? null
      : (s.push(this.parser.createNodeMesh(t)),
        Promise.all(s).then(u => {
          const c = u.pop(),
            h = c.isGroup ? c.children : [c],
            f = u[0].count,
            d = []
          for (const p of h) {
            const g = new ae(),
              v = new U(),
              m = new wa(),
              y = new U(1, 1, 1),
              _ = new XY(p.geometry, p.material, f)
            for (let x = 0; x < f; x++)
              l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, x),
                l.ROTATION && m.fromBufferAttribute(l.ROTATION, x),
                l.SCALE && y.fromBufferAttribute(l.SCALE, x),
                _.setMatrixAt(x, g.compose(v, m, y))
            for (const x in l)
              if (x === '_COLOR_0') {
                const A = l[x]
                _.instanceColor = new qA(A.array, A.itemSize, A.normalized)
              } else
                x !== 'TRANSLATION' &&
                  x !== 'ROTATION' &&
                  x !== 'SCALE' &&
                  p.geometry.setAttribute(x, l[x])
            Fe.prototype.copy.call(_, p),
              this.parser.assignFinalMaterial(_),
              d.push(_)
          }
          return c.isGroup ? (c.clear(), c.add(...d), c) : d[0]
        }))
  }
}
const IB = 'glTF',
  $f = 12,
  TD = {
    JSON: 1313821514,
    BIN: 5130562,
  }
class Mq {
  constructor(t) {
    ;(this.name = Me.KHR_BINARY_GLTF), (this.content = null), (this.body = null)
    const e = new DataView(t, 0, $f),
      n = new TextDecoder()
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(t.slice(0, 4))),
        version: e.getUint32(4, !0),
        length: e.getUint32(8, !0),
      }),
      this.header.magic !== IB)
    )
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
    if (this.header.version < 2)
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
    const i = this.header.length - $f,
      a = new DataView(t, $f)
    let o = 0
    for (; o < i; ) {
      const s = a.getUint32(o, !0)
      o += 4
      const l = a.getUint32(o, !0)
      if (((o += 4), l === TD.JSON)) {
        const u = new Uint8Array(t, $f + o, s)
        this.content = n.decode(u)
      } else if (l === TD.BIN) {
        const u = $f + o
        this.body = t.slice(u, u + s)
      }
      o += s
    }
    if (this.content === null)
      throw new Error('THREE.GLTFLoader: JSON content not found.')
  }
}
class Tq {
  constructor(t, e) {
    if (!e)
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
    ;(this.name = Me.KHR_DRACO_MESH_COMPRESSION),
      (this.json = t),
      (this.dracoLoader = e),
      this.dracoLoader.preload()
  }
  decodePrimitive(t, e) {
    const n = this.json,
      i = this.dracoLoader,
      a = t.extensions[this.name].bufferView,
      o = t.extensions[this.name].attributes,
      s = {},
      l = {},
      u = {}
    for (const c in o) {
      const h = tb[c] || c.toLowerCase()
      s[h] = o[c]
    }
    for (const c in t.attributes) {
      const h = tb[c] || c.toLowerCase()
      if (o[c] !== void 0) {
        const f = n.accessors[t.attributes[c]],
          d = Ch[f.componentType]
        ;(u[h] = d.name), (l[h] = f.normalized === !0)
      }
    }
    return e.getDependency('bufferView', a).then(function (c) {
      return new Promise(function (h, f) {
        i.decodeDracoFile(
          c,
          function (d) {
            for (const p in d.attributes) {
              const g = d.attributes[p],
                v = l[p]
              v !== void 0 && (g.normalized = v)
            }
            h(d)
          },
          s,
          u,
          ar,
          f,
        )
      })
    })
  }
}
class Cq {
  constructor() {
    this.name = Me.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(t, e) {
    return (
      ((e.texCoord === void 0 || e.texCoord === t.channel) &&
        e.offset === void 0 &&
        e.rotation === void 0 &&
        e.scale === void 0) ||
        ((t = t.clone()),
        e.texCoord !== void 0 && (t.channel = e.texCoord),
        e.offset !== void 0 && t.offset.fromArray(e.offset),
        e.rotation !== void 0 && (t.rotation = e.rotation),
        e.scale !== void 0 && t.repeat.fromArray(e.scale),
        (t.needsUpdate = !0)),
      t
    )
  }
}
class Eq {
  constructor() {
    this.name = Me.KHR_MESH_QUANTIZATION
  }
}
class OB extends pv {
  constructor(t, e, n, i) {
    super(t, e, n, i)
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      a = t * i * 3 + i
    for (let o = 0; o !== i; o++) e[o] = n[a + o]
    return e
  }
  interpolate_(t, e, n, i) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      s = this.valueSize,
      l = s * 2,
      u = s * 3,
      c = i - e,
      h = (n - e) / c,
      f = h * h,
      d = f * h,
      p = t * u,
      g = p - u,
      v = -2 * d + 3 * f,
      m = d - f,
      y = 1 - v,
      _ = m - f + h
    for (let x = 0; x !== s; x++) {
      const A = o[g + x + s],
        S = o[g + x + l] * c,
        b = o[p + x + s],
        T = o[p + x] * c
      a[x] = y * A + _ * S + v * b + m * T
    }
    return a
  }
}
const Dq = new wa()
class Lq extends OB {
  interpolate_(t, e, n, i) {
    const a = super.interpolate_(t, e, n, i)
    return Dq.fromArray(a).normalize().toArray(a), a
  }
}
const Bi = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Ch = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  CD = {
    9728: Ur,
    9729: gi,
    9984: Bk,
    9985: Im,
    9986: Cd,
    9987: Fo,
  },
  ED = {
    33071: Ps,
    33648: py,
    10497: Jn,
  },
  mx = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
  },
  tb = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv1',
    TEXCOORD_2: 'uv2',
    TEXCOORD_3: 'uv3',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex',
  },
  vs = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences',
  },
  Pq = {
    CUBICSPLINE: void 0,
    LINEAR: yp,
    STEP: mp,
  },
  yx = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND',
  }
function Rq(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new Th({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: $o,
      })),
    r.DefaultMaterial
  )
}
function Tl(r, t, e) {
  for (const n in e.extensions)
    r[n] === void 0 &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[n] = e.extensions[n]))
}
function Ro(r, t) {
  t.extras !== void 0 &&
    (typeof t.extras == 'object'
      ? Object.assign(r.userData, t.extras)
      : console.warn(
          'THREE.GLTFLoader: Ignoring primitive type .extras, ' + t.extras,
        ))
}
function Iq(r, t, e) {
  let n = !1,
    i = !1,
    a = !1
  for (let u = 0, c = t.length; u < c; u++) {
    const h = t[u]
    if (
      (h.POSITION !== void 0 && (n = !0),
      h.NORMAL !== void 0 && (i = !0),
      h.COLOR_0 !== void 0 && (a = !0),
      n && i && a)
    )
      break
  }
  if (!n && !i && !a) return Promise.resolve(r)
  const o = [],
    s = [],
    l = []
  for (let u = 0, c = t.length; u < c; u++) {
    const h = t[u]
    if (n) {
      const f =
        h.POSITION !== void 0
          ? e.getDependency('accessor', h.POSITION)
          : r.attributes.position
      o.push(f)
    }
    if (i) {
      const f =
        h.NORMAL !== void 0
          ? e.getDependency('accessor', h.NORMAL)
          : r.attributes.normal
      s.push(f)
    }
    if (a) {
      const f =
        h.COLOR_0 !== void 0
          ? e.getDependency('accessor', h.COLOR_0)
          : r.attributes.color
      l.push(f)
    }
  }
  return Promise.all([Promise.all(o), Promise.all(s), Promise.all(l)]).then(
    function (u) {
      const c = u[0],
        h = u[1],
        f = u[2]
      return (
        n && (r.morphAttributes.position = c),
        i && (r.morphAttributes.normal = h),
        a && (r.morphAttributes.color = f),
        (r.morphTargetsRelative = !0),
        r
      )
    },
  )
}
function Oq(r, t) {
  if ((r.updateMorphTargets(), t.weights !== void 0))
    for (let e = 0, n = t.weights.length; e < n; e++)
      r.morphTargetInfluences[e] = t.weights[e]
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const e = t.extras.targetNames
    if (r.morphTargetInfluences.length === e.length) {
      r.morphTargetDictionary = {}
      for (let n = 0, i = e.length; n < i; n++)
        r.morphTargetDictionary[e[n]] = n
    } else
      console.warn(
        'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.',
      )
  }
}
function Nq(r) {
  let t
  const e = r.extensions && r.extensions[Me.KHR_DRACO_MESH_COMPRESSION]
  if (
    (e
      ? (t = 'draco:' + e.bufferView + ':' + e.indices + ':' + _x(e.attributes))
      : (t = r.indices + ':' + _x(r.attributes) + ':' + r.mode),
    r.targets !== void 0)
  )
    for (let n = 0, i = r.targets.length; n < i; n++)
      t += ':' + _x(r.targets[n])
  return t
}
function _x(r) {
  let t = ''
  const e = Object.keys(r).sort()
  for (let n = 0, i = e.length; n < i; n++) t += e[n] + ':' + r[e[n]] + ';'
  return t
}
function eb(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error(
        'THREE.GLTFLoader: Unsupported normalized accessor component type.',
      )
  }
}
function kq(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? 'image/jpeg'
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? 'image/webp'
    : 'image/png'
}
const Bq = new ae()
class Fq {
  constructor(t = {}, e = {}) {
    ;(this.json = t),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = e),
      (this.cache = new oq()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = {
        refs: {},
        uses: {},
      }),
      (this.cameraCache = {
        refs: {},
        uses: {},
      }),
      (this.lightCache = {
        refs: {},
        uses: {},
      }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {})
    let n = !1,
      i = -1,
      a = !1,
      o = -1
    if (typeof navigator < 'u') {
      const s = navigator.userAgent
      n = /^((?!chrome|android).)*safari/i.test(s) === !0
      const l = s.match(/Version\/(\d+)/)
      ;(i = n && l ? parseInt(l[1], 10) : -1),
        (a = s.indexOf('Firefox') > -1),
        (o = a ? s.match(/Firefox\/([0-9]+)\./)[1] : -1)
    }
    typeof createImageBitmap > 'u' || (n && i < 17) || (a && o < 98)
      ? (this.textureLoader = new ZM(this.options.manager))
      : (this.textureLoader = new G$(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new wp(this.options.manager)),
      this.fileLoader.setResponseType('arraybuffer'),
      this.options.crossOrigin === 'use-credentials' &&
        this.fileLoader.setWithCredentials(!0)
  }
  setExtensions(t) {
    this.extensions = t
  }
  setPlugins(t) {
    this.plugins = t
  }
  parse(t, e) {
    const n = this,
      i = this.json,
      a = this.extensions
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs()
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot()
        }),
      )
        .then(function () {
          return Promise.all([
            n.getDependencies('scene'),
            n.getDependencies('animation'),
            n.getDependencies('camera'),
          ])
        })
        .then(function (o) {
          const s = {
            scene: o[0][i.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: i.asset,
            parser: n,
            userData: {},
          }
          return (
            Tl(a, s, i),
            Ro(s, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(s)
              }),
            ).then(function () {
              for (const l of s.scenes) l.updateMatrixWorld()
              t(s)
            })
          )
        })
        .catch(e)
  }
  _markDefs() {
    const t = this.json.nodes || [],
      e = this.json.skins || [],
      n = this.json.meshes || []
    for (let i = 0, a = e.length; i < a; i++) {
      const o = e[i].joints
      for (let s = 0, l = o.length; s < l; s++) t[o[s]].isBone = !0
    }
    for (let i = 0, a = t.length; i < a; i++) {
      const o = t[i]
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
    }
  }
  _addNodeRef(t, e) {
    e !== void 0 &&
      (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
  }
  _getNodeRef(t, e, n) {
    if (t.refs[e] <= 1) return n
    const i = n.clone(),
      a = (o, s) => {
        const l = this.associations.get(o)
        l != null && this.associations.set(s, l)
        for (const [u, c] of o.children.entries()) a(c, s.children[u])
      }
    return a(n, i), (i.name += '_instance_' + t.uses[e]++), i
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins)
    e.push(this)
    for (let n = 0; n < e.length; n++) {
      const i = t(e[n])
      if (i) return i
    }
    return null
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins)
    e.unshift(this)
    const n = []
    for (let i = 0; i < e.length; i++) {
      const a = t(e[i])
      a && n.push(a)
    }
    return n
  }
  getDependency(t, e) {
    const n = t + ':' + e
    let i = this.cache.get(n)
    if (!i) {
      switch (t) {
        case 'scene':
          i = this.loadScene(e)
          break
        case 'node':
          i = this._invokeOne(function (a) {
            return a.loadNode && a.loadNode(e)
          })
          break
        case 'mesh':
          i = this._invokeOne(function (a) {
            return a.loadMesh && a.loadMesh(e)
          })
          break
        case 'accessor':
          i = this.loadAccessor(e)
          break
        case 'bufferView':
          i = this._invokeOne(function (a) {
            return a.loadBufferView && a.loadBufferView(e)
          })
          break
        case 'buffer':
          i = this.loadBuffer(e)
          break
        case 'material':
          i = this._invokeOne(function (a) {
            return a.loadMaterial && a.loadMaterial(e)
          })
          break
        case 'texture':
          i = this._invokeOne(function (a) {
            return a.loadTexture && a.loadTexture(e)
          })
          break
        case 'skin':
          i = this.loadSkin(e)
          break
        case 'animation':
          i = this._invokeOne(function (a) {
            return a.loadAnimation && a.loadAnimation(e)
          })
          break
        case 'camera':
          i = this.loadCamera(e)
          break
        default:
          if (
            ((i = this._invokeOne(function (a) {
              return a != this && a.getDependency && a.getDependency(t, e)
            })),
            !i)
          )
            throw new Error('Unknown type: ' + t)
          break
      }
      this.cache.add(n, i)
    }
    return i
  }
  getDependencies(t) {
    let e = this.cache.get(t)
    if (!e) {
      const n = this,
        i = this.json[t + (t === 'mesh' ? 'es' : 's')] || []
      ;(e = Promise.all(
        i.map(function (a, o) {
          return n.getDependency(t, o)
        }),
      )),
        this.cache.add(t, e)
    }
    return e
  }
  loadBuffer(t) {
    const e = this.json.buffers[t],
      n = this.fileLoader
    if (e.type && e.type !== 'arraybuffer')
      throw new Error(
        'THREE.GLTFLoader: ' + e.type + ' buffer type is not supported.',
      )
    if (e.uri === void 0 && t === 0)
      return Promise.resolve(this.extensions[Me.KHR_BINARY_GLTF].body)
    const i = this.options
    return new Promise(function (a, o) {
      n.load(Kd.resolveURL(e.uri, i.path), a, void 0, function () {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
      })
    })
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t]
    return this.getDependency('buffer', e.buffer).then(function (n) {
      const i = e.byteLength || 0,
        a = e.byteOffset || 0
      return n.slice(a, a + i)
    })
  }
  loadAccessor(t) {
    const e = this,
      n = this.json,
      i = this.json.accessors[t]
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = mx[i.type],
        s = Ch[i.componentType],
        l = i.normalized === !0,
        u = new s(i.count * o)
      return Promise.resolve(new ir(u, o, l))
    }
    const a = []
    return (
      i.bufferView !== void 0
        ? a.push(this.getDependency('bufferView', i.bufferView))
        : a.push(null),
      i.sparse !== void 0 &&
        (a.push(this.getDependency('bufferView', i.sparse.indices.bufferView)),
        a.push(this.getDependency('bufferView', i.sparse.values.bufferView))),
      Promise.all(a).then(function (o) {
        const s = o[0],
          l = mx[i.type],
          u = Ch[i.componentType],
          c = u.BYTES_PER_ELEMENT,
          h = c * l,
          f = i.byteOffset || 0,
          d =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          p = i.normalized === !0
        let g, v
        if (d && d !== h) {
          const m = Math.floor(f / d),
            y =
              'InterleavedBuffer:' +
              i.bufferView +
              ':' +
              i.componentType +
              ':' +
              m +
              ':' +
              i.count
          let _ = e.cache.get(y)
          _ ||
            ((g = new u(s, m * d, (i.count * d) / c)),
            (_ = new UM(g, d / c)),
            e.cache.add(y, _)),
            (v = new _a(_, l, (f % d) / c, p))
        } else s === null ? (g = new u(i.count * l)) : (g = new u(s, f, i.count * l)), (v = new ir(g, l, p))
        if (i.sparse !== void 0) {
          const m = mx.SCALAR,
            y = Ch[i.sparse.indices.componentType],
            _ = i.sparse.indices.byteOffset || 0,
            x = i.sparse.values.byteOffset || 0,
            A = new y(o[1], _, i.sparse.count * m),
            S = new u(o[2], x, i.sparse.count * l)
          s !== null && (v = new ir(v.array.slice(), v.itemSize, v.normalized))
          for (let b = 0, T = A.length; b < T; b++) {
            const w = A[b]
            if (
              (v.setX(w, S[b * l]),
              l >= 2 && v.setY(w, S[b * l + 1]),
              l >= 3 && v.setZ(w, S[b * l + 2]),
              l >= 4 && v.setW(w, S[b * l + 3]),
              l >= 5)
            )
              throw new Error(
                'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
              )
          }
        }
        return v
      })
    )
  }
  loadTexture(t) {
    const e = this.json,
      n = this.options,
      a = e.textures[t].source,
      o = e.images[a]
    let s = this.textureLoader
    if (o.uri) {
      const l = n.manager.getHandler(o.uri)
      l !== null && (s = l)
    }
    return this.loadTextureImage(t, a, s)
  }
  loadTextureImage(t, e, n) {
    const i = this,
      a = this.json,
      o = a.textures[t],
      s = a.images[e],
      l = (s.uri || s.bufferView) + ':' + o.sampler
    if (this.textureCache[l]) return this.textureCache[l]
    const u = this.loadImageSource(e, n)
      .then(function (c) {
        ;(c.flipY = !1),
          (c.name = o.name || s.name || ''),
          c.name === '' &&
            typeof s.uri == 'string' &&
            s.uri.startsWith('data:image/') === !1 &&
            (c.name = s.uri)
        const f = (a.samplers || {})[o.sampler] || {}
        return (
          (c.magFilter = CD[f.magFilter] || gi),
          (c.minFilter = CD[f.minFilter] || Fo),
          (c.wrapS = ED[f.wrapS] || Jn),
          (c.wrapT = ED[f.wrapT] || Jn),
          i.associations.set(c, {
            textures: t,
          }),
          c
        )
      })
      .catch(function () {
        return null
      })
    return (this.textureCache[l] = u), u
  }
  loadImageSource(t, e) {
    const n = this,
      i = this.json,
      a = this.options
    if (this.sourceCache[t] !== void 0)
      return this.sourceCache[t].then(h => h.clone())
    const o = i.images[t],
      s = self.URL || self.webkitURL
    let l = o.uri || '',
      u = !1
    if (o.bufferView !== void 0)
      l = n.getDependency('bufferView', o.bufferView).then(function (h) {
        u = !0
        const f = new Blob([h], {
          type: o.mimeType,
        })
        return (l = s.createObjectURL(f)), l
      })
    else if (o.uri === void 0)
      throw new Error(
        'THREE.GLTFLoader: Image ' + t + ' is missing URI and bufferView',
      )
    const c = Promise.resolve(l)
      .then(function (h) {
        return new Promise(function (f, d) {
          let p = f
          e.isImageBitmapLoader === !0 &&
            (p = function (g) {
              const v = new Yn(g)
              ;(v.needsUpdate = !0), f(v)
            }),
            e.load(Kd.resolveURL(h, a.path), p, void 0, d)
        })
      })
      .then(function (h) {
        return (
          u === !0 && s.revokeObjectURL(l),
          Ro(h, o),
          (h.userData.mimeType = o.mimeType || kq(o.uri)),
          h
        )
      })
      .catch(function (h) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), h)
      })
    return (this.sourceCache[t] = c), c
  }
  assignTexture(t, e, n, i) {
    const a = this
    return this.getDependency('texture', n.index).then(function (o) {
      if (!o) return null
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((o = o.clone()), (o.channel = n.texCoord)),
        a.extensions[Me.KHR_TEXTURE_TRANSFORM])
      ) {
        const s =
          n.extensions !== void 0
            ? n.extensions[Me.KHR_TEXTURE_TRANSFORM]
            : void 0
        if (s) {
          const l = a.associations.get(o)
          ;(o = a.extensions[Me.KHR_TEXTURE_TRANSFORM].extendTexture(o, s)),
            a.associations.set(o, l)
        }
      }
      return i !== void 0 && (o.colorSpace = i), (t[e] = o), o
    })
  }
  assignFinalMaterial(t) {
    const e = t.geometry
    let n = t.material
    const i = e.attributes.tangent === void 0,
      a = e.attributes.color !== void 0,
      o = e.attributes.normal === void 0
    if (t.isPoints) {
      const s = 'PointsMaterial:' + n.uuid
      let l = this.cache.get(s)
      l ||
        ((l = new HM()),
        ji.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(s, l)),
        (n = l)
    } else if (t.isLine) {
      const s = 'LineBasicMaterial:' + n.uuid
      let l = this.cache.get(s)
      l ||
        ((l = new dv()),
        ji.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        this.cache.add(s, l)),
        (n = l)
    }
    if (i || a || o) {
      let s = 'ClonedMaterial:' + n.uuid + ':'
      i && (s += 'derivative-tangents:'),
        a && (s += 'vertex-colors:'),
        o && (s += 'flat-shading:')
      let l = this.cache.get(s)
      l ||
        ((l = n.clone()),
        a && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(s, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l)
    }
    t.material = n
  }
  getMaterialType() {
    return Th
  }
  loadMaterial(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      a = n.materials[t]
    let o
    const s = {},
      l = a.extensions || {},
      u = []
    if (l[Me.KHR_MATERIALS_UNLIT]) {
      const h = i[Me.KHR_MATERIALS_UNLIT]
      ;(o = h.getMaterialType()), u.push(h.extendParams(s, a, e))
    } else {
      const h = a.pbrMetallicRoughness || {}
      if (
        ((s.color = new qt(1, 1, 1)),
        (s.opacity = 1),
        Array.isArray(h.baseColorFactor))
      ) {
        const f = h.baseColorFactor
        s.color.setRGB(f[0], f[1], f[2], ar), (s.opacity = f[3])
      }
      h.baseColorTexture !== void 0 &&
        u.push(e.assignTexture(s, 'map', h.baseColorTexture, cn)),
        (s.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1),
        (s.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
        h.metallicRoughnessTexture !== void 0 &&
          (u.push(
            e.assignTexture(s, 'metalnessMap', h.metallicRoughnessTexture),
          ),
          u.push(
            e.assignTexture(s, 'roughnessMap', h.metallicRoughnessTexture),
          )),
        (o = this._invokeOne(function (f) {
          return f.getMaterialType && f.getMaterialType(t)
        })),
        u.push(
          Promise.all(
            this._invokeAll(function (f) {
              return f.extendMaterialParams && f.extendMaterialParams(t, s)
            }),
          ),
        )
    }
    a.doubleSided === !0 && (s.side = dr)
    const c = a.alphaMode || yx.OPAQUE
    if (
      (c === yx.BLEND
        ? ((s.transparent = !0), (s.depthWrite = !1))
        : ((s.transparent = !1),
          c === yx.MASK &&
            (s.alphaTest = a.alphaCutoff !== void 0 ? a.alphaCutoff : 0.5)),
      a.normalTexture !== void 0 &&
        o !== on &&
        (u.push(e.assignTexture(s, 'normalMap', a.normalTexture)),
        (s.normalScale = new pt(1, 1)),
        a.normalTexture.scale !== void 0))
    ) {
      const h = a.normalTexture.scale
      s.normalScale.set(h, h)
    }
    if (
      (a.occlusionTexture !== void 0 &&
        o !== on &&
        (u.push(e.assignTexture(s, 'aoMap', a.occlusionTexture)),
        a.occlusionTexture.strength !== void 0 &&
          (s.aoMapIntensity = a.occlusionTexture.strength)),
      a.emissiveFactor !== void 0 && o !== on)
    ) {
      const h = a.emissiveFactor
      s.emissive = new qt().setRGB(h[0], h[1], h[2], ar)
    }
    return (
      a.emissiveTexture !== void 0 &&
        o !== on &&
        u.push(e.assignTexture(s, 'emissiveMap', a.emissiveTexture, cn)),
      Promise.all(u).then(function () {
        const h = new o(s)
        return (
          a.name && (h.name = a.name),
          Ro(h, a),
          e.associations.set(h, {
            materials: t,
          }),
          a.extensions && Tl(i, h, a),
          h
        )
      })
    )
  }
  createUniqueName(t) {
    const e = Xe.sanitizeNodeName(t || '')
    return e in this.nodeNamesUsed
      ? e + '_' + ++this.nodeNamesUsed[e]
      : ((this.nodeNamesUsed[e] = 0), e)
  }
  loadGeometries(t) {
    const e = this,
      n = this.extensions,
      i = this.primitiveCache
    function a(s) {
      return n[Me.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(s, e)
        .then(function (l) {
          return DD(l, s, e)
        })
    }
    const o = []
    for (let s = 0, l = t.length; s < l; s++) {
      const u = t[s],
        c = Nq(u),
        h = i[c]
      if (h) o.push(h.promise)
      else {
        let f
        u.extensions && u.extensions[Me.KHR_DRACO_MESH_COMPRESSION]
          ? (f = a(u))
          : (f = DD(new Mn(), u, e)),
          (i[c] = {
            primitive: u,
            promise: f,
          }),
          o.push(f)
      }
    }
    return Promise.all(o)
  }
  loadMesh(t) {
    const e = this,
      n = this.json,
      i = this.extensions,
      a = n.meshes[t],
      o = a.primitives,
      s = []
    for (let l = 0, u = o.length; l < u; l++) {
      const c =
        o[l].material === void 0
          ? Rq(this.cache)
          : this.getDependency('material', o[l].material)
      s.push(c)
    }
    return (
      s.push(e.loadGeometries(o)),
      Promise.all(s).then(function (l) {
        const u = l.slice(0, l.length - 1),
          c = l[l.length - 1],
          h = []
        for (let d = 0, p = c.length; d < p; d++) {
          const g = c[d],
            v = o[d]
          let m
          const y = u[d]
          if (
            v.mode === Bi.TRIANGLES ||
            v.mode === Bi.TRIANGLE_STRIP ||
            v.mode === Bi.TRIANGLE_FAN ||
            v.mode === void 0
          )
            (m = a.isSkinnedMesh === !0 ? new GY(g, y) : new De(g, y)),
              m.isSkinnedMesh === !0 && m.normalizeSkinWeights(),
              v.mode === Bi.TRIANGLE_STRIP
                ? (m.geometry = MD(m.geometry, $k))
                : v.mode === Bi.TRIANGLE_FAN &&
                  (m.geometry = MD(m.geometry, XA))
          else if (v.mode === Bi.LINES) m = new gB(g, y)
          else if (v.mode === Bi.LINE_STRIP) m = new GM(g, y)
          else if (v.mode === Bi.LINE_LOOP) m = new mB(g, y)
          else if (v.mode === Bi.POINTS) m = new yB(g, y)
          else
            throw new Error(
              'THREE.GLTFLoader: Primitive mode unsupported: ' + v.mode,
            )
          Object.keys(m.geometry.morphAttributes).length > 0 && Oq(m, a),
            (m.name = e.createUniqueName(a.name || 'mesh_' + t)),
            Ro(m, a),
            v.extensions && Tl(i, m, v),
            e.assignFinalMaterial(m),
            h.push(m)
        }
        for (let d = 0, p = h.length; d < p; d++)
          e.associations.set(h[d], {
            meshes: t,
            primitives: d,
          })
        if (h.length === 1) return a.extensions && Tl(i, h[0], a), h[0]
        const f = new un()
        a.extensions && Tl(i, f, a),
          e.associations.set(f, {
            meshes: t,
          })
        for (let d = 0, p = h.length; d < p; d++) f.add(h[d])
        return f
      })
    )
  }
  loadCamera(t) {
    let e
    const n = this.json.cameras[t],
      i = n[n.type]
    if (!i) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.')
      return
    }
    return (
      n.type === 'perspective'
        ? (e = new wr(
            IM.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6,
          ))
        : n.type === 'orthographic' &&
          (e = new O0(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (e.name = this.createUniqueName(n.name)),
      Ro(e, n),
      Promise.resolve(e)
    )
  }
  loadSkin(t) {
    const e = this.json.skins[t],
      n = []
    for (let i = 0, a = e.joints.length; i < a; i++)
      n.push(this._loadNodeShallow(e.joints[i]))
    return (
      e.inverseBindMatrices !== void 0
        ? n.push(this.getDependency('accessor', e.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const a = i.pop(),
          o = i,
          s = [],
          l = []
        for (let u = 0, c = o.length; u < c; u++) {
          const h = o[u]
          if (h) {
            s.push(h)
            const f = new ae()
            a !== null && f.fromArray(a.array, u * 16), l.push(f)
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              e.joints[u],
            )
        }
        return new VM(s, l)
      })
    )
  }
  loadAnimation(t) {
    const e = this.json,
      n = this,
      i = e.animations[t],
      a = i.name ? i.name : 'animation_' + t,
      o = [],
      s = [],
      l = [],
      u = [],
      c = []
    for (let h = 0, f = i.channels.length; h < f; h++) {
      const d = i.channels[h],
        p = i.samplers[d.sampler],
        g = d.target,
        v = g.node,
        m = i.parameters !== void 0 ? i.parameters[p.input] : p.input,
        y = i.parameters !== void 0 ? i.parameters[p.output] : p.output
      g.node !== void 0 &&
        (o.push(this.getDependency('node', v)),
        s.push(this.getDependency('accessor', m)),
        l.push(this.getDependency('accessor', y)),
        u.push(p),
        c.push(g))
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(s),
      Promise.all(l),
      Promise.all(u),
      Promise.all(c),
    ]).then(function (h) {
      const f = h[0],
        d = h[1],
        p = h[2],
        g = h[3],
        v = h[4],
        m = []
      for (let y = 0, _ = f.length; y < _; y++) {
        const x = f[y],
          A = d[y],
          S = p[y],
          b = g[y],
          T = v[y]
        if (x === void 0) continue
        x.updateMatrix && x.updateMatrix()
        const w = n._createAnimationTracks(x, A, S, b, T)
        if (w) for (let M = 0; M < w.length; M++) m.push(w[M])
      }
      return new L$(a, void 0, m)
    })
  }
  createNodeMesh(t) {
    const e = this.json,
      n = this,
      i = e.nodes[t]
    return i.mesh === void 0
      ? null
      : n.getDependency('mesh', i.mesh).then(function (a) {
          const o = n._getNodeRef(n.meshCache, i.mesh, a)
          return (
            i.weights !== void 0 &&
              o.traverse(function (s) {
                if (s.isMesh)
                  for (let l = 0, u = i.weights.length; l < u; l++)
                    s.morphTargetInfluences[l] = i.weights[l]
              }),
            o
          )
        })
  }
  loadNode(t) {
    const e = this.json,
      n = this,
      i = e.nodes[t],
      a = n._loadNodeShallow(t),
      o = [],
      s = i.children || []
    for (let u = 0, c = s.length; u < c; u++)
      o.push(n.getDependency('node', s[u]))
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency('skin', i.skin)
    return Promise.all([a, Promise.all(o), l]).then(function (u) {
      const c = u[0],
        h = u[1],
        f = u[2]
      f !== null &&
        c.traverse(function (d) {
          d.isSkinnedMesh && d.bind(f, Bq)
        })
      for (let d = 0, p = h.length; d < p; d++) c.add(h[d])
      return c
    })
  }
  _loadNodeShallow(t) {
    const e = this.json,
      n = this.extensions,
      i = this
    if (this.nodeCache[t] !== void 0) return this.nodeCache[t]
    const a = e.nodes[t],
      o = a.name ? i.createUniqueName(a.name) : '',
      s = [],
      l = i._invokeOne(function (u) {
        return u.createNodeMesh && u.createNodeMesh(t)
      })
    return (
      l && s.push(l),
      a.camera !== void 0 &&
        s.push(
          i.getDependency('camera', a.camera).then(function (u) {
            return i._getNodeRef(i.cameraCache, a.camera, u)
          }),
        ),
      i
        ._invokeAll(function (u) {
          return u.createNodeAttachment && u.createNodeAttachment(t)
        })
        .forEach(function (u) {
          s.push(u)
        }),
      (this.nodeCache[t] = Promise.all(s).then(function (u) {
        let c
        if (
          (a.isBone === !0
            ? (c = new pB())
            : u.length > 1
            ? (c = new un())
            : u.length === 1
            ? (c = u[0])
            : (c = new Fe()),
          c !== u[0])
        )
          for (let h = 0, f = u.length; h < f; h++) c.add(u[h])
        if (
          (a.name && ((c.userData.name = a.name), (c.name = o)),
          Ro(c, a),
          a.extensions && Tl(n, c, a),
          a.matrix !== void 0)
        ) {
          const h = new ae()
          h.fromArray(a.matrix), c.applyMatrix4(h)
        } else a.translation !== void 0 && c.position.fromArray(a.translation), a.rotation !== void 0 && c.quaternion.fromArray(a.rotation), a.scale !== void 0 && c.scale.fromArray(a.scale)
        return (
          i.associations.has(c) || i.associations.set(c, {}),
          (i.associations.get(c).nodes = t),
          c
        )
      })),
      this.nodeCache[t]
    )
  }
  loadScene(t) {
    const e = this.extensions,
      n = this.json.scenes[t],
      i = this,
      a = new un()
    n.name && (a.name = i.createUniqueName(n.name)),
      Ro(a, n),
      n.extensions && Tl(e, a, n)
    const o = n.nodes || [],
      s = []
    for (let l = 0, u = o.length; l < u; l++)
      s.push(i.getDependency('node', o[l]))
    return Promise.all(s).then(function (l) {
      for (let c = 0, h = l.length; c < h; c++) a.add(l[c])
      const u = c => {
        const h = new Map()
        for (const [f, d] of i.associations)
          (f instanceof ji || f instanceof Yn) && h.set(f, d)
        return (
          c.traverse(f => {
            const d = i.associations.get(f)
            d != null && h.set(f, d)
          }),
          h
        )
      }
      return (i.associations = u(a)), a
    })
  }
  _createAnimationTracks(t, e, n, i, a) {
    const o = [],
      s = t.name ? t.name : t.uuid,
      l = []
    vs[a.path] === vs.weights
      ? t.traverse(function (f) {
          f.morphTargetInfluences && l.push(f.name ? f.name : f.uuid)
        })
      : l.push(s)
    let u
    switch (vs[a.path]) {
      case vs.weights:
        u = Wh
        break
      case vs.rotation:
        u = Xh
        break
      case vs.position:
      case vs.scale:
        u = Yh
        break
      default:
        switch (n.itemSize) {
          case 1:
            u = Wh
            break
          case 2:
          case 3:
          default:
            u = Yh
            break
        }
        break
    }
    const c = i.interpolation !== void 0 ? Pq[i.interpolation] : yp,
      h = this._getArrayFromAccessor(n)
    for (let f = 0, d = l.length; f < d; f++) {
      const p = new u(l[f] + '.' + vs[a.path], e.array, h, c)
      i.interpolation === 'CUBICSPLINE' &&
        this._createCubicSplineTrackInterpolant(p),
        o.push(p)
    }
    return o
  }
  _getArrayFromAccessor(t) {
    let e = t.array
    if (t.normalized) {
      const n = eb(e.constructor),
        i = new Float32Array(e.length)
      for (let a = 0, o = e.length; a < o; a++) i[a] = e[a] * n
      e = i
    }
    return e
  }
  _createCubicSplineTrackInterpolant(t) {
    ;(t.createInterpolant = function (n) {
      const i = this instanceof Xh ? Lq : OB
      return new i(this.times, this.values, this.getValueSize() / 3, n)
    }),
      (t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)
  }
}
function zq(r, t, e) {
  const n = t.attributes,
    i = new Ei()
  if (n.POSITION !== void 0) {
    const s = e.json.accessors[n.POSITION],
      l = s.min,
      u = s.max
    if (l !== void 0 && u !== void 0) {
      if (
        (i.set(new U(l[0], l[1], l[2]), new U(u[0], u[1], u[2])), s.normalized)
      ) {
        const c = eb(Ch[s.componentType])
        i.min.multiplyScalar(c), i.max.multiplyScalar(c)
      }
    } else {
      console.warn(
        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
      )
      return
    }
  } else return
  const a = t.targets
  if (a !== void 0) {
    const s = new U(),
      l = new U()
    for (let u = 0, c = a.length; u < c; u++) {
      const h = a[u]
      if (h.POSITION !== void 0) {
        const f = e.json.accessors[h.POSITION],
          d = f.min,
          p = f.max
        if (d !== void 0 && p !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(d[0]), Math.abs(p[0]))),
            l.setY(Math.max(Math.abs(d[1]), Math.abs(p[1]))),
            l.setZ(Math.max(Math.abs(d[2]), Math.abs(p[2]))),
            f.normalized)
          ) {
            const g = eb(Ch[f.componentType])
            l.multiplyScalar(g)
          }
          s.max(l)
        } else
          console.warn(
            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
          )
      }
    }
    i.expandByVector(s)
  }
  r.boundingBox = i
  const o = new na()
  i.getCenter(o.center),
    (o.radius = i.min.distanceTo(i.max) / 2),
    (r.boundingSphere = o)
}
function DD(r, t, e) {
  const n = t.attributes,
    i = []
  function a(o, s) {
    return e.getDependency('accessor', o).then(function (l) {
      r.setAttribute(s, l)
    })
  }
  for (const o in n) {
    const s = tb[o] || o.toLowerCase()
    s in r.attributes || i.push(a(n[o], s))
  }
  if (t.indices !== void 0 && !r.index) {
    const o = e.getDependency('accessor', t.indices).then(function (s) {
      r.setIndex(s)
    })
    i.push(o)
  }
  return (
    Be.workingColorSpace !== ar &&
      'COLOR_0' in n &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Be.workingColorSpace}" not supported.`,
      ),
    Ro(r, t),
    zq(r, t, e),
    Promise.all(i).then(function () {
      return t.targets !== void 0 ? Iq(r, t.targets, e) : r
    })
  )
}
const xx = new WeakMap()
class Uq extends fl {
  constructor(t) {
    super(t),
      (this.decoderPath = ''),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ''),
      (this.defaultAttributeIDs = {
        position: 'POSITION',
        normal: 'NORMAL',
        color: 'COLOR',
        uv: 'TEX_COORD',
      }),
      (this.defaultAttributeTypes = {
        position: 'Float32Array',
        normal: 'Float32Array',
        color: 'Float32Array',
        uv: 'Float32Array',
      })
  }
  setDecoderPath(t) {
    return (this.decoderPath = t), this
  }
  setDecoderConfig(t) {
    return (this.decoderConfig = t), this
  }
  setWorkerLimit(t) {
    return (this.workerLimit = t), this
  }
  load(t, e, n, i) {
    const a = new wp(this.manager)
    a.setPath(this.path),
      a.setResponseType('arraybuffer'),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        t,
        o => {
          this.parse(o, e, i)
        },
        n,
        i,
      )
  }
  parse(t, e, n = () => {}) {
    this.decodeDracoFile(t, e, null, null, cn, n).catch(n)
  }
  decodeDracoFile(t, e, n, i, a = ar, o = () => {}) {
    const s = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n,
      vertexColorSpace: a,
    }
    return this.decodeGeometry(t, s).then(e).catch(o)
  }
  decodeGeometry(t, e) {
    const n = JSON.stringify(e)
    if (xx.has(t)) {
      const l = xx.get(t)
      if (l.key === n) return l.promise
      if (t.byteLength === 0)
        throw new Error(
          'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
        )
    }
    let i
    const a = this.workerNextTaskID++,
      o = t.byteLength,
      s = this._getWorker(a, o)
        .then(
          l => (
            (i = l),
            new Promise((u, c) => {
              ;(i._callbacks[a] = {
                resolve: u,
                reject: c,
              }),
                i.postMessage(
                  {
                    type: 'decode',
                    id: a,
                    taskConfig: e,
                    buffer: t,
                  },
                  [t],
                )
            })
          ),
        )
        .then(l => this._createGeometry(l.geometry))
    return (
      s
        .catch(() => !0)
        .then(() => {
          i && a && this._releaseTask(i, a)
        }),
      xx.set(t, {
        key: n,
        promise: s,
      }),
      s
    )
  }
  _createGeometry(t) {
    const e = new Mn()
    t.index && e.setIndex(new ir(t.index.array, 1))
    for (let n = 0; n < t.attributes.length; n++) {
      const i = t.attributes[n],
        a = i.name,
        o = i.array,
        s = i.itemSize,
        l = new ir(o, s)
      a === 'color' &&
        (this._assignVertexColorSpace(l, i.vertexColorSpace),
        (l.normalized = !(o instanceof Float32Array))),
        e.setAttribute(a, l)
    }
    return e
  }
  _assignVertexColorSpace(t, e) {
    if (e !== cn) return
    const n = new qt()
    for (let i = 0, a = t.count; i < a; i++)
      n.fromBufferAttribute(t, i).convertSRGBToLinear(),
        t.setXYZ(i, n.r, n.g, n.b)
  }
  _loadLibrary(t, e) {
    const n = new wp(this.manager)
    return (
      n.setPath(this.decoderPath),
      n.setResponseType(e),
      n.setWithCredentials(this.withCredentials),
      new Promise((i, a) => {
        n.load(t, i, void 0, a)
      })
    )
  }
  preload() {
    return this._initDecoder(), this
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending
    const t =
        typeof WebAssembly != 'object' || this.decoderConfig.type === 'js',
      e = []
    return (
      t
        ? e.push(this._loadLibrary('draco_decoder.js', 'text'))
        : (e.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
          e.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
      (this.decoderPending = Promise.all(e).then(n => {
        const i = n[0]
        t || (this.decoderConfig.wasmBinary = n[1])
        const a = Vq.toString(),
          o = [
            '/* draco decoder */',
            i,
            '',
            '/* worker */',
            a.substring(a.indexOf('{') + 1, a.lastIndexOf('}')),
          ].join(`
`)
        this.workerSourceURL = URL.createObjectURL(new Blob([o]))
      })),
      this.decoderPending
    )
  }
  _getWorker(t, e) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL)
        ;(i._callbacks = {}),
          (i._taskCosts = {}),
          (i._taskLoad = 0),
          i.postMessage({
            type: 'init',
            decoderConfig: this.decoderConfig,
          }),
          (i.onmessage = function (a) {
            const o = a.data
            switch (o.type) {
              case 'decode':
                i._callbacks[o.id].resolve(o)
                break
              case 'error':
                i._callbacks[o.id].reject(o)
                break
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"',
                )
            }
          }),
          this.workerPool.push(i)
      } else
        this.workerPool.sort(function (i, a) {
          return i._taskLoad > a._taskLoad ? -1 : 1
        })
      const n = this.workerPool[this.workerPool.length - 1]
      return (n._taskCosts[t] = e), (n._taskLoad += e), n
    })
  }
  _releaseTask(t, e) {
    ;(t._taskLoad -= t._taskCosts[e]),
      delete t._callbacks[e],
      delete t._taskCosts[e]
  }
  debug() {
    console.log(
      'Task load: ',
      this.workerPool.map(t => t._taskLoad),
    )
  }
  dispose() {
    for (let t = 0; t < this.workerPool.length; ++t)
      this.workerPool[t].terminate()
    return (
      (this.workerPool.length = 0),
      this.workerSourceURL !== '' && URL.revokeObjectURL(this.workerSourceURL),
      this
    )
  }
}
function Vq() {
  let r, t
  onmessage = function (o) {
    const s = o.data
    switch (s.type) {
      case 'init':
        ;(r = s.decoderConfig),
          (t = new Promise(function (c) {
            ;(r.onModuleLoaded = function (h) {
              c({
                draco: h,
              })
            }),
              DracoDecoderModule(r)
          }))
        break
      case 'decode':
        const l = s.buffer,
          u = s.taskConfig
        t.then(c => {
          const h = c.draco,
            f = new h.Decoder()
          try {
            const d = e(h, f, new Int8Array(l), u),
              p = d.attributes.map(g => g.array.buffer)
            d.index && p.push(d.index.array.buffer),
              self.postMessage(
                {
                  type: 'decode',
                  id: s.id,
                  geometry: d,
                },
                p,
              )
          } catch (d) {
            console.error(d),
              self.postMessage({
                type: 'error',
                id: s.id,
                error: d.message,
              })
          } finally {
            h.destroy(f)
          }
        })
        break
    }
  }
  function e(o, s, l, u) {
    const c = u.attributeIDs,
      h = u.attributeTypes
    let f, d
    const p = s.GetEncodedGeometryType(l)
    if (p === o.TRIANGULAR_MESH)
      (f = new o.Mesh()), (d = s.DecodeArrayToMesh(l, l.byteLength, f))
    else if (p === o.POINT_CLOUD)
      (f = new o.PointCloud()),
        (d = s.DecodeArrayToPointCloud(l, l.byteLength, f))
    else throw new Error('THREE.DRACOLoader: Unexpected geometry type.')
    if (!d.ok() || f.ptr === 0)
      throw new Error('THREE.DRACOLoader: Decoding failed: ' + d.error_msg())
    const g = {
      index: null,
      attributes: [],
    }
    for (const v in c) {
      const m = self[h[v]]
      let y, _
      if (u.useUniqueIDs) (_ = c[v]), (y = s.GetAttributeByUniqueId(f, _))
      else {
        if (((_ = s.GetAttributeId(f, o[c[v]])), _ === -1)) continue
        y = s.GetAttribute(f, _)
      }
      const x = i(o, s, f, v, m, y)
      v === 'color' && (x.vertexColorSpace = u.vertexColorSpace),
        g.attributes.push(x)
    }
    return p === o.TRIANGULAR_MESH && (g.index = n(o, s, f)), o.destroy(f), g
  }
  function n(o, s, l) {
    const c = l.num_faces() * 3,
      h = c * 4,
      f = o._malloc(h)
    s.GetTrianglesUInt32Array(l, h, f)
    const d = new Uint32Array(o.HEAPF32.buffer, f, c).slice()
    return (
      o._free(f),
      {
        array: d,
        itemSize: 1,
      }
    )
  }
  function i(o, s, l, u, c, h) {
    const f = h.num_components(),
      p = l.num_points() * f,
      g = p * c.BYTES_PER_ELEMENT,
      v = a(o, c),
      m = o._malloc(g)
    s.GetAttributeDataArrayForAllPoints(l, h, v, g, m)
    const y = new c(o.HEAPF32.buffer, m, p).slice()
    return (
      o._free(m),
      {
        name: u,
        array: y,
        itemSize: f,
      }
    )
  }
  function a(o, s) {
    switch (s) {
      case Float32Array:
        return o.DT_FLOAT32
      case Int8Array:
        return o.DT_INT8
      case Int16Array:
        return o.DT_INT16
      case Int32Array:
        return o.DT_INT32
      case Uint8Array:
        return o.DT_UINT8
      case Uint16Array:
        return o.DT_UINT16
      case Uint32Array:
        return o.DT_UINT32
    }
  }
}
let nb = {
  GLTFLoader: 'GLTF',
  TextureLoader: 'Texture',
  FontLoader: 'Font',
  MMDLoader: 'MMD',
  MTLLoader: 'MTL',
  OBJLoader: 'OBJ',
  PCDLoader: 'PCD',
  FileLoader: 'File',
  ImageLoader: 'Image',
  ObjectLoader: 'Object',
  MaterialLoader: 'Material',
  CubeTextureLoader: 'CubeTexture',
  RGBELoader: 'RGBELoader',
  FBXLoader: 'FBX',
}
const Gq = Object.values(nb)
class Hq extends z0 {
  constructor({dracoPath: t} = {}) {
    super(),
      (this.dracoPath = t || './draco/gltf/'),
      (this.itemsLoaded = 0),
      (this.itemsTotal = 0),
      (this.assets = []),
      (this.loaders = {}),
      this.initDefaultLoader()
  }
  initManager() {
    const t = new LB()
    return (
      (t.onProgress = (e, n, i) => {
        ;(this.itemsLoaded = n),
          (this.itemsTotal = i),
          this.emit('onProgress', e, n, i)
      }),
      (t.onError = e => {
        this.emit('onError', e)
      }),
      t
    )
  }
  initDefaultLoader() {
    ;[
      {
        loader: aq,
        name: 'GLTFLoader',
      },
      {
        loader: ZM,
        name: 'TextureLoader',
      },
    ].map(t => this.addLoader(t.loader, t.name))
  }
  initDraco(t) {
    const e = new Uq()
    e.setDecoderPath(this.dracoPath), e.preload(), t.setDRACOLoader(e)
  }
  addLoader(t, e = '') {
    if (t.name && nb[e]) {
      if (!this.loaders[e]) {
        let i = new t(this.manager),
          a = e
        i instanceof fl &&
          (a === 'GLTFLoader' && this.initDraco(i), (this.loaders[nb[a]] = i))
      }
    } else throw new Error('请配置正确的加载器')
  }
  loadItem(t) {
    return new Promise((e, n) => {
      if (!this.loaders[t.type]) throw new Error(`资源${t.path}没有配置加载器`)
      this.loaders[t.type].load(
        t.path,
        i => {
          this.itemsLoaded++,
            this.emit('onProgress', t.path, this.itemsLoaded, this.itemsTotal),
            e({
              ...t,
              data: i,
            })
        },
        null,
        i => {
          this.emit('onError', i), n(i)
        },
      )
    })
  }
  loadAll(t) {
    return (
      (this.itemsLoaded = 0),
      (this.itemsTotal = 0),
      new Promise((e, n) => {
        let i = this.matchType(t),
          a = []
        ;(this.itemsTotal = i.length),
          i.map(o => {
            let s = this.loadItem(o)
            a.push(s)
          }),
          Promise.all(a)
            .then(o => {
              ;(this.assets = o), this.emit('onLoad'), e(o)
            })
            .catch(o => {
              this.emit('onError', o), n(o)
            })
      })
    )
  }
  matchType(t) {
    return (
      (this.assets = t
        .map(e => ({
          type: Gq.includes(e.type) ? e.type : '',
          path: e.path,
          name: e.name,
          data: null,
        }))
        .filter(e => {
          if (!e.type) throw new Error(`资源${e.path},type不正确`)
          return e.type
        })),
      this.assets
    )
  }
  getResource(t) {
    let e = this.assets.find(n => n.name === t)
    if (!e) throw new Error(`资源${t}不存在`)
    return e.data
  }
  destroy() {
    this.off('onProgress'),
      this.off('onLoad'),
      this.off('onError'),
      (this.assets = [])
  }
}
class LD {
  constructor(t, e) {
    ;(this.wasIntersected = !1),
      (this.wasIntersectedOnMouseDown = !1),
      (this.target = t),
      (this.name = e),
      (this.intersected = !1),
      (this.distance = 0)
  }
}
class Wr {
  constructor(t, e = null) {
    ;(this.coords = new pt(0, 0)),
      (this.distance = 0),
      (this.intersected = !1),
      (this.wasIntersected = !1),
      (this.wasIntersectedOnMouseDown = !1),
      (this.cancelBubble = !1),
      (this.type = t),
      (this.originalEvent = e)
  }
  stopPropagation() {
    this.cancelBubble = !0
  }
}
class Wq {
  constructor(t, e, n, i) {
    ;(this.dispose = () => {
      this.domElement.removeEventListener('click', this.onMouseClick),
        this.supportsPointerEvents &&
          (this.bindEventsOnBodyElement
            ? this.domElement.ownerDocument.removeEventListener(
                'pointermove',
                this.onDocumentPointerMove,
              )
            : this.domElement.removeEventListener(
                'pointermove',
                this.onDocumentPointerMove,
              ),
          this.domElement.removeEventListener(
            'pointerdown',
            this.onPointerDown,
          ),
          this.domElement.removeEventListener('pointerup', this.onPointerUp)),
        this.bindEventsOnBodyElement
          ? this.domElement.ownerDocument.removeEventListener(
              'mousemove',
              this.onDocumentMouseMove,
            )
          : this.domElement.removeEventListener(
              'mousemove',
              this.onDocumentMouseMove,
            ),
        this.domElement.removeEventListener('mousedown', this.onMouseDown),
        this.domElement.removeEventListener('mouseup', this.onMouseUp),
        this.domElement.removeEventListener('touchstart', this.onTouchStart),
        this.domElement.removeEventListener('touchmove', this.onTouchMove),
        this.domElement.removeEventListener('touchend', this.onTouchEnd)
    }),
      (this.add = (a, o = []) => {
        if (a && !this.interactiveObjects.find(s => s.target === a))
          if (o.length > 0)
            o.forEach(s => {
              const l = a.getObjectByName(s)
              if (l) {
                const u = new LD(l, s)
                this.interactiveObjects.push(u)
              }
            })
          else {
            const s = new LD(a, a.name)
            this.interactiveObjects.push(s)
          }
      }),
      (this.remove = (a, o = []) => {
        a &&
          (o.length > 0
            ? o.forEach(s => {
                const l = a.getObjectByName(s)
                l &&
                  (this.interactiveObjects = this.interactiveObjects.filter(
                    u => u.target !== l,
                  ))
              })
            : (this.interactiveObjects = this.interactiveObjects.filter(
                s => s.target !== a,
              )))
      }),
      (this.update = () => {
        var a
        this.raycaster.setFromCamera(this.mouse, this.camera),
          this.interactiveObjects.forEach(u => {
            u.target && this.checkIntersection(u)
          }),
          this.interactiveObjects.sort(function (u, c) {
            return u.distance - c.distance
          })
        const o =
          (a = this.interactiveObjects.find(u => u.intersected)) !== null &&
          a !== void 0
            ? a
            : null
        if (o != this.closestObject) {
          if (this.closestObject) {
            const u = new Wr('mouseout')
            this.dispatch(this.closestObject, u)
          }
          if (o) {
            const u = new Wr('mouseover')
            this.dispatch(o, u)
          }
          this.closestObject = o
        }
        let s
        this.interactiveObjects.forEach(u => {
          !u.intersected &&
            u.wasIntersected &&
            (s || (s = new Wr('mouseleave')), this.dispatch(u, s))
        })
        let l
        this.interactiveObjects.forEach(u => {
          u.intersected &&
            !u.wasIntersected &&
            (l || (l = new Wr('mouseenter')), this.dispatch(u, l))
        })
      }),
      (this.checkIntersection = a => {
        const o = this.raycaster.intersectObjects([a.target], !0)
        if (((a.wasIntersected = a.intersected), o.length > 0)) {
          let s = o[0].distance
          o.forEach(l => {
            l.distance < s && (s = l.distance)
          }),
            (a.intersected = !0),
            (a.distance = s)
        } else a.intersected = !1
      }),
      (this.onDocumentMouseMove = a => {
        this.mapPositionToPoint(this.mouse, a.clientX, a.clientY)
        const o = new Wr('mousemove', a)
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.onDocumentPointerMove = a => {
        this.mapPositionToPoint(this.mouse, a.clientX, a.clientY)
        const o = new Wr('pointermove', a)
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.onTouchMove = a => {
        a.touches.length > 0 &&
          this.mapPositionToPoint(
            this.mouse,
            a.touches[0].clientX,
            a.touches[0].clientY,
          )
        const o = new Wr(
          this.treatTouchEventsAsMouseEvents ? 'mousemove' : 'touchmove',
          a,
        )
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.onMouseClick = a => {
        this.update()
        const o = new Wr('click', a)
        this.interactiveObjects.forEach(s => {
          s.intersected && this.dispatch(s, o)
        })
      }),
      (this.onMouseDown = a => {
        this.mapPositionToPoint(this.mouse, a.clientX, a.clientY), this.update()
        const o = new Wr('mousedown', a)
        this.interactiveObjects.forEach(s => {
          s.intersected
            ? ((s.wasIntersectedOnMouseDown = !0), this.dispatch(s, o))
            : (s.wasIntersectedOnMouseDown = !1)
        })
      }),
      (this.onPointerDown = a => {
        this.mapPositionToPoint(this.mouse, a.clientX, a.clientY), this.update()
        const o = new Wr('pointerdown', a)
        this.interactiveObjects.forEach(s => {
          s.intersected && this.dispatch(s, o)
        })
      }),
      (this.onTouchStart = a => {
        a.touches.length > 0 &&
          this.mapPositionToPoint(
            this.mouse,
            a.touches[0].clientX,
            a.touches[0].clientY,
          ),
          this.update()
        const o = new Wr(
          this.treatTouchEventsAsMouseEvents ? 'mousedown' : 'touchstart',
          a,
        )
        this.interactiveObjects.forEach(s => {
          s.intersected && this.dispatch(s, o)
        })
      }),
      (this.onMouseUp = a => {
        const o = new Wr('mouseup', a)
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.onPointerUp = a => {
        const o = new Wr('pointerup', a)
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.onTouchEnd = a => {
        a.touches.length > 0 &&
          this.mapPositionToPoint(
            this.mouse,
            a.touches[0].clientX,
            a.touches[0].clientY,
          ),
          this.update()
        const o = new Wr(
          this.treatTouchEventsAsMouseEvents ? 'mouseup' : 'touchend',
          a,
        )
        this.interactiveObjects.forEach(s => {
          this.dispatch(s, o)
        })
      }),
      (this.dispatch = (a, o) => {
        a.target &&
          !o.cancelBubble &&
          ((o.coords = this.mouse),
          (o.distance = a.distance),
          (o.intersected = a.intersected),
          (o.wasIntersected = a.wasIntersected),
          (o.wasIntersectedOnMouseDown = a.wasIntersectedOnMouseDown),
          a.target.dispatchEvent(o))
      }),
      (this.mapPositionToPoint = (a, o, s) => {
        const l = this.renderer.domElement.getBoundingClientRect()
        ;(a.x = ((o - l.left) / l.width) * 2 - 1),
          (a.y = -((s - l.top) / l.height) * 2 + 1)
      }),
      (this.renderer = t),
      (this.camera = e),
      (this.domElement = n),
      (this.bindEventsOnBodyElement =
        i && typeof i.bindEventsOnBodyElement < 'u'
          ? i.bindEventsOnBodyElement
          : !0),
      (this.scene = i && typeof i.scene < 'u' ? i.scene : null),
      this.scene &&
        (this.scene.onBeforeRender = () => {
          this.autoAdd &&
            this.scene !== null &&
            this.scene.traverse(a => {
              this.add(a),
                a.addEventListener('removed', o => {
                  this.remove(o.target)
                })
            }),
            this.update()
        }),
      (this.autoAdd = i && typeof i.autoAdd < 'u' ? i.autoAdd : !1),
      this.autoAdd &&
        this.scene === null &&
        console.error(
          'Attention: Options.scene needs to be set when using options.autoAdd',
        ),
      (this.mouse = new pt(-1, 1)),
      (this.supportsPointerEvents = !!window.PointerEvent),
      (this.interactiveObjects = []),
      (this.closestObject = null),
      (this.raycaster = new Q$()),
      n.addEventListener('click', this.onMouseClick),
      this.supportsPointerEvents &&
        (this.bindEventsOnBodyElement
          ? n.ownerDocument.addEventListener(
              'pointermove',
              this.onDocumentPointerMove,
            )
          : n.addEventListener('pointermove', this.onDocumentPointerMove),
        n.addEventListener('pointerdown', this.onPointerDown),
        n.addEventListener('pointerup', this.onPointerUp)),
      this.bindEventsOnBodyElement
        ? n.ownerDocument.addEventListener(
            'mousemove',
            this.onDocumentMouseMove,
          )
        : n.addEventListener('mousemove', this.onDocumentMouseMove),
      n.addEventListener('mousedown', this.onMouseDown),
      n.addEventListener('mouseup', this.onMouseUp),
      n.addEventListener('touchstart', this.onTouchStart, {
        passive: !0,
      }),
      n.addEventListener('touchmove', this.onTouchMove, {
        passive: !0,
      }),
      n.addEventListener('touchend', this.onTouchEnd, {
        passive: !0,
      }),
      (this.treatTouchEventsAsMouseEvents = !0)
  }
}
const NB = r => {
    r instanceof Array ? r.forEach(NB) : (r.map && r.map.dispose(), r.dispose())
  },
  kB = r => {
    r.geometry && r.geometry.dispose(),
      r.material && NB(r.material),
      r.texture && r.texture.dispose(),
      r.children && r.children.forEach(kB)
  },
  va = r => {
    if (r && r.children)
      for (; r.children.length; ) {
        const t = r.children[0]
        r.remove(t), kB(t)
      }
  }
function BB(r = 10, t = 62) {
  var e =
      '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(
        '',
      ),
    n = [],
    i
  if (((t = t || e.length), r))
    for (i = 0; i < r; i++) n[i] = e[0 | (Math.random() * t)]
  else {
    var a
    for (n[8] = n[13] = n[18] = n[23] = '-', n[14] = '4', i = 0; i < 36; i++)
      n[i] ||
        ((a = 0 | (Math.random() * 16)), (n[i] = e[i == 19 ? (a & 3) | 8 : a]))
  }
  return n.join('')
}
function PD(r) {
  var t = new U(),
    e = new Ei()
  e.expandByObject(r)
  var n = new U()
  e.getSize(n)
  var i = new U()
  e.getCenter(i)
  let a = {
    box3: e,
    boxSize: n,
    center: i,
  }
  if (r.geometry) {
    r.geometry.computeBoundingBox(), r.geometry.computeBoundingSphere()
    const {max: o, min: s} = r.geometry.boundingBox
    ;(t.x = o.x - s.x), (t.y = o.y - s.y), (t.z = o.z - s.z), (a.size = t)
  }
  return a
}
function Xq(r) {
  let t = r,
    e = 0
  for (; Array.isArray(t); ) e++, (t = t[0])
  for (; e < 4; ) (r = [r]), e++
  return r
}
const QM = r => {
  let t = JSON.parse(r),
    e = t.features
  for (let n = 0; n < e.length; n++) {
    const i = e[n]
    i.geometry.coordinates = Xq(i.geometry.coordinates)
  }
  return t
}
function Yq(r, t) {
  let e = r[0]
  for (let n = 1; n < r.length; n++) {
    const i = r[n]
    t(i) < t(e) && (e = i)
  }
  return e
}
function $q(r, t) {
  let e = r[0]
  for (let n = 1; n < r.length; n++) {
    const i = r[n]
    t(i) > t(e) && (e = i)
  }
  return e
}
class qq {
  constructor({
    canvas: t,
    sizes: e,
    scene: n,
    camera: i,
    postprocessing: a = !1,
    composer: o = null,
  }) {
    ;(this.canvas = t),
      (this.sizes = e),
      (this.scene = n),
      (this.camera = i),
      (this.postprocessing = a),
      (this.composer = o),
      this.setInstance()
  }
  setInstance() {
    ;(this.instance = new cB({
      alpha: !1,
      antialias: !0,
      canvas: this.canvas,
    })),
      this.instance.setSize(this.sizes.width, this.sizes.height),
      this.instance.setPixelRatio(this.sizes.pixelRatio)
  }
  resize() {
    this.instance.setSize(this.sizes.width, this.sizes.height),
      this.instance.setPixelRatio(this.sizes.pixelRatio)
  }
  update() {
    this.postprocessing && this.composer
      ? this.composer.render()
      : this.instance.render(this.scene, this.camera.instance)
  }
  destroy() {
    this.instance.dispose(), this.instance.forceContextLoss()
  }
}
const RD = {
    type: 'change',
  },
  Sx = {
    type: 'start',
  },
  ID = {
    type: 'end',
  },
  yg = new hf(),
  OD = new Cs(),
  Zq = Math.cos(70 * IM.DEG2RAD)
class FB extends Ju {
  constructor(t, e) {
    super(),
      (this.object = t),
      (this.domElement = e),
      (this.domElement.style.touchAction = 'none'),
      (this.enabled = !0),
      (this.target = new U()),
      (this.cursor = new U()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: 'ArrowLeft',
        UP: 'ArrowUp',
        RIGHT: 'ArrowRight',
        BOTTOM: 'ArrowDown',
      }),
      (this.mouseButtons = {
        LEFT: hc.ROTATE,
        MIDDLE: hc.DOLLY,
        RIGHT: hc.PAN,
      }),
      (this.touches = {
        ONE: fc.ROTATE,
        TWO: fc.DOLLY_PAN,
      }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return s.phi
      }),
      (this.getAzimuthalAngle = function () {
        return s.theta
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target)
      }),
      (this.listenToKeyEvents = function (O) {
        O.addEventListener('keydown', Bt), (this._domElementKeyEvents = O)
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener('keydown', Bt),
          (this._domElementKeyEvents = null)
      }),
      (this.saveState = function () {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom)
      }),
      (this.reset = function () {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(RD),
          n.update(),
          (a = i.NONE)
      }),
      (this.update = (function () {
        const O = new U(),
          j = new wa().setFromUnitVectors(t.up, new U(0, 1, 0)),
          tt = j.clone().invert(),
          ot = new U(),
          St = new wa(),
          jt = new U(),
          ce = 2 * Math.PI
        return function (Gn = null) {
          const Ie = n.object.position
          O.copy(Ie).sub(n.target),
            O.applyQuaternion(j),
            s.setFromVector3(O),
            n.autoRotate && a === i.NONE && E(M(Gn)),
            n.enableDamping
              ? ((s.theta += l.theta * n.dampingFactor),
                (s.phi += l.phi * n.dampingFactor))
              : ((s.theta += l.theta), (s.phi += l.phi))
          let Hn = n.minAzimuthAngle,
            On = n.maxAzimuthAngle
          isFinite(Hn) &&
            isFinite(On) &&
            (Hn < -Math.PI ? (Hn += ce) : Hn > Math.PI && (Hn -= ce),
            On < -Math.PI ? (On += ce) : On > Math.PI && (On -= ce),
            Hn <= On
              ? (s.theta = Math.max(Hn, Math.min(On, s.theta)))
              : (s.theta =
                  s.theta > (Hn + On) / 2
                    ? Math.max(Hn, s.theta)
                    : Math.min(On, s.theta))),
            (s.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, s.phi),
            )),
            s.makeSafe(),
            n.enableDamping === !0
              ? n.target.addScaledVector(c, n.dampingFactor)
              : n.target.add(c),
            n.target.sub(n.cursor),
            n.target.clampLength(n.minTargetRadius, n.maxTargetRadius),
            n.target.add(n.cursor)
          let ss = !1
          if ((n.zoomToCursor && S) || n.object.isOrthographicCamera)
            s.radius = H(s.radius)
          else {
            const sr = s.radius
            ;(s.radius = H(s.radius * u)), (ss = sr != s.radius)
          }
          if (
            (O.setFromSpherical(s),
            O.applyQuaternion(tt),
            Ie.copy(n.target).add(O),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((l.theta *= 1 - n.dampingFactor),
                (l.phi *= 1 - n.dampingFactor),
                c.multiplyScalar(1 - n.dampingFactor))
              : (l.set(0, 0, 0), c.set(0, 0, 0)),
            n.zoomToCursor && S)
          ) {
            let sr = null
            if (n.object.isPerspectiveCamera) {
              const So = O.length()
              sr = H(So * u)
              const _l = So - sr
              n.object.position.addScaledVector(x, _l),
                n.object.updateMatrixWorld(),
                (ss = !!_l)
            } else if (n.object.isOrthographicCamera) {
              const So = new U(A.x, A.y, 0)
              So.unproject(n.object)
              const _l = n.object.zoom
              ;(n.object.zoom = Math.max(
                n.minZoom,
                Math.min(n.maxZoom, n.object.zoom / u),
              )),
                n.object.updateProjectionMatrix(),
                (ss = _l !== n.object.zoom)
              const If = new U(A.x, A.y, 0)
              If.unproject(n.object),
                n.object.position.sub(If).add(So),
                n.object.updateMatrixWorld(),
                (sr = O.length())
            } else
              console.warn(
                'WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.',
              ),
                (n.zoomToCursor = !1)
            sr !== null &&
              (this.screenSpacePanning
                ? n.target
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix)
                    .multiplyScalar(sr)
                    .add(n.object.position)
                : (yg.origin.copy(n.object.position),
                  yg.direction
                    .set(0, 0, -1)
                    .transformDirection(n.object.matrix),
                  Math.abs(n.object.up.dot(yg.direction)) < Zq
                    ? t.lookAt(n.target)
                    : (OD.setFromNormalAndCoplanarPoint(n.object.up, n.target),
                      yg.intersectPlane(OD, n.target))))
          } else if (n.object.isOrthographicCamera) {
            const sr = n.object.zoom
            ;(n.object.zoom = Math.max(
              n.minZoom,
              Math.min(n.maxZoom, n.object.zoom / u),
            )),
              sr !== n.object.zoom &&
                (n.object.updateProjectionMatrix(), (ss = !0))
          }
          return (
            (u = 1),
            (S = !1),
            ss ||
            ot.distanceToSquared(n.object.position) > o ||
            8 * (1 - St.dot(n.object.quaternion)) > o ||
            jt.distanceToSquared(n.target) > o
              ? (n.dispatchEvent(RD),
                ot.copy(n.object.position),
                St.copy(n.object.quaternion),
                jt.copy(n.target),
                !0)
              : !1
          )
        }
      })()),
      (this.dispose = function () {
        n.domElement.removeEventListener('contextmenu', Ot),
          n.domElement.removeEventListener('pointerdown', Lt),
          n.domElement.removeEventListener('pointercancel', N),
          n.domElement.removeEventListener('wheel', yt),
          n.domElement.removeEventListener('pointermove', G),
          n.domElement.removeEventListener('pointerup', N),
          n.domElement.getRootNode().removeEventListener('keydown', Kt, {
            capture: !0,
          }),
          n._domElementKeyEvents !== null &&
            (n._domElementKeyEvents.removeEventListener('keydown', Bt),
            (n._domElementKeyEvents = null))
      })
    const n = this,
      i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      }
    let a = i.NONE
    const o = 1e-6,
      s = new AD(),
      l = new AD()
    let u = 1
    const c = new U(),
      h = new pt(),
      f = new pt(),
      d = new pt(),
      p = new pt(),
      g = new pt(),
      v = new pt(),
      m = new pt(),
      y = new pt(),
      _ = new pt(),
      x = new U(),
      A = new pt()
    let S = !1
    const b = [],
      T = {}
    let w = !1
    function M(O) {
      return O !== null
        ? ((2 * Math.PI) / 60) * n.autoRotateSpeed * O
        : ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed
    }
    function C(O) {
      const j = Math.abs(O * 0.01)
      return Math.pow(0.95, n.zoomSpeed * j)
    }
    function E(O) {
      l.theta -= O
    }
    function D(O) {
      l.phi -= O
    }
    const P = (function () {
        const O = new U()
        return function (tt, ot) {
          O.setFromMatrixColumn(ot, 0), O.multiplyScalar(-tt), c.add(O)
        }
      })(),
      L = (function () {
        const O = new U()
        return function (tt, ot) {
          n.screenSpacePanning === !0
            ? O.setFromMatrixColumn(ot, 1)
            : (O.setFromMatrixColumn(ot, 0), O.crossVectors(n.object.up, O)),
            O.multiplyScalar(tt),
            c.add(O)
        }
      })(),
      I = (function () {
        const O = new U()
        return function (tt, ot) {
          const St = n.domElement
          if (n.object.isPerspectiveCamera) {
            const jt = n.object.position
            O.copy(jt).sub(n.target)
            let ce = O.length()
            ;(ce *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              P((2 * tt * ce) / St.clientHeight, n.object.matrix),
              L((2 * ot * ce) / St.clientHeight, n.object.matrix)
          } else
            n.object.isOrthographicCamera
              ? (P(
                  (tt * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    St.clientWidth,
                  n.object.matrix,
                ),
                L(
                  (ot * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    St.clientHeight,
                  n.object.matrix,
                ))
              : (console.warn(
                  'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.',
                ),
                (n.enablePan = !1))
        }
      })()
    function F(O) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera
        ? (u /= O)
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
          ),
          (n.enableZoom = !1))
    }
    function k(O) {
      n.object.isPerspectiveCamera || n.object.isOrthographicCamera
        ? (u *= O)
        : (console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
          ),
          (n.enableZoom = !1))
    }
    function V(O, j) {
      if (!n.zoomToCursor) return
      S = !0
      const tt = n.domElement.getBoundingClientRect(),
        ot = O - tt.left,
        St = j - tt.top,
        jt = tt.width,
        ce = tt.height
      ;(A.x = (ot / jt) * 2 - 1),
        (A.y = -(St / ce) * 2 + 1),
        x
          .set(A.x, A.y, 1)
          .unproject(n.object)
          .sub(n.object.position)
          .normalize()
    }
    function H(O) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, O))
    }
    function Y(O) {
      h.set(O.clientX, O.clientY)
    }
    function K(O) {
      V(O.clientX, O.clientX), m.set(O.clientX, O.clientY)
    }
    function ut(O) {
      p.set(O.clientX, O.clientY)
    }
    function W(O) {
      f.set(O.clientX, O.clientY),
        d.subVectors(f, h).multiplyScalar(n.rotateSpeed)
      const j = n.domElement
      E((2 * Math.PI * d.x) / j.clientHeight),
        D((2 * Math.PI * d.y) / j.clientHeight),
        h.copy(f),
        n.update()
    }
    function Z(O) {
      y.set(O.clientX, O.clientY),
        _.subVectors(y, m),
        _.y > 0 ? F(C(_.y)) : _.y < 0 && k(C(_.y)),
        m.copy(y),
        n.update()
    }
    function ft(O) {
      g.set(O.clientX, O.clientY),
        v.subVectors(g, p).multiplyScalar(n.panSpeed),
        I(v.x, v.y),
        p.copy(g),
        n.update()
    }
    function lt(O) {
      V(O.clientX, O.clientY),
        O.deltaY < 0 ? k(C(O.deltaY)) : O.deltaY > 0 && F(C(O.deltaY)),
        n.update()
    }
    function ct(O) {
      let j = !1
      switch (O.code) {
        case n.keys.UP:
          O.ctrlKey || O.metaKey || O.shiftKey
            ? D((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : I(0, n.keyPanSpeed),
            (j = !0)
          break
        case n.keys.BOTTOM:
          O.ctrlKey || O.metaKey || O.shiftKey
            ? D((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : I(0, -n.keyPanSpeed),
            (j = !0)
          break
        case n.keys.LEFT:
          O.ctrlKey || O.metaKey || O.shiftKey
            ? E((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : I(n.keyPanSpeed, 0),
            (j = !0)
          break
        case n.keys.RIGHT:
          O.ctrlKey || O.metaKey || O.shiftKey
            ? E((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : I(-n.keyPanSpeed, 0),
            (j = !0)
          break
      }
      j && (O.preventDefault(), n.update())
    }
    function At(O) {
      if (b.length === 1) h.set(O.pageX, O.pageY)
      else {
        const j = de(O),
          tt = 0.5 * (O.pageX + j.x),
          ot = 0.5 * (O.pageY + j.y)
        h.set(tt, ot)
      }
    }
    function gt(O) {
      if (b.length === 1) p.set(O.pageX, O.pageY)
      else {
        const j = de(O),
          tt = 0.5 * (O.pageX + j.x),
          ot = 0.5 * (O.pageY + j.y)
        p.set(tt, ot)
      }
    }
    function dt(O) {
      const j = de(O),
        tt = O.pageX - j.x,
        ot = O.pageY - j.y,
        St = Math.sqrt(tt * tt + ot * ot)
      m.set(0, St)
    }
    function B(O) {
      n.enableZoom && dt(O), n.enablePan && gt(O)
    }
    function ht(O) {
      n.enableZoom && dt(O), n.enableRotate && At(O)
    }
    function it(O) {
      if (b.length == 1) f.set(O.pageX, O.pageY)
      else {
        const tt = de(O),
          ot = 0.5 * (O.pageX + tt.x),
          St = 0.5 * (O.pageY + tt.y)
        f.set(ot, St)
      }
      d.subVectors(f, h).multiplyScalar(n.rotateSpeed)
      const j = n.domElement
      E((2 * Math.PI * d.x) / j.clientHeight),
        D((2 * Math.PI * d.y) / j.clientHeight),
        h.copy(f)
    }
    function xt(O) {
      if (b.length === 1) g.set(O.pageX, O.pageY)
      else {
        const j = de(O),
          tt = 0.5 * (O.pageX + j.x),
          ot = 0.5 * (O.pageY + j.y)
        g.set(tt, ot)
      }
      v.subVectors(g, p).multiplyScalar(n.panSpeed), I(v.x, v.y), p.copy(g)
    }
    function rt(O) {
      const j = de(O),
        tt = O.pageX - j.x,
        ot = O.pageY - j.y,
        St = Math.sqrt(tt * tt + ot * ot)
      y.set(0, St),
        _.set(0, Math.pow(y.y / m.y, n.zoomSpeed)),
        F(_.y),
        m.copy(y)
      const jt = (O.pageX + j.x) * 0.5,
        ce = (O.pageY + j.y) * 0.5
      V(jt, ce)
    }
    function kt(O) {
      n.enableZoom && rt(O), n.enablePan && xt(O)
    }
    function Ct(O) {
      n.enableZoom && rt(O), n.enableRotate && it(O)
    }
    function Lt(O) {
      n.enabled !== !1 &&
        (b.length === 0 &&
          (n.domElement.setPointerCapture(O.pointerId),
          n.domElement.addEventListener('pointermove', G),
          n.domElement.addEventListener('pointerup', N)),
        !Gt(O) && (Te(O), O.pointerType === 'touch' ? fe(O) : J(O)))
    }
    function G(O) {
      n.enabled !== !1 && (O.pointerType === 'touch' ? Mt(O) : vt(O))
    }
    function N(O) {
      switch ((se(O), b.length)) {
        case 0:
          n.domElement.releasePointerCapture(O.pointerId),
            n.domElement.removeEventListener('pointermove', G),
            n.domElement.removeEventListener('pointerup', N),
            n.dispatchEvent(ID),
            (a = i.NONE)
          break
        case 1:
          const j = b[0],
            tt = T[j]
          fe({
            pointerId: j,
            pageX: tt.x,
            pageY: tt.y,
          })
          break
      }
    }
    function J(O) {
      let j
      switch (O.button) {
        case 0:
          j = n.mouseButtons.LEFT
          break
        case 1:
          j = n.mouseButtons.MIDDLE
          break
        case 2:
          j = n.mouseButtons.RIGHT
          break
        default:
          j = -1
      }
      switch (j) {
        case hc.DOLLY:
          if (n.enableZoom === !1) return
          K(O), (a = i.DOLLY)
          break
        case hc.ROTATE:
          if (O.ctrlKey || O.metaKey || O.shiftKey) {
            if (n.enablePan === !1) return
            ut(O), (a = i.PAN)
          } else {
            if (n.enableRotate === !1) return
            Y(O), (a = i.ROTATE)
          }
          break
        case hc.PAN:
          if (O.ctrlKey || O.metaKey || O.shiftKey) {
            if (n.enableRotate === !1) return
            Y(O), (a = i.ROTATE)
          } else {
            if (n.enablePan === !1) return
            ut(O), (a = i.PAN)
          }
          break
        default:
          a = i.NONE
      }
      a !== i.NONE && n.dispatchEvent(Sx)
    }
    function vt(O) {
      switch (a) {
        case i.ROTATE:
          if (n.enableRotate === !1) return
          W(O)
          break
        case i.DOLLY:
          if (n.enableZoom === !1) return
          Z(O)
          break
        case i.PAN:
          if (n.enablePan === !1) return
          ft(O)
          break
      }
    }
    function yt(O) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        a !== i.NONE ||
        (O.preventDefault(),
        n.dispatchEvent(Sx),
        lt(mt(O)),
        n.dispatchEvent(ID))
    }
    function mt(O) {
      const j = O.deltaMode,
        tt = {
          clientX: O.clientX,
          clientY: O.clientY,
          deltaY: O.deltaY,
        }
      switch (j) {
        case 1:
          tt.deltaY *= 16
          break
        case 2:
          tt.deltaY *= 100
          break
      }
      return O.ctrlKey && !w && (tt.deltaY *= 10), tt
    }
    function Kt(O) {
      O.key === 'Control' &&
        ((w = !0),
        n.domElement.getRootNode().addEventListener('keyup', It, {
          passive: !0,
          capture: !0,
        }))
    }
    function It(O) {
      O.key === 'Control' &&
        ((w = !1),
        n.domElement.getRootNode().removeEventListener('keyup', It, {
          passive: !0,
          capture: !0,
        }))
    }
    function Bt(O) {
      n.enabled === !1 || n.enablePan === !1 || ct(O)
    }
    function fe(O) {
      switch ((ue(O), b.length)) {
        case 1:
          switch (n.touches.ONE) {
            case fc.ROTATE:
              if (n.enableRotate === !1) return
              At(O), (a = i.TOUCH_ROTATE)
              break
            case fc.PAN:
              if (n.enablePan === !1) return
              gt(O), (a = i.TOUCH_PAN)
              break
            default:
              a = i.NONE
          }
          break
        case 2:
          switch (n.touches.TWO) {
            case fc.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return
              B(O), (a = i.TOUCH_DOLLY_PAN)
              break
            case fc.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return
              ht(O), (a = i.TOUCH_DOLLY_ROTATE)
              break
            default:
              a = i.NONE
          }
          break
        default:
          a = i.NONE
      }
      a !== i.NONE && n.dispatchEvent(Sx)
    }
    function Mt(O) {
      switch ((ue(O), a)) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1) return
          it(O), n.update()
          break
        case i.TOUCH_PAN:
          if (n.enablePan === !1) return
          xt(O), n.update()
          break
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return
          kt(O), n.update()
          break
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return
          Ct(O), n.update()
          break
        default:
          a = i.NONE
      }
    }
    function Ot(O) {
      n.enabled !== !1 && O.preventDefault()
    }
    function Te(O) {
      b.push(O.pointerId)
    }
    function se(O) {
      delete T[O.pointerId]
      for (let j = 0; j < b.length; j++)
        if (b[j] == O.pointerId) {
          b.splice(j, 1)
          return
        }
    }
    function Gt(O) {
      for (let j = 0; j < b.length; j++) if (b[j] == O.pointerId) return !0
      return !1
    }
    function ue(O) {
      let j = T[O.pointerId]
      j === void 0 && ((j = new pt()), (T[O.pointerId] = j)),
        j.set(O.pageX, O.pageY)
    }
    function de(O) {
      const j = O.pointerId === b[0] ? b[1] : b[0]
      return T[j]
    }
    n.domElement.addEventListener('contextmenu', Ot),
      n.domElement.addEventListener('pointerdown', Lt),
      n.domElement.addEventListener('pointercancel', N),
      n.domElement.addEventListener('wheel', yt, {
        passive: !1,
      }),
      n.domElement.getRootNode().addEventListener('keydown', Kt, {
        passive: !0,
        capture: !0,
      }),
      this.update()
  }
}
class Kq {
  constructor(
    {sizes: t, scene: e, canvas: n},
    i = {
      isOrthographic: !1,
    },
  ) {
    ;(this.sizes = t),
      (this.scene = e),
      (this.canvas = n),
      (this.options = Object.assign(
        {
          isOrthographic: !1,
        },
        i,
      )),
      this.setInstance()
  }
  setInstance() {
    ;(this.instance = null),
      this.setCamera(this.options.isOrthographic),
      this.instance.position.set(10, 10, 10),
      this.scene.add(this.instance)
  }
  setCamera(t = !0) {
    let e = this.sizes.width / this.sizes.height
    if (t) {
      let n = 120
      this.instance = new O0(-n * e, n * e, n, -n, 1, 1e4)
    } else this.instance = new wr(45, e, 1, 1e4)
    this.setControls()
  }
  setControls() {
    ;(this.controls = new FB(this.instance, this.canvas)),
      (this.controls.enableDamping = !0),
      this.controls.update()
  }
  resize() {
    let t = this.sizes.width / this.sizes.height
    if (this.options.isOrthographic) {
      let e = 120
      ;(this.instance.left = -e * t),
        (this.instance.right = e * t),
        (this.instance.top = e),
        (this.instance.bottom = -e)
    } else this.instance.aspect = t
    this.instance.updateProjectionMatrix()
  }
  update() {
    this.controls.update()
  }
  destroy() {
    this.controls.dispose()
  }
}
class jq {
  constructor() {
    ;(this._partials = new Float64Array(32)), (this._n = 0)
  }
  add(t) {
    const e = this._partials
    let n = 0
    for (let i = 0; i < this._n && i < 32; i++) {
      const a = e[i],
        o = t + a,
        s = Math.abs(t) < Math.abs(a) ? t - (o - a) : a - (o - t)
      s && (e[n++] = s), (t = o)
    }
    return (e[n] = t), (this._n = n + 1), this
  }
  valueOf() {
    const t = this._partials
    let e = this._n,
      n,
      i,
      a,
      o = 0
    if (e > 0) {
      for (
        o = t[--e];
        e > 0 && ((n = o), (i = t[--e]), (o = n + i), (a = i - (o - n)), !a);

      );
      e > 0 &&
        ((a < 0 && t[e - 1] < 0) || (a > 0 && t[e - 1] > 0)) &&
        ((i = a * 2), (n = o + i), i == n - o && (o = n))
    }
    return o
  }
}
function* Jq(r) {
  for (const t of r) yield* t
}
function zB(r) {
  return Array.from(Jq(r))
}
var tn = 1e-6,
  Qq = 1e-12,
  Pe = Math.PI,
  Jr = Pe / 2,
  ND = Pe / 4,
  Qi = Pe * 2,
  pi = 180 / Pe,
  Bn = Pe / 180,
  An = Math.abs,
  UB = Math.atan,
  Mp = Math.atan2,
  Dn = Math.cos,
  tZ = Math.exp,
  eZ = Math.log,
  Ln = Math.sin,
  nZ =
    Math.sign ||
    function (r) {
      return r > 0 ? 1 : r < 0 ? -1 : 0
    },
  U0 = Math.sqrt,
  rZ = Math.tan
function iZ(r) {
  return r > 1 ? 0 : r < -1 ? Pe : Math.acos(r)
}
function Tp(r) {
  return r > 1 ? Jr : r < -1 ? -Jr : Math.asin(r)
}
function Ld() {}
function by(r, t) {
  r && BD.hasOwnProperty(r.type) && BD[r.type](r, t)
}
var kD = {
    Feature: function (r, t) {
      by(r.geometry, t)
    },
    FeatureCollection: function (r, t) {
      for (var e = r.features, n = -1, i = e.length; ++n < i; )
        by(e[n].geometry, t)
    },
  },
  BD = {
    Sphere: function (r, t) {
      t.sphere()
    },
    Point: function (r, t) {
      ;(r = r.coordinates), t.point(r[0], r[1], r[2])
    },
    MultiPoint: function (r, t) {
      for (var e = r.coordinates, n = -1, i = e.length; ++n < i; )
        (r = e[n]), t.point(r[0], r[1], r[2])
    },
    LineString: function (r, t) {
      rb(r.coordinates, t, 0)
    },
    MultiLineString: function (r, t) {
      for (var e = r.coordinates, n = -1, i = e.length; ++n < i; )
        rb(e[n], t, 0)
    },
    Polygon: function (r, t) {
      FD(r.coordinates, t)
    },
    MultiPolygon: function (r, t) {
      for (var e = r.coordinates, n = -1, i = e.length; ++n < i; ) FD(e[n], t)
    },
    GeometryCollection: function (r, t) {
      for (var e = r.geometries, n = -1, i = e.length; ++n < i; ) by(e[n], t)
    },
  }
function rb(r, t, e) {
  var n = -1,
    i = r.length - e,
    a
  for (t.lineStart(); ++n < i; ) (a = r[n]), t.point(a[0], a[1], a[2])
  t.lineEnd()
}
function FD(r, t) {
  var e = -1,
    n = r.length
  for (t.polygonStart(); ++e < n; ) rb(r[e], t, 1)
  t.polygonEnd()
}
function aZ(r, t) {
  r && kD.hasOwnProperty(r.type) ? kD[r.type](r, t) : by(r, t)
}
function ib(r) {
  return [Mp(r[1], r[0]), Tp(r[2])]
}
function $h(r) {
  var t = r[0],
    e = r[1],
    n = Dn(e)
  return [n * Dn(t), n * Ln(t), Ln(e)]
}
function _g(r, t) {
  return r[0] * t[0] + r[1] * t[1] + r[2] * t[2]
}
function wy(r, t) {
  return [
    r[1] * t[2] - r[2] * t[1],
    r[2] * t[0] - r[0] * t[2],
    r[0] * t[1] - r[1] * t[0],
  ]
}
function Ax(r, t) {
  ;(r[0] += t[0]), (r[1] += t[1]), (r[2] += t[2])
}
function xg(r, t) {
  return [r[0] * t, r[1] * t, r[2] * t]
}
function ab(r) {
  var t = U0(r[0] * r[0] + r[1] * r[1] + r[2] * r[2])
  ;(r[0] /= t), (r[1] /= t), (r[2] /= t)
}
function ob(r, t) {
  function e(n, i) {
    return (n = r(n, i)), t(n[0], n[1])
  }
  return (
    r.invert &&
      t.invert &&
      (e.invert = function (n, i) {
        return (n = t.invert(n, i)), n && r.invert(n[0], n[1])
      }),
    e
  )
}
function sb(r, t) {
  return An(r) > Pe && (r -= Math.round(r / Qi) * Qi), [r, t]
}
sb.invert = sb
function VB(r, t, e) {
  return (r %= Qi)
    ? t || e
      ? ob(UD(r), VD(t, e))
      : UD(r)
    : t || e
    ? VD(t, e)
    : sb
}
function zD(r) {
  return function (t, e) {
    return (t += r), An(t) > Pe && (t -= Math.round(t / Qi) * Qi), [t, e]
  }
}
function UD(r) {
  var t = zD(r)
  return (t.invert = zD(-r)), t
}
function VD(r, t) {
  var e = Dn(r),
    n = Ln(r),
    i = Dn(t),
    a = Ln(t)
  function o(s, l) {
    var u = Dn(l),
      c = Dn(s) * u,
      h = Ln(s) * u,
      f = Ln(l),
      d = f * e + c * n
    return [Mp(h * i - d * a, c * e - f * n), Tp(d * i + h * a)]
  }
  return (
    (o.invert = function (s, l) {
      var u = Dn(l),
        c = Dn(s) * u,
        h = Ln(s) * u,
        f = Ln(l),
        d = f * i - h * a
      return [Mp(h * i + f * a, c * e + d * n), Tp(d * e - c * n)]
    }),
    o
  )
}
function oZ(r) {
  r = VB(r[0] * Bn, r[1] * Bn, r.length > 2 ? r[2] * Bn : 0)
  function t(e) {
    return (e = r(e[0] * Bn, e[1] * Bn)), (e[0] *= pi), (e[1] *= pi), e
  }
  return (
    (t.invert = function (e) {
      return (e = r.invert(e[0] * Bn, e[1] * Bn)), (e[0] *= pi), (e[1] *= pi), e
    }),
    t
  )
}
function sZ(r, t, e, n, i, a) {
  if (e) {
    var o = Dn(t),
      s = Ln(t),
      l = n * e
    i == null
      ? ((i = t + n * Qi), (a = t - l / 2))
      : ((i = GD(o, i)),
        (a = GD(o, a)),
        (n > 0 ? i < a : i > a) && (i += n * Qi))
    for (var u, c = i; n > 0 ? c > a : c < a; c -= l)
      (u = ib([o, -s * Dn(c), -s * Ln(c)])), r.point(u[0], u[1])
  }
}
function GD(r, t) {
  ;(t = $h(t)), (t[0] -= r), ab(t)
  var e = iZ(-t[1])
  return ((-t[2] < 0 ? -e : e) + Qi - tn) % Qi
}
function GB() {
  var r = [],
    t
  return {
    point: function (e, n, i) {
      t.push([e, n, i])
    },
    lineStart: function () {
      r.push((t = []))
    },
    lineEnd: Ld,
    rejoin: function () {
      r.length > 1 && r.push(r.pop().concat(r.shift()))
    },
    result: function () {
      var e = r
      return (r = []), (t = null), e
    },
  }
}
function Um(r, t) {
  return An(r[0] - t[0]) < tn && An(r[1] - t[1]) < tn
}
function Sg(r, t, e, n) {
  ;(this.x = r),
    (this.z = t),
    (this.o = e),
    (this.e = n),
    (this.v = !1),
    (this.n = this.p = null)
}
function HB(r, t, e, n, i) {
  var a = [],
    o = [],
    s,
    l
  if (
    (r.forEach(function (p) {
      if (!((g = p.length - 1) <= 0)) {
        var g,
          v = p[0],
          m = p[g],
          y
        if (Um(v, m)) {
          if (!v[2] && !m[2]) {
            for (i.lineStart(), s = 0; s < g; ++s) i.point((v = p[s])[0], v[1])
            i.lineEnd()
            return
          }
          m[0] += 2 * tn
        }
        a.push((y = new Sg(v, p, null, !0))),
          o.push((y.o = new Sg(v, null, y, !1))),
          a.push((y = new Sg(m, p, null, !1))),
          o.push((y.o = new Sg(m, null, y, !0)))
      }
    }),
    !!a.length)
  ) {
    for (o.sort(t), HD(a), HD(o), s = 0, l = o.length; s < l; ++s)
      o[s].e = e = !e
    for (var u = a[0], c, h; ; ) {
      for (var f = u, d = !0; f.v; ) if ((f = f.n) === u) return
      ;(c = f.z), i.lineStart()
      do {
        if (((f.v = f.o.v = !0), f.e)) {
          if (d)
            for (s = 0, l = c.length; s < l; ++s) i.point((h = c[s])[0], h[1])
          else n(f.x, f.n.x, 1, i)
          f = f.n
        } else {
          if (d)
            for (c = f.p.z, s = c.length - 1; s >= 0; --s)
              i.point((h = c[s])[0], h[1])
          else n(f.x, f.p.x, -1, i)
          f = f.p
        }
        ;(f = f.o), (c = f.z), (d = !d)
      } while (!f.v)
      i.lineEnd()
    }
  }
}
function HD(r) {
  if ((t = r.length)) {
    for (var t, e = 0, n = r[0], i; ++e < t; )
      (n.n = i = r[e]), (i.p = n), (n = i)
    ;(n.n = i = r[0]), (i.p = n)
  }
}
function bx(r) {
  return An(r[0]) <= Pe ? r[0] : nZ(r[0]) * (((An(r[0]) + Pe) % Qi) - Pe)
}
function lZ(r, t) {
  var e = bx(t),
    n = t[1],
    i = Ln(n),
    a = [Ln(e), -Dn(e), 0],
    o = 0,
    s = 0,
    l = new jq()
  i === 1 ? (n = Jr + tn) : i === -1 && (n = -Jr - tn)
  for (var u = 0, c = r.length; u < c; ++u)
    if ((f = (h = r[u]).length))
      for (
        var h,
          f,
          d = h[f - 1],
          p = bx(d),
          g = d[1] / 2 + ND,
          v = Ln(g),
          m = Dn(g),
          y = 0;
        y < f;
        ++y, p = x, v = S, m = b, d = _
      ) {
        var _ = h[y],
          x = bx(_),
          A = _[1] / 2 + ND,
          S = Ln(A),
          b = Dn(A),
          T = x - p,
          w = T >= 0 ? 1 : -1,
          M = w * T,
          C = M > Pe,
          E = v * S
        if (
          (l.add(Mp(E * w * Ln(M), m * b + E * Dn(M))),
          (o += C ? T + w * Qi : T),
          C ^ (p >= e) ^ (x >= e))
        ) {
          var D = wy($h(d), $h(_))
          ab(D)
          var P = wy(a, D)
          ab(P)
          var L = (C ^ (T >= 0) ? -1 : 1) * Tp(P[2])
          ;(n > L || (n === L && (D[0] || D[1]))) &&
            (s += C ^ (T >= 0) ? 1 : -1)
        }
      }
  return (o < -tn || (o < tn && l < -Qq)) ^ (s & 1)
}
function WB(r, t, e, n) {
  return function (i) {
    var a = t(i),
      o = GB(),
      s = t(o),
      l = !1,
      u,
      c,
      h,
      f = {
        point: d,
        lineStart: g,
        lineEnd: v,
        polygonStart: function () {
          ;(f.point = m), (f.lineStart = y), (f.lineEnd = _), (c = []), (u = [])
        },
        polygonEnd: function () {
          ;(f.point = d), (f.lineStart = g), (f.lineEnd = v), (c = zB(c))
          var x = lZ(u, n)
          c.length
            ? (l || (i.polygonStart(), (l = !0)), HB(c, cZ, x, e, i))
            : x &&
              (l || (i.polygonStart(), (l = !0)),
              i.lineStart(),
              e(null, null, 1, i),
              i.lineEnd()),
            l && (i.polygonEnd(), (l = !1)),
            (c = u = null)
        },
        sphere: function () {
          i.polygonStart(),
            i.lineStart(),
            e(null, null, 1, i),
            i.lineEnd(),
            i.polygonEnd()
        },
      }
    function d(x, A) {
      r(x, A) && i.point(x, A)
    }
    function p(x, A) {
      a.point(x, A)
    }
    function g() {
      ;(f.point = p), a.lineStart()
    }
    function v() {
      ;(f.point = d), a.lineEnd()
    }
    function m(x, A) {
      h.push([x, A]), s.point(x, A)
    }
    function y() {
      s.lineStart(), (h = [])
    }
    function _() {
      m(h[0][0], h[0][1]), s.lineEnd()
      var x = s.clean(),
        A = o.result(),
        S,
        b = A.length,
        T,
        w,
        M
      if ((h.pop(), u.push(h), (h = null), !!b)) {
        if (x & 1) {
          if (((w = A[0]), (T = w.length - 1) > 0)) {
            for (
              l || (i.polygonStart(), (l = !0)), i.lineStart(), S = 0;
              S < T;
              ++S
            )
              i.point((M = w[S])[0], M[1])
            i.lineEnd()
          }
          return
        }
        b > 1 && x & 2 && A.push(A.pop().concat(A.shift())),
          c.push(A.filter(uZ))
      }
    }
    return f
  }
}
function uZ(r) {
  return r.length > 1
}
function cZ(r, t) {
  return (
    ((r = r.x)[0] < 0 ? r[1] - Jr - tn : Jr - r[1]) -
    ((t = t.x)[0] < 0 ? t[1] - Jr - tn : Jr - t[1])
  )
}
const WD = WB(
  function () {
    return !0
  },
  hZ,
  dZ,
  [-Pe, -Jr],
)
function hZ(r) {
  var t = NaN,
    e = NaN,
    n = NaN,
    i
  return {
    lineStart: function () {
      r.lineStart(), (i = 1)
    },
    point: function (a, o) {
      var s = a > 0 ? Pe : -Pe,
        l = An(a - t)
      An(l - Pe) < tn
        ? (r.point(t, (e = (e + o) / 2 > 0 ? Jr : -Jr)),
          r.point(n, e),
          r.lineEnd(),
          r.lineStart(),
          r.point(s, e),
          r.point(a, e),
          (i = 0))
        : n !== s &&
          l >= Pe &&
          (An(t - n) < tn && (t -= n * tn),
          An(a - s) < tn && (a -= s * tn),
          (e = fZ(t, e, a, o)),
          r.point(n, e),
          r.lineEnd(),
          r.lineStart(),
          r.point(s, e),
          (i = 0)),
        r.point((t = a), (e = o)),
        (n = s)
    },
    lineEnd: function () {
      r.lineEnd(), (t = e = NaN)
    },
    clean: function () {
      return 2 - i
    },
  }
}
function fZ(r, t, e, n) {
  var i,
    a,
    o = Ln(r - e)
  return An(o) > tn
    ? UB(
        (Ln(t) * (a = Dn(n)) * Ln(e) - Ln(n) * (i = Dn(t)) * Ln(r)) /
          (i * a * o),
      )
    : (t + n) / 2
}
function dZ(r, t, e, n) {
  var i
  if (r == null)
    (i = e * Jr),
      n.point(-Pe, i),
      n.point(0, i),
      n.point(Pe, i),
      n.point(Pe, 0),
      n.point(Pe, -i),
      n.point(0, -i),
      n.point(-Pe, -i),
      n.point(-Pe, 0),
      n.point(-Pe, i)
  else if (An(r[0] - t[0]) > tn) {
    var a = r[0] < t[0] ? Pe : -Pe
    ;(i = (e * a) / 2), n.point(-a, i), n.point(0, i), n.point(a, i)
  } else n.point(t[0], t[1])
}
function pZ(r) {
  var t = Dn(r),
    e = 2 * Bn,
    n = t > 0,
    i = An(t) > tn
  function a(c, h, f, d) {
    sZ(d, r, e, f, c, h)
  }
  function o(c, h) {
    return Dn(c) * Dn(h) > t
  }
  function s(c) {
    var h, f, d, p, g
    return {
      lineStart: function () {
        ;(p = d = !1), (g = 1)
      },
      point: function (v, m) {
        var y = [v, m],
          _,
          x = o(v, m),
          A = n ? (x ? 0 : u(v, m)) : x ? u(v + (v < 0 ? Pe : -Pe), m) : 0
        if (
          (!h && (p = d = x) && c.lineStart(),
          x !== d &&
            ((_ = l(h, y)), (!_ || Um(h, _) || Um(y, _)) && (y[2] = 1)),
          x !== d)
        )
          (g = 0),
            x
              ? (c.lineStart(), (_ = l(y, h)), c.point(_[0], _[1]))
              : ((_ = l(h, y)), c.point(_[0], _[1], 2), c.lineEnd()),
            (h = _)
        else if (i && h && n ^ x) {
          var S
          !(A & f) &&
            (S = l(y, h, !0)) &&
            ((g = 0),
            n
              ? (c.lineStart(),
                c.point(S[0][0], S[0][1]),
                c.point(S[1][0], S[1][1]),
                c.lineEnd())
              : (c.point(S[1][0], S[1][1]),
                c.lineEnd(),
                c.lineStart(),
                c.point(S[0][0], S[0][1], 3)))
        }
        x && (!h || !Um(h, y)) && c.point(y[0], y[1]), (h = y), (d = x), (f = A)
      },
      lineEnd: function () {
        d && c.lineEnd(), (h = null)
      },
      clean: function () {
        return g | ((p && d) << 1)
      },
    }
  }
  function l(c, h, f) {
    var d = $h(c),
      p = $h(h),
      g = [1, 0, 0],
      v = wy(d, p),
      m = _g(v, v),
      y = v[0],
      _ = m - y * y
    if (!_) return !f && c
    var x = (t * m) / _,
      A = (-t * y) / _,
      S = wy(g, v),
      b = xg(g, x),
      T = xg(v, A)
    Ax(b, T)
    var w = S,
      M = _g(b, w),
      C = _g(w, w),
      E = M * M - C * (_g(b, b) - 1)
    if (!(E < 0)) {
      var D = U0(E),
        P = xg(w, (-M - D) / C)
      if ((Ax(P, b), (P = ib(P)), !f)) return P
      var L = c[0],
        I = h[0],
        F = c[1],
        k = h[1],
        V
      I < L && ((V = L), (L = I), (I = V))
      var H = I - L,
        Y = An(H - Pe) < tn,
        K = Y || H < tn
      if (
        (!Y && k < F && ((V = F), (F = k), (k = V)),
        K
          ? Y
            ? (F + k > 0) ^ (P[1] < (An(P[0] - L) < tn ? F : k))
            : F <= P[1] && P[1] <= k
          : (H > Pe) ^ (L <= P[0] && P[0] <= I))
      ) {
        var ut = xg(w, (-M + D) / C)
        return Ax(ut, b), [P, ib(ut)]
      }
    }
  }
  function u(c, h) {
    var f = n ? r : Pe - r,
      d = 0
    return (
      c < -f ? (d |= 1) : c > f && (d |= 2),
      h < -f ? (d |= 4) : h > f && (d |= 8),
      d
    )
  }
  return WB(o, s, a, n ? [0, -r] : [-Pe, r - Pe])
}
function vZ(r, t, e, n, i, a) {
  var o = r[0],
    s = r[1],
    l = t[0],
    u = t[1],
    c = 0,
    h = 1,
    f = l - o,
    d = u - s,
    p
  if (((p = e - o), !(!f && p > 0))) {
    if (((p /= f), f < 0)) {
      if (p < c) return
      p < h && (h = p)
    } else if (f > 0) {
      if (p > h) return
      p > c && (c = p)
    }
    if (((p = i - o), !(!f && p < 0))) {
      if (((p /= f), f < 0)) {
        if (p > h) return
        p > c && (c = p)
      } else if (f > 0) {
        if (p < c) return
        p < h && (h = p)
      }
      if (((p = n - s), !(!d && p > 0))) {
        if (((p /= d), d < 0)) {
          if (p < c) return
          p < h && (h = p)
        } else if (d > 0) {
          if (p > h) return
          p > c && (c = p)
        }
        if (((p = a - s), !(!d && p < 0))) {
          if (((p /= d), d < 0)) {
            if (p > h) return
            p > c && (c = p)
          } else if (d > 0) {
            if (p < c) return
            p < h && (h = p)
          }
          return (
            c > 0 && ((r[0] = o + c * f), (r[1] = s + c * d)),
            h < 1 && ((t[0] = o + h * f), (t[1] = s + h * d)),
            !0
          )
        }
      }
    }
  }
}
var Pd = 1e9,
  Ag = -Pd
function gZ(r, t, e, n) {
  function i(u, c) {
    return r <= u && u <= e && t <= c && c <= n
  }
  function a(u, c, h, f) {
    var d = 0,
      p = 0
    if (u == null || (d = o(u, h)) !== (p = o(c, h)) || (l(u, c) < 0) ^ (h > 0))
      do f.point(d === 0 || d === 3 ? r : e, d > 1 ? n : t)
      while ((d = (d + h + 4) % 4) !== p)
    else f.point(c[0], c[1])
  }
  function o(u, c) {
    return An(u[0] - r) < tn
      ? c > 0
        ? 0
        : 3
      : An(u[0] - e) < tn
      ? c > 0
        ? 2
        : 1
      : An(u[1] - t) < tn
      ? c > 0
        ? 1
        : 0
      : c > 0
      ? 3
      : 2
  }
  function s(u, c) {
    return l(u.x, c.x)
  }
  function l(u, c) {
    var h = o(u, 1),
      f = o(c, 1)
    return h !== f
      ? h - f
      : h === 0
      ? c[1] - u[1]
      : h === 1
      ? u[0] - c[0]
      : h === 2
      ? u[1] - c[1]
      : c[0] - u[0]
  }
  return function (u) {
    var c = u,
      h = GB(),
      f,
      d,
      p,
      g,
      v,
      m,
      y,
      _,
      x,
      A,
      S,
      b = {
        point: T,
        lineStart: E,
        lineEnd: D,
        polygonStart: M,
        polygonEnd: C,
      }
    function T(L, I) {
      i(L, I) && c.point(L, I)
    }
    function w() {
      for (var L = 0, I = 0, F = d.length; I < F; ++I)
        for (
          var k = d[I],
            V = 1,
            H = k.length,
            Y = k[0],
            K,
            ut,
            W = Y[0],
            Z = Y[1];
          V < H;
          ++V
        )
          (K = W),
            (ut = Z),
            (Y = k[V]),
            (W = Y[0]),
            (Z = Y[1]),
            ut <= n
              ? Z > n && (W - K) * (n - ut) > (Z - ut) * (r - K) && ++L
              : Z <= n && (W - K) * (n - ut) < (Z - ut) * (r - K) && --L
      return L
    }
    function M() {
      ;(c = h), (f = []), (d = []), (S = !0)
    }
    function C() {
      var L = w(),
        I = S && L,
        F = (f = zB(f)).length
      ;(I || F) &&
        (u.polygonStart(),
        I && (u.lineStart(), a(null, null, 1, u), u.lineEnd()),
        F && HB(f, s, L, a, u),
        u.polygonEnd()),
        (c = u),
        (f = d = p = null)
    }
    function E() {
      ;(b.point = P), d && d.push((p = [])), (A = !0), (x = !1), (y = _ = NaN)
    }
    function D() {
      f && (P(g, v), m && x && h.rejoin(), f.push(h.result())),
        (b.point = T),
        x && c.lineEnd()
    }
    function P(L, I) {
      var F = i(L, I)
      if ((d && p.push([L, I]), A))
        (g = L), (v = I), (m = F), (A = !1), F && (c.lineStart(), c.point(L, I))
      else if (F && x) c.point(L, I)
      else {
        var k = [
            (y = Math.max(Ag, Math.min(Pd, y))),
            (_ = Math.max(Ag, Math.min(Pd, _))),
          ],
          V = [
            (L = Math.max(Ag, Math.min(Pd, L))),
            (I = Math.max(Ag, Math.min(Pd, I))),
          ]
        vZ(k, V, r, t, e, n)
          ? (x || (c.lineStart(), c.point(k[0], k[1])),
            c.point(V[0], V[1]),
            F || c.lineEnd(),
            (S = !1))
          : F && (c.lineStart(), c.point(L, I), (S = !1))
      }
      ;(y = L), (_ = I), (x = F)
    }
    return b
  }
}
const XD = r => r
var qh = 1 / 0,
  My = qh,
  Cp = -qh,
  Ty = Cp,
  mZ = {
    point: yZ,
    lineStart: Ld,
    lineEnd: Ld,
    polygonStart: Ld,
    polygonEnd: Ld,
    result: function () {
      var r = [
        [qh, My],
        [Cp, Ty],
      ]
      return (Cp = Ty = -(My = qh = 1 / 0)), r
    },
  }
function yZ(r, t) {
  r < qh && (qh = r), r > Cp && (Cp = r), t < My && (My = t), t > Ty && (Ty = t)
}
const YD = mZ
function tT(r) {
  return function (t) {
    var e = new lb()
    for (var n in r) e[n] = r[n]
    return (e.stream = t), e
  }
}
function lb() {}
lb.prototype = {
  constructor: lb,
  point: function (r, t) {
    this.stream.point(r, t)
  },
  sphere: function () {
    this.stream.sphere()
  },
  lineStart: function () {
    this.stream.lineStart()
  },
  lineEnd: function () {
    this.stream.lineEnd()
  },
  polygonStart: function () {
    this.stream.polygonStart()
  },
  polygonEnd: function () {
    this.stream.polygonEnd()
  },
}
function eT(r, t, e) {
  var n = r.clipExtent && r.clipExtent()
  return (
    r.scale(150).translate([0, 0]),
    n != null && r.clipExtent(null),
    aZ(e, r.stream(YD)),
    t(YD.result()),
    n != null && r.clipExtent(n),
    r
  )
}
function XB(r, t, e) {
  return eT(
    r,
    function (n) {
      var i = t[1][0] - t[0][0],
        a = t[1][1] - t[0][1],
        o = Math.min(i / (n[1][0] - n[0][0]), a / (n[1][1] - n[0][1])),
        s = +t[0][0] + (i - o * (n[1][0] + n[0][0])) / 2,
        l = +t[0][1] + (a - o * (n[1][1] + n[0][1])) / 2
      r.scale(150 * o).translate([s, l])
    },
    e,
  )
}
function _Z(r, t, e) {
  return XB(r, [[0, 0], t], e)
}
function xZ(r, t, e) {
  return eT(
    r,
    function (n) {
      var i = +t,
        a = i / (n[1][0] - n[0][0]),
        o = (i - a * (n[1][0] + n[0][0])) / 2,
        s = -a * n[0][1]
      r.scale(150 * a).translate([o, s])
    },
    e,
  )
}
function SZ(r, t, e) {
  return eT(
    r,
    function (n) {
      var i = +t,
        a = i / (n[1][1] - n[0][1]),
        o = -a * n[0][0],
        s = (i - a * (n[1][1] + n[0][1])) / 2
      r.scale(150 * a).translate([o, s])
    },
    e,
  )
}
var $D = 16,
  AZ = Dn(30 * Bn)
function qD(r, t) {
  return +t ? wZ(r, t) : bZ(r)
}
function bZ(r) {
  return tT({
    point: function (t, e) {
      ;(t = r(t, e)), this.stream.point(t[0], t[1])
    },
  })
}
function wZ(r, t) {
  function e(n, i, a, o, s, l, u, c, h, f, d, p, g, v) {
    var m = u - n,
      y = c - i,
      _ = m * m + y * y
    if (_ > 4 * t && g--) {
      var x = o + f,
        A = s + d,
        S = l + p,
        b = U0(x * x + A * A + S * S),
        T = Tp((S /= b)),
        w = An(An(S) - 1) < tn || An(a - h) < tn ? (a + h) / 2 : Mp(A, x),
        M = r(w, T),
        C = M[0],
        E = M[1],
        D = C - n,
        P = E - i,
        L = y * D - m * P
      ;((L * L) / _ > t ||
        An((m * D + y * P) / _ - 0.5) > 0.3 ||
        o * f + s * d + l * p < AZ) &&
        (e(n, i, a, o, s, l, C, E, w, (x /= b), (A /= b), S, g, v),
        v.point(C, E),
        e(C, E, w, x, A, S, u, c, h, f, d, p, g, v))
    }
  }
  return function (n) {
    var i,
      a,
      o,
      s,
      l,
      u,
      c,
      h,
      f,
      d,
      p,
      g,
      v = {
        point: m,
        lineStart: y,
        lineEnd: x,
        polygonStart: function () {
          n.polygonStart(), (v.lineStart = A)
        },
        polygonEnd: function () {
          n.polygonEnd(), (v.lineStart = y)
        },
      }
    function m(T, w) {
      ;(T = r(T, w)), n.point(T[0], T[1])
    }
    function y() {
      ;(h = NaN), (v.point = _), n.lineStart()
    }
    function _(T, w) {
      var M = $h([T, w]),
        C = r(T, w)
      e(
        h,
        f,
        c,
        d,
        p,
        g,
        (h = C[0]),
        (f = C[1]),
        (c = T),
        (d = M[0]),
        (p = M[1]),
        (g = M[2]),
        $D,
        n,
      ),
        n.point(h, f)
    }
    function x() {
      ;(v.point = m), n.lineEnd()
    }
    function A() {
      y(), (v.point = S), (v.lineEnd = b)
    }
    function S(T, w) {
      _((i = T), w), (a = h), (o = f), (s = d), (l = p), (u = g), (v.point = _)
    }
    function b() {
      e(h, f, c, d, p, g, a, o, i, s, l, u, $D, n), (v.lineEnd = x), x()
    }
    return v
  }
}
var MZ = tT({
  point: function (r, t) {
    this.stream.point(r * Bn, t * Bn)
  },
})
function TZ(r) {
  return tT({
    point: function (t, e) {
      var n = r(t, e)
      return this.stream.point(n[0], n[1])
    },
  })
}
function CZ(r, t, e, n, i) {
  function a(o, s) {
    return (o *= n), (s *= i), [t + r * o, e - r * s]
  }
  return (
    (a.invert = function (o, s) {
      return [((o - t) / r) * n, ((e - s) / r) * i]
    }),
    a
  )
}
function ZD(r, t, e, n, i, a) {
  if (!a) return CZ(r, t, e, n, i)
  var o = Dn(a),
    s = Ln(a),
    l = o * r,
    u = s * r,
    c = o / r,
    h = s / r,
    f = (s * e - o * t) / r,
    d = (s * t + o * e) / r
  function p(g, v) {
    return (g *= n), (v *= i), [l * g - u * v + t, e - u * g - l * v]
  }
  return (
    (p.invert = function (g, v) {
      return [n * (c * g - h * v + f), i * (d - h * g - c * v)]
    }),
    p
  )
}
function EZ(r) {
  return DZ(function () {
    return r
  })()
}
function DZ(r) {
  var t,
    e = 150,
    n = 480,
    i = 250,
    a = 0,
    o = 0,
    s = 0,
    l = 0,
    u = 0,
    c,
    h = 0,
    f = 1,
    d = 1,
    p = null,
    g = WD,
    v = null,
    m,
    y,
    _,
    x = XD,
    A = 0.5,
    S,
    b,
    T,
    w,
    M
  function C(L) {
    return T(L[0] * Bn, L[1] * Bn)
  }
  function E(L) {
    return (L = T.invert(L[0], L[1])), L && [L[0] * pi, L[1] * pi]
  }
  ;(C.stream = function (L) {
    return w && M === L ? w : (w = MZ(TZ(c)(g(S(x((M = L)))))))
  }),
    (C.preclip = function (L) {
      return arguments.length ? ((g = L), (p = void 0), P()) : g
    }),
    (C.postclip = function (L) {
      return arguments.length ? ((x = L), (v = m = y = _ = null), P()) : x
    }),
    (C.clipAngle = function (L) {
      return arguments.length
        ? ((g = +L ? pZ((p = L * Bn)) : ((p = null), WD)), P())
        : p * pi
    }),
    (C.clipExtent = function (L) {
      return arguments.length
        ? ((x =
            L == null
              ? ((v = m = y = _ = null), XD)
              : gZ(
                  (v = +L[0][0]),
                  (m = +L[0][1]),
                  (y = +L[1][0]),
                  (_ = +L[1][1]),
                )),
          P())
        : v == null
        ? null
        : [
            [v, m],
            [y, _],
          ]
    }),
    (C.scale = function (L) {
      return arguments.length ? ((e = +L), D()) : e
    }),
    (C.translate = function (L) {
      return arguments.length ? ((n = +L[0]), (i = +L[1]), D()) : [n, i]
    }),
    (C.center = function (L) {
      return arguments.length
        ? ((a = (L[0] % 360) * Bn), (o = (L[1] % 360) * Bn), D())
        : [a * pi, o * pi]
    }),
    (C.rotate = function (L) {
      return arguments.length
        ? ((s = (L[0] % 360) * Bn),
          (l = (L[1] % 360) * Bn),
          (u = L.length > 2 ? (L[2] % 360) * Bn : 0),
          D())
        : [s * pi, l * pi, u * pi]
    }),
    (C.angle = function (L) {
      return arguments.length ? ((h = (L % 360) * Bn), D()) : h * pi
    }),
    (C.reflectX = function (L) {
      return arguments.length ? ((f = L ? -1 : 1), D()) : f < 0
    }),
    (C.reflectY = function (L) {
      return arguments.length ? ((d = L ? -1 : 1), D()) : d < 0
    }),
    (C.precision = function (L) {
      return arguments.length ? ((S = qD(b, (A = L * L))), P()) : U0(A)
    }),
    (C.fitExtent = function (L, I) {
      return XB(C, L, I)
    }),
    (C.fitSize = function (L, I) {
      return _Z(C, L, I)
    }),
    (C.fitWidth = function (L, I) {
      return xZ(C, L, I)
    }),
    (C.fitHeight = function (L, I) {
      return SZ(C, L, I)
    })
  function D() {
    var L = ZD(e, 0, 0, f, d, h).apply(null, t(a, o)),
      I = ZD(e, n - L[0], i - L[1], f, d, h)
    return (
      (c = VB(s, l, u)), (b = ob(t, I)), (T = ob(c, b)), (S = qD(b, A)), P()
    )
  }
  function P() {
    return (w = M = null), C
  }
  return function () {
    return (t = r.apply(this, arguments)), (C.invert = t.invert && E), D()
  }
}
function nT(r, t) {
  return [r, eZ(rZ((Jr + t) / 2))]
}
nT.invert = function (r, t) {
  return [r, 2 * UB(tZ(t)) - Jr]
}
function V0() {
  return LZ(nT).scale(961 / Qi)
}
function LZ(r) {
  var t = EZ(r),
    e = t.center,
    n = t.scale,
    i = t.translate,
    a = t.clipExtent,
    o = null,
    s,
    l,
    u
  ;(t.scale = function (h) {
    return arguments.length ? (n(h), c()) : n()
  }),
    (t.translate = function (h) {
      return arguments.length ? (i(h), c()) : i()
    }),
    (t.center = function (h) {
      return arguments.length ? (e(h), c()) : e()
    }),
    (t.clipExtent = function (h) {
      return arguments.length
        ? (h == null
            ? (o = s = l = u = null)
            : ((o = +h[0][0]), (s = +h[0][1]), (l = +h[1][0]), (u = +h[1][1])),
          c())
        : o == null
        ? null
        : [
            [o, s],
            [l, u],
          ]
    })
  function c() {
    var h = Pe * n(),
      f = t(oZ(t.rotate()).invert([0, 0]))
    return a(
      o == null
        ? [
            [f[0] - h, f[1] - h],
            [f[0] + h, f[1] + h],
          ]
        : r === nT
        ? [
            [Math.max(f[0] - h, o), s],
            [Math.min(f[0] + h, l), u],
          ]
        : [
            [o, Math.max(f[1] - h, s)],
            [l, Math.min(f[1] + h, u)],
          ],
    )
  }
  return c()
}
class PZ extends z0 {
  constructor(t, e = {}) {
    super()
    let n = {
      isOrthographic: !1,
    }
    ;(this.config = Object.assign({}, n, e)),
      (this.canvas = t),
      (this.scene = new hB()),
      (this.sizes = new nq(this)),
      (this.time = new rq(this)),
      (this.camera = new Kq(this, {
        isOrthographic: this.config.isOrthographic,
      })),
      (this.renderer = new qq(this)),
      this.sizes.on('resize', () => {
        this.resize()
      }),
      this.time.on('tick', i => {
        this.update(i)
      })
  }
  setAxesHelper(t = 250) {
    if (!t) return !1
    let e = new RB(t)
    this.scene.add(e)
  }
  resize() {
    this.camera.resize(), this.renderer.resize()
  }
  update(t) {
    this.camera.update(t), this.renderer.update(t)
  }
  destroy() {
    this.sizes.destroy(),
      this.time.destroy(),
      this.camera.destroy(),
      this.renderer.destroy(),
      this.scene.traverse(t => {
        if (t instanceof De) {
          t.geometry.dispose()
          for (const e in t.material) {
            const n = t.material[e]
            n && typeof n.dispose == 'function' && n.dispose()
          }
        }
      }),
      this.canvas.parentNode.removeChild(this.canvas)
  }
}
/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.17.0
 * @author George Michael Brower
 * @license MIT
 */
class ro {
  constructor(t, e, n, i, a = 'div') {
    ;(this.parent = t),
      (this.object = e),
      (this.property = n),
      (this._disabled = !1),
      (this._hidden = !1),
      (this.initialValue = this.getValue()),
      (this.domElement = document.createElement('div')),
      this.domElement.classList.add('controller'),
      this.domElement.classList.add(i),
      (this.$name = document.createElement('div')),
      this.$name.classList.add('name'),
      (ro.nextNameID = ro.nextNameID || 0),
      (this.$name.id = 'lil-gui-name-' + ++ro.nextNameID),
      (this.$widget = document.createElement(a)),
      this.$widget.classList.add('widget'),
      (this.$disable = this.$widget),
      this.domElement.appendChild(this.$name),
      this.domElement.appendChild(this.$widget),
      this.parent.children.push(this),
      this.parent.controllers.push(this),
      this.parent.$children.appendChild(this.domElement),
      (this._listenCallback = this._listenCallback.bind(this)),
      this.name(n)
  }
  name(t) {
    return (this._name = t), (this.$name.innerHTML = t), this
  }
  onChange(t) {
    return (this._onChange = t), this
  }
  _callOnChange() {
    this.parent._callOnChange(this),
      this._onChange !== void 0 && this._onChange.call(this, this.getValue()),
      (this._changed = !0)
  }
  onFinishChange(t) {
    return (this._onFinishChange = t), this
  }
  _callOnFinishChange() {
    this._changed &&
      (this.parent._callOnFinishChange(this),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, this.getValue())),
      (this._changed = !1)
  }
  reset() {
    return this.setValue(this.initialValue), this._callOnFinishChange(), this
  }
  enable(t = !0) {
    return this.disable(!t)
  }
  disable(t = !0) {
    return (
      t === this._disabled ||
        ((this._disabled = t),
        this.domElement.classList.toggle('disabled', t),
        this.$disable.toggleAttribute('disabled', t)),
      this
    )
  }
  show(t = !0) {
    return (
      (this._hidden = !t),
      (this.domElement.style.display = this._hidden ? 'none' : ''),
      this
    )
  }
  hide() {
    return this.show(!1)
  }
  options(t) {
    const e = this.parent.add(this.object, this.property, t)
    return e.name(this._name), this.destroy(), e
  }
  min(t) {
    return this
  }
  max(t) {
    return this
  }
  step(t) {
    return this
  }
  decimals(t) {
    return this
  }
  listen(t = !0) {
    return (
      (this._listening = t),
      this._listenCallbackID !== void 0 &&
        (cancelAnimationFrame(this._listenCallbackID),
        (this._listenCallbackID = void 0)),
      this._listening && this._listenCallback(),
      this
    )
  }
  _listenCallback() {
    this._listenCallbackID = requestAnimationFrame(this._listenCallback)
    const t = this.save()
    t !== this._listenPrevValue && this.updateDisplay(),
      (this._listenPrevValue = t)
  }
  getValue() {
    return this.object[this.property]
  }
  setValue(t) {
    return (
      (this.object[this.property] = t),
      this._callOnChange(),
      this.updateDisplay(),
      this
    )
  }
  updateDisplay() {
    return this
  }
  load(t) {
    return this.setValue(t), this._callOnFinishChange(), this
  }
  save() {
    return this.getValue()
  }
  destroy() {
    this.listen(!1),
      this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.controllers.splice(this.parent.controllers.indexOf(this), 1),
      this.parent.$children.removeChild(this.domElement)
  }
}
let RZ = class extends ro {
  constructor(t, e, n) {
    super(t, e, n, 'boolean', 'label'),
      (this.$input = document.createElement('input')),
      this.$input.setAttribute('type', 'checkbox'),
      this.$input.setAttribute('aria-labelledby', this.$name.id),
      this.$widget.appendChild(this.$input),
      this.$input.addEventListener('change', () => {
        this.setValue(this.$input.checked), this._callOnFinishChange()
      }),
      (this.$disable = this.$input),
      this.updateDisplay()
  }
  updateDisplay() {
    return (this.$input.checked = this.getValue()), this
  }
}
function ub(r) {
  let t, e
  return (
    (t = r.match(/(#|0x)?([a-f0-9]{6})/i))
      ? (e = t[2])
      : (t = r.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))
      ? (e =
          parseInt(t[1]).toString(16).padStart(2, 0) +
          parseInt(t[2]).toString(16).padStart(2, 0) +
          parseInt(t[3]).toString(16).padStart(2, 0))
      : (t = r.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i)) &&
        (e = t[1] + t[1] + t[2] + t[2] + t[3] + t[3]),
    !!e && '#' + e
  )
}
const IZ = {
    isPrimitive: !0,
    match: r => typeof r == 'string',
    fromHexString: ub,
    toHexString: ub,
  },
  Ep = {
    isPrimitive: !0,
    match: r => typeof r == 'number',
    fromHexString: r => parseInt(r.substring(1), 16),
    toHexString: r => '#' + r.toString(16).padStart(6, 0),
  },
  OZ = {
    isPrimitive: !1,
    match: Array.isArray,
    fromHexString(r, t, e = 1) {
      const n = Ep.fromHexString(r)
      ;(t[0] = (((n >> 16) & 255) / 255) * e),
        (t[1] = (((n >> 8) & 255) / 255) * e),
        (t[2] = ((255 & n) / 255) * e)
    },
    toHexString: ([r, t, e], n = 1) =>
      Ep.toHexString(
        ((r * (n = 255 / n)) << 16) ^ ((t * n) << 8) ^ ((e * n) << 0),
      ),
  },
  NZ = {
    isPrimitive: !1,
    match: r => Object(r) === r,
    fromHexString(r, t, e = 1) {
      const n = Ep.fromHexString(r)
      ;(t.r = (((n >> 16) & 255) / 255) * e),
        (t.g = (((n >> 8) & 255) / 255) * e),
        (t.b = ((255 & n) / 255) * e)
    },
    toHexString: ({r, g: t, b: e}, n = 1) =>
      Ep.toHexString(
        ((r * (n = 255 / n)) << 16) ^ ((t * n) << 8) ^ ((e * n) << 0),
      ),
  },
  kZ = [IZ, Ep, OZ, NZ]
class BZ extends ro {
  constructor(t, e, n, i) {
    var a
    super(t, e, n, 'color'),
      (this.$input = document.createElement('input')),
      this.$input.setAttribute('type', 'color'),
      this.$input.setAttribute('tabindex', -1),
      this.$input.setAttribute('aria-labelledby', this.$name.id),
      (this.$text = document.createElement('input')),
      this.$text.setAttribute('type', 'text'),
      this.$text.setAttribute('spellcheck', 'false'),
      this.$text.setAttribute('aria-labelledby', this.$name.id),
      (this.$display = document.createElement('div')),
      this.$display.classList.add('display'),
      this.$display.appendChild(this.$input),
      this.$widget.appendChild(this.$display),
      this.$widget.appendChild(this.$text),
      (this._format = ((a = this.initialValue), kZ.find(o => o.match(a)))),
      (this._rgbScale = i),
      (this._initialValueHexString = this.save()),
      (this._textFocused = !1),
      this.$input.addEventListener('input', () => {
        this._setValueFromHexString(this.$input.value)
      }),
      this.$input.addEventListener('blur', () => {
        this._callOnFinishChange()
      }),
      this.$text.addEventListener('input', () => {
        const o = ub(this.$text.value)
        o && this._setValueFromHexString(o)
      }),
      this.$text.addEventListener('focus', () => {
        ;(this._textFocused = !0), this.$text.select()
      }),
      this.$text.addEventListener('blur', () => {
        ;(this._textFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange()
      }),
      (this.$disable = this.$text),
      this.updateDisplay()
  }
  reset() {
    return this._setValueFromHexString(this._initialValueHexString), this
  }
  _setValueFromHexString(t) {
    if (this._format.isPrimitive) {
      const e = this._format.fromHexString(t)
      this.setValue(e)
    } else
      this._format.fromHexString(t, this.getValue(), this._rgbScale),
        this._callOnChange(),
        this.updateDisplay()
  }
  save() {
    return this._format.toHexString(this.getValue(), this._rgbScale)
  }
  load(t) {
    return this._setValueFromHexString(t), this._callOnFinishChange(), this
  }
  updateDisplay() {
    return (
      (this.$input.value = this._format.toHexString(
        this.getValue(),
        this._rgbScale,
      )),
      this._textFocused || (this.$text.value = this.$input.value.substring(1)),
      (this.$display.style.backgroundColor = this.$input.value),
      this
    )
  }
}
class Mx extends ro {
  constructor(t, e, n) {
    super(t, e, n, 'function'),
      (this.$button = document.createElement('button')),
      this.$button.appendChild(this.$name),
      this.$widget.appendChild(this.$button),
      this.$button.addEventListener('click', i => {
        i.preventDefault(), this.getValue().call(this.object)
      }),
      this.$button.addEventListener('touchstart', () => {}, {
        passive: !0,
      }),
      (this.$disable = this.$button)
  }
}
class FZ extends ro {
  constructor(t, e, n, i, a, o) {
    super(t, e, n, 'number'), this._initInput(), this.min(i), this.max(a)
    const s = o !== void 0
    this.step(s ? o : this._getImplicitStep(), s), this.updateDisplay()
  }
  decimals(t) {
    return (this._decimals = t), this.updateDisplay(), this
  }
  min(t) {
    return (this._min = t), this._onUpdateMinMax(), this
  }
  max(t) {
    return (this._max = t), this._onUpdateMinMax(), this
  }
  step(t, e = !0) {
    return (this._step = t), (this._stepExplicit = e), this
  }
  updateDisplay() {
    const t = this.getValue()
    if (this._hasSlider) {
      let e = (t - this._min) / (this._max - this._min)
      ;(e = Math.max(0, Math.min(e, 1))),
        (this.$fill.style.width = 100 * e + '%')
    }
    return (
      this._inputFocused ||
        (this.$input.value =
          this._decimals === void 0 ? t : t.toFixed(this._decimals)),
      this
    )
  }
  _initInput() {
    ;(this.$input = document.createElement('input')),
      this.$input.setAttribute('type', 'number'),
      this.$input.setAttribute('step', 'any'),
      this.$input.setAttribute('aria-labelledby', this.$name.id),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input)
    const t = c => {
      const h = parseFloat(this.$input.value)
      isNaN(h) ||
        (this._snapClampSetValue(h + c), (this.$input.value = this.getValue()))
    }
    let e,
      n,
      i,
      a,
      o,
      s = !1
    const l = c => {
        if (s) {
          const h = c.clientX - e,
            f = c.clientY - n
          Math.abs(f) > 5
            ? (c.preventDefault(),
              this.$input.blur(),
              (s = !1),
              this._setDraggingStyle(!0, 'vertical'))
            : Math.abs(h) > 5 && u()
        }
        if (!s) {
          const h = c.clientY - i
          ;(o -= h * this._step * this._arrowKeyMultiplier(c)),
            a + o > this._max
              ? (o = this._max - a)
              : a + o < this._min && (o = this._min - a),
            this._snapClampSetValue(a + o)
        }
        i = c.clientY
      },
      u = () => {
        this._setDraggingStyle(!1, 'vertical'),
          this._callOnFinishChange(),
          window.removeEventListener('mousemove', l),
          window.removeEventListener('mouseup', u)
      }
    this.$input.addEventListener('input', () => {
      let c = parseFloat(this.$input.value)
      isNaN(c) ||
        (this._stepExplicit && (c = this._snap(c)),
        this.setValue(this._clamp(c)))
    }),
      this.$input.addEventListener('keydown', c => {
        c.code === 'Enter' && this.$input.blur(),
          c.code === 'ArrowUp' &&
            (c.preventDefault(), t(this._step * this._arrowKeyMultiplier(c))),
          c.code === 'ArrowDown' &&
            (c.preventDefault(),
            t(this._step * this._arrowKeyMultiplier(c) * -1))
      }),
      this.$input.addEventListener(
        'wheel',
        c => {
          this._inputFocused &&
            (c.preventDefault(), t(this._step * this._normalizeMouseWheel(c)))
        },
        {
          passive: !1,
        },
      ),
      this.$input.addEventListener('mousedown', c => {
        ;(e = c.clientX),
          (n = i = c.clientY),
          (s = !0),
          (a = this.getValue()),
          (o = 0),
          window.addEventListener('mousemove', l),
          window.addEventListener('mouseup', u)
      }),
      this.$input.addEventListener('focus', () => {
        this._inputFocused = !0
      }),
      this.$input.addEventListener('blur', () => {
        ;(this._inputFocused = !1),
          this.updateDisplay(),
          this._callOnFinishChange()
      })
  }
  _initSlider() {
    ;(this._hasSlider = !0),
      (this.$slider = document.createElement('div')),
      this.$slider.classList.add('slider'),
      (this.$fill = document.createElement('div')),
      this.$fill.classList.add('fill'),
      this.$slider.appendChild(this.$fill),
      this.$widget.insertBefore(this.$slider, this.$input),
      this.domElement.classList.add('hasSlider')
    const t = f => {
        const d = this.$slider.getBoundingClientRect()
        let p =
          ((g = f),
          (v = d.left),
          (m = d.right),
          (y = this._min),
          (_ = this._max),
          ((g - v) / (m - v)) * (_ - y) + y)
        var g, v, m, y, _
        this._snapClampSetValue(p)
      },
      e = f => {
        t(f.clientX)
      },
      n = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener('mousemove', e),
          window.removeEventListener('mouseup', n)
      }
    let i,
      a,
      o = !1
    const s = f => {
        f.preventDefault(),
          this._setDraggingStyle(!0),
          t(f.touches[0].clientX),
          (o = !1)
      },
      l = f => {
        if (o) {
          const d = f.touches[0].clientX - i,
            p = f.touches[0].clientY - a
          Math.abs(d) > Math.abs(p)
            ? s(f)
            : (window.removeEventListener('touchmove', l),
              window.removeEventListener('touchend', u))
        } else f.preventDefault(), t(f.touches[0].clientX)
      },
      u = () => {
        this._callOnFinishChange(),
          this._setDraggingStyle(!1),
          window.removeEventListener('touchmove', l),
          window.removeEventListener('touchend', u)
      },
      c = this._callOnFinishChange.bind(this)
    let h
    this.$slider.addEventListener('mousedown', f => {
      this._setDraggingStyle(!0),
        t(f.clientX),
        window.addEventListener('mousemove', e),
        window.addEventListener('mouseup', n)
    }),
      this.$slider.addEventListener(
        'touchstart',
        f => {
          f.touches.length > 1 ||
            (this._hasScrollBar
              ? ((i = f.touches[0].clientX),
                (a = f.touches[0].clientY),
                (o = !0))
              : s(f),
            window.addEventListener('touchmove', l, {
              passive: !1,
            }),
            window.addEventListener('touchend', u))
        },
        {
          passive: !1,
        },
      ),
      this.$slider.addEventListener(
        'wheel',
        f => {
          if (Math.abs(f.deltaX) < Math.abs(f.deltaY) && this._hasScrollBar)
            return
          f.preventDefault()
          const d = this._normalizeMouseWheel(f) * this._step
          this._snapClampSetValue(this.getValue() + d),
            (this.$input.value = this.getValue()),
            clearTimeout(h),
            (h = setTimeout(c, 400))
        },
        {
          passive: !1,
        },
      )
  }
  _setDraggingStyle(t, e = 'horizontal') {
    this.$slider && this.$slider.classList.toggle('active', t),
      document.body.classList.toggle('lil-gui-dragging', t),
      document.body.classList.toggle('lil-gui-' + e, t)
  }
  _getImplicitStep() {
    return this._hasMin && this._hasMax ? (this._max - this._min) / 1e3 : 0.1
  }
  _onUpdateMinMax() {
    !this._hasSlider &&
      this._hasMin &&
      this._hasMax &&
      (this._stepExplicit || this.step(this._getImplicitStep(), !1),
      this._initSlider(),
      this.updateDisplay())
  }
  _normalizeMouseWheel(t) {
    let {deltaX: e, deltaY: n} = t
    return (
      Math.floor(t.deltaY) !== t.deltaY &&
        t.wheelDelta &&
        ((e = 0),
        (n = -t.wheelDelta / 120),
        (n *= this._stepExplicit ? 1 : 10)),
      e + -n
    )
  }
  _arrowKeyMultiplier(t) {
    let e = this._stepExplicit ? 1 : 10
    return t.shiftKey ? (e *= 10) : t.altKey && (e /= 10), e
  }
  _snap(t) {
    const e = Math.round(t / this._step) * this._step
    return parseFloat(e.toPrecision(15))
  }
  _clamp(t) {
    return t < this._min && (t = this._min), t > this._max && (t = this._max), t
  }
  _snapClampSetValue(t) {
    this.setValue(this._clamp(this._snap(t)))
  }
  get _hasScrollBar() {
    const t = this.parent.root.$children
    return t.scrollHeight > t.clientHeight
  }
  get _hasMin() {
    return this._min !== void 0
  }
  get _hasMax() {
    return this._max !== void 0
  }
}
class zZ extends ro {
  constructor(t, e, n, i) {
    super(t, e, n, 'option'),
      (this.$select = document.createElement('select')),
      this.$select.setAttribute('aria-labelledby', this.$name.id),
      (this.$display = document.createElement('div')),
      this.$display.classList.add('display'),
      (this._values = Array.isArray(i) ? i : Object.values(i)),
      (this._names = Array.isArray(i) ? i : Object.keys(i)),
      this._names.forEach(a => {
        const o = document.createElement('option')
        ;(o.innerHTML = a), this.$select.appendChild(o)
      }),
      this.$select.addEventListener('change', () => {
        this.setValue(this._values[this.$select.selectedIndex]),
          this._callOnFinishChange()
      }),
      this.$select.addEventListener('focus', () => {
        this.$display.classList.add('focus')
      }),
      this.$select.addEventListener('blur', () => {
        this.$display.classList.remove('focus')
      }),
      this.$widget.appendChild(this.$select),
      this.$widget.appendChild(this.$display),
      (this.$disable = this.$select),
      this.updateDisplay()
  }
  updateDisplay() {
    const t = this.getValue(),
      e = this._values.indexOf(t)
    return (
      (this.$select.selectedIndex = e),
      (this.$display.innerHTML = e === -1 ? t : this._names[e]),
      this
    )
  }
}
class UZ extends ro {
  constructor(t, e, n) {
    super(t, e, n, 'string'),
      (this.$input = document.createElement('input')),
      this.$input.setAttribute('type', 'text'),
      this.$input.setAttribute('aria-labelledby', this.$name.id),
      this.$input.addEventListener('input', () => {
        this.setValue(this.$input.value)
      }),
      this.$input.addEventListener('keydown', i => {
        i.code === 'Enter' && this.$input.blur()
      }),
      this.$input.addEventListener('blur', () => {
        this._callOnFinishChange()
      }),
      this.$widget.appendChild(this.$input),
      (this.$disable = this.$input),
      this.updateDisplay()
  }
  updateDisplay() {
    return (this.$input.value = this.getValue()), this
  }
}
let KD = !1
class rT {
  constructor({
    parent: t,
    autoPlace: e = t === void 0,
    container: n,
    width: i,
    title: a = 'Controls',
    injectStyles: o = !0,
    touchStyles: s = !0,
  } = {}) {
    if (
      ((this.parent = t),
      (this.root = t ? t.root : this),
      (this.children = []),
      (this.controllers = []),
      (this.folders = []),
      (this._closed = !1),
      (this._hidden = !1),
      (this.domElement = document.createElement('div')),
      this.domElement.classList.add('lil-gui'),
      (this.$title = document.createElement('div')),
      this.$title.classList.add('title'),
      this.$title.setAttribute('role', 'button'),
      this.$title.setAttribute('aria-expanded', !0),
      this.$title.setAttribute('tabindex', 0),
      this.$title.addEventListener('click', () =>
        this.openAnimated(this._closed),
      ),
      this.$title.addEventListener('keydown', l => {
        ;(l.code !== 'Enter' && l.code !== 'Space') ||
          (l.preventDefault(), this.$title.click())
      }),
      this.$title.addEventListener('touchstart', () => {}, {
        passive: !0,
      }),
      (this.$children = document.createElement('div')),
      this.$children.classList.add('children'),
      this.domElement.appendChild(this.$title),
      this.domElement.appendChild(this.$children),
      this.title(a),
      s && this.domElement.classList.add('allow-touch-styles'),
      this.parent)
    )
      return (
        this.parent.children.push(this),
        this.parent.folders.push(this),
        void this.parent.$children.appendChild(this.domElement)
      )
    this.domElement.classList.add('root'),
      !KD &&
        o &&
        ((function (l) {
          const u = document.createElement('style')
          u.innerHTML = l
          const c = document.querySelector(
            'head link[rel=stylesheet], head style',
          )
          c ? document.head.insertBefore(u, c) : document.head.appendChild(u)
        })(
          '.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}',
        ),
        (KD = !0)),
      n
        ? n.appendChild(this.domElement)
        : e &&
          (this.domElement.classList.add('autoPlace'),
          document.body.appendChild(this.domElement)),
      i && this.domElement.style.setProperty('--width', i + 'px'),
      this.domElement.addEventListener('keydown', l => l.stopPropagation()),
      this.domElement.addEventListener('keyup', l => l.stopPropagation())
  }
  add(t, e, n, i, a) {
    if (Object(n) === n) return new zZ(this, t, e, n)
    const o = t[e]
    switch (typeof o) {
      case 'number':
        return new FZ(this, t, e, n, i, a)
      case 'boolean':
        return new RZ(this, t, e)
      case 'string':
        return new UZ(this, t, e)
      case 'function':
        return new Mx(this, t, e)
    }
    console.error(
      `gui.add failed
	property:`,
      e,
      `
	object:`,
      t,
      `
	value:`,
      o,
    )
  }
  addColor(t, e, n = 1) {
    return new BZ(this, t, e, n)
  }
  addFolder(t) {
    return new rT({
      parent: this,
      title: t,
    })
  }
  load(t, e = !0) {
    return (
      t.controllers &&
        this.controllers.forEach(n => {
          n instanceof Mx ||
            (n._name in t.controllers && n.load(t.controllers[n._name]))
        }),
      e &&
        t.folders &&
        this.folders.forEach(n => {
          n._title in t.folders && n.load(t.folders[n._title])
        }),
      this
    )
  }
  save(t = !0) {
    const e = {
      controllers: {},
      folders: {},
    }
    return (
      this.controllers.forEach(n => {
        if (!(n instanceof Mx)) {
          if (n._name in e.controllers)
            throw new Error(
              `Cannot save GUI with duplicate property "${n._name}"`,
            )
          e.controllers[n._name] = n.save()
        }
      }),
      t &&
        this.folders.forEach(n => {
          if (n._title in e.folders)
            throw new Error(
              `Cannot save GUI with duplicate folder "${n._title}"`,
            )
          e.folders[n._title] = n.save()
        }),
      e
    )
  }
  open(t = !0) {
    return (
      (this._closed = !t),
      this.$title.setAttribute('aria-expanded', !this._closed),
      this.domElement.classList.toggle('closed', this._closed),
      this
    )
  }
  close() {
    return this.open(!1)
  }
  show(t = !0) {
    return (
      (this._hidden = !t),
      (this.domElement.style.display = this._hidden ? 'none' : ''),
      this
    )
  }
  hide() {
    return this.show(!1)
  }
  openAnimated(t = !0) {
    return (
      (this._closed = !t),
      this.$title.setAttribute('aria-expanded', !this._closed),
      requestAnimationFrame(() => {
        const e = this.$children.clientHeight
        ;(this.$children.style.height = e + 'px'),
          this.domElement.classList.add('transition')
        const n = a => {
          a.target === this.$children &&
            ((this.$children.style.height = ''),
            this.domElement.classList.remove('transition'),
            this.$children.removeEventListener('transitionend', n))
        }
        this.$children.addEventListener('transitionend', n)
        const i = t ? this.$children.scrollHeight : 0
        this.domElement.classList.toggle('closed', !t),
          requestAnimationFrame(() => {
            this.$children.style.height = i + 'px'
          })
      }),
      this
    )
  }
  title(t) {
    return (this._title = t), (this.$title.innerHTML = t), this
  }
  reset(t = !0) {
    return (
      (t ? this.controllersRecursive() : this.controllers).forEach(e =>
        e.reset(),
      ),
      this
    )
  }
  onChange(t) {
    return (this._onChange = t), this
  }
  _callOnChange(t) {
    this.parent && this.parent._callOnChange(t),
      this._onChange !== void 0 &&
        this._onChange.call(this, {
          object: t.object,
          property: t.property,
          value: t.getValue(),
          controller: t,
        })
  }
  onFinishChange(t) {
    return (this._onFinishChange = t), this
  }
  _callOnFinishChange(t) {
    this.parent && this.parent._callOnFinishChange(t),
      this._onFinishChange !== void 0 &&
        this._onFinishChange.call(this, {
          object: t.object,
          property: t.property,
          value: t.getValue(),
          controller: t,
        })
  }
  destroy() {
    this.parent &&
      (this.parent.children.splice(this.parent.children.indexOf(this), 1),
      this.parent.folders.splice(this.parent.folders.indexOf(this), 1)),
      this.domElement.parentElement &&
        this.domElement.parentElement.removeChild(this.domElement),
      Array.from(this.children).forEach(t => t.destroy())
  }
  controllersRecursive() {
    let t = Array.from(this.controllers)
    return (
      this.folders.forEach(e => {
        t = t.concat(e.controllersRecursive())
      }),
      t
    )
  }
  foldersRecursive() {
    let t = Array.from(this.folders)
    return (
      this.folders.forEach(e => {
        t = t.concat(e.foldersRecursive())
      }),
      t
    )
  }
}
const VZ = rT
class GZ {
  constructor(t = !1) {
    ;(this.active = t),
      window.location.hash === '#debug' && (this.active = !0),
      this.active && ((this.instance = new VZ()), this.instance.close())
  }
  update() {}
  destroy() {
    this.active && this.instance.destroy()
  }
}
const jD = new U(),
  HZ = new wa(),
  JD = new U()
class YB extends Fe {
  constructor(t = document.createElement('div')) {
    super(),
      (this.isCSS3DObject = !0),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.pointerEvents = 'auto'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      this.addEventListener('removed', function () {
        this.traverse(function (e) {
          e.element instanceof Element &&
            e.element.parentNode !== null &&
            e.element.parentNode.removeChild(e.element)
        })
      })
  }
  copy(t, e) {
    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this
  }
}
class WZ extends YB {
  constructor(t) {
    super(t), (this.isCSS3DSprite = !0), (this.rotation2D = 0)
  }
  copy(t, e) {
    return super.copy(t, e), (this.rotation2D = t.rotation2D), this
  }
}
const Ia = new ae(),
  XZ = new ae()
class YZ {
  constructor(t = {}) {
    const e = this
    let n, i, a, o
    const s = {
        camera: {
          style: '',
        },
        objects: new WeakMap(),
      },
      l = t.element !== void 0 ? t.element : document.createElement('div')
    ;(l.style.overflow = 'hidden'), (this.domElement = l)
    const u = document.createElement('div')
    ;(u.style.transformOrigin = '0 0'),
      (u.style.pointerEvents = 'none'),
      l.appendChild(u)
    const c = document.createElement('div')
    ;(c.style.transformStyle = 'preserve-3d'),
      u.appendChild(c),
      (this.getSize = function () {
        return {
          width: n,
          height: i,
        }
      }),
      (this.render = function (v, m) {
        const y = m.projectionMatrix.elements[5] * o
        m.view && m.view.enabled
          ? ((u.style.transform = `translate( ${
              -m.view.offsetX * (n / m.view.width)
            }px, ${-m.view.offsetY * (i / m.view.height)}px )`),
            (u.style.transform += `scale( ${m.view.fullWidth / m.view.width}, ${
              m.view.fullHeight / m.view.height
            } )`))
          : (u.style.transform = ''),
          v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(),
          m.parent === null &&
            m.matrixWorldAutoUpdate === !0 &&
            m.updateMatrixWorld()
        let _, x
        m.isOrthographicCamera &&
          ((_ = -(m.right + m.left) / 2), (x = (m.top + m.bottom) / 2))
        const A =
            m.view && m.view.enabled ? m.view.height / m.view.fullHeight : 1,
          S = m.isOrthographicCamera
            ? `scale( ${A} )scale(` +
              y +
              ')translate(' +
              h(_) +
              'px,' +
              h(x) +
              'px)' +
              f(m.matrixWorldInverse)
            : `scale( ${A} )translateZ(` + y + 'px)' + f(m.matrixWorldInverse),
          T =
            (m.isPerspectiveCamera ? 'perspective(' + y + 'px) ' : '') +
            S +
            'translate(' +
            a +
            'px,' +
            o +
            'px)'
        s.camera.style !== T && ((c.style.transform = T), (s.camera.style = T)),
          g(v, v, m)
      }),
      (this.setSize = function (v, m) {
        ;(n = v),
          (i = m),
          (a = n / 2),
          (o = i / 2),
          (l.style.width = v + 'px'),
          (l.style.height = m + 'px'),
          (u.style.width = v + 'px'),
          (u.style.height = m + 'px'),
          (c.style.width = v + 'px'),
          (c.style.height = m + 'px')
      })
    function h(v) {
      return Math.abs(v) < 1e-10 ? 0 : v
    }
    function f(v) {
      const m = v.elements
      return (
        'matrix3d(' +
        h(m[0]) +
        ',' +
        h(-m[1]) +
        ',' +
        h(m[2]) +
        ',' +
        h(m[3]) +
        ',' +
        h(m[4]) +
        ',' +
        h(-m[5]) +
        ',' +
        h(m[6]) +
        ',' +
        h(m[7]) +
        ',' +
        h(m[8]) +
        ',' +
        h(-m[9]) +
        ',' +
        h(m[10]) +
        ',' +
        h(m[11]) +
        ',' +
        h(m[12]) +
        ',' +
        h(-m[13]) +
        ',' +
        h(m[14]) +
        ',' +
        h(m[15]) +
        ')'
      )
    }
    function d(v) {
      const m = v.elements
      return (
        'translate(-50%,-50%)' +
        ('matrix3d(' +
          h(m[0]) +
          ',' +
          h(m[1]) +
          ',' +
          h(m[2]) +
          ',' +
          h(m[3]) +
          ',' +
          h(-m[4]) +
          ',' +
          h(-m[5]) +
          ',' +
          h(-m[6]) +
          ',' +
          h(-m[7]) +
          ',' +
          h(m[8]) +
          ',' +
          h(m[9]) +
          ',' +
          h(m[10]) +
          ',' +
          h(m[11]) +
          ',' +
          h(m[12]) +
          ',' +
          h(m[13]) +
          ',' +
          h(m[14]) +
          ',' +
          h(m[15]) +
          ')')
      )
    }
    function p(v) {
      v.isCSS3DObject && (v.element.style.display = 'none')
      for (let m = 0, y = v.children.length; m < y; m++) p(v.children[m])
    }
    function g(v, m, y, _) {
      if (v.visible === !1) {
        p(v)
        return
      }
      if (v.isCSS3DObject) {
        const x = v.layers.test(y.layers) === !0,
          A = v.element
        if (((A.style.display = x === !0 ? '' : 'none'), x === !0)) {
          v.onBeforeRender(e, m, y)
          let S
          v.isCSS3DSprite
            ? (Ia.copy(y.matrixWorldInverse),
              Ia.transpose(),
              v.rotation2D !== 0 && Ia.multiply(XZ.makeRotationZ(v.rotation2D)),
              v.matrixWorld.decompose(jD, HZ, JD),
              Ia.setPosition(jD),
              Ia.scale(JD),
              (Ia.elements[3] = 0),
              (Ia.elements[7] = 0),
              (Ia.elements[11] = 0),
              (Ia.elements[15] = 1),
              (S = d(Ia)))
            : (S = d(v.matrixWorld))
          const b = s.objects.get(v)
          if (b === void 0 || b.style !== S) {
            A.style.transform = S
            const T = {
              style: S,
            }
            s.objects.set(v, T)
          }
          A.parentNode !== c && c.appendChild(A), v.onAfterRender(e, m, y)
        }
      }
      for (let x = 0, A = v.children.length; x < A; x++) g(v.children[x], m, y)
    }
  }
}
class $Z {
  constructor({scene: t, camera: e, time: n, sizes: i, canvas: a}) {
    ;(this.scene = t),
      (this.camera = e),
      (this.time = n),
      (this.sizes = i),
      (this.canvas = a),
      (this.parent = null)
    let {width: o, height: s} = this.sizes,
      l = new YZ()
    ;(this.css3dRender = l),
      l.setSize(o, s),
      (l.domElement.style.position = 'absolute'),
      (l.domElement.style.left = '0px'),
      (l.domElement.style.top = '0px'),
      (l.domElement.style.pointerEvents = 'none'),
      (l.domElement.className = 'label3d-' + BB()),
      this.canvas.parentNode.appendChild(l.domElement),
      this.time.on('tick', () => {
        this.update()
      }),
      this.sizes.on('resize', () => {
        this.resize()
      })
  }
  create(t = '', e = '', n = !1) {
    let i = document.createElement('div')
    ;(i.innerHTML = t),
      (i.className = e),
      (i.style.visibility = 'hidden'),
      (i.style.position = 'absolute'),
      e ||
        ((i.style.padding = '10px'),
        (i.style.color = '#fff'),
        (i.style.fontSize = '12px'),
        (i.style.textAlign = 'center'),
        (i.style.background = 'rgba(0,0,0,0.6)'),
        (i.style.borderRadius = '4px'))
    let a = null
    return (
      n ? (a = new WZ(i)) : (a = new YB(i)),
      (a.init = (o, s) => {
        ;(a.element.innerHTML = o),
          (a.element.style.visibility = 'visible'),
          a.position.copy(s)
      }),
      (a.hide = () => {
        a.element.style.visibility = 'hidden'
      }),
      (a.scaleHide = () => {
        a.element.classList.add('scale-hidden')
      }),
      (a.show = () => {
        ;(a.element.style.visibility = 'visible'),
          a.element.classList.remove('scale-hidden')
      }),
      (a.setParent = o => {
        ;(this.parent = o), o.add(a)
      }),
      (a.remove = () => {
        this.parent.remove(a)
      }),
      a
    )
  }
  setLabelStyle(t, e = 0.1, n = 'x', i = Math.PI / 2, a = 'none') {
    ;(t.element.style.pointerEvents = a),
      t.scale.set(e, e, e),
      (t.rotation[n] = i)
  }
  setRenderLevel(t) {
    this.css3dRender.domElement.style.zIndex = t
  }
  update() {
    this.css3dRender.render(this.scene, this.camera.instance)
  }
  destroy() {
    if (this.css3dRender) {
      let t = this.css3dRender.domElement
      t.parentNode.removeChild(t)
    }
  }
  resize() {
    let {width: t, height: e} = this.sizes
    this.css3dRender.setSize(t, e)
  }
}
class qZ extends Fe {
  constructor(t = document.createElement('div')) {
    super(),
      (this.isCSS2DObject = !0),
      (this.element = t),
      (this.element.style.position = 'absolute'),
      (this.element.style.userSelect = 'none'),
      this.element.setAttribute('draggable', !1),
      (this.center = new pt(0.5, 0.5)),
      this.addEventListener('removed', function () {
        this.traverse(function (e) {
          e.element instanceof Element &&
            e.element.parentNode !== null &&
            e.element.parentNode.removeChild(e.element)
        })
      })
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.element = t.element.cloneNode(!0)),
      (this.center = t.center),
      this
    )
  }
}
const Nc = new U(),
  QD = new ae(),
  tL = new ae(),
  eL = new U(),
  nL = new U()
class ZZ {
  constructor(t = {}) {
    const e = this
    let n, i, a, o
    const s = {
        objects: new WeakMap(),
      },
      l = t.element !== void 0 ? t.element : document.createElement('div')
    ;(l.style.overflow = 'hidden'),
      (this.domElement = l),
      (this.getSize = function () {
        return {
          width: n,
          height: i,
        }
      }),
      (this.render = function (p, g) {
        p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(),
          g.parent === null &&
            g.matrixWorldAutoUpdate === !0 &&
            g.updateMatrixWorld(),
          QD.copy(g.matrixWorldInverse),
          tL.multiplyMatrices(g.projectionMatrix, QD),
          c(p, p, g),
          d(p)
      }),
      (this.setSize = function (p, g) {
        ;(n = p),
          (i = g),
          (a = n / 2),
          (o = i / 2),
          (l.style.width = p + 'px'),
          (l.style.height = g + 'px')
      })
    function u(p) {
      p.isCSS2DObject && (p.element.style.display = 'none')
      for (let g = 0, v = p.children.length; g < v; g++) u(p.children[g])
    }
    function c(p, g, v) {
      if (p.visible === !1) {
        u(p)
        return
      }
      if (p.isCSS2DObject) {
        Nc.setFromMatrixPosition(p.matrixWorld), Nc.applyMatrix4(tL)
        const m = Nc.z >= -1 && Nc.z <= 1 && p.layers.test(v.layers) === !0,
          y = p.element
        ;(y.style.display = m === !0 ? '' : 'none'),
          m === !0 &&
            (p.onBeforeRender(e, g, v),
            (y.style.transform =
              'translate(' +
              -100 * p.center.x +
              '%,' +
              -100 * p.center.y +
              '%)translate(' +
              (Nc.x * a + a) +
              'px,' +
              (-Nc.y * o + o) +
              'px)'),
            y.parentNode !== l && l.appendChild(y),
            p.onAfterRender(e, g, v))
        const _ = {
          distanceToCameraSquared: h(v, p),
        }
        s.objects.set(p, _)
      }
      for (let m = 0, y = p.children.length; m < y; m++) c(p.children[m], g, v)
    }
    function h(p, g) {
      return (
        eL.setFromMatrixPosition(p.matrixWorld),
        nL.setFromMatrixPosition(g.matrixWorld),
        eL.distanceToSquared(nL)
      )
    }
    function f(p) {
      const g = []
      return (
        p.traverseVisible(function (v) {
          v.isCSS2DObject && g.push(v)
        }),
        g
      )
    }
    function d(p) {
      const g = f(p).sort(function (m, y) {
          if (m.renderOrder !== y.renderOrder)
            return y.renderOrder - m.renderOrder
          const _ = s.objects.get(m).distanceToCameraSquared,
            x = s.objects.get(y).distanceToCameraSquared
          return _ - x
        }),
        v = g.length
      for (let m = 0, y = g.length; m < y; m++)
        g[m].element.style.zIndex = v - m
    }
  }
}
class KZ {
  constructor({scene: t, camera: e, time: n, sizes: i, canvas: a}) {
    ;(this.scene = t),
      (this.camera = e),
      (this.time = n),
      (this.sizes = i),
      (this.canvas = a),
      (this.parent = null)
    let {width: o, height: s} = this.sizes,
      l = new ZZ()
    ;(this.css2dRender = l),
      l.setSize(o, s),
      (l.domElement.style.position = 'absolute'),
      (l.domElement.style.left = '0px'),
      (l.domElement.style.top = '0px'),
      (l.domElement.style.pointerEvents = 'none'),
      (l.domElement.className = 'label3d-' + BB()),
      this.canvas.parentNode.appendChild(l.domElement),
      this.time.on('tick', () => {
        this.update()
      }),
      this.sizes.on('resize', () => {
        this.resize()
      })
  }
  create(t = '', e = '') {
    let n = document.createElement('div')
    ;(n.innerHTML = t),
      (n.className = e),
      (n.style.visibility = 'hidden'),
      (n.style.position = 'absolute'),
      e ||
        ((n.style.padding = '10px'),
        (n.style.color = '#fff'),
        (n.style.fontSize = '12px'),
        (n.style.textAlign = 'center'),
        (n.style.background = 'rgba(0,0,0,0.6)'),
        (n.style.borderRadius = '4px'))
    let i = null
    return (
      (i = new qZ(n)),
      (i.init = (a, o) => {
        ;(i.element.innerHTML = a),
          (i.element.style.visibility = 'visible'),
          i.position.copy(o)
      }),
      (i.hide = () => {
        i.element.style.visibility = 'hidden'
      }),
      (i.scaleHide = () => {
        i.element.classList.add('scale-hidden')
      }),
      (i.show = () => {
        ;(i.element.style.visibility = 'visible'),
          i.element.classList.remove('scale-hidden')
      }),
      (i.setParent = a => {
        ;(this.parent = a), a.add(i)
      }),
      (i.remove = () => {
        this.parent.remove(i)
      }),
      i
    )
  }
  setLabelStyle(t, e = 'none') {
    t.element.style.pointerEvents = e
  }
  setRenderLevel(t) {
    this.css2dRender.domElement.style.zIndex = t
  }
  update() {
    this.css2dRender.render(this.scene, this.camera.instance)
  }
  destroy() {
    if (this.css2dRender) {
      let t = this.css2dRender.domElement
      t.parentNode.removeChild(t)
    }
  }
  resize() {
    let {width: t, height: e} = this.sizes
    this.css2dRender.setSize(t, e)
  }
}
class jZ {
  constructor({time: t}, e) {
    ;(this.time = t),
      (this.options = Object.assign(
        {},
        {
          width: 10,
          scale: 1,
          position: new U(0, 0, 0),
          needRotate: !1,
          rotateSpeed: 0.001,
          material: new on({
            transparent: !0,
            opacity: 1,
            depthTest: !0,
          }),
        },
        e,
      ))
    let n = new Ti(this.options.width, this.options.width),
      i = new De(n, this.options.material)
    i.position.copy(this.options.position),
      i.scale.set(this.options.scale, this.options.scale, this.options.scale),
      (this.instance = i)
  }
  setParent(t) {
    t.add(this.instance),
      this.time.on('tick', () => {
        this.update()
      })
  }
  update() {
    this.options.needRotate &&
      (this.instance.rotation.z += this.options.rotateSpeed)
  }
}
class JZ extends Fe {
  constructor(t, e) {
    super(),
      (this.assets = t.assets),
      (this.config = Object.assign(
        {
          size: 10,
          color: 65535,
          renderOrder: 99,
        },
        e,
      )),
      (this.material = null),
      this.init()
  }
  init() {
    const {size: t, color: e} = this.config,
      n = new Ti(t, t, 1),
      i = new lo({
        vertexShader: `
        varying vec2 vUv;
        void main() {
            vec4 modelPosition = modelMatrix * vec4(position, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectionPosition = projectionMatrix * viewPosition;
            gl_Position = projectionPosition;
            vUv = uv;

        }
      `,
        fragmentShader: `
        uniform vec3 iResolution;           // viewport resolution (in pixels)
        uniform float iTime;                 // shader playback time (in seconds)
        varying vec2 vUv;
        uniform vec3 iColor;
        uniform float iAlpha;

        // returns a vec3 color from every pixel requested.
        // Generates a BnW Ping on normalized 2d coordinate system
        vec3 RadarPing(
            in vec2 uv,
            in vec2 center,
            in float innerTail,
            in float frontierBorder,
            in float timeResetSeconds,
            in float radarPingSpeed,
            in float fadeDistance,
            float t
        ) {
            vec2 diff = center - uv;
            float r = length(diff);
            float time = mod(t, timeResetSeconds) * radarPingSpeed;

            float circle;
            // r is the distance to the center.
            // circle = BipCenter---//---innerTail---time---frontierBorder
            //illustration
            //https://sketch.io/render/sk-14b54f90080084bad1602f81cadd4d07.jpeg
            circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder, time, r);
            circle *= smoothstep(fadeDistance, 0.0, r); // fade to 0 after fadeDistance

            return vec3(circle);
        }

        void main() {

            //normalize coordinates
            vec2 uv = vUv; //move coordinates to 0..1
            uv = uv.xy * 2.; // translate to the center
            uv += vec2(-1.0, -1.0);
            // uv.x *= iResolution.x / iResolution.y; //correct the aspect ratio

            vec3 color;
            // generate some radar pings
            float fadeDistance = 0.6;
            float resetTimeSec = 3.0;
            float radarPingSpeed = 0.2;
            vec2 greenPing = vec2(0.0, 0.0);
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime) * iColor;
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 1.) * iColor;
            color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec, radarPingSpeed, fadeDistance, iTime + 2.) * iColor;
            //return the new color
            gl_FragColor = vec4(color, iAlpha);
        }
      `,
        side: dr,
        transparent: !0,
        blending: $r,
        depthWrite: !1,
        uniforms: {
          iResolution: {
            value: new pt(t, t),
          },
          iTime: {
            value: 0,
          },
          iAlpha: {
            value: 1,
          },
          iColor: {
            value: new qt(e),
          },
        },
      })
    this.material = i
    let a = new De(n, i)
    a.rotateX(-Math.PI / 2), this.add(a), this.createMidPoint()
  }
  createMidPoint() {
    const {size: t, color: e} = this.config,
      n = new Ti(t, t, 1)
    let i = this.assets.instance.getResource('particle')
    ;(i.colorSpace = cn), (i.wrapS = i.wrapT = Jn)
    let a = new on({
        map: i,
        alphaMap: i,
        color: e,
        transparent: !0,
        opacity: 1,
        blending: $r,
        depthWrite: !1,
      }),
      o = new De(n, a)
    o.rotateX(-Math.PI / 2), this.add(o)
  }
  update(t) {
    this.material && (this.material.uniforms.iTime.value += t)
  }
}
class QZ {
  constructor({}, t = {}) {
    ;(this.mapGroup = new un()),
      (this.coordinates = []),
      (this.config = Object.assign(
        {
          position: new U(0, 0, 0),
          geoProjectionCenter: new pt(0, 0),
          geoProjectionScale: 120,
          data: '',
          renderOrder: 1,
          merge: !1,
          material: new on({
            color: 1582651,
            transparent: !0,
            opacity: 1,
          }),
        },
        t,
      )),
      this.mapGroup.position.copy(this.config.position)
    let e = QM(this.config.data)
    this.create(e)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    let {merge: e} = this.config,
      n = []
    if (
      (t.features.forEach(i => {
        const a = new Fe()
        let {name: o, center: s = [], centroid: l = []} = i.properties
        this.coordinates.push({
          name: o,
          center: s,
          centroid: l,
        }),
          (a.userData.name = o),
          i.geometry.coordinates.forEach(u => {
            u.forEach(c => {
              const h = new wu()
              for (let d = 0; d < c.length; d++) {
                if (!c[d][0] || !c[d][1]) return !1
                const [p, g] = this.geoProjection(c[d])
                d === 0 && h.moveTo(p, -g), h.lineTo(p, -g)
              }
              const f = new qM(h)
              if (e) n.push(f)
              else {
                const d = new De(f, this.config.material)
                ;(d.renderOrder = this.config.renderOrder),
                  (d.userData.name = o),
                  a.add(d)
              }
            })
          }),
          e || this.mapGroup.add(a)
      }),
      e)
    ) {
      let i = iq(n)
      const a = new De(i, this.config.material)
      ;(a.renderOrder = this.config.renderOrder), this.mapGroup.add(a)
    }
  }
  getCoordinates() {
    return this.coordinates
  }
  setParent(t) {
    t.add(this.mapGroup)
  }
}
class tK {
  constructor({assets: t, time: e}, n = {}) {
    ;(this.mapGroup = new un()),
      (this.assets = t),
      (this.time = e),
      (this.coordinates = []),
      (this.config = Object.assign(
        {
          position: new U(0, 0, 0),
          geoProjectionCenter: new pt(0, 0),
          geoProjectionScale: 120,
          data: '',
          renderOrder: 1,
          topFaceMaterial: new on({
            color: 1582651,
            transparent: !0,
            opacity: 1,
          }),
          sideMaterial: new on({
            color: 464171,
            transparent: !0,
            opacity: 1,
          }),
          depth: 0.1,
        },
        n,
      )),
      this.mapGroup.position.copy(this.config.position)
    let i = QM(this.config.data)
    this.create(i)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    t.features.forEach(e => {
      const n = new Fe()
      let {name: i, center: a = [], centroid: o = []} = e.properties
      this.coordinates.push({
        name: i,
        center: a,
        centroid: o,
      })
      const s = {
        depth: this.config.depth,
        bevelEnabled: !0,
        bevelSegments: 1,
        bevelThickness: 0.1,
      }
      let l = [this.config.topFaceMaterial, this.config.sideMaterial]
      e.geometry.coordinates.forEach(u => {
        u.forEach((c, h) => {
          const f = new wu()
          for (let g = 0; g < c.length; g++) {
            if (!c[g][0] || !c[g][1]) return !1
            const [v, m] = this.geoProjection(c[g])
            g === 0 && f.moveTo(v, -m), f.lineTo(v, -m)
          }
          const d = new B0(f, s),
            p = new De(d, l)
          n.add(p)
        })
      }),
        this.mapGroup.add(n)
    })
  }
  getCoordinates() {
    return this.coordinates
  }
  setParent(t) {
    t.add(this.mapGroup)
  }
}
const rL = new Ei(),
  bg = new U()
class $B extends V$ {
  constructor() {
    super(),
      (this.isLineSegmentsGeometry = !0),
      (this.type = 'LineSegmentsGeometry')
    const t = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      e = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]
    this.setIndex(n),
      this.setAttribute('position', new nn(t, 3)),
      this.setAttribute('uv', new nn(e, 2))
  }
  applyMatrix4(t) {
    const e = this.attributes.instanceStart,
      n = this.attributes.instanceEnd
    return (
      e !== void 0 &&
        (e.applyMatrix4(t), n.applyMatrix4(t), (e.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  setPositions(t) {
    let e
    t instanceof Float32Array
      ? (e = t)
      : Array.isArray(t) && (e = new Float32Array(t))
    const n = new JA(e, 6, 1)
    return (
      this.setAttribute('instanceStart', new _a(n, 3, 0)),
      this.setAttribute('instanceEnd', new _a(n, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    )
  }
  setColors(t) {
    let e
    t instanceof Float32Array
      ? (e = t)
      : Array.isArray(t) && (e = new Float32Array(t))
    const n = new JA(e, 6, 1)
    return (
      this.setAttribute('instanceColorStart', new _a(n, 3, 0)),
      this.setAttribute('instanceColorEnd', new _a(n, 3, 3)),
      this
    )
  }
  fromWireframeGeometry(t) {
    return this.setPositions(t.attributes.position.array), this
  }
  fromEdgesGeometry(t) {
    return this.setPositions(t.attributes.position.array), this
  }
  fromMesh(t) {
    return this.fromWireframeGeometry(new b$(t.geometry)), this
  }
  fromLineSegments(t) {
    const e = t.geometry
    return this.setPositions(e.attributes.position.array), this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ei())
    const t = this.attributes.instanceStart,
      e = this.attributes.instanceEnd
    t !== void 0 &&
      e !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(t),
      rL.setFromBufferAttribute(e),
      this.boundingBox.union(rL))
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new na()),
      this.boundingBox === null && this.computeBoundingBox()
    const t = this.attributes.instanceStart,
      e = this.attributes.instanceEnd
    if (t !== void 0 && e !== void 0) {
      const n = this.boundingSphere.center
      this.boundingBox.getCenter(n)
      let i = 0
      for (let a = 0, o = t.count; a < o; a++)
        bg.fromBufferAttribute(t, a),
          (i = Math.max(i, n.distanceToSquared(bg))),
          bg.fromBufferAttribute(e, a),
          (i = Math.max(i, n.distanceToSquared(bg)))
      ;(this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',
            this,
          )
    }
  }
  toJSON() {}
  applyMatrix(t) {
    return (
      console.warn(
        'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().',
      ),
      this.applyMatrix4(t)
    )
  }
}
Rt.line = {
  worldUnits: {
    value: 1,
  },
  linewidth: {
    value: 1,
  },
  resolution: {
    value: new pt(1, 1),
  },
  dashOffset: {
    value: 0,
  },
  dashScale: {
    value: 1,
  },
  dashSize: {
    value: 1,
  },
  gapSize: {
    value: 1,
  },
}
qr.line = {
  uniforms: kM.merge([Rt.common, Rt.fog, Rt.line]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`,
}
class qB extends lo {
  constructor(t) {
    super({
      type: 'LineMaterial',
      uniforms: kM.clone(qr.line.uniforms),
      vertexShader: qr.line.vertexShader,
      fragmentShader: qr.line.fragmentShader,
      clipping: !0,
    }),
      (this.isLineMaterial = !0),
      this.setValues(t)
  }
  get color() {
    return this.uniforms.diffuse.value
  }
  set color(t) {
    this.uniforms.diffuse.value = t
  }
  get worldUnits() {
    return 'WORLD_UNITS' in this.defines
  }
  set worldUnits(t) {
    t === !0 ? (this.defines.WORLD_UNITS = '') : delete this.defines.WORLD_UNITS
  }
  get linewidth() {
    return this.uniforms.linewidth.value
  }
  set linewidth(t) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = t)
  }
  get dashed() {
    return 'USE_DASH' in this.defines
  }
  set dashed(t) {
    ;(t === !0) !== this.dashed && (this.needsUpdate = !0),
      t === !0 ? (this.defines.USE_DASH = '') : delete this.defines.USE_DASH
  }
  get dashScale() {
    return this.uniforms.dashScale.value
  }
  set dashScale(t) {
    this.uniforms.dashScale.value = t
  }
  get dashSize() {
    return this.uniforms.dashSize.value
  }
  set dashSize(t) {
    this.uniforms.dashSize.value = t
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value
  }
  set dashOffset(t) {
    this.uniforms.dashOffset.value = t
  }
  get gapSize() {
    return this.uniforms.gapSize.value
  }
  set gapSize(t) {
    this.uniforms.gapSize.value = t
  }
  get opacity() {
    return this.uniforms.opacity.value
  }
  set opacity(t) {
    this.uniforms && (this.uniforms.opacity.value = t)
  }
  get resolution() {
    return this.uniforms.resolution.value
  }
  set resolution(t) {
    this.uniforms.resolution.value.copy(t)
  }
  get alphaToCoverage() {
    return 'USE_ALPHA_TO_COVERAGE' in this.defines
  }
  set alphaToCoverage(t) {
    this.defines &&
      ((t === !0) !== this.alphaToCoverage && (this.needsUpdate = !0),
      t === !0
        ? (this.defines.USE_ALPHA_TO_COVERAGE = '')
        : delete this.defines.USE_ALPHA_TO_COVERAGE)
  }
}
const Tx = new Oe(),
  iL = new U(),
  aL = new U(),
  ur = new Oe(),
  cr = new Oe(),
  Oa = new Oe(),
  Cx = new U(),
  Ex = new ae(),
  hr = new tq(),
  oL = new U(),
  wg = new Ei(),
  Mg = new na(),
  Na = new Oe()
let qa, Mu
function sL(r, t, e) {
  return (
    Na.set(0, 0, -t, 1).applyMatrix4(r.projectionMatrix),
    Na.multiplyScalar(1 / Na.w),
    (Na.x = Mu / e.width),
    (Na.y = Mu / e.height),
    Na.applyMatrix4(r.projectionMatrixInverse),
    Na.multiplyScalar(1 / Na.w),
    Math.abs(Math.max(Na.x, Na.y))
  )
}
function eK(r, t) {
  const e = r.matrixWorld,
    n = r.geometry,
    i = n.attributes.instanceStart,
    a = n.attributes.instanceEnd,
    o = Math.min(n.instanceCount, i.count)
  for (let s = 0, l = o; s < l; s++) {
    hr.start.fromBufferAttribute(i, s),
      hr.end.fromBufferAttribute(a, s),
      hr.applyMatrix4(e)
    const u = new U(),
      c = new U()
    qa.distanceSqToSegment(hr.start, hr.end, c, u),
      c.distanceTo(u) < Mu * 0.5 &&
        t.push({
          point: c,
          pointOnLine: u,
          distance: qa.origin.distanceTo(c),
          object: r,
          face: null,
          faceIndex: s,
          uv: null,
          uv1: null,
        })
  }
}
function nK(r, t, e) {
  const n = t.projectionMatrix,
    a = r.material.resolution,
    o = r.matrixWorld,
    s = r.geometry,
    l = s.attributes.instanceStart,
    u = s.attributes.instanceEnd,
    c = Math.min(s.instanceCount, l.count),
    h = -t.near
  qa.at(1, Oa),
    (Oa.w = 1),
    Oa.applyMatrix4(t.matrixWorldInverse),
    Oa.applyMatrix4(n),
    Oa.multiplyScalar(1 / Oa.w),
    (Oa.x *= a.x / 2),
    (Oa.y *= a.y / 2),
    (Oa.z = 0),
    Cx.copy(Oa),
    Ex.multiplyMatrices(t.matrixWorldInverse, o)
  for (let f = 0, d = c; f < d; f++) {
    if (
      (ur.fromBufferAttribute(l, f),
      cr.fromBufferAttribute(u, f),
      (ur.w = 1),
      (cr.w = 1),
      ur.applyMatrix4(Ex),
      cr.applyMatrix4(Ex),
      ur.z > h && cr.z > h)
    )
      continue
    if (ur.z > h) {
      const _ = ur.z - cr.z,
        x = (ur.z - h) / _
      ur.lerp(cr, x)
    } else if (cr.z > h) {
      const _ = cr.z - ur.z,
        x = (cr.z - h) / _
      cr.lerp(ur, x)
    }
    ur.applyMatrix4(n),
      cr.applyMatrix4(n),
      ur.multiplyScalar(1 / ur.w),
      cr.multiplyScalar(1 / cr.w),
      (ur.x *= a.x / 2),
      (ur.y *= a.y / 2),
      (cr.x *= a.x / 2),
      (cr.y *= a.y / 2),
      hr.start.copy(ur),
      (hr.start.z = 0),
      hr.end.copy(cr),
      (hr.end.z = 0)
    const g = hr.closestPointToPointParameter(Cx, !0)
    hr.at(g, oL)
    const v = IM.lerp(ur.z, cr.z, g),
      m = v >= -1 && v <= 1,
      y = Cx.distanceTo(oL) < Mu * 0.5
    if (m && y) {
      hr.start.fromBufferAttribute(l, f),
        hr.end.fromBufferAttribute(u, f),
        hr.start.applyMatrix4(o),
        hr.end.applyMatrix4(o)
      const _ = new U(),
        x = new U()
      qa.distanceSqToSegment(hr.start, hr.end, x, _),
        e.push({
          point: x,
          pointOnLine: _,
          distance: qa.origin.distanceTo(x),
          object: r,
          face: null,
          faceIndex: f,
          uv: null,
          uv1: null,
        })
    }
  }
}
class rK extends De {
  constructor(
    t = new $B(),
    e = new qB({
      color: Math.random() * 16777215,
    }),
  ) {
    super(t, e), (this.isLineSegments2 = !0), (this.type = 'LineSegments2')
  }
  computeLineDistances() {
    const t = this.geometry,
      e = t.attributes.instanceStart,
      n = t.attributes.instanceEnd,
      i = new Float32Array(2 * e.count)
    for (let o = 0, s = 0, l = e.count; o < l; o++, s += 2)
      iL.fromBufferAttribute(e, o),
        aL.fromBufferAttribute(n, o),
        (i[s] = s === 0 ? 0 : i[s - 1]),
        (i[s + 1] = i[s] + iL.distanceTo(aL))
    const a = new JA(i, 2, 1)
    return (
      t.setAttribute('instanceDistanceStart', new _a(a, 1, 0)),
      t.setAttribute('instanceDistanceEnd', new _a(a, 1, 1)),
      this
    )
  }
  raycast(t, e) {
    const n = this.material.worldUnits,
      i = t.camera
    i === null &&
      !n &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.',
      )
    const a = (t.params.Line2 !== void 0 && t.params.Line2.threshold) || 0
    qa = t.ray
    const o = this.matrixWorld,
      s = this.geometry,
      l = this.material
    ;(Mu = l.linewidth + a),
      s.boundingSphere === null && s.computeBoundingSphere(),
      Mg.copy(s.boundingSphere).applyMatrix4(o)
    let u
    if (n) u = Mu * 0.5
    else {
      const h = Math.max(i.near, Mg.distanceToPoint(qa.origin))
      u = sL(i, h, l.resolution)
    }
    if (((Mg.radius += u), qa.intersectsSphere(Mg) === !1)) return
    s.boundingBox === null && s.computeBoundingBox(),
      wg.copy(s.boundingBox).applyMatrix4(o)
    let c
    if (n) c = Mu * 0.5
    else {
      const h = Math.max(i.near, wg.distanceToPoint(qa.origin))
      c = sL(i, h, l.resolution)
    }
    wg.expandByScalar(c),
      qa.intersectsBox(wg) !== !1 && (n ? eK(this, e) : nK(this, i, e))
  }
  onBeforeRender(t) {
    const e = this.material.uniforms
    e &&
      e.resolution &&
      (t.getViewport(Tx),
      this.material.uniforms.resolution.value.set(Tx.z, Tx.w))
  }
}
class ZB extends $B {
  constructor() {
    super(), (this.isLineGeometry = !0), (this.type = 'LineGeometry')
  }
  setPositions(t) {
    const e = t.length - 3,
      n = new Float32Array(2 * e)
    for (let i = 0; i < e; i += 3)
      (n[2 * i] = t[i]),
        (n[2 * i + 1] = t[i + 1]),
        (n[2 * i + 2] = t[i + 2]),
        (n[2 * i + 3] = t[i + 3]),
        (n[2 * i + 4] = t[i + 4]),
        (n[2 * i + 5] = t[i + 5])
    return super.setPositions(n), this
  }
  setColors(t) {
    const e = t.length - 3,
      n = new Float32Array(2 * e)
    for (let i = 0; i < e; i += 3)
      (n[2 * i] = t[i]),
        (n[2 * i + 1] = t[i + 1]),
        (n[2 * i + 2] = t[i + 2]),
        (n[2 * i + 3] = t[i + 3]),
        (n[2 * i + 4] = t[i + 4]),
        (n[2 * i + 5] = t[i + 5])
    return super.setColors(n), this
  }
  fromLine(t) {
    const e = t.geometry
    return this.setPositions(e.attributes.position.array), this
  }
}
class iK extends rK {
  constructor(
    t = new ZB(),
    e = new qB({
      color: Math.random() * 16777215,
    }),
  ) {
    super(t, e), (this.isLine2 = !0), (this.type = 'Line2')
  }
}
let Dx = class {
  constructor({}, t = {}) {
    this.config = Object.assign(
      {
        visibelProvince: '',
        geoProjectionCenter: [0, 0],
        geoProjectionScale: 120,
        position: new U(0, 0, 0),
        data: '',
        material: new dv({
          color: 16777215,
        }),
        type: 'LineLoop',
        renderOrder: 1,
        tubeRadius: 0.2,
      },
      t,
    )
    let e = QM(this.config.data),
      n = this.create(e)
    ;(this.lineGroup = n), this.lineGroup.position.copy(this.config.position)
  }
  geoProjection(t) {
    return V0()
      .center(this.config.geoProjectionCenter)
      .scale(this.config.geoProjectionScale)
      .translate([0, 0])(t)
  }
  create(t) {
    const {type: e, visibelProvince: n} = this.config
    let i = t.features,
      a = new un()
    for (let o = 0; o < i.length; o++) {
      const s = i[o]
      let l = new un()
      if (((l.name = 'meshLineGroup' + o), s.properties.name === n)) {
        console.log(n)
        continue
      }
      s.geometry.coordinates.forEach(u => {
        const c = []
        let h = null
        e === 'Line2'
          ? (u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(d, -p, 0)
            }),
            (h = this.createLine2(c)))
          : e === 'Line3'
          ? (u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(new U(d, -p, 0))
            }),
            (h = this.createLine3(c)))
          : u[0].forEach(f => {
              const [d, p] = this.geoProjection(f)
              c.push(new U(d, -p, 0)), (h = this.createLine(c))
            }),
          l.add(h)
      }),
        a.add(l)
    }
    return a
  }
  createLine3(t) {
    const e = this.config.tubeRadius,
      n = 256 * 10,
      i = 4,
      a = !1,
      {material: o, renderOrder: s} = this.config,
      l = new _B(t),
      u = new bp(l, n, e, i, a),
      c = new De(u, o)
    return (c.name = 'mapLine3'), (c.renderOrder = s), c
  }
  createLine2(t) {
    const {material: e, renderOrder: n} = this.config,
      i = new ZB()
    i.setPositions(t)
    let a = new iK(i, e)
    return (
      (a.name = 'mapLine2'), (a.renderOrder = n), a.computeLineDistances(), a
    )
  }
  createLine(t) {
    const {material: e, renderOrder: n, type: i} = this.config,
      a = new Mn()
    a.setFromPoints(t)
    let o = new mB(a, e)
    return (o.renderOrder = n), (o.name = 'mapLine'), o
  }
  setParent(t) {
    t.add(this.lineGroup)
  }
}
function Io(r) {
  if (r === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called",
    )
  return r
}
function KB(r, t) {
  ;(r.prototype = Object.create(t.prototype)),
    (r.prototype.constructor = r),
    (r.__proto__ = t)
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Ai = {
    autoSleep: 120,
    force3D: 'auto',
    nullTargetWarn: 1,
    units: {
      lineHeight: '',
    },
  },
  Zh = {
    duration: 0.5,
    overwrite: !1,
    delay: 0,
  },
  iT,
  Tr,
  hn,
  $i = 1e8,
  Qe = 1 / $i,
  cb = Math.PI * 2,
  aK = cb / 4,
  oK = 0,
  jB = Math.sqrt,
  sK = Math.cos,
  lK = Math.sin,
  or = function (t) {
    return typeof t == 'string'
  },
  bn = function (t) {
    return typeof t == 'function'
  },
  Zo = function (t) {
    return typeof t == 'number'
  },
  aT = function (t) {
    return typeof t > 'u'
  },
  uo = function (t) {
    return typeof t == 'object'
  },
  ti = function (t) {
    return t !== !1
  },
  oT = function () {
    return typeof window < 'u'
  },
  Tg = function (t) {
    return bn(t) || or(t)
  },
  JB =
    (typeof ArrayBuffer == 'function' && ArrayBuffer.isView) || function () {},
  Cr = Array.isArray,
  hb = /(?:-?\.?\d|\.)+/gi,
  QB = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  gh = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  Lx = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  tF = /[+-]=-?[.\d]+/,
  eF = /[^,'"\[\]\s]+/gi,
  uK = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  pn,
  Wa,
  fb,
  sT,
  Ci = {},
  Cy = {},
  nF,
  rF = function (t) {
    return (Cy = Hu(t, Ci)) && ii
  },
  lT = function (t, e) {
    return console.warn(
      'Invalid property',
      t,
      'set to',
      e,
      'Missing plugin? gsap.registerPlugin()',
    )
  },
  Dp = function (t, e) {
    return !e && console.warn(t)
  },
  iF = function (t, e) {
    return (t && (Ci[t] = e) && Cy && (Cy[t] = e)) || Ci
  },
  Lp = function () {
    return 0
  },
  cK = {
    suppressEvents: !0,
    isStart: !0,
    kill: !1,
  },
  Vm = {
    suppressEvents: !0,
    kill: !1,
  },
  hK = {
    suppressEvents: !0,
  },
  uT = {},
  qs = [],
  db = {},
  aF,
  vi = {},
  Px = {},
  lL = 30,
  Gm = [],
  cT = '',
  hT = function (t) {
    var e = t[0],
      n,
      i
    if ((uo(e) || bn(e) || (t = [t]), !(n = (e._gsap || {}).harness))) {
      for (i = Gm.length; i-- && !Gm[i].targetTest(e); );
      n = Gm[i]
    }
    for (i = t.length; i--; )
      (t[i] && (t[i]._gsap || (t[i]._gsap = new DF(t[i], n)))) || t.splice(i, 1)
    return t
  },
  Tu = function (t) {
    return t._gsap || hT(qi(t))[0]._gsap
  },
  oF = function (t, e, n) {
    return (n = t[e]) && bn(n)
      ? t[e]()
      : (aT(n) && t.getAttribute && t.getAttribute(e)) || n
  },
  ei = function (t, e) {
    return (t = t.split(',')).forEach(e) || t
  },
  En = function (t) {
    return Math.round(t * 1e5) / 1e5 || 0
  },
  er = function (t) {
    return Math.round(t * 1e7) / 1e7 || 0
  },
  Eh = function (t, e) {
    var n = e.charAt(0),
      i = parseFloat(e.substr(2))
    return (
      (t = parseFloat(t)),
      n === '+' ? t + i : n === '-' ? t - i : n === '*' ? t * i : t / i
    )
  },
  fK = function (t, e) {
    for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
    return i < n
  },
  Ey = function () {
    var t = qs.length,
      e = qs.slice(0),
      n,
      i
    for (db = {}, qs.length = 0, n = 0; n < t; n++)
      (i = e[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
  },
  sF = function (t, e, n, i) {
    qs.length && !Tr && Ey(),
      t.render(e, n, i || (Tr && e < 0 && (t._initted || t._startAt))),
      qs.length && !Tr && Ey()
  },
  lF = function (t) {
    var e = parseFloat(t)
    return (e || e === 0) && (t + '').match(eF).length < 2
      ? e
      : or(t)
      ? t.trim()
      : t
  },
  uF = function (t) {
    return t
  },
  ta = function (t, e) {
    for (var n in e) n in t || (t[n] = e[n])
    return t
  },
  dK = function (t) {
    return function (e, n) {
      for (var i in n)
        i in e || (i === 'duration' && t) || i === 'ease' || (e[i] = n[i])
    }
  },
  Hu = function (t, e) {
    for (var n in e) t[n] = e[n]
    return t
  },
  uL = function r(t, e) {
    for (var n in e)
      n !== '__proto__' &&
        n !== 'constructor' &&
        n !== 'prototype' &&
        (t[n] = uo(e[n]) ? r(t[n] || (t[n] = {}), e[n]) : e[n])
    return t
  },
  Dy = function (t, e) {
    var n = {},
      i
    for (i in t) i in e || (n[i] = t[i])
    return n
  },
  jd = function (t) {
    var e = t.parent || pn,
      n = t.keyframes ? dK(Cr(t.keyframes)) : ta
    if (ti(t.inherit))
      for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp)
    return t
  },
  pK = function (t, e) {
    for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; );
    return n < 0
  },
  cF = function (t, e, n, i, a) {
    n === void 0 && (n = '_first'), i === void 0 && (i = '_last')
    var o = t[i],
      s
    if (a) for (s = e[a]; o && o[a] > s; ) o = o._prev
    return (
      o ? ((e._next = o._next), (o._next = e)) : ((e._next = t[n]), (t[n] = e)),
      e._next ? (e._next._prev = e) : (t[i] = e),
      (e._prev = o),
      (e.parent = e._dp = t),
      e
    )
  },
  G0 = function (t, e, n, i) {
    n === void 0 && (n = '_first'), i === void 0 && (i = '_last')
    var a = e._prev,
      o = e._next
    a ? (a._next = o) : t[n] === e && (t[n] = o),
      o ? (o._prev = a) : t[i] === e && (t[i] = a),
      (e._next = e._prev = e.parent = null)
  },
  tl = function (t, e) {
    t.parent &&
      (!e || t.parent.autoRemoveChildren) &&
      t.parent.remove &&
      t.parent.remove(t),
      (t._act = 0)
  },
  Cu = function (t, e) {
    if (t && (!e || e._end > t._dur || e._start < 0))
      for (var n = t; n; ) (n._dirty = 1), (n = n.parent)
    return t
  },
  vK = function (t) {
    for (var e = t.parent; e && e.parent; )
      (e._dirty = 1), e.totalDuration(), (e = e.parent)
    return t
  },
  pb = function (t, e, n, i) {
    return (
      t._startAt &&
      (Tr
        ? t._startAt.revert(Vm)
        : (t.vars.immediateRender && !t.vars.autoRevert) ||
          t._startAt.render(e, !0, i))
    )
  },
  gK = function r(t) {
    return !t || (t._ts && r(t.parent))
  },
  cL = function (t) {
    return t._repeat ? Kh(t._tTime, (t = t.duration() + t._rDelay)) * t : 0
  },
  Kh = function (t, e) {
    var n = Math.floor((t /= e))
    return t && n === t ? n - 1 : n
  },
  Ly = function (t, e) {
    return (
      (t - e._start) * e._ts +
      (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    )
  },
  H0 = function (t) {
    return (t._end = er(
      t._start + (t._tDur / Math.abs(t._ts || t._rts || Qe) || 0),
    ))
  },
  W0 = function (t, e) {
    var n = t._dp
    return (
      n &&
        n.smoothChildTiming &&
        t._ts &&
        ((t._start = er(
          n._time -
            (t._ts > 0
              ? e / t._ts
              : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts),
        )),
        H0(t),
        n._dirty || Cu(n, t)),
      t
    )
  },
  hF = function (t, e) {
    var n
    if (
      ((e._time ||
        (!e._dur && e._initted) ||
        (e._start < t._time && (e._dur || !e.add))) &&
        ((n = Ly(t.rawTime(), e)),
        (!e._dur || vv(0, e.totalDuration(), n) - e._tTime > Qe) &&
          e.render(n, !0)),
      Cu(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
    ) {
      if (t._dur < t.duration())
        for (n = t; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp)
      t._zTime = -Qe
    }
  },
  Za = function (t, e, n, i) {
    return (
      e.parent && tl(e),
      (e._start = er(
        (Zo(n) ? n : n || t !== pn ? ki(t, n, e) : t._time) + e._delay,
      )),
      (e._end = er(
        e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0),
      )),
      cF(t, e, '_first', '_last', t._sort ? '_start' : 0),
      vb(e) || (t._recent = e),
      i || hF(t, e),
      t._ts < 0 && W0(t, t._tTime),
      t
    )
  },
  fF = function (t, e) {
    return (
      (Ci.ScrollTrigger || lT('scrollTrigger', e)) &&
      Ci.ScrollTrigger.create(e, t)
    )
  },
  dF = function (t, e, n, i, a) {
    if ((dT(t, e, a), !t._initted)) return 1
    if (
      !n &&
      t._pt &&
      !Tr &&
      ((t._dur && t.vars.lazy !== !1) || (!t._dur && t.vars.lazy)) &&
      aF !== mi.frame
    )
      return qs.push(t), (t._lazy = [a, i]), 1
  },
  mK = function r(t) {
    var e = t.parent
    return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || r(e))
  },
  vb = function (t) {
    var e = t.data
    return e === 'isFromStart' || e === 'isStart'
  },
  yK = function (t, e, n, i) {
    var a = t.ratio,
      o =
        e < 0 ||
        (!e &&
          ((!t._start && mK(t) && !(!t._initted && vb(t))) ||
            ((t._ts < 0 || t._dp._ts < 0) && !vb(t))))
          ? 0
          : 1,
      s = t._rDelay,
      l = 0,
      u,
      c,
      h
    if (
      (s &&
        t._repeat &&
        ((l = vv(0, t._tDur, e)),
        (c = Kh(l, s)),
        t._yoyo && c & 1 && (o = 1 - o),
        c !== Kh(t._tTime, s) &&
          ((a = 1 - o), t.vars.repeatRefresh && t._initted && t.invalidate())),
      o !== a || Tr || i || t._zTime === Qe || (!e && t._zTime))
    ) {
      if (!t._initted && dF(t, e, i, n, l)) return
      for (
        h = t._zTime,
          t._zTime = e || (n ? Qe : 0),
          n || (n = e && !h),
          t.ratio = o,
          t._from && (o = 1 - o),
          t._time = 0,
          t._tTime = l,
          u = t._pt;
        u;

      )
        u.r(o, u.d), (u = u._next)
      e < 0 && pb(t, e, n, !0),
        t._onUpdate && !n && _i(t, 'onUpdate'),
        l && t._repeat && !n && t.parent && _i(t, 'onRepeat'),
        (e >= t._tDur || e < 0) &&
          t.ratio === o &&
          (o && tl(t, 1),
          !n &&
            !Tr &&
            (_i(t, o ? 'onComplete' : 'onReverseComplete', !0),
            t._prom && t._prom()))
    } else t._zTime || (t._zTime = e)
  },
  _K = function (t, e, n) {
    var i
    if (n > e)
      for (i = t._first; i && i._start <= n; ) {
        if (i.data === 'isPause' && i._start > e) return i
        i = i._next
      }
    else
      for (i = t._last; i && i._start >= n; ) {
        if (i.data === 'isPause' && i._start < e) return i
        i = i._prev
      }
  },
  jh = function (t, e, n, i) {
    var a = t._repeat,
      o = er(e) || 0,
      s = t._tTime / t._tDur
    return (
      s && !i && (t._time *= o / t._dur),
      (t._dur = o),
      (t._tDur = a ? (a < 0 ? 1e10 : er(o * (a + 1) + t._rDelay * a)) : o),
      s > 0 && !i && W0(t, (t._tTime = t._tDur * s)),
      t.parent && H0(t),
      n || Cu(t.parent, t),
      t
    )
  },
  hL = function (t) {
    return t instanceof zr ? Cu(t) : jh(t, t._dur)
  },
  xK = {
    _start: 0,
    endTime: Lp,
    totalDuration: Lp,
  },
  ki = function r(t, e, n) {
    var i = t.labels,
      a = t._recent || xK,
      o = t.duration() >= $i ? a.endTime(!1) : t._dur,
      s,
      l,
      u
    return or(e) && (isNaN(e) || e in i)
      ? ((l = e.charAt(0)),
        (u = e.substr(-1) === '%'),
        (s = e.indexOf('=')),
        l === '<' || l === '>'
          ? (s >= 0 && (e = e.replace(/=/, '')),
            (l === '<' ? a._start : a.endTime(a._repeat >= 0)) +
              (parseFloat(e.substr(1)) || 0) *
                (u ? (s < 0 ? a : n).totalDuration() / 100 : 1))
          : s < 0
          ? (e in i || (i[e] = o), i[e])
          : ((l = parseFloat(e.charAt(s - 1) + e.substr(s + 1))),
            u && n && (l = (l / 100) * (Cr(n) ? n[0] : n).totalDuration()),
            s > 1 ? r(t, e.substr(0, s - 1), n) + l : o + l))
      : e == null
      ? o
      : +e
  },
  Jd = function (t, e, n) {
    var i = Zo(e[1]),
      a = (i ? 2 : 1) + (t < 2 ? 0 : 1),
      o = e[a],
      s,
      l
    if ((i && (o.duration = e[1]), (o.parent = n), t)) {
      for (s = o, l = n; l && !('immediateRender' in s); )
        (s = l.vars.defaults || {}), (l = ti(l.vars.inherit) && l.parent)
      ;(o.immediateRender = ti(s.immediateRender)),
        t < 2 ? (o.runBackwards = 1) : (o.startAt = e[a - 1])
    }
    return new Fn(e[0], o, e[a + 1])
  },
  dl = function (t, e) {
    return t || t === 0 ? e(t) : e
  },
  vv = function (t, e, n) {
    return n < t ? t : n > e ? e : n
  },
  Mr = function (t, e) {
    return !or(t) || !(e = uK.exec(t)) ? '' : e[1]
  },
  SK = function (t, e, n) {
    return dl(n, function (i) {
      return vv(t, e, i)
    })
  },
  gb = [].slice,
  pF = function (t, e) {
    return (
      t &&
      uo(t) &&
      'length' in t &&
      ((!e && !t.length) || (t.length - 1 in t && uo(t[0]))) &&
      !t.nodeType &&
      t !== Wa
    )
  },
  AK = function (t, e, n) {
    return (
      n === void 0 && (n = []),
      t.forEach(function (i) {
        var a
        return (or(i) && !e) || pF(i, 1)
          ? (a = n).push.apply(a, qi(i))
          : n.push(i)
      }) || n
    )
  },
  qi = function (t, e, n) {
    return hn && !e && hn.selector
      ? hn.selector(t)
      : or(t) && !n && (fb || !Jh())
      ? gb.call((e || sT).querySelectorAll(t), 0)
      : Cr(t)
      ? AK(t, n)
      : pF(t)
      ? gb.call(t, 0)
      : t
      ? [t]
      : []
  },
  mb = function (t) {
    return (
      (t = qi(t)[0] || Dp('Invalid scope') || {}),
      function (e) {
        var n = t.current || t.nativeElement || t
        return qi(
          e,
          n.querySelectorAll
            ? n
            : n === t
            ? Dp('Invalid scope') || sT.createElement('div')
            : t,
        )
      }
    )
  },
  vF = function (t) {
    return t.sort(function () {
      return 0.5 - Math.random()
    })
  },
  gF = function (t) {
    if (bn(t)) return t
    var e = uo(t)
        ? t
        : {
            each: t,
          },
      n = Eu(e.ease),
      i = e.from || 0,
      a = parseFloat(e.base) || 0,
      o = {},
      s = i > 0 && i < 1,
      l = isNaN(i) || s,
      u = e.axis,
      c = i,
      h = i
    return (
      or(i)
        ? (c = h =
            {
              center: 0.5,
              edges: 0.5,
              end: 1,
            }[i] || 0)
        : !s && l && ((c = i[0]), (h = i[1])),
      function (f, d, p) {
        var g = (p || e).length,
          v = o[g],
          m,
          y,
          _,
          x,
          A,
          S,
          b,
          T,
          w
        if (!v) {
          if (((w = e.grid === 'auto' ? 0 : (e.grid || [1, $i])[1]), !w)) {
            for (
              b = -$i;
              b < (b = p[w++].getBoundingClientRect().left) && w < g;

            );
            w < g && w--
          }
          for (
            v = o[g] = [],
              m = l ? Math.min(w, g) * c - 0.5 : i % w,
              y = w === $i ? 0 : l ? (g * h) / w - 0.5 : (i / w) | 0,
              b = 0,
              T = $i,
              S = 0;
            S < g;
            S++
          )
            (_ = (S % w) - m),
              (x = y - ((S / w) | 0)),
              (v[S] = A = u ? Math.abs(u === 'y' ? x : _) : jB(_ * _ + x * x)),
              A > b && (b = A),
              A < T && (T = A)
          i === 'random' && vF(v),
            (v.max = b - T),
            (v.min = T),
            (v.v = g =
              (parseFloat(e.amount) ||
                parseFloat(e.each) *
                  (w > g
                    ? g - 1
                    : u
                    ? u === 'y'
                      ? g / w
                      : w
                    : Math.max(w, g / w)) ||
                0) * (i === 'edges' ? -1 : 1)),
            (v.b = g < 0 ? a - g : a),
            (v.u = Mr(e.amount || e.each) || 0),
            (n = n && g < 0 ? TF(n) : n)
        }
        return (
          (g = (v[f] - v.min) / v.max || 0),
          er(v.b + (n ? n(g) : g) * v.v) + v.u
        )
      }
    )
  },
  yb = function (t) {
    var e = Math.pow(10, ((t + '').split('.')[1] || '').length)
    return function (n) {
      var i = er(Math.round(parseFloat(n) / t) * t * e)
      return (i - (i % 1)) / e + (Zo(n) ? 0 : Mr(n))
    }
  },
  mF = function (t, e) {
    var n = Cr(t),
      i,
      a
    return (
      !n &&
        uo(t) &&
        ((i = n = t.radius || $i),
        t.values
          ? ((t = qi(t.values)), (a = !Zo(t[0])) && (i *= i))
          : (t = yb(t.increment))),
      dl(
        e,
        n
          ? bn(t)
            ? function (o) {
                return (a = t(o)), Math.abs(a - o) <= i ? a : o
              }
            : function (o) {
                for (
                  var s = parseFloat(a ? o.x : o),
                    l = parseFloat(a ? o.y : 0),
                    u = $i,
                    c = 0,
                    h = t.length,
                    f,
                    d;
                  h--;

                )
                  a
                    ? ((f = t[h].x - s), (d = t[h].y - l), (f = f * f + d * d))
                    : (f = Math.abs(t[h] - s)),
                    f < u && ((u = f), (c = h))
                return (
                  (c = !i || u <= i ? t[c] : o),
                  a || c === o || Zo(o) ? c : c + Mr(o)
                )
              }
          : yb(t),
      )
    )
  },
  yF = function (t, e, n, i) {
    return dl(Cr(t) ? !e : n === !0 ? !!(n = 0) : !i, function () {
      return Cr(t)
        ? t[~~(Math.random() * t.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + '').length - 2) : 1) &&
            Math.floor(
              Math.round((t - n / 2 + Math.random() * (e - t + n * 0.99)) / n) *
                n *
                i,
            ) / i
    })
  },
  bK = function () {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n]
    return function (i) {
      return e.reduce(function (a, o) {
        return o(a)
      }, i)
    }
  },
  wK = function (t, e) {
    return function (n) {
      return t(parseFloat(n)) + (e || Mr(n))
    }
  },
  MK = function (t, e, n) {
    return xF(t, e, 0, 1, n)
  },
  _F = function (t, e, n) {
    return dl(n, function (i) {
      return t[~~e(i)]
    })
  },
  TK = function r(t, e, n) {
    var i = e - t
    return Cr(t)
      ? _F(t, r(0, t.length), e)
      : dl(n, function (a) {
          return ((i + ((a - t) % i)) % i) + t
        })
  },
  CK = function r(t, e, n) {
    var i = e - t,
      a = i * 2
    return Cr(t)
      ? _F(t, r(0, t.length - 1), e)
      : dl(n, function (o) {
          return (o = (a + ((o - t) % a)) % a || 0), t + (o > i ? a - o : o)
        })
  },
  Pp = function (t) {
    for (var e = 0, n = '', i, a, o, s; ~(i = t.indexOf('random(', e)); )
      (o = t.indexOf(')', i)),
        (s = t.charAt(i + 7) === '['),
        (a = t.substr(i + 7, o - i - 7).match(s ? eF : hb)),
        (n +=
          t.substr(e, i - e) + yF(s ? a : +a[0], s ? 0 : +a[1], +a[2] || 1e-5)),
        (e = o + 1)
    return n + t.substr(e, t.length - e)
  },
  xF = function (t, e, n, i, a) {
    var o = e - t,
      s = i - n
    return dl(a, function (l) {
      return n + (((l - t) / o) * s || 0)
    })
  },
  EK = function r(t, e, n, i) {
    var a = isNaN(t + e)
      ? 0
      : function (d) {
          return (1 - d) * t + d * e
        }
    if (!a) {
      var o = or(t),
        s = {},
        l,
        u,
        c,
        h,
        f
      if ((n === !0 && (i = 1) && (n = null), o))
        (t = {
          p: t,
        }),
          (e = {
            p: e,
          })
      else if (Cr(t) && !Cr(e)) {
        for (c = [], h = t.length, f = h - 2, u = 1; u < h; u++)
          c.push(r(t[u - 1], t[u]))
        h--,
          (a = function (p) {
            p *= h
            var g = Math.min(f, ~~p)
            return c[g](p - g)
          }),
          (n = e)
      } else i || (t = Hu(Cr(t) ? [] : {}, t))
      if (!c) {
        for (l in e) fT.call(s, t, l, 'get', e[l])
        a = function (p) {
          return gT(p, s) || (o ? t.p : t)
        }
      }
    }
    return dl(n, a)
  },
  fL = function (t, e, n) {
    var i = t.labels,
      a = $i,
      o,
      s,
      l
    for (o in i)
      (s = i[o] - e),
        s < 0 == !!n && s && a > (s = Math.abs(s)) && ((l = o), (a = s))
    return l
  },
  _i = function (t, e, n) {
    var i = t.vars,
      a = i[e],
      o = hn,
      s = t._ctx,
      l,
      u,
      c
    if (a)
      return (
        (l = i[e + 'Params']),
        (u = i.callbackScope || t),
        n && qs.length && Ey(),
        s && (hn = s),
        (c = l ? a.apply(u, l) : a.call(u)),
        (hn = o),
        c
      )
  },
  Rd = function (t) {
    return (
      tl(t),
      t.scrollTrigger && t.scrollTrigger.kill(!!Tr),
      t.progress() < 1 && _i(t, 'onInterrupt'),
      t
    )
  },
  mh,
  SF = [],
  AF = function (t) {
    if (t)
      if (((t = (!t.name && t.default) || t), oT() || t.headless)) {
        var e = t.name,
          n = bn(t),
          i =
            e && !n && t.init
              ? function () {
                  this._props = []
                }
              : t,
          a = {
            init: Lp,
            render: gT,
            add: fT,
            kill: WK,
            modifier: HK,
            rawVars: 0,
          },
          o = {
            targetTest: 0,
            get: 0,
            getSetter: vT,
            aliases: {},
            register: 0,
          }
        if ((Jh(), t !== i)) {
          if (vi[e]) return
          ta(i, ta(Dy(t, a), o)),
            Hu(i.prototype, Hu(a, Dy(t, o))),
            (vi[(i.prop = e)] = i),
            t.targetTest && (Gm.push(i), (uT[e] = 1)),
            (e =
              (e === 'css' ? 'CSS' : e.charAt(0).toUpperCase() + e.substr(1)) +
              'Plugin')
        }
        iF(e, i), t.register && t.register(ii, i, ni)
      } else SF.push(t)
  },
  Ke = 255,
  Id = {
    aqua: [0, Ke, Ke],
    lime: [0, Ke, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, Ke],
    navy: [0, 0, 128],
    white: [Ke, Ke, Ke],
    olive: [128, 128, 0],
    yellow: [Ke, Ke, 0],
    orange: [Ke, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [Ke, 0, 0],
    pink: [Ke, 192, 203],
    cyan: [0, Ke, Ke],
    transparent: [Ke, Ke, Ke, 0],
  },
  Rx = function (t, e, n) {
    return (
      (t += t < 0 ? 1 : t > 1 ? -1 : 0),
      ((t * 6 < 1
        ? e + (n - e) * t * 6
        : t < 0.5
        ? n
        : t * 3 < 2
        ? e + (n - e) * (2 / 3 - t) * 6
        : e) *
        Ke +
        0.5) |
        0
    )
  },
  bF = function (t, e, n) {
    var i = t ? (Zo(t) ? [t >> 16, (t >> 8) & Ke, t & Ke] : 0) : Id.black,
      a,
      o,
      s,
      l,
      u,
      c,
      h,
      f,
      d,
      p
    if (!i) {
      if ((t.substr(-1) === ',' && (t = t.substr(0, t.length - 1)), Id[t]))
        i = Id[t]
      else if (t.charAt(0) === '#') {
        if (
          (t.length < 6 &&
            ((a = t.charAt(1)),
            (o = t.charAt(2)),
            (s = t.charAt(3)),
            (t =
              '#' +
              a +
              a +
              o +
              o +
              s +
              s +
              (t.length === 5 ? t.charAt(4) + t.charAt(4) : ''))),
          t.length === 9)
        )
          return (
            (i = parseInt(t.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & Ke, i & Ke, parseInt(t.substr(7), 16) / 255]
          )
        ;(t = parseInt(t.substr(1), 16)), (i = [t >> 16, (t >> 8) & Ke, t & Ke])
      } else if (t.substr(0, 3) === 'hsl') {
        if (((i = p = t.match(hb)), !e))
          (l = (+i[0] % 360) / 360),
            (u = +i[1] / 100),
            (c = +i[2] / 100),
            (o = c <= 0.5 ? c * (u + 1) : c + u - c * u),
            (a = c * 2 - o),
            i.length > 3 && (i[3] *= 1),
            (i[0] = Rx(l + 1 / 3, a, o)),
            (i[1] = Rx(l, a, o)),
            (i[2] = Rx(l - 1 / 3, a, o))
        else if (~t.indexOf('='))
          return (i = t.match(QB)), n && i.length < 4 && (i[3] = 1), i
      } else i = t.match(hb) || Id.transparent
      i = i.map(Number)
    }
    return (
      e &&
        !p &&
        ((a = i[0] / Ke),
        (o = i[1] / Ke),
        (s = i[2] / Ke),
        (h = Math.max(a, o, s)),
        (f = Math.min(a, o, s)),
        (c = (h + f) / 2),
        h === f
          ? (l = u = 0)
          : ((d = h - f),
            (u = c > 0.5 ? d / (2 - h - f) : d / (h + f)),
            (l =
              h === a
                ? (o - s) / d + (o < s ? 6 : 0)
                : h === o
                ? (s - a) / d + 2
                : (a - o) / d + 4),
            (l *= 60)),
        (i[0] = ~~(l + 0.5)),
        (i[1] = ~~(u * 100 + 0.5)),
        (i[2] = ~~(c * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    )
  },
  wF = function (t) {
    var e = [],
      n = [],
      i = -1
    return (
      t.split(Zs).forEach(function (a) {
        var o = a.match(gh) || []
        e.push.apply(e, o), n.push((i += o.length + 1))
      }),
      (e.c = n),
      e
    )
  },
  dL = function (t, e, n) {
    var i = '',
      a = (t + i).match(Zs),
      o = e ? 'hsla(' : 'rgba(',
      s = 0,
      l,
      u,
      c,
      h
    if (!a) return t
    if (
      ((a = a.map(function (f) {
        return (
          (f = bF(f, e, 1)) &&
          o +
            (e ? f[0] + ',' + f[1] + '%,' + f[2] + '%,' + f[3] : f.join(',')) +
            ')'
        )
      })),
      n && ((c = wF(t)), (l = n.c), l.join(i) !== c.c.join(i)))
    )
      for (u = t.replace(Zs, '1').split(gh), h = u.length - 1; s < h; s++)
        i +=
          u[s] +
          (~l.indexOf(s)
            ? a.shift() || o + '0,0,0,0)'
            : (c.length ? c : a.length ? a : n).shift())
    if (!u) for (u = t.split(Zs), h = u.length - 1; s < h; s++) i += u[s] + a[s]
    return i + u[h]
  },
  Zs = (function () {
    var r =
        '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b',
      t
    for (t in Id) r += '|' + t + '\\b'
    return new RegExp(r + ')', 'gi')
  })(),
  DK = /hsl[a]?\(/,
  MF = function (t) {
    var e = t.join(' '),
      n
    if (((Zs.lastIndex = 0), Zs.test(e)))
      return (
        (n = DK.test(e)),
        (t[1] = dL(t[1], n)),
        (t[0] = dL(t[0], n, wF(t[1]))),
        !0
      )
  },
  Rp,
  mi = (function () {
    var r = Date.now,
      t = 500,
      e = 33,
      n = r(),
      i = n,
      a = 1e3 / 240,
      o = a,
      s = [],
      l,
      u,
      c,
      h,
      f,
      d,
      p = function g(v) {
        var m = r() - i,
          y = v === !0,
          _,
          x,
          A,
          S
        if (
          ((m > t || m < 0) && (n += m - e),
          (i += m),
          (A = i - n),
          (_ = A - o),
          (_ > 0 || y) &&
            ((S = ++h.frame),
            (f = A - h.time * 1e3),
            (h.time = A = A / 1e3),
            (o += _ + (_ >= a ? 4 : a - _)),
            (x = 1)),
          y || (l = u(g)),
          x)
        )
          for (d = 0; d < s.length; d++) s[d](A, f, S, v)
      }
    return (
      (h = {
        time: 0,
        frame: 0,
        tick: function () {
          p(!0)
        },
        deltaRatio: function (v) {
          return f / (1e3 / (v || 60))
        },
        wake: function () {
          nF &&
            (!fb &&
              oT() &&
              ((Wa = fb = window),
              (sT = Wa.document || {}),
              (Ci.gsap = ii),
              (Wa.gsapVersions || (Wa.gsapVersions = [])).push(ii.version),
              rF(Cy || Wa.GreenSockGlobals || (!Wa.gsap && Wa) || {}),
              SF.forEach(AF)),
            (c = typeof requestAnimationFrame < 'u' && requestAnimationFrame),
            l && h.sleep(),
            (u =
              c ||
              function (v) {
                return setTimeout(v, (o - h.time * 1e3 + 1) | 0)
              }),
            (Rp = 1),
            p(2))
        },
        sleep: function () {
          ;(c ? cancelAnimationFrame : clearTimeout)(l), (Rp = 0), (u = Lp)
        },
        lagSmoothing: function (v, m) {
          ;(t = v || 1 / 0), (e = Math.min(m || 33, t))
        },
        fps: function (v) {
          ;(a = 1e3 / (v || 240)), (o = h.time * 1e3 + a)
        },
        add: function (v, m, y) {
          var _ = m
            ? function (x, A, S, b) {
                v(x, A, S, b), h.remove(_)
              }
            : v
          return h.remove(v), s[y ? 'unshift' : 'push'](_), Jh(), _
        },
        remove: function (v, m) {
          ~(m = s.indexOf(v)) && s.splice(m, 1) && d >= m && d--
        },
        _listeners: s,
      }),
      h
    )
  })(),
  Jh = function () {
    return !Rp && mi.wake()
  },
  Le = {},
  LK = /^[\d.\-M][\d.\-,\s]/,
  PK = /["']/g,
  RK = function (t) {
    for (
      var e = {},
        n = t.substr(1, t.length - 3).split(':'),
        i = n[0],
        a = 1,
        o = n.length,
        s,
        l,
        u;
      a < o;
      a++
    )
      (l = n[a]),
        (s = a !== o - 1 ? l.lastIndexOf(',') : l.length),
        (u = l.substr(0, s)),
        (e[i] = isNaN(u) ? u.replace(PK, '').trim() : +u),
        (i = l.substr(s + 1).trim())
    return e
  },
  IK = function (t) {
    var e = t.indexOf('(') + 1,
      n = t.indexOf(')'),
      i = t.indexOf('(', e)
    return t.substring(e, ~i && i < n ? t.indexOf(')', n + 1) : n)
  },
  OK = function (t) {
    var e = (t + '').split('('),
      n = Le[e[0]]
    return n && e.length > 1 && n.config
      ? n.config.apply(
          null,
          ~t.indexOf('{') ? [RK(e[1])] : IK(t).split(',').map(lF),
        )
      : Le._CE && LK.test(t)
      ? Le._CE('', t)
      : n
  },
  TF = function (t) {
    return function (e) {
      return 1 - t(1 - e)
    }
  },
  CF = function r(t, e) {
    for (var n = t._first, i; n; )
      n instanceof zr
        ? r(n, e)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== e &&
          (n.timeline
            ? r(n.timeline, e)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = e))),
        (n = n._next)
  },
  Eu = function (t, e) {
    return (t && (bn(t) ? t : Le[t] || OK(t))) || e
  },
  Qu = function (t, e, n, i) {
    n === void 0 &&
      (n = function (l) {
        return 1 - e(1 - l)
      }),
      i === void 0 &&
        (i = function (l) {
          return l < 0.5 ? e(l * 2) / 2 : 1 - e((1 - l) * 2) / 2
        })
    var a = {
        easeIn: e,
        easeOut: n,
        easeInOut: i,
      },
      o
    return (
      ei(t, function (s) {
        ;(Le[s] = Ci[s] = a), (Le[(o = s.toLowerCase())] = n)
        for (var l in a)
          Le[
            o + (l === 'easeIn' ? '.in' : l === 'easeOut' ? '.out' : '.inOut')
          ] = Le[s + '.' + l] = a[l]
      }),
      a
    )
  },
  EF = function (t) {
    return function (e) {
      return e < 0.5 ? (1 - t(1 - e * 2)) / 2 : 0.5 + t((e - 0.5) * 2) / 2
    }
  },
  Ix = function r(t, e, n) {
    var i = e >= 1 ? e : 1,
      a = (n || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1),
      o = (a / cb) * (Math.asin(1 / i) || 0),
      s = function (c) {
        return c === 1 ? 1 : i * Math.pow(2, -10 * c) * lK((c - o) * a) + 1
      },
      l =
        t === 'out'
          ? s
          : t === 'in'
          ? function (u) {
              return 1 - s(1 - u)
            }
          : EF(s)
    return (
      (a = cb / a),
      (l.config = function (u, c) {
        return r(t, u, c)
      }),
      l
    )
  },
  Ox = function r(t, e) {
    e === void 0 && (e = 1.70158)
    var n = function (o) {
        return o ? --o * o * ((e + 1) * o + e) + 1 : 0
      },
      i =
        t === 'out'
          ? n
          : t === 'in'
          ? function (a) {
              return 1 - n(1 - a)
            }
          : EF(n)
    return (
      (i.config = function (a) {
        return r(t, a)
      }),
      i
    )
  }
ei('Linear,Quad,Cubic,Quart,Quint,Strong', function (r, t) {
  var e = t < 5 ? t + 1 : t
  Qu(
    r + ',Power' + (e - 1),
    t
      ? function (n) {
          return Math.pow(n, e)
        }
      : function (n) {
          return n
        },
    function (n) {
      return 1 - Math.pow(1 - n, e)
    },
    function (n) {
      return n < 0.5 ? Math.pow(n * 2, e) / 2 : 1 - Math.pow((1 - n) * 2, e) / 2
    },
  )
})
Le.Linear.easeNone = Le.none = Le.Linear.easeIn
Qu('Elastic', Ix('in'), Ix('out'), Ix())
;(function (r, t) {
  var e = 1 / t,
    n = 2 * e,
    i = 2.5 * e,
    a = function (s) {
      return s < e
        ? r * s * s
        : s < n
        ? r * Math.pow(s - 1.5 / t, 2) + 0.75
        : s < i
        ? r * (s -= 2.25 / t) * s + 0.9375
        : r * Math.pow(s - 2.625 / t, 2) + 0.984375
    }
  Qu(
    'Bounce',
    function (o) {
      return 1 - a(1 - o)
    },
    a,
  )
})(7.5625, 2.75)
Qu('Expo', function (r) {
  return r ? Math.pow(2, 10 * (r - 1)) : 0
})
Qu('Circ', function (r) {
  return -(jB(1 - r * r) - 1)
})
Qu('Sine', function (r) {
  return r === 1 ? 1 : -sK(r * aK) + 1
})
Qu('Back', Ox('in'), Ox('out'), Ox())
Le.SteppedEase =
  Le.steps =
  Ci.SteppedEase =
    {
      config: function (t, e) {
        t === void 0 && (t = 1)
        var n = 1 / t,
          i = t + (e ? 0 : 1),
          a = e ? 1 : 0,
          o = 1 - Qe
        return function (s) {
          return (((i * vv(0, o, s)) | 0) + a) * n
        }
      },
    }
Zh.ease = Le['quad.out']
ei(
  'onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt',
  function (r) {
    return (cT += r + ',' + r + 'Params,')
  },
)
var DF = function (t, e) {
    ;(this.id = oK++),
      (t._gsap = this),
      (this.target = t),
      (this.harness = e),
      (this.get = e ? e.get : oF),
      (this.set = e ? e.getSetter : vT)
  },
  Ip = (function () {
    function r(e) {
      ;(this.vars = e),
        (this._delay = +e.delay || 0),
        (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
          ((this._rDelay = e.repeatDelay || 0),
          (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
        (this._ts = 1),
        jh(this, +e.duration, 1, 1),
        (this.data = e.data),
        hn && ((this._ctx = hn), hn.data.push(this)),
        Rp || mi.wake()
    }
    var t = r.prototype
    return (
      (t.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay
      }),
      (t.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n,
            )
          : this.totalDuration() && this._dur
      }),
      (t.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            jh(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1),
            ))
          : this._tDur
      }),
      (t.totalTime = function (n, i) {
        if ((Jh(), !arguments.length)) return this._tTime
        var a = this._dp
        if (a && a.smoothChildTiming && this._ts) {
          for (W0(this, n), !a._dp || a.parent || hF(a, this); a && a.parent; )
            a.parent._time !==
              a._start +
                (a._ts >= 0
                  ? a._tTime / a._ts
                  : (a.totalDuration() - a._tTime) / -a._ts) &&
              a.totalTime(a._tTime, !0),
              (a = a.parent)
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            Za(this._dp, this, this._start - this._delay)
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === Qe) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), sF(this, n, i)),
          this
        )
      }),
      (t.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + cL(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i,
            )
          : this._time
      }),
      (t.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.rawTime() > 0
          ? 1
          : 0
      }),
      (t.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                cL(this),
              i,
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.rawTime() > 0
          ? 1
          : 0
      }),
      (t.iteration = function (n, i) {
        var a = this.duration() + this._rDelay
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * a, i)
          : this._repeat
          ? Kh(this._tTime, a) + 1
          : 1
      }),
      (t.timeScale = function (n, i) {
        if (!arguments.length) return this._rts === -Qe ? 0 : this._rts
        if (this._rts === n) return this
        var a =
          this.parent && this._ts ? Ly(this.parent._time, this) : this._tTime
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -Qe ? 0 : this._rts),
          this.totalTime(vv(-Math.abs(this._delay), this._tDur, a), i !== !1),
          H0(this),
          vK(this)
        )
      }),
      (t.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Jh(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== Qe &&
                      (this._tTime -= Qe),
                  ))),
            this)
          : this._ps
      }),
      (t.startTime = function (n) {
        if (arguments.length) {
          this._start = n
          var i = this.parent || this._dp
          return (
            i && (i._sort || !this.parent) && Za(i, this, n - this._delay), this
          )
        }
        return this._start
      }),
      (t.endTime = function (n) {
        return (
          this._start +
          (ti(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        )
      }),
      (t.rawTime = function (n) {
        var i = this.parent || this._dp
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? Ly(i.rawTime(n), this)
            : this._tTime
          : this._tTime
      }),
      (t.revert = function (n) {
        n === void 0 && (n = hK)
        var i = Tr
        return (
          (Tr = n),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(n),
            this.totalTime(-0.01, n.suppressEvents)),
          this.data !== 'nested' && n.kill !== !1 && this.kill(),
          (Tr = i),
          this
        )
      }),
      (t.globalTime = function (n) {
        for (var i = this, a = arguments.length ? n : i.rawTime(); i; )
          (a = i._start + a / (Math.abs(i._ts) || 1)), (i = i._dp)
        return !this.parent && this._sat ? this._sat.globalTime(n) : a
      }),
      (t.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), hL(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat
      }),
      (t.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time
          return (this._rDelay = n), hL(this), i ? this.time(i) : this
        }
        return this._rDelay
      }),
      (t.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo
      }),
      (t.seek = function (n, i) {
        return this.totalTime(ki(this, n), ti(i))
      }),
      (t.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, ti(i))
      }),
      (t.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
      }),
      (t.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        )
      }),
      (t.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0)
      }),
      (t.resume = function () {
        return this.paused(!1)
      }),
      (t.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -Qe : 0)),
            this)
          : this._rts < 0
      }),
      (t.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -Qe), this
      }),
      (t.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          a
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (a = n.rawTime(!0)) >= i &&
            a < this.endTime(!0) - Qe)
        )
      }),
      (t.eventCallback = function (n, i, a) {
        var o = this.vars
        return arguments.length > 1
          ? (i
              ? ((o[n] = i),
                a && (o[n + 'Params'] = a),
                n === 'onUpdate' && (this._onUpdate = i))
              : delete o[n],
            this)
          : o[n]
      }),
      (t.then = function (n) {
        var i = this
        return new Promise(function (a) {
          var o = bn(n) ? n : uF,
            s = function () {
              var u = i.then
              ;(i.then = null),
                bn(o) && (o = o(i)) && (o.then || o === i) && (i.then = u),
                a(o),
                (i.then = u)
            }
          ;(i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? s()
            : (i._prom = s)
        })
      }),
      (t.kill = function () {
        Rd(this)
      }),
      r
    )
  })()
ta(Ip.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Qe,
  _prom: 0,
  _ps: !1,
  _rts: 1,
})
var zr = (function (r) {
  KB(t, r)
  function t(n, i) {
    var a
    return (
      n === void 0 && (n = {}),
      (a = r.call(this, n) || this),
      (a.labels = {}),
      (a.smoothChildTiming = !!n.smoothChildTiming),
      (a.autoRemoveChildren = !!n.autoRemoveChildren),
      (a._sort = ti(n.sortChildren)),
      pn && Za(n.parent || pn, Io(a), i),
      n.reversed && a.reverse(),
      n.paused && a.paused(!0),
      n.scrollTrigger && fF(Io(a), n.scrollTrigger),
      a
    )
  }
  var e = t.prototype
  return (
    (e.to = function (i, a, o) {
      return Jd(0, arguments, this), this
    }),
    (e.from = function (i, a, o) {
      return Jd(1, arguments, this), this
    }),
    (e.fromTo = function (i, a, o, s) {
      return Jd(2, arguments, this), this
    }),
    (e.set = function (i, a, o) {
      return (
        (a.duration = 0),
        (a.parent = this),
        jd(a).repeatDelay || (a.repeat = 0),
        (a.immediateRender = !!a.immediateRender),
        new Fn(i, a, ki(this, o), 1),
        this
      )
    }),
    (e.call = function (i, a, o) {
      return Za(this, Fn.delayedCall(0, i, a), o)
    }),
    (e.staggerTo = function (i, a, o, s, l, u, c) {
      return (
        (o.duration = a),
        (o.stagger = o.stagger || s),
        (o.onComplete = u),
        (o.onCompleteParams = c),
        (o.parent = this),
        new Fn(i, o, ki(this, l)),
        this
      )
    }),
    (e.staggerFrom = function (i, a, o, s, l, u, c) {
      return (
        (o.runBackwards = 1),
        (jd(o).immediateRender = ti(o.immediateRender)),
        this.staggerTo(i, a, o, s, l, u, c)
      )
    }),
    (e.staggerFromTo = function (i, a, o, s, l, u, c, h) {
      return (
        (s.startAt = o),
        (jd(s).immediateRender = ti(s.immediateRender)),
        this.staggerTo(i, a, s, l, u, c, h)
      )
    }),
    (e.render = function (i, a, o) {
      var s = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        u = this._dur,
        c = i <= 0 ? 0 : er(i),
        h = this._zTime < 0 != i < 0 && (this._initted || !u),
        f,
        d,
        p,
        g,
        v,
        m,
        y,
        _,
        x,
        A,
        S,
        b
      if (
        (this !== pn && c > l && i >= 0 && (c = l), c !== this._tTime || o || h)
      ) {
        if (
          (s !== this._time &&
            u &&
            ((c += this._time - s), (i += this._time - s)),
          (f = c),
          (x = this._start),
          (_ = this._ts),
          (m = !_),
          h && (u || (s = this._zTime), (i || !a) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((S = this._yoyo),
            (v = u + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(v * 100 + i, a, o)
          if (
            ((f = er(c % v)),
            c === l
              ? ((g = this._repeat), (f = u))
              : ((g = ~~(c / v)),
                g && g === c / v && ((f = u), g--),
                f > u && (f = u)),
            (A = Kh(this._tTime, v)),
            !s &&
              this._tTime &&
              A !== g &&
              this._tTime - A * v - this._dur <= 0 &&
              (A = g),
            S && g & 1 && ((f = u - f), (b = 1)),
            g !== A && !this._lock)
          ) {
            var T = S && A & 1,
              w = T === (S && g & 1)
            if (
              (g < A && (T = !T),
              (s = T ? 0 : c % u ? u : c),
              (this._lock = 1),
              (this.render(s || (b ? 0 : er(g * v)), a, !u)._lock = 0),
              (this._tTime = c),
              !a && this.parent && _i(this, 'onRepeat'),
              this.vars.repeatRefresh && !b && (this.invalidate()._lock = 1),
              (s && s !== this._time) ||
                m !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this
            if (
              ((u = this._dur),
              (l = this._tDur),
              w &&
                ((this._lock = 2),
                (s = T ? u : -1e-4),
                this.render(s, !0),
                this.vars.repeatRefresh && !b && this.invalidate()),
              (this._lock = 0),
              !this._ts && !m)
            )
              return this
            CF(this, b)
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = _K(this, er(s), er(f))), y && (c -= f - (f = y._start))),
          (this._tTime = c),
          (this._time = f),
          (this._act = !_),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (s = 0)),
          !s && f && !a && !g && (_i(this, 'onStart'), this._tTime !== c))
        )
          return this
        if (f >= s && i >= 0)
          for (d = this._first; d; ) {
            if (
              ((p = d._next), (d._act || f >= d._start) && d._ts && y !== d)
            ) {
              if (d.parent !== this) return this.render(i, a, o)
              if (
                (d.render(
                  d._ts > 0
                    ? (f - d._start) * d._ts
                    : (d._dirty ? d.totalDuration() : d._tDur) +
                        (f - d._start) * d._ts,
                  a,
                  o,
                ),
                f !== this._time || (!this._ts && !m))
              ) {
                ;(y = 0), p && (c += this._zTime = -Qe)
                break
              }
            }
            d = p
          }
        else {
          d = this._last
          for (var M = i < 0 ? i : f; d; ) {
            if (((p = d._prev), (d._act || M <= d._end) && d._ts && y !== d)) {
              if (d.parent !== this) return this.render(i, a, o)
              if (
                (d.render(
                  d._ts > 0
                    ? (M - d._start) * d._ts
                    : (d._dirty ? d.totalDuration() : d._tDur) +
                        (M - d._start) * d._ts,
                  a,
                  o || (Tr && (d._initted || d._startAt)),
                ),
                f !== this._time || (!this._ts && !m))
              ) {
                ;(y = 0), p && (c += this._zTime = M ? -Qe : Qe)
                break
              }
            }
            d = p
          }
        }
        if (
          y &&
          !a &&
          (this.pause(),
          (y.render(f >= s ? 0 : -Qe)._zTime = f >= s ? 1 : -1),
          this._ts)
        )
          return (this._start = x), H0(this), this.render(i, a, o)
        this._onUpdate && !a && _i(this, 'onUpdate', !0),
          ((c === l && this._tTime >= this.totalDuration()) || (!c && s)) &&
            (x === this._start || Math.abs(_) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !u) &&
                ((c === l && this._ts > 0) || (!c && this._ts < 0)) &&
                tl(this, 1),
              !a &&
                !(i < 0 && !s) &&
                (c || s || !l) &&
                (_i(
                  this,
                  c === l && i >= 0 ? 'onComplete' : 'onReverseComplete',
                  !0,
                ),
                this._prom &&
                  !(c < l && this.timeScale() > 0) &&
                  this._prom())))
      }
      return this
    }),
    (e.add = function (i, a) {
      var o = this
      if ((Zo(a) || (a = ki(this, a, i)), !(i instanceof Ip))) {
        if (Cr(i))
          return (
            i.forEach(function (s) {
              return o.add(s, a)
            }),
            this
          )
        if (or(i)) return this.addLabel(i, a)
        if (bn(i)) i = Fn.delayedCall(0, i)
        else return this
      }
      return this !== i ? Za(this, i, a) : this
    }),
    (e.getChildren = function (i, a, o, s) {
      i === void 0 && (i = !0),
        a === void 0 && (a = !0),
        o === void 0 && (o = !0),
        s === void 0 && (s = -$i)
      for (var l = [], u = this._first; u; )
        u._start >= s &&
          (u instanceof Fn
            ? a && l.push(u)
            : (o && l.push(u), i && l.push.apply(l, u.getChildren(!0, a, o)))),
          (u = u._next)
      return l
    }),
    (e.getById = function (i) {
      for (var a = this.getChildren(1, 1, 1), o = a.length; o--; )
        if (a[o].vars.id === i) return a[o]
    }),
    (e.remove = function (i) {
      return or(i)
        ? this.removeLabel(i)
        : bn(i)
        ? this.killTweensOf(i)
        : (G0(this, i),
          i === this._recent && (this._recent = this._last),
          Cu(this))
    }),
    (e.totalTime = function (i, a) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = er(
              mi.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts),
            )),
          r.prototype.totalTime.call(this, i, a),
          (this._forcing = 0),
          this)
        : this._tTime
    }),
    (e.addLabel = function (i, a) {
      return (this.labels[i] = ki(this, a)), this
    }),
    (e.removeLabel = function (i) {
      return delete this.labels[i], this
    }),
    (e.addPause = function (i, a, o) {
      var s = Fn.delayedCall(0, a || Lp, o)
      return (
        (s.data = 'isPause'), (this._hasPause = 1), Za(this, s, ki(this, i))
      )
    }),
    (e.removePause = function (i) {
      var a = this._first
      for (i = ki(this, i); a; )
        a._start === i && a.data === 'isPause' && tl(a), (a = a._next)
    }),
    (e.killTweensOf = function (i, a, o) {
      for (var s = this.getTweensOf(i, o), l = s.length; l--; )
        Is !== s[l] && s[l].kill(i, a)
      return this
    }),
    (e.getTweensOf = function (i, a) {
      for (var o = [], s = qi(i), l = this._first, u = Zo(a), c; l; )
        l instanceof Fn
          ? fK(l._targets, s) &&
            (u
              ? (!Is || (l._initted && l._ts)) &&
                l.globalTime(0) <= a &&
                l.globalTime(l.totalDuration()) > a
              : !a || l.isActive()) &&
            o.push(l)
          : (c = l.getTweensOf(s, a)).length && o.push.apply(o, c),
          (l = l._next)
      return o
    }),
    (e.tweenTo = function (i, a) {
      a = a || {}
      var o = this,
        s = ki(o, i),
        l = a,
        u = l.startAt,
        c = l.onStart,
        h = l.onStartParams,
        f = l.immediateRender,
        d,
        p = Fn.to(
          o,
          ta(
            {
              ease: a.ease || 'none',
              lazy: !1,
              immediateRender: !1,
              time: s,
              overwrite: 'auto',
              duration:
                a.duration ||
                Math.abs(
                  (s - (u && 'time' in u ? u.time : o._time)) / o.timeScale(),
                ) ||
                Qe,
              onStart: function () {
                if ((o.pause(), !d)) {
                  var v =
                    a.duration ||
                    Math.abs(
                      (s - (u && 'time' in u ? u.time : o._time)) /
                        o.timeScale(),
                    )
                  p._dur !== v && jh(p, v, 0, 1).render(p._time, !0, !0),
                    (d = 1)
                }
                c && c.apply(p, h || [])
              },
            },
            a,
          ),
        )
      return f ? p.render(0) : p
    }),
    (e.tweenFromTo = function (i, a, o) {
      return this.tweenTo(
        a,
        ta(
          {
            startAt: {
              time: ki(this, i),
            },
          },
          o,
        ),
      )
    }),
    (e.recent = function () {
      return this._recent
    }),
    (e.nextLabel = function (i) {
      return i === void 0 && (i = this._time), fL(this, ki(this, i))
    }),
    (e.previousLabel = function (i) {
      return i === void 0 && (i = this._time), fL(this, ki(this, i), 1)
    }),
    (e.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + Qe)
    }),
    (e.shiftChildren = function (i, a, o) {
      o === void 0 && (o = 0)
      for (var s = this._first, l = this.labels, u; s; )
        s._start >= o && ((s._start += i), (s._end += i)), (s = s._next)
      if (a) for (u in l) l[u] >= o && (l[u] += i)
      return Cu(this)
    }),
    (e.invalidate = function (i) {
      var a = this._first
      for (this._lock = 0; a; ) a.invalidate(i), (a = a._next)
      return r.prototype.invalidate.call(this, i)
    }),
    (e.clear = function (i) {
      i === void 0 && (i = !0)
      for (var a = this._first, o; a; ) (o = a._next), this.remove(a), (a = o)
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Cu(this)
      )
    }),
    (e.totalDuration = function (i) {
      var a = 0,
        o = this,
        s = o._last,
        l = $i,
        u,
        c,
        h
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -i : i),
        )
      if (o._dirty) {
        for (h = o.parent; s; )
          (u = s._prev),
            s._dirty && s.totalDuration(),
            (c = s._start),
            c > l && o._sort && s._ts && !o._lock
              ? ((o._lock = 1), (Za(o, s, c - s._delay, 1)._lock = 0))
              : (l = c),
            c < 0 &&
              s._ts &&
              ((a -= c),
              ((!h && !o._dp) || (h && h.smoothChildTiming)) &&
                ((o._start += c / o._ts), (o._time -= c), (o._tTime -= c)),
              o.shiftChildren(-c, !1, -1 / 0),
              (l = 0)),
            s._end > a && s._ts && (a = s._end),
            (s = u)
        jh(o, o === pn && o._time > a ? o._time : a, 1, 1), (o._dirty = 0)
      }
      return o._tDur
    }),
    (t.updateRoot = function (i) {
      if ((pn._ts && (sF(pn, Ly(i, pn)), (aF = mi.frame)), mi.frame >= lL)) {
        lL += Ai.autoSleep || 120
        var a = pn._first
        if ((!a || !a._ts) && Ai.autoSleep && mi._listeners.length < 2) {
          for (; a && !a._ts; ) a = a._next
          a || mi.sleep()
        }
      }
    }),
    t
  )
})(Ip)
ta(zr.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0,
})
var NK = function (t, e, n, i, a, o, s) {
    var l = new ni(this._pt, t, e, 0, 1, NF, null, a),
      u = 0,
      c = 0,
      h,
      f,
      d,
      p,
      g,
      v,
      m,
      y
    for (
      l.b = n,
        l.e = i,
        n += '',
        i += '',
        (m = ~i.indexOf('random(')) && (i = Pp(i)),
        o && ((y = [n, i]), o(y, t, e), (n = y[0]), (i = y[1])),
        f = n.match(Lx) || [];
      (h = Lx.exec(i));

    )
      (p = h[0]),
        (g = i.substring(u, h.index)),
        d ? (d = (d + 1) % 5) : g.substr(-5) === 'rgba(' && (d = 1),
        p !== f[c++] &&
          ((v = parseFloat(f[c - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: g || c === 1 ? g : ',',
            s: v,
            c: p.charAt(1) === '=' ? Eh(v, p) - v : parseFloat(p) - v,
            m: d && d < 4 ? Math.round : 0,
          }),
          (u = Lx.lastIndex))
    return (
      (l.c = u < i.length ? i.substring(u, i.length) : ''),
      (l.fp = s),
      (tF.test(i) || m) && (l.e = 0),
      (this._pt = l),
      l
    )
  },
  fT = function (t, e, n, i, a, o, s, l, u, c) {
    bn(i) && (i = i(a || 0, t, o))
    var h = t[e],
      f =
        n !== 'get'
          ? n
          : bn(h)
          ? u
            ? t[
                e.indexOf('set') || !bn(t['get' + e.substr(3)])
                  ? e
                  : 'get' + e.substr(3)
              ](u)
            : t[e]()
          : h,
      d = bn(h) ? (u ? UK : IF) : pT,
      p
    if (
      (or(i) &&
        (~i.indexOf('random(') && (i = Pp(i)),
        i.charAt(1) === '=' &&
          ((p = Eh(f, i) + (Mr(f) || 0)), (p || p === 0) && (i = p))),
      !c || f !== i || _b)
    )
      return !isNaN(f * i) && i !== ''
        ? ((p = new ni(
            this._pt,
            t,
            e,
            +f || 0,
            i - (f || 0),
            typeof h == 'boolean' ? GK : OF,
            0,
            d,
          )),
          u && (p.fp = u),
          s && p.modifier(s, this, t),
          (this._pt = p))
        : (!h && !(e in t) && lT(e, i),
          NK.call(this, t, e, f, i, d, l || Ai.stringFilter, u))
  },
  kK = function (t, e, n, i, a) {
    if (
      (bn(t) && (t = Qd(t, a, e, n, i)),
      !uo(t) || (t.style && t.nodeType) || Cr(t) || JB(t))
    )
      return or(t) ? Qd(t, a, e, n, i) : t
    var o = {},
      s
    for (s in t) o[s] = Qd(t[s], a, e, n, i)
    return o
  },
  LF = function (t, e, n, i, a, o) {
    var s, l, u, c
    if (
      vi[t] &&
      (s = new vi[t]()).init(
        a,
        s.rawVars ? e[t] : kK(e[t], i, a, o, n),
        n,
        i,
        o,
      ) !== !1 &&
      ((n._pt = l = new ni(n._pt, a, t, 0, 1, s.render, s, 0, s.priority)),
      n !== mh)
    )
      for (u = n._ptLookup[n._targets.indexOf(a)], c = s._props.length; c--; )
        u[s._props[c]] = l
    return s
  },
  Is,
  _b,
  dT = function r(t, e, n) {
    var i = t.vars,
      a = i.ease,
      o = i.startAt,
      s = i.immediateRender,
      l = i.lazy,
      u = i.onUpdate,
      c = i.runBackwards,
      h = i.yoyoEase,
      f = i.keyframes,
      d = i.autoRevert,
      p = t._dur,
      g = t._startAt,
      v = t._targets,
      m = t.parent,
      y = m && m.data === 'nested' ? m.vars.targets : v,
      _ = t._overwrite === 'auto' && !iT,
      x = t.timeline,
      A,
      S,
      b,
      T,
      w,
      M,
      C,
      E,
      D,
      P,
      L,
      I,
      F
    if (
      (x && (!f || !a) && (a = 'none'),
      (t._ease = Eu(a, Zh.ease)),
      (t._yEase = h ? TF(Eu(h === !0 ? a : h, Zh.ease)) : 0),
      h &&
        t._yoyo &&
        !t._repeat &&
        ((h = t._yEase), (t._yEase = t._ease), (t._ease = h)),
      (t._from = !x && !!i.runBackwards),
      !x || (f && !i.stagger))
    ) {
      if (
        ((E = v[0] ? Tu(v[0]).harness : 0),
        (I = E && i[E.prop]),
        (A = Dy(i, uT)),
        g &&
          (g._zTime < 0 && g.progress(1),
          e < 0 && c && s && !d ? g.render(-1, !0) : g.revert(c && p ? Vm : cK),
          (g._lazy = 0)),
        o)
      ) {
        if (
          (tl(
            (t._startAt = Fn.set(
              v,
              ta(
                {
                  data: 'isStart',
                  overwrite: !1,
                  parent: m,
                  immediateRender: !0,
                  lazy: !g && ti(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    u &&
                    function () {
                      return _i(t, 'onUpdate')
                    },
                  stagger: 0,
                },
                o,
              ),
            )),
          ),
          (t._startAt._dp = 0),
          (t._startAt._sat = t),
          e < 0 && (Tr || (!s && !d)) && t._startAt.revert(Vm),
          s && p && e <= 0 && n <= 0)
        ) {
          e && (t._zTime = e)
          return
        }
      } else if (c && p && !g) {
        if (
          (e && (s = !1),
          (b = ta(
            {
              overwrite: !1,
              data: 'isFromStart',
              lazy: s && !g && ti(l),
              immediateRender: s,
              stagger: 0,
              parent: m,
            },
            A,
          )),
          I && (b[E.prop] = I),
          tl((t._startAt = Fn.set(v, b))),
          (t._startAt._dp = 0),
          (t._startAt._sat = t),
          e < 0 && (Tr ? t._startAt.revert(Vm) : t._startAt.render(-1, !0)),
          (t._zTime = e),
          !s)
        )
          r(t._startAt, Qe, Qe)
        else if (!e) return
      }
      for (
        t._pt = t._ptCache = 0, l = (p && ti(l)) || (l && !p), S = 0;
        S < v.length;
        S++
      ) {
        if (
          ((w = v[S]),
          (C = w._gsap || hT(v)[S]._gsap),
          (t._ptLookup[S] = P = {}),
          db[C.id] && qs.length && Ey(),
          (L = y === v ? S : y.indexOf(w)),
          E &&
            (D = new E()).init(w, I || A, t, L, y) !== !1 &&
            ((t._pt = T =
              new ni(t._pt, w, D.name, 0, 1, D.render, D, 0, D.priority)),
            D._props.forEach(function (k) {
              P[k] = T
            }),
            D.priority && (M = 1)),
          !E || I)
        )
          for (b in A)
            vi[b] && (D = LF(b, A, t, L, w, y))
              ? D.priority && (M = 1)
              : (P[b] = T =
                  fT.call(t, w, b, 'get', A[b], L, y, 0, i.stringFilter))
        t._op && t._op[S] && t.kill(w, t._op[S]),
          _ &&
            t._pt &&
            ((Is = t),
            pn.killTweensOf(w, P, t.globalTime(e)),
            (F = !t.parent),
            (Is = 0)),
          t._pt && l && (db[C.id] = 1)
      }
      M && kF(t), t._onInit && t._onInit(t)
    }
    ;(t._onUpdate = u),
      (t._initted = (!t._op || t._pt) && !F),
      f && e <= 0 && x.render($i, !0, !0)
  },
  BK = function (t, e, n, i, a, o, s, l) {
    var u = ((t._pt && t._ptCache) || (t._ptCache = {}))[e],
      c,
      h,
      f,
      d
    if (!u)
      for (
        u = t._ptCache[e] = [], f = t._ptLookup, d = t._targets.length;
        d--;

      ) {
        if (((c = f[d][e]), c && c.d && c.d._pt))
          for (c = c.d._pt; c && c.p !== e && c.fp !== e; ) c = c._next
        if (!c)
          return (
            (_b = 1),
            (t.vars[e] = '+=0'),
            dT(t, s),
            (_b = 0),
            l ? Dp(e + ' not eligible for reset') : 1
          )
        u.push(c)
      }
    for (d = u.length; d--; )
      (h = u[d]),
        (c = h._pt || h),
        (c.s = (i || i === 0) && !a ? i : c.s + (i || 0) + o * c.c),
        (c.c = n - c.s),
        h.e && (h.e = En(n) + Mr(h.e)),
        h.b && (h.b = c.s + Mr(h.b))
  },
  FK = function (t, e) {
    var n = t[0] ? Tu(t[0]).harness : 0,
      i = n && n.aliases,
      a,
      o,
      s,
      l
    if (!i) return e
    a = Hu({}, e)
    for (o in i)
      if (o in a) for (l = i[o].split(','), s = l.length; s--; ) a[l[s]] = a[o]
    return a
  },
  zK = function (t, e, n, i) {
    var a = e.ease || i || 'power1.inOut',
      o,
      s
    if (Cr(e))
      (s = n[t] || (n[t] = [])),
        e.forEach(function (l, u) {
          return s.push({
            t: (u / (e.length - 1)) * 100,
            v: l,
            e: a,
          })
        })
    else
      for (o in e)
        (s = n[o] || (n[o] = [])),
          o === 'ease' ||
            s.push({
              t: parseFloat(t),
              v: e[o],
              e: a,
            })
  },
  Qd = function (t, e, n, i, a) {
    return bn(t)
      ? t.call(e, n, i, a)
      : or(t) && ~t.indexOf('random(')
      ? Pp(t)
      : t
  },
  PF = cT + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
  RF = {}
ei(PF + ',id,stagger,delay,duration,paused,scrollTrigger', function (r) {
  return (RF[r] = 1)
})
var Fn = (function (r) {
  KB(t, r)
  function t(n, i, a, o) {
    var s
    typeof i == 'number' && ((a.duration = i), (i = a), (a = null)),
      (s = r.call(this, o ? i : jd(i)) || this)
    var l = s.vars,
      u = l.duration,
      c = l.delay,
      h = l.immediateRender,
      f = l.stagger,
      d = l.overwrite,
      p = l.keyframes,
      g = l.defaults,
      v = l.scrollTrigger,
      m = l.yoyoEase,
      y = i.parent || pn,
      _ = (Cr(n) || JB(n) ? Zo(n[0]) : 'length' in i) ? [n] : qi(n),
      x,
      A,
      S,
      b,
      T,
      w,
      M,
      C
    if (
      ((s._targets = _.length
        ? hT(_)
        : Dp(
            'GSAP target ' + n + ' not found. https://gsap.com',
            !Ai.nullTargetWarn,
          ) || []),
      (s._ptLookup = []),
      (s._overwrite = d),
      p || f || Tg(u) || Tg(c))
    ) {
      if (
        ((i = s.vars),
        (x = s.timeline =
          new zr({
            data: 'nested',
            defaults: g || {},
            targets: y && y.data === 'nested' ? y.vars.targets : _,
          })),
        x.kill(),
        (x.parent = x._dp = Io(s)),
        (x._start = 0),
        f || Tg(u) || Tg(c))
      ) {
        if (((b = _.length), (M = f && gF(f)), uo(f)))
          for (T in f) ~PF.indexOf(T) && (C || (C = {}), (C[T] = f[T]))
        for (A = 0; A < b; A++)
          (S = Dy(i, RF)),
            (S.stagger = 0),
            m && (S.yoyoEase = m),
            C && Hu(S, C),
            (w = _[A]),
            (S.duration = +Qd(u, Io(s), A, w, _)),
            (S.delay = (+Qd(c, Io(s), A, w, _) || 0) - s._delay),
            !f &&
              b === 1 &&
              S.delay &&
              ((s._delay = c = S.delay), (s._start += c), (S.delay = 0)),
            x.to(w, S, M ? M(A, w, _) : 0),
            (x._ease = Le.none)
        x.duration() ? (u = c = 0) : (s.timeline = 0)
      } else if (p) {
        jd(
          ta(x.vars.defaults, {
            ease: 'none',
          }),
        ),
          (x._ease = Eu(p.ease || i.ease || 'none'))
        var E = 0,
          D,
          P,
          L
        if (Cr(p))
          p.forEach(function (I) {
            return x.to(_, I, '>')
          }),
            x.duration()
        else {
          S = {}
          for (T in p)
            T === 'ease' || T === 'easeEach' || zK(T, p[T], S, p.easeEach)
          for (T in S)
            for (
              D = S[T].sort(function (I, F) {
                return I.t - F.t
              }),
                E = 0,
                A = 0;
              A < D.length;
              A++
            )
              (P = D[A]),
                (L = {
                  ease: P.e,
                  duration: ((P.t - (A ? D[A - 1].t : 0)) / 100) * u,
                }),
                (L[T] = P.v),
                x.to(_, L, E),
                (E += L.duration)
          x.duration() < u &&
            x.to(
              {},
              {
                duration: u - x.duration(),
              },
            )
        }
      }
      u || s.duration((u = x.duration()))
    } else s.timeline = 0
    return (
      d === !0 && !iT && ((Is = Io(s)), pn.killTweensOf(_), (Is = 0)),
      Za(y, Io(s), a),
      i.reversed && s.reverse(),
      i.paused && s.paused(!0),
      (h ||
        (!u &&
          !p &&
          s._start === er(y._time) &&
          ti(h) &&
          gK(Io(s)) &&
          y.data !== 'nested')) &&
        ((s._tTime = -Qe), s.render(Math.max(0, -c) || 0)),
      v && fF(Io(s), v),
      s
    )
  }
  var e = t.prototype
  return (
    (e.render = function (i, a, o) {
      var s = this._time,
        l = this._tDur,
        u = this._dur,
        c = i < 0,
        h = i > l - Qe && !c ? l : i < Qe ? 0 : i,
        f,
        d,
        p,
        g,
        v,
        m,
        y,
        _,
        x
      if (!u) yK(this, i, a, o)
      else if (
        h !== this._tTime ||
        !i ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== c)
      ) {
        if (((f = h), (_ = this.timeline), this._repeat)) {
          if (((g = u + this._rDelay), this._repeat < -1 && c))
            return this.totalTime(g * 100 + i, a, o)
          if (
            ((f = er(h % g)),
            h === l
              ? ((p = this._repeat), (f = u))
              : ((p = ~~(h / g)),
                p && p === er(h / g) && ((f = u), p--),
                f > u && (f = u)),
            (m = this._yoyo && p & 1),
            m && ((x = this._yEase), (f = u - f)),
            (v = Kh(this._tTime, g)),
            f === s && !o && this._initted && p === v)
          )
            return (this._tTime = h), this
          p !== v &&
            (_ && this._yEase && CF(_, m),
            this.vars.repeatRefresh &&
              !m &&
              !this._lock &&
              this._time !== g &&
              this._initted &&
              ((this._lock = o = 1),
              (this.render(er(g * p), !0).invalidate()._lock = 0)))
        }
        if (!this._initted) {
          if (dF(this, c ? i : f, o, a, h)) return (this._tTime = 0), this
          if (s !== this._time && !(o && this.vars.repeatRefresh && p !== v))
            return this
          if (u !== this._dur) return this.render(i, a, o)
        }
        if (
          ((this._tTime = h),
          (this._time = f),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = y = (x || this._ease)(f / u)),
          this._from && (this.ratio = y = 1 - y),
          f && !s && !a && !p && (_i(this, 'onStart'), this._tTime !== h))
        )
          return this
        for (d = this._pt; d; ) d.r(y, d.d), (d = d._next)
        ;(_ && _.render(i < 0 ? i : _._dur * _._ease(f / this._dur), a, o)) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !a &&
            (c && pb(this, i, a, o), _i(this, 'onUpdate')),
          this._repeat &&
            p !== v &&
            this.vars.onRepeat &&
            !a &&
            this.parent &&
            _i(this, 'onRepeat'),
          (h === this._tDur || !h) &&
            this._tTime === h &&
            (c && !this._onUpdate && pb(this, i, !0, !0),
            (i || !u) &&
              ((h === this._tDur && this._ts > 0) || (!h && this._ts < 0)) &&
              tl(this, 1),
            !a &&
              !(c && !s) &&
              (h || s || m) &&
              (_i(this, h === l ? 'onComplete' : 'onReverseComplete', !0),
              this._prom && !(h < l && this.timeScale() > 0) && this._prom()))
      }
      return this
    }),
    (e.targets = function () {
      return this._targets
    }),
    (e.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        r.prototype.invalidate.call(this, i)
      )
    }),
    (e.resetTo = function (i, a, o, s, l) {
      Rp || mi.wake(), this._ts || this.play()
      var u = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        c
      return (
        this._initted || dT(this, u),
        (c = this._ease(u / this._dur)),
        BK(this, i, a, o, s, c, u, l)
          ? this.resetTo(i, a, o, s, 1)
          : (W0(this, 0),
            this.parent ||
              cF(
                this._dp,
                this,
                '_first',
                '_last',
                this._dp._sort ? '_start' : 0,
              ),
            this.render(0))
      )
    }),
    (e.kill = function (i, a) {
      if ((a === void 0 && (a = 'all'), !i && (!a || a === 'all')))
        return (this._lazy = this._pt = 0), this.parent ? Rd(this) : this
      if (this.timeline) {
        var o = this.timeline.totalDuration()
        return (
          this.timeline.killTweensOf(i, a, Is && Is.vars.overwrite !== !0)
            ._first || Rd(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            jh(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        )
      }
      var s = this._targets,
        l = i ? qi(i) : s,
        u = this._ptLookup,
        c = this._pt,
        h,
        f,
        d,
        p,
        g,
        v,
        m
      if ((!a || a === 'all') && pK(s, l))
        return a === 'all' && (this._pt = 0), Rd(this)
      for (
        h = this._op = this._op || [],
          a !== 'all' &&
            (or(a) &&
              ((g = {}),
              ei(a, function (y) {
                return (g[y] = 1)
              }),
              (a = g)),
            (a = FK(s, a))),
          m = s.length;
        m--;

      )
        if (~l.indexOf(s[m])) {
          ;(f = u[m]),
            a === 'all'
              ? ((h[m] = a), (p = f), (d = {}))
              : ((d = h[m] = h[m] || {}), (p = a))
          for (g in p)
            (v = f && f[g]),
              v &&
                ((!('kill' in v.d) || v.d.kill(g) === !0) && G0(this, v, '_pt'),
                delete f[g]),
              d !== 'all' && (d[g] = 1)
        }
      return this._initted && !this._pt && c && Rd(this), this
    }),
    (t.to = function (i, a) {
      return new t(i, a, arguments[2])
    }),
    (t.from = function (i, a) {
      return Jd(1, arguments)
    }),
    (t.delayedCall = function (i, a, o, s) {
      return new t(a, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: a,
        onReverseComplete: a,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: s,
      })
    }),
    (t.fromTo = function (i, a, o) {
      return Jd(2, arguments)
    }),
    (t.set = function (i, a) {
      return (a.duration = 0), a.repeatDelay || (a.repeat = 0), new t(i, a)
    }),
    (t.killTweensOf = function (i, a, o) {
      return pn.killTweensOf(i, a, o)
    }),
    t
  )
})(Ip)
ta(Fn.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0,
})
ei('staggerTo,staggerFrom,staggerFromTo', function (r) {
  Fn[r] = function () {
    var t = new zr(),
      e = gb.call(arguments, 0)
    return e.splice(r === 'staggerFromTo' ? 5 : 4, 0, 0), t[r].apply(t, e)
  }
})
var pT = function (t, e, n) {
    return (t[e] = n)
  },
  IF = function (t, e, n) {
    return t[e](n)
  },
  UK = function (t, e, n, i) {
    return t[e](i.fp, n)
  },
  VK = function (t, e, n) {
    return t.setAttribute(e, n)
  },
  vT = function (t, e) {
    return bn(t[e]) ? IF : aT(t[e]) && t.setAttribute ? VK : pT
  },
  OF = function (t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e)
  },
  GK = function (t, e) {
    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
  },
  NF = function (t, e) {
    var n = e._pt,
      i = ''
    if (!t && e.b) i = e.b
    else if (t === 1 && e.e) i = e.e
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * t) : Math.round((n.s + n.c * t) * 1e4) / 1e4) +
          i),
          (n = n._next)
      i += e.c
    }
    e.set(e.t, e.p, i, e)
  },
  gT = function (t, e) {
    for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next)
  },
  HK = function (t, e, n, i) {
    for (var a = this._pt, o; a; )
      (o = a._next), a.p === i && a.modifier(t, e, n), (a = o)
  },
  WK = function (t) {
    for (var e = this._pt, n, i; e; )
      (i = e._next),
        (e.p === t && !e.op) || e.op === t
          ? G0(this, e, '_pt')
          : e.dep || (n = 1),
        (e = i)
    return !n
  },
  XK = function (t, e, n, i) {
    i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
  },
  kF = function (t) {
    for (var e = t._pt, n, i, a, o; e; ) {
      for (n = e._next, i = a; i && i.pr > e.pr; ) i = i._next
      ;(e._prev = i ? i._prev : o) ? (e._prev._next = e) : (a = e),
        (e._next = i) ? (i._prev = e) : (o = e),
        (e = n)
    }
    t._pt = a
  },
  ni = (function () {
    function r(e, n, i, a, o, s, l, u, c) {
      ;(this.t = n),
        (this.s = a),
        (this.c = o),
        (this.p = i),
        (this.r = s || OF),
        (this.d = l || this),
        (this.set = u || pT),
        (this.pr = c || 0),
        (this._next = e),
        e && (e._prev = this)
    }
    var t = r.prototype
    return (
      (t.modifier = function (n, i, a) {
        ;(this.mSet = this.mSet || this.set),
          (this.set = XK),
          (this.m = n),
          (this.mt = a),
          (this.tween = i)
      }),
      r
    )
  })()
ei(
  cT +
    'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
  function (r) {
    return (uT[r] = 1)
  },
)
Ci.TweenMax = Ci.TweenLite = Fn
Ci.TimelineLite = Ci.TimelineMax = zr
pn = new zr({
  sortChildren: !1,
  defaults: Zh,
  autoRemoveChildren: !0,
  id: 'root',
  smoothChildTiming: !0,
})
Ai.stringFilter = MF
var Du = [],
  Hm = {},
  YK = [],
  pL = 0,
  $K = 0,
  Nx = function (t) {
    return (Hm[t] || YK).map(function (e) {
      return e()
    })
  },
  xb = function () {
    var t = Date.now(),
      e = []
    t - pL > 2 &&
      (Nx('matchMediaInit'),
      Du.forEach(function (n) {
        var i = n.queries,
          a = n.conditions,
          o,
          s,
          l,
          u
        for (s in i)
          (o = Wa.matchMedia(i[s]).matches),
            o && (l = 1),
            o !== a[s] && ((a[s] = o), (u = 1))
        u && (n.revert(), l && e.push(n))
      }),
      Nx('matchMediaRevert'),
      e.forEach(function (n) {
        return n.onMatch(n, function (i) {
          return n.add(null, i)
        })
      }),
      (pL = t),
      Nx('matchMedia'))
  },
  BF = (function () {
    function r(e, n) {
      ;(this.selector = n && mb(n)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = $K++),
        e && this.add(e)
    }
    var t = r.prototype
    return (
      (t.add = function (n, i, a) {
        bn(n) && ((a = i), (i = n), (n = bn))
        var o = this,
          s = function () {
            var u = hn,
              c = o.selector,
              h
            return (
              u && u !== o && u.data.push(o),
              a && (o.selector = mb(a)),
              (hn = o),
              (h = i.apply(o, arguments)),
              bn(h) && o._r.push(h),
              (hn = u),
              (o.selector = c),
              (o.isReverted = !1),
              h
            )
          }
        return (
          (o.last = s),
          n === bn
            ? s(o, function (l) {
                return o.add(null, l)
              })
            : n
            ? (o[n] = s)
            : s
        )
      }),
      (t.ignore = function (n) {
        var i = hn
        ;(hn = null), n(this), (hn = i)
      }),
      (t.getTweens = function () {
        var n = []
        return (
          this.data.forEach(function (i) {
            return i instanceof r
              ? n.push.apply(n, i.getTweens())
              : i instanceof Fn &&
                  !(i.parent && i.parent.data === 'nested') &&
                  n.push(i)
          }),
          n
        )
      }),
      (t.clear = function () {
        this._r.length = this.data.length = 0
      }),
      (t.kill = function (n, i) {
        var a = this
        if (
          (n
            ? (function () {
                for (var s = a.getTweens(), l = a.data.length, u; l--; )
                  (u = a.data[l]),
                    u.data === 'isFlip' &&
                      (u.revert(),
                      u.getChildren(!0, !0, !1).forEach(function (c) {
                        return s.splice(s.indexOf(c), 1)
                      }))
                for (
                  s
                    .map(function (c) {
                      return {
                        g:
                          c._dur ||
                          c._delay ||
                          (c._sat && !c._sat.vars.immediateRender)
                            ? c.globalTime(0)
                            : -1 / 0,
                        t: c,
                      }
                    })
                    .sort(function (c, h) {
                      return h.g - c.g || -1 / 0
                    })
                    .forEach(function (c) {
                      return c.t.revert(n)
                    }),
                    l = a.data.length;
                  l--;

                )
                  (u = a.data[l]),
                    u instanceof zr
                      ? u.data !== 'nested' &&
                        (u.scrollTrigger && u.scrollTrigger.revert(), u.kill())
                      : !(u instanceof Fn) && u.revert && u.revert(n)
                a._r.forEach(function (c) {
                  return c(n, a)
                }),
                  (a.isReverted = !0)
              })()
            : this.data.forEach(function (s) {
                return s.kill && s.kill()
              }),
          this.clear(),
          i)
        )
          for (var o = Du.length; o--; ) Du[o].id === this.id && Du.splice(o, 1)
      }),
      (t.revert = function (n) {
        this.kill(n || {})
      }),
      r
    )
  })(),
  qK = (function () {
    function r(e) {
      ;(this.contexts = []), (this.scope = e), hn && hn.data.push(this)
    }
    var t = r.prototype
    return (
      (t.add = function (n, i, a) {
        uo(n) ||
          (n = {
            matches: n,
          })
        var o = new BF(0, a || this.scope),
          s = (o.conditions = {}),
          l,
          u,
          c
        hn && !o.selector && (o.selector = hn.selector),
          this.contexts.push(o),
          (i = o.add('onMatch', i)),
          (o.queries = n)
        for (u in n)
          u === 'all'
            ? (c = 1)
            : ((l = Wa.matchMedia(n[u])),
              l &&
                (Du.indexOf(o) < 0 && Du.push(o),
                (s[u] = l.matches) && (c = 1),
                l.addListener
                  ? l.addListener(xb)
                  : l.addEventListener('change', xb)))
        return (
          c &&
            i(o, function (h) {
              return o.add(null, h)
            }),
          this
        )
      }),
      (t.revert = function (n) {
        this.kill(n || {})
      }),
      (t.kill = function (n) {
        this.contexts.forEach(function (i) {
          return i.kill(n, !0)
        })
      }),
      r
    )
  })(),
  Py = {
    registerPlugin: function () {
      for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
        e[n] = arguments[n]
      e.forEach(function (i) {
        return AF(i)
      })
    },
    timeline: function (t) {
      return new zr(t)
    },
    getTweensOf: function (t, e) {
      return pn.getTweensOf(t, e)
    },
    getProperty: function (t, e, n, i) {
      or(t) && (t = qi(t)[0])
      var a = Tu(t || {}).get,
        o = n ? uF : lF
      return (
        n === 'native' && (n = ''),
        t &&
          (e
            ? o(((vi[e] && vi[e].get) || a)(t, e, n, i))
            : function (s, l, u) {
                return o(((vi[s] && vi[s].get) || a)(t, s, l, u))
              })
      )
    },
    quickSetter: function (t, e, n) {
      if (((t = qi(t)), t.length > 1)) {
        var i = t.map(function (c) {
            return ii.quickSetter(c, e, n)
          }),
          a = i.length
        return function (c) {
          for (var h = a; h--; ) i[h](c)
        }
      }
      t = t[0] || {}
      var o = vi[e],
        s = Tu(t),
        l = (s.harness && (s.harness.aliases || {})[e]) || e,
        u = o
          ? function (c) {
              var h = new o()
              ;(mh._pt = 0),
                h.init(t, n ? c + n : c, mh, 0, [t]),
                h.render(1, h),
                mh._pt && gT(1, mh)
            }
          : s.set(t, l)
      return o
        ? u
        : function (c) {
            return u(t, l, n ? c + n : c, s, 1)
          }
    },
    quickTo: function (t, e, n) {
      var i,
        a = ii.to(
          t,
          Hu(((i = {}), (i[e] = '+=0.1'), (i.paused = !0), i), n || {}),
        ),
        o = function (l, u, c) {
          return a.resetTo(e, l, u, c)
        }
      return (o.tween = a), o
    },
    isTweening: function (t) {
      return pn.getTweensOf(t, !0).length > 0
    },
    defaults: function (t) {
      return t && t.ease && (t.ease = Eu(t.ease, Zh.ease)), uL(Zh, t || {})
    },
    config: function (t) {
      return uL(Ai, t || {})
    },
    registerEffect: function (t) {
      var e = t.name,
        n = t.effect,
        i = t.plugins,
        a = t.defaults,
        o = t.extendTimeline
      ;(i || '').split(',').forEach(function (s) {
        return (
          s && !vi[s] && !Ci[s] && Dp(e + ' effect requires ' + s + ' plugin.')
        )
      }),
        (Px[e] = function (s, l, u) {
          return n(qi(s), ta(l || {}, a), u)
        }),
        o &&
          (zr.prototype[e] = function (s, l, u) {
            return this.add(Px[e](s, uo(l) ? l : (u = l) && {}, this), u)
          })
    },
    registerEase: function (t, e) {
      Le[t] = Eu(e)
    },
    parseEase: function (t, e) {
      return arguments.length ? Eu(t, e) : Le
    },
    getById: function (t) {
      return pn.getById(t)
    },
    exportRoot: function (t, e) {
      t === void 0 && (t = {})
      var n = new zr(t),
        i,
        a
      for (
        n.smoothChildTiming = ti(t.smoothChildTiming),
          pn.remove(n),
          n._dp = 0,
          n._time = n._tTime = pn._time,
          i = pn._first;
        i;

      )
        (a = i._next),
          (e ||
            !(
              !i._dur &&
              i instanceof Fn &&
              i.vars.onComplete === i._targets[0]
            )) &&
            Za(n, i, i._start - i._delay),
          (i = a)
      return Za(pn, n, 0), n
    },
    context: function (t, e) {
      return t ? new BF(t, e) : hn
    },
    matchMedia: function (t) {
      return new qK(t)
    },
    matchMediaRefresh: function () {
      return (
        Du.forEach(function (t) {
          var e = t.conditions,
            n,
            i
          for (i in e) e[i] && ((e[i] = !1), (n = 1))
          n && t.revert()
        }) || xb()
      )
    },
    addEventListener: function (t, e) {
      var n = Hm[t] || (Hm[t] = [])
      ~n.indexOf(e) || n.push(e)
    },
    removeEventListener: function (t, e) {
      var n = Hm[t],
        i = n && n.indexOf(e)
      i >= 0 && n.splice(i, 1)
    },
    utils: {
      wrap: TK,
      wrapYoyo: CK,
      distribute: gF,
      random: yF,
      snap: mF,
      normalize: MK,
      getUnit: Mr,
      clamp: SK,
      splitColor: bF,
      toArray: qi,
      selector: mb,
      mapRange: xF,
      pipe: bK,
      unitize: wK,
      interpolate: EK,
      shuffle: vF,
    },
    install: rF,
    effects: Px,
    ticker: mi,
    updateRoot: zr.updateRoot,
    plugins: vi,
    globalTimeline: pn,
    core: {
      PropTween: ni,
      globals: iF,
      Tween: Fn,
      Timeline: zr,
      Animation: Ip,
      getCache: Tu,
      _removeLinkedListItem: G0,
      reverting: function () {
        return Tr
      },
      context: function (t) {
        return t && hn && (hn.data.push(t), (t._ctx = hn)), hn
      },
      suppressOverwrites: function (t) {
        return (iT = t)
      },
    },
  }
ei('to,from,fromTo,delayedCall,set,killTweensOf', function (r) {
  return (Py[r] = Fn[r])
})
mi.add(zr.updateRoot)
mh = Py.to(
  {},
  {
    duration: 0,
  },
)
var ZK = function (t, e) {
    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
      n = n._next
    return n
  },
  KK = function (t, e) {
    var n = t._targets,
      i,
      a,
      o
    for (i in e)
      for (a = n.length; a--; )
        (o = t._ptLookup[a][i]),
          o &&
            (o = o.d) &&
            (o._pt && (o = ZK(o, i)),
            o && o.modifier && o.modifier(e[i], t, n[a], i))
  },
  kx = function (t, e) {
    return {
      name: t,
      rawVars: 1,
      init: function (i, a, o) {
        o._onInit = function (s) {
          var l, u
          if (
            (or(a) &&
              ((l = {}),
              ei(a, function (c) {
                return (l[c] = 1)
              }),
              (a = l)),
            e)
          ) {
            l = {}
            for (u in a) l[u] = e(a[u])
            a = l
          }
          KK(s, a)
        }
      },
    }
  },
  ii =
    Py.registerPlugin(
      {
        name: 'attr',
        init: function (t, e, n, i, a) {
          var o, s, l
          this.tween = n
          for (o in e)
            (l = t.getAttribute(o) || ''),
              (s = this.add(
                t,
                'setAttribute',
                (l || 0) + '',
                e[o],
                i,
                a,
                0,
                0,
                o,
              )),
              (s.op = o),
              (s.b = l),
              this._props.push(o)
        },
        render: function (t, e) {
          for (var n = e._pt; n; )
            Tr ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next)
        },
      },
      {
        name: 'endArray',
        init: function (t, e) {
          for (var n = e.length; n--; )
            this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1)
        },
      },
      kx('roundProps', yb),
      kx('modifiers'),
      kx('snap', mF),
    ) || Py
Fn.version = zr.version = ii.version = '3.12.5'
nF = 1
oT() && Jh()
Le.Power0
Le.Power1
Le.Power2
Le.Power3
Le.Power4
Le.Linear
Le.Quad
Le.Cubic
Le.Quart
Le.Quint
Le.Strong
Le.Elastic
Le.Back
Le.SteppedEase
Le.Bounce
Le.Sine
Le.Expo
Le.Circ
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var vL,
  Os,
  Dh,
  mT,
  vu,
  gL,
  yT,
  jK = function () {
    return typeof window < 'u'
  },
  Ko = {},
  eu = 180 / Math.PI,
  Lh = Math.PI / 180,
  kc = Math.atan2,
  mL = 1e8,
  _T = /([A-Z])/g,
  JK = /(left|right|width|margin|padding|x)/i,
  QK = /[\s,\(]\S/,
  Ja = {
    autoAlpha: 'opacity,visibility',
    scale: 'scaleX,scaleY',
    alpha: 'opacity',
  },
  Sb = function (t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
  },
  tj = function (t, e) {
    return e.set(
      e.t,
      e.p,
      t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u,
      e,
    )
  },
  ej = function (t, e) {
    return e.set(
      e.t,
      e.p,
      t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b,
      e,
    )
  },
  nj = function (t, e) {
    var n = e.s + e.c * t
    e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e)
  },
  FF = function (t, e) {
    return e.set(e.t, e.p, t ? e.e : e.b, e)
  },
  zF = function (t, e) {
    return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
  },
  rj = function (t, e, n) {
    return (t.style[e] = n)
  },
  ij = function (t, e, n) {
    return t.style.setProperty(e, n)
  },
  aj = function (t, e, n) {
    return (t._gsap[e] = n)
  },
  oj = function (t, e, n) {
    return (t._gsap.scaleX = t._gsap.scaleY = n)
  },
  sj = function (t, e, n, i, a) {
    var o = t._gsap
    ;(o.scaleX = o.scaleY = n), o.renderTransform(a, o)
  },
  lj = function (t, e, n, i, a) {
    var o = t._gsap
    ;(o[e] = n), o.renderTransform(a, o)
  },
  gn = 'transform',
  ri = gn + 'Origin',
  uj = function r(t, e) {
    var n = this,
      i = this.target,
      a = i.style,
      o = i._gsap
    if (t in Ko && a) {
      if (((this.tfm = this.tfm || {}), t !== 'transform'))
        (t = Ja[t] || t),
          ~t.indexOf(',')
            ? t.split(',').forEach(function (s) {
                return (n.tfm[s] = Bo(i, s))
              })
            : (this.tfm[t] = o.x ? o[t] : Bo(i, t)),
          t === ri && (this.tfm.zOrigin = o.zOrigin)
      else
        return Ja.transform.split(',').forEach(function (s) {
          return r.call(n, s, e)
        })
      if (this.props.indexOf(gn) >= 0) return
      o.svg &&
        ((this.svgo = i.getAttribute('data-svg-origin')),
        this.props.push(ri, e, '')),
        (t = gn)
    }
    ;(a || e) && this.props.push(t, e, a[t])
  },
  UF = function (t) {
    t.translate &&
      (t.removeProperty('translate'),
      t.removeProperty('scale'),
      t.removeProperty('rotate'))
  },
  cj = function () {
    var t = this.props,
      e = this.target,
      n = e.style,
      i = e._gsap,
      a,
      o
    for (a = 0; a < t.length; a += 3)
      t[a + 1]
        ? (e[t[a]] = t[a + 2])
        : t[a + 2]
        ? (n[t[a]] = t[a + 2])
        : n.removeProperty(
            t[a].substr(0, 2) === '--'
              ? t[a]
              : t[a].replace(_T, '-$1').toLowerCase(),
          )
    if (this.tfm) {
      for (o in this.tfm) i[o] = this.tfm[o]
      i.svg &&
        (i.renderTransform(),
        e.setAttribute('data-svg-origin', this.svgo || '')),
        (a = yT()),
        (!a || !a.isStart) &&
          !n[gn] &&
          (UF(n),
          i.zOrigin &&
            n[ri] &&
            ((n[ri] += ' ' + i.zOrigin + 'px'),
            (i.zOrigin = 0),
            i.renderTransform()),
          (i.uncache = 1))
    }
  },
  VF = function (t, e) {
    var n = {
      target: t,
      props: [],
      revert: cj,
      save: uj,
    }
    return (
      t._gsap || ii.core.getCache(t),
      e &&
        e.split(',').forEach(function (i) {
          return n.save(i)
        }),
      n
    )
  },
  GF,
  Ab = function (t, e) {
    var n = Os.createElementNS
      ? Os.createElementNS(
          (e || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'),
          t,
        )
      : Os.createElement(t)
    return n && n.style ? n : Os.createElement(t)
  },
  io = function r(t, e, n) {
    var i = getComputedStyle(t)
    return (
      i[e] ||
      i.getPropertyValue(e.replace(_T, '-$1').toLowerCase()) ||
      i.getPropertyValue(e) ||
      (!n && r(t, Qh(e) || e, 1)) ||
      ''
    )
  },
  yL = 'O,Moz,ms,Ms,Webkit'.split(','),
  Qh = function (t, e, n) {
    var i = e || vu,
      a = i.style,
      o = 5
    if (t in a && !n) return t
    for (
      t = t.charAt(0).toUpperCase() + t.substr(1);
      o-- && !(yL[o] + t in a);

    );
    return o < 0 ? null : (o === 3 ? 'ms' : o >= 0 ? yL[o] : '') + t
  },
  bb = function () {
    jK() &&
      window.document &&
      ((vL = window),
      (Os = vL.document),
      (Dh = Os.documentElement),
      (vu = Ab('div') || {
        style: {},
      }),
      Ab('div'),
      (gn = Qh(gn)),
      (ri = gn + 'Origin'),
      (vu.style.cssText =
        'border-width:0;line-height:0;position:absolute;padding:0'),
      (GF = !!Qh('perspective')),
      (yT = ii.core.reverting),
      (mT = 1))
  },
  Bx = function r(t) {
    var e = Ab(
        'svg',
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute('xmlns')) ||
          'http://www.w3.org/2000/svg',
      ),
      n = this.parentNode,
      i = this.nextSibling,
      a = this.style.cssText,
      o
    if (
      (Dh.appendChild(e),
      e.appendChild(this),
      (this.style.display = 'block'),
      t)
    )
      try {
        ;(o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = r)
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox())
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Dh.removeChild(e),
      (this.style.cssText = a),
      o
    )
  },
  _L = function (t, e) {
    for (var n = e.length; n--; )
      if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
  },
  HF = function (t) {
    var e
    try {
      e = t.getBBox()
    } catch {
      e = Bx.call(t, !0)
    }
    return (
      (e && (e.width || e.height)) || t.getBBox === Bx || (e = Bx.call(t, !0)),
      e && !e.width && !e.x && !e.y
        ? {
            x: +_L(t, ['x', 'cx', 'x1']) || 0,
            y: +_L(t, ['y', 'cy', 'y1']) || 0,
            width: 0,
            height: 0,
          }
        : e
    )
  },
  WF = function (t) {
    return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && HF(t))
  },
  Wu = function (t, e) {
    if (e) {
      var n = t.style,
        i
      e in Ko && e !== ri && (e = gn),
        n.removeProperty
          ? ((i = e.substr(0, 2)),
            (i === 'ms' || e.substr(0, 6) === 'webkit') && (e = '-' + e),
            n.removeProperty(
              i === '--' ? e : e.replace(_T, '-$1').toLowerCase(),
            ))
          : n.removeAttribute(e)
    }
  },
  Ns = function (t, e, n, i, a, o) {
    var s = new ni(t._pt, e, n, 0, 1, o ? zF : FF)
    return (t._pt = s), (s.b = i), (s.e = a), t._props.push(n), s
  },
  xL = {
    deg: 1,
    rad: 1,
    turn: 1,
  },
  hj = {
    grid: 1,
    flex: 1,
  },
  el = function r(t, e, n, i) {
    var a = parseFloat(n) || 0,
      o = (n + '').trim().substr((a + '').length) || 'px',
      s = vu.style,
      l = JK.test(e),
      u = t.tagName.toLowerCase() === 'svg',
      c = (u ? 'client' : 'offset') + (l ? 'Width' : 'Height'),
      h = 100,
      f = i === 'px',
      d = i === '%',
      p,
      g,
      v,
      m
    if (i === o || !a || xL[i] || xL[o]) return a
    if (
      (o !== 'px' && !f && (a = r(t, e, n, 'px')),
      (m = t.getCTM && WF(t)),
      (d || o === '%') && (Ko[e] || ~e.indexOf('adius')))
    )
      return (
        (p = m ? t.getBBox()[l ? 'width' : 'height'] : t[c]),
        En(d ? (a / p) * h : (a / 100) * p)
      )
    if (
      ((s[l ? 'width' : 'height'] = h + (f ? o : i)),
      (g =
        ~e.indexOf('adius') || (i === 'em' && t.appendChild && !u)
          ? t
          : t.parentNode),
      m && (g = (t.ownerSVGElement || {}).parentNode),
      (!g || g === Os || !g.appendChild) && (g = Os.body),
      (v = g._gsap),
      v && d && v.width && l && v.time === mi.time && !v.uncache)
    )
      return En((a / v.width) * h)
    if (d && (e === 'height' || e === 'width')) {
      var y = t.style[e]
      ;(t.style[e] = h + i), (p = t[c]), y ? (t.style[e] = y) : Wu(t, e)
    } else
      (d || o === '%') &&
        !hj[io(g, 'display')] &&
        (s.position = io(t, 'position')),
        g === t && (s.position = 'static'),
        g.appendChild(vu),
        (p = vu[c]),
        g.removeChild(vu),
        (s.position = 'absolute')
    return (
      l && d && ((v = Tu(g)), (v.time = mi.time), (v.width = g[c])),
      En(f ? (p * a) / h : p && a ? (h / p) * a : 0)
    )
  },
  Bo = function (t, e, n, i) {
    var a
    return (
      mT || bb(),
      e in Ja &&
        e !== 'transform' &&
        ((e = Ja[e]), ~e.indexOf(',') && (e = e.split(',')[0])),
      Ko[e] && e !== 'transform'
        ? ((a = Np(t, i)),
          (a =
            e !== 'transformOrigin'
              ? a[e]
              : a.svg
              ? a.origin
              : Iy(io(t, ri)) + ' ' + a.zOrigin + 'px'))
        : ((a = t.style[e]),
          (!a || a === 'auto' || i || ~(a + '').indexOf('calc(')) &&
            (a =
              (Ry[e] && Ry[e](t, e, n)) ||
              io(t, e) ||
              oF(t, e) ||
              (e === 'opacity' ? 1 : 0))),
      n && !~(a + '').trim().indexOf(' ') ? el(t, e, a, n) + n : a
    )
  },
  fj = function (t, e, n, i) {
    if (!n || n === 'none') {
      var a = Qh(e, t, 1),
        o = a && io(t, a, 1)
      o && o !== n
        ? ((e = a), (n = o))
        : e === 'borderColor' && (n = io(t, 'borderTopColor'))
    }
    var s = new ni(this._pt, t.style, e, 0, 1, NF),
      l = 0,
      u = 0,
      c,
      h,
      f,
      d,
      p,
      g,
      v,
      m,
      y,
      _,
      x,
      A
    if (
      ((s.b = n),
      (s.e = i),
      (n += ''),
      (i += ''),
      i === 'auto' &&
        ((g = t.style[e]),
        (t.style[e] = i),
        (i = io(t, e) || i),
        g ? (t.style[e] = g) : Wu(t, e)),
      (c = [n, i]),
      MF(c),
      (n = c[0]),
      (i = c[1]),
      (f = n.match(gh) || []),
      (A = i.match(gh) || []),
      A.length)
    ) {
      for (; (h = gh.exec(i)); )
        (v = h[0]),
          (y = i.substring(l, h.index)),
          p
            ? (p = (p + 1) % 5)
            : (y.substr(-5) === 'rgba(' || y.substr(-5) === 'hsla(') && (p = 1),
          v !== (g = f[u++] || '') &&
            ((d = parseFloat(g) || 0),
            (x = g.substr((d + '').length)),
            v.charAt(1) === '=' && (v = Eh(d, v) + x),
            (m = parseFloat(v)),
            (_ = v.substr((m + '').length)),
            (l = gh.lastIndex - _.length),
            _ ||
              ((_ = _ || Ai.units[e] || x),
              l === i.length && ((i += _), (s.e += _))),
            x !== _ && (d = el(t, e, g, _) || 0),
            (s._pt = {
              _next: s._pt,
              p: y || u === 1 ? y : ',',
              s: d,
              c: m - d,
              m: (p && p < 4) || e === 'zIndex' ? Math.round : 0,
            }))
      s.c = l < i.length ? i.substring(l, i.length) : ''
    } else s.r = e === 'display' && i === 'none' ? zF : FF
    return tF.test(i) && (s.e = 0), (this._pt = s), s
  },
  SL = {
    top: '0%',
    bottom: '100%',
    left: '0%',
    right: '100%',
    center: '50%',
  },
  dj = function (t) {
    var e = t.split(' '),
      n = e[0],
      i = e[1] || '50%'
    return (
      (n === 'top' || n === 'bottom' || i === 'left' || i === 'right') &&
        ((t = n), (n = i), (i = t)),
      (e[0] = SL[n] || n),
      (e[1] = SL[i] || i),
      e.join(' ')
    )
  },
  pj = function (t, e) {
    if (e.tween && e.tween._time === e.tween._dur) {
      var n = e.t,
        i = n.style,
        a = e.u,
        o = n._gsap,
        s,
        l,
        u
      if (a === 'all' || a === !0) (i.cssText = ''), (l = 1)
      else
        for (a = a.split(','), u = a.length; --u > -1; )
          (s = a[u]),
            Ko[s] && ((l = 1), (s = s === 'transformOrigin' ? ri : gn)),
            Wu(n, s)
      l &&
        (Wu(n, gn),
        o &&
          (o.svg && n.removeAttribute('transform'),
          Np(n, 1),
          (o.uncache = 1),
          UF(i)))
    }
  },
  Ry = {
    clearProps: function (t, e, n, i, a) {
      if (a.data !== 'isFromStart') {
        var o = (t._pt = new ni(t._pt, e, n, 0, 0, pj))
        return (o.u = i), (o.pr = -10), (o.tween = a), t._props.push(n), 1
      }
    },
  },
  Op = [1, 0, 0, 1, 0, 0],
  XF = {},
  YF = function (t) {
    return t === 'matrix(1, 0, 0, 1, 0, 0)' || t === 'none' || !t
  },
  AL = function (t) {
    var e = io(t, gn)
    return YF(e) ? Op : e.substr(7).match(QB).map(En)
  },
  xT = function (t, e) {
    var n = t._gsap || Tu(t),
      i = t.style,
      a = AL(t),
      o,
      s,
      l,
      u
    return n.svg && t.getAttribute('transform')
      ? ((l = t.transform.baseVal.consolidate().matrix),
        (a = [l.a, l.b, l.c, l.d, l.e, l.f]),
        a.join(',') === '1,0,0,1,0,0' ? Op : a)
      : (a === Op &&
          !t.offsetParent &&
          t !== Dh &&
          !n.svg &&
          ((l = i.display),
          (i.display = 'block'),
          (o = t.parentNode),
          (!o || !t.offsetParent) &&
            ((u = 1), (s = t.nextElementSibling), Dh.appendChild(t)),
          (a = AL(t)),
          l ? (i.display = l) : Wu(t, 'display'),
          u &&
            (s
              ? o.insertBefore(t, s)
              : o
              ? o.appendChild(t)
              : Dh.removeChild(t))),
        e && a.length > 6 ? [a[0], a[1], a[4], a[5], a[12], a[13]] : a)
  },
  wb = function (t, e, n, i, a, o) {
    var s = t._gsap,
      l = a || xT(t, !0),
      u = s.xOrigin || 0,
      c = s.yOrigin || 0,
      h = s.xOffset || 0,
      f = s.yOffset || 0,
      d = l[0],
      p = l[1],
      g = l[2],
      v = l[3],
      m = l[4],
      y = l[5],
      _ = e.split(' '),
      x = parseFloat(_[0]) || 0,
      A = parseFloat(_[1]) || 0,
      S,
      b,
      T,
      w
    n
      ? l !== Op &&
        (b = d * v - p * g) &&
        ((T = x * (v / b) + A * (-g / b) + (g * y - v * m) / b),
        (w = x * (-p / b) + A * (d / b) - (d * y - p * m) / b),
        (x = T),
        (A = w))
      : ((S = HF(t)),
        (x = S.x + (~_[0].indexOf('%') ? (x / 100) * S.width : x)),
        (A = S.y + (~(_[1] || _[0]).indexOf('%') ? (A / 100) * S.height : A))),
      i || (i !== !1 && s.smooth)
        ? ((m = x - u),
          (y = A - c),
          (s.xOffset = h + (m * d + y * g) - m),
          (s.yOffset = f + (m * p + y * v) - y))
        : (s.xOffset = s.yOffset = 0),
      (s.xOrigin = x),
      (s.yOrigin = A),
      (s.smooth = !!i),
      (s.origin = e),
      (s.originIsAbsolute = !!n),
      (t.style[ri] = '0px 0px'),
      o &&
        (Ns(o, s, 'xOrigin', u, x),
        Ns(o, s, 'yOrigin', c, A),
        Ns(o, s, 'xOffset', h, s.xOffset),
        Ns(o, s, 'yOffset', f, s.yOffset)),
      t.setAttribute('data-svg-origin', x + ' ' + A)
  },
  Np = function (t, e) {
    var n = t._gsap || new DF(t)
    if ('x' in n && !e && !n.uncache) return n
    var i = t.style,
      a = n.scaleX < 0,
      o = 'px',
      s = 'deg',
      l = getComputedStyle(t),
      u = io(t, ri) || '0',
      c,
      h,
      f,
      d,
      p,
      g,
      v,
      m,
      y,
      _,
      x,
      A,
      S,
      b,
      T,
      w,
      M,
      C,
      E,
      D,
      P,
      L,
      I,
      F,
      k,
      V,
      H,
      Y,
      K,
      ut,
      W,
      Z
    return (
      (c = h = f = g = v = m = y = _ = x = 0),
      (d = p = 1),
      (n.svg = !!(t.getCTM && WF(t))),
      l.translate &&
        ((l.translate !== 'none' ||
          l.scale !== 'none' ||
          l.rotate !== 'none') &&
          (i[gn] =
            (l.translate !== 'none'
              ? 'translate3d(' +
                (l.translate + ' 0 0').split(' ').slice(0, 3).join(', ') +
                ') '
              : '') +
            (l.rotate !== 'none' ? 'rotate(' + l.rotate + ') ' : '') +
            (l.scale !== 'none'
              ? 'scale(' + l.scale.split(' ').join(',') + ') '
              : '') +
            (l[gn] !== 'none' ? l[gn] : '')),
        (i.scale = i.rotate = i.translate = 'none')),
      (b = xT(t, n.svg)),
      n.svg &&
        (n.uncache
          ? ((k = t.getBBox()),
            (u = n.xOrigin - k.x + 'px ' + (n.yOrigin - k.y) + 'px'),
            (F = ''))
          : (F = !e && t.getAttribute('data-svg-origin')),
        wb(t, F || u, !!F || n.originIsAbsolute, n.smooth !== !1, b)),
      (A = n.xOrigin || 0),
      (S = n.yOrigin || 0),
      b !== Op &&
        ((C = b[0]),
        (E = b[1]),
        (D = b[2]),
        (P = b[3]),
        (c = L = b[4]),
        (h = I = b[5]),
        b.length === 6
          ? ((d = Math.sqrt(C * C + E * E)),
            (p = Math.sqrt(P * P + D * D)),
            (g = C || E ? kc(E, C) * eu : 0),
            (y = D || P ? kc(D, P) * eu + g : 0),
            y && (p *= Math.abs(Math.cos(y * Lh))),
            n.svg && ((c -= A - (A * C + S * D)), (h -= S - (A * E + S * P))))
          : ((Z = b[6]),
            (ut = b[7]),
            (H = b[8]),
            (Y = b[9]),
            (K = b[10]),
            (W = b[11]),
            (c = b[12]),
            (h = b[13]),
            (f = b[14]),
            (T = kc(Z, K)),
            (v = T * eu),
            T &&
              ((w = Math.cos(-T)),
              (M = Math.sin(-T)),
              (F = L * w + H * M),
              (k = I * w + Y * M),
              (V = Z * w + K * M),
              (H = L * -M + H * w),
              (Y = I * -M + Y * w),
              (K = Z * -M + K * w),
              (W = ut * -M + W * w),
              (L = F),
              (I = k),
              (Z = V)),
            (T = kc(-D, K)),
            (m = T * eu),
            T &&
              ((w = Math.cos(-T)),
              (M = Math.sin(-T)),
              (F = C * w - H * M),
              (k = E * w - Y * M),
              (V = D * w - K * M),
              (W = P * M + W * w),
              (C = F),
              (E = k),
              (D = V)),
            (T = kc(E, C)),
            (g = T * eu),
            T &&
              ((w = Math.cos(T)),
              (M = Math.sin(T)),
              (F = C * w + E * M),
              (k = L * w + I * M),
              (E = E * w - C * M),
              (I = I * w - L * M),
              (C = F),
              (L = k)),
            v &&
              Math.abs(v) + Math.abs(g) > 359.9 &&
              ((v = g = 0), (m = 180 - m)),
            (d = En(Math.sqrt(C * C + E * E + D * D))),
            (p = En(Math.sqrt(I * I + Z * Z))),
            (T = kc(L, I)),
            (y = Math.abs(T) > 2e-4 ? T * eu : 0),
            (x = W ? 1 / (W < 0 ? -W : W) : 0)),
        n.svg &&
          ((F = t.getAttribute('transform')),
          (n.forceCSS = t.setAttribute('transform', '') || !YF(io(t, gn))),
          F && t.setAttribute('transform', F))),
      Math.abs(y) > 90 &&
        Math.abs(y) < 270 &&
        (a
          ? ((d *= -1), (y += g <= 0 ? 180 : -180), (g += g <= 0 ? 180 : -180))
          : ((p *= -1), (y += y <= 0 ? 180 : -180))),
      (e = e || n.uncache),
      (n.x =
        c -
        ((n.xPercent =
          c &&
          ((!e && n.xPercent) ||
            (Math.round(t.offsetWidth / 2) === Math.round(-c) ? -50 : 0)))
          ? (t.offsetWidth * n.xPercent) / 100
          : 0) +
        o),
      (n.y =
        h -
        ((n.yPercent =
          h &&
          ((!e && n.yPercent) ||
            (Math.round(t.offsetHeight / 2) === Math.round(-h) ? -50 : 0)))
          ? (t.offsetHeight * n.yPercent) / 100
          : 0) +
        o),
      (n.z = f + o),
      (n.scaleX = En(d)),
      (n.scaleY = En(p)),
      (n.rotation = En(g) + s),
      (n.rotationX = En(v) + s),
      (n.rotationY = En(m) + s),
      (n.skewX = y + s),
      (n.skewY = _ + s),
      (n.transformPerspective = x + o),
      (n.zOrigin = parseFloat(u.split(' ')[2]) || (!e && n.zOrigin) || 0) &&
        (i[ri] = Iy(u)),
      (n.xOffset = n.yOffset = 0),
      (n.force3D = Ai.force3D),
      (n.renderTransform = n.svg ? gj : GF ? $F : vj),
      (n.uncache = 0),
      n
    )
  },
  Iy = function (t) {
    return (t = t.split(' '))[0] + ' ' + t[1]
  },
  Fx = function (t, e, n) {
    var i = Mr(e)
    return En(parseFloat(e) + parseFloat(el(t, 'x', n + 'px', i))) + i
  },
  vj = function (t, e) {
    ;(e.z = '0px'),
      (e.rotationY = e.rotationX = '0deg'),
      (e.force3D = 0),
      $F(t, e)
  },
  Cl = '0deg',
  qf = '0px',
  El = ') ',
  $F = function (t, e) {
    var n = e || this,
      i = n.xPercent,
      a = n.yPercent,
      o = n.x,
      s = n.y,
      l = n.z,
      u = n.rotation,
      c = n.rotationY,
      h = n.rotationX,
      f = n.skewX,
      d = n.skewY,
      p = n.scaleX,
      g = n.scaleY,
      v = n.transformPerspective,
      m = n.force3D,
      y = n.target,
      _ = n.zOrigin,
      x = '',
      A = (m === 'auto' && t && t !== 1) || m === !0
    if (_ && (h !== Cl || c !== Cl)) {
      var S = parseFloat(c) * Lh,
        b = Math.sin(S),
        T = Math.cos(S),
        w
      ;(S = parseFloat(h) * Lh),
        (w = Math.cos(S)),
        (o = Fx(y, o, b * w * -_)),
        (s = Fx(y, s, -Math.sin(S) * -_)),
        (l = Fx(y, l, T * w * -_ + _))
    }
    v !== qf && (x += 'perspective(' + v + El),
      (i || a) && (x += 'translate(' + i + '%, ' + a + '%) '),
      (A || o !== qf || s !== qf || l !== qf) &&
        (x +=
          l !== qf || A
            ? 'translate3d(' + o + ', ' + s + ', ' + l + ') '
            : 'translate(' + o + ', ' + s + El),
      u !== Cl && (x += 'rotate(' + u + El),
      c !== Cl && (x += 'rotateY(' + c + El),
      h !== Cl && (x += 'rotateX(' + h + El),
      (f !== Cl || d !== Cl) && (x += 'skew(' + f + ', ' + d + El),
      (p !== 1 || g !== 1) && (x += 'scale(' + p + ', ' + g + El),
      (y.style[gn] = x || 'translate(0, 0)')
  },
  gj = function (t, e) {
    var n = e || this,
      i = n.xPercent,
      a = n.yPercent,
      o = n.x,
      s = n.y,
      l = n.rotation,
      u = n.skewX,
      c = n.skewY,
      h = n.scaleX,
      f = n.scaleY,
      d = n.target,
      p = n.xOrigin,
      g = n.yOrigin,
      v = n.xOffset,
      m = n.yOffset,
      y = n.forceCSS,
      _ = parseFloat(o),
      x = parseFloat(s),
      A,
      S,
      b,
      T,
      w
    ;(l = parseFloat(l)),
      (u = parseFloat(u)),
      (c = parseFloat(c)),
      c && ((c = parseFloat(c)), (u += c), (l += c)),
      l || u
        ? ((l *= Lh),
          (u *= Lh),
          (A = Math.cos(l) * h),
          (S = Math.sin(l) * h),
          (b = Math.sin(l - u) * -f),
          (T = Math.cos(l - u) * f),
          u &&
            ((c *= Lh),
            (w = Math.tan(u - c)),
            (w = Math.sqrt(1 + w * w)),
            (b *= w),
            (T *= w),
            c &&
              ((w = Math.tan(c)),
              (w = Math.sqrt(1 + w * w)),
              (A *= w),
              (S *= w))),
          (A = En(A)),
          (S = En(S)),
          (b = En(b)),
          (T = En(T)))
        : ((A = h), (T = f), (S = b = 0)),
      ((_ && !~(o + '').indexOf('px')) || (x && !~(s + '').indexOf('px'))) &&
        ((_ = el(d, 'x', o, 'px')), (x = el(d, 'y', s, 'px'))),
      (p || g || v || m) &&
        ((_ = En(_ + p - (p * A + g * b) + v)),
        (x = En(x + g - (p * S + g * T) + m))),
      (i || a) &&
        ((w = d.getBBox()),
        (_ = En(_ + (i / 100) * w.width)),
        (x = En(x + (a / 100) * w.height))),
      (w =
        'matrix(' + A + ',' + S + ',' + b + ',' + T + ',' + _ + ',' + x + ')'),
      d.setAttribute('transform', w),
      y && (d.style[gn] = w)
  },
  mj = function (t, e, n, i, a) {
    var o = 360,
      s = or(a),
      l = parseFloat(a) * (s && ~a.indexOf('rad') ? eu : 1),
      u = l - i,
      c = i + u + 'deg',
      h,
      f
    return (
      s &&
        ((h = a.split('_')[1]),
        h === 'short' && ((u %= o), u !== u % (o / 2) && (u += u < 0 ? o : -o)),
        h === 'cw' && u < 0
          ? (u = ((u + o * mL) % o) - ~~(u / o) * o)
          : h === 'ccw' && u > 0 && (u = ((u - o * mL) % o) - ~~(u / o) * o)),
      (t._pt = f = new ni(t._pt, e, n, i, u, tj)),
      (f.e = c),
      (f.u = 'deg'),
      t._props.push(n),
      f
    )
  },
  bL = function (t, e) {
    for (var n in e) t[n] = e[n]
    return t
  },
  yj = function (t, e, n) {
    var i = bL({}, n._gsap),
      a = 'perspective,force3D,transformOrigin,svgOrigin',
      o = n.style,
      s,
      l,
      u,
      c,
      h,
      f,
      d,
      p
    i.svg
      ? ((u = n.getAttribute('transform')),
        n.setAttribute('transform', ''),
        (o[gn] = e),
        (s = Np(n, 1)),
        Wu(n, gn),
        n.setAttribute('transform', u))
      : ((u = getComputedStyle(n)[gn]),
        (o[gn] = e),
        (s = Np(n, 1)),
        (o[gn] = u))
    for (l in Ko)
      (u = i[l]),
        (c = s[l]),
        u !== c &&
          a.indexOf(l) < 0 &&
          ((d = Mr(u)),
          (p = Mr(c)),
          (h = d !== p ? el(n, l, u, p) : parseFloat(u)),
          (f = parseFloat(c)),
          (t._pt = new ni(t._pt, s, l, h, f - h, Sb)),
          (t._pt.u = p || 0),
          t._props.push(l))
    bL(s, i)
  }
ei('padding,margin,Width,Radius', function (r, t) {
  var e = 'Top',
    n = 'Right',
    i = 'Bottom',
    a = 'Left',
    o = (t < 3 ? [e, n, i, a] : [e + a, e + n, i + n, i + a]).map(function (s) {
      return t < 2 ? r + s : 'border' + s + r
    })
  Ry[t > 1 ? 'border' + r : r] = function (s, l, u, c, h) {
    var f, d
    if (arguments.length < 4)
      return (
        (f = o.map(function (p) {
          return Bo(s, p, u)
        })),
        (d = f.join(' ')),
        d.split(f[0]).length === 5 ? f[0] : d
      )
    ;(f = (c + '').split(' ')),
      (d = {}),
      o.forEach(function (p, g) {
        return (d[p] = f[g] = f[g] || f[((g - 1) / 2) | 0])
      }),
      s.init(l, d, h)
  }
})
var qF = {
  name: 'css',
  register: bb,
  targetTest: function (t) {
    return t.style && t.nodeType
  },
  init: function (t, e, n, i, a) {
    var o = this._props,
      s = t.style,
      l = n.vars.startAt,
      u,
      c,
      h,
      f,
      d,
      p,
      g,
      v,
      m,
      y,
      _,
      x,
      A,
      S,
      b,
      T
    mT || bb(),
      (this.styles = this.styles || VF(t)),
      (T = this.styles.props),
      (this.tween = n)
    for (g in e)
      if (g !== 'autoRound' && ((c = e[g]), !(vi[g] && LF(g, e, n, i, t, a)))) {
        if (
          ((d = typeof c),
          (p = Ry[g]),
          d === 'function' && ((c = c.call(n, i, t, a)), (d = typeof c)),
          d === 'string' && ~c.indexOf('random(') && (c = Pp(c)),
          p)
        )
          p(this, t, g, c, n) && (b = 1)
        else if (g.substr(0, 2) === '--')
          (u = (getComputedStyle(t).getPropertyValue(g) + '').trim()),
            (c += ''),
            (Zs.lastIndex = 0),
            Zs.test(u) || ((v = Mr(u)), (m = Mr(c))),
            m ? v !== m && (u = el(t, g, u, m) + m) : v && (c += v),
            this.add(s, 'setProperty', u, c, i, a, 0, 0, g),
            o.push(g),
            T.push(g, 0, s[g])
        else if (d !== 'undefined') {
          if (
            (l && g in l
              ? ((u = typeof l[g] == 'function' ? l[g].call(n, i, t, a) : l[g]),
                or(u) && ~u.indexOf('random(') && (u = Pp(u)),
                Mr(u + '') ||
                  u === 'auto' ||
                  (u += Ai.units[g] || Mr(Bo(t, g)) || ''),
                (u + '').charAt(1) === '=' && (u = Bo(t, g)))
              : (u = Bo(t, g)),
            (f = parseFloat(u)),
            (y = d === 'string' && c.charAt(1) === '=' && c.substr(0, 2)),
            y && (c = c.substr(2)),
            (h = parseFloat(c)),
            g in Ja &&
              (g === 'autoAlpha' &&
                (f === 1 && Bo(t, 'visibility') === 'hidden' && h && (f = 0),
                T.push('visibility', 0, s.visibility),
                Ns(
                  this,
                  s,
                  'visibility',
                  f ? 'inherit' : 'hidden',
                  h ? 'inherit' : 'hidden',
                  !h,
                )),
              g !== 'scale' &&
                g !== 'transform' &&
                ((g = Ja[g]), ~g.indexOf(',') && (g = g.split(',')[0]))),
            (_ = g in Ko),
            _)
          ) {
            if (
              (this.styles.save(g),
              x ||
                ((A = t._gsap),
                (A.renderTransform && !e.parseTransform) ||
                  Np(t, e.parseTransform),
                (S = e.smoothOrigin !== !1 && A.smooth),
                (x = this._pt =
                  new ni(this._pt, s, gn, 0, 1, A.renderTransform, A, 0, -1)),
                (x.dep = 1)),
              g === 'scale')
            )
              (this._pt = new ni(
                this._pt,
                A,
                'scaleY',
                A.scaleY,
                (y ? Eh(A.scaleY, y + h) : h) - A.scaleY || 0,
                Sb,
              )),
                (this._pt.u = 0),
                o.push('scaleY', g),
                (g += 'X')
            else if (g === 'transformOrigin') {
              T.push(ri, 0, s[ri]),
                (c = dj(c)),
                A.svg
                  ? wb(t, c, 0, S, 0, this)
                  : ((m = parseFloat(c.split(' ')[2]) || 0),
                    m !== A.zOrigin && Ns(this, A, 'zOrigin', A.zOrigin, m),
                    Ns(this, s, g, Iy(u), Iy(c)))
              continue
            } else if (g === 'svgOrigin') {
              wb(t, c, 1, S, 0, this)
              continue
            } else if (g in XF) {
              mj(this, A, g, f, y ? Eh(f, y + c) : c)
              continue
            } else if (g === 'smoothOrigin') {
              Ns(this, A, 'smooth', A.smooth, c)
              continue
            } else if (g === 'force3D') {
              A[g] = c
              continue
            } else if (g === 'transform') {
              yj(this, c, t)
              continue
            }
          } else g in s || (g = Qh(g) || g)
          if (_ || ((h || h === 0) && (f || f === 0) && !QK.test(c) && g in s))
            (v = (u + '').substr((f + '').length)),
              h || (h = 0),
              (m = Mr(c) || (g in Ai.units ? Ai.units[g] : v)),
              v !== m && (f = el(t, g, u, m)),
              (this._pt = new ni(
                this._pt,
                _ ? A : s,
                g,
                f,
                (y ? Eh(f, y + h) : h) - f,
                !_ && (m === 'px' || g === 'zIndex') && e.autoRound !== !1
                  ? nj
                  : Sb,
              )),
              (this._pt.u = m || 0),
              v !== m && m !== '%' && ((this._pt.b = u), (this._pt.r = ej))
          else if (g in s) fj.call(this, t, g, u, y ? y + c : c)
          else if (g in t) this.add(t, g, u || t[g], y ? y + c : c, i, a)
          else if (g !== 'parseTransform') {
            lT(g, c)
            continue
          }
          _ || (g in s ? T.push(g, 0, s[g]) : T.push(g, 1, u || t[g])),
            o.push(g)
        }
      }
    b && kF(this)
  },
  render: function (t, e) {
    if (e.tween._time || !yT())
      for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next)
    else e.styles.revert()
  },
  get: Bo,
  aliases: Ja,
  getSetter: function (t, e, n) {
    var i = Ja[e]
    return (
      i && i.indexOf(',') < 0 && (e = i),
      e in Ko && e !== ri && (t._gsap.x || Bo(t, 'x'))
        ? n && gL === n
          ? e === 'scale'
            ? oj
            : aj
          : (gL = n || {}) && (e === 'scale' ? sj : lj)
        : t.style && !aT(t.style[e])
        ? rj
        : ~e.indexOf('-')
        ? ij
        : vT(t, e)
    )
  },
  core: {
    _removeProperty: Wu,
    _getMatrix: xT,
  },
}
ii.utils.checkPrefix = Qh
ii.core.getStyleSaver = VF
;(function (r, t, e, n) {
  var i = ei(r + ',' + t + ',' + e, function (a) {
    Ko[a] = 1
  })
  ei(t, function (a) {
    ;(Ai.units[a] = 'deg'), (XF[a] = 1)
  }),
    (Ja[i[13]] = r + ',' + t),
    ei(n, function (a) {
      var o = a.split(':')
      Ja[o[1]] = i[o[0]]
    })
})(
  'x,y,z,scale,scaleX,scaleY,xPercent,yPercent',
  'rotation,rotationX,rotationY,skewX,skewY',
  'transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
  '0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY',
)
ei(
  'x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective',
  function (r) {
    Ai.units[r] = 'px'
  },
)
ii.registerPlugin(qF)
var Sn = ii.registerPlugin(qF) || ii
Sn.core.Tween
class _j extends Fe {
  constructor(t, e) {
    super(),
      (this.config = Object.assign(
        {
          color1: 16566615,
          color2: 16777215,
        },
        e,
      )),
      (this.assets = {
        instance: null,
      }),
      (this.assets.instance = t.assets.instance),
      (this.sceneGroup = t.sceneGroup),
      (this.gsapObjects = []),
      (this.animateElements = {}),
      this.init()
  }
  init() {
    let t = this.config.color1,
      e = new Ti(1.5, 1.5, 1),
      n = new Ti(0.3, 3, 1)
    n.translate(0, 1, 0)
    let i = new on({
        color: t,
        transparent: !0,
        fog: !1,
        side: dr,
        depthWrite: !1,
      }),
      a = i.clone()
    a.map = this.assets.instance.getResource('focusArrows')
    let o = i.clone()
    o.map = this.assets.instance.getResource('focusBar')
    let s = i.clone()
    s.map = this.assets.instance.getResource('focusBg')
    let l = i.clone()
    ;(l.color = new qt(this.config.color2)),
      (l.map = this.assets.instance.getResource('focusMidQuan'))
    let u = i.clone()
    ;(u.map = this.assets.instance.getResource('focusMoveBg')),
      (u.blending = $r)
    let c = new De(e, a),
      h = new De(n, o)
    h.rotation.x = Math.PI / 2
    let f = h.clone()
    f.rotation.y = Math.PI / 2
    let d = new De(e, s),
      p = new De(e, l),
      g = new De(e, u),
      v = [p, d, c, g, h, f]
    v.map(y => {
      y.renderOrder = 99
    }),
      this.add(...v)
    let m = 0
    g.scale.setScalar(m),
      (this.animateElements = {
        focusMidQuan: p,
        focusArrows: c,
        focusMoveBg: g,
      }),
      this.startAnimate()
  }
  startAnimate() {
    let t = Sn.to(this.animateElements.focusMidQuan.rotation, {
        z: 2 * Math.PI,
        duration: 8,
        repeat: -1,
        ease: 'none',
      }),
      e = Sn.to(this.animateElements.focusArrows.rotation, {
        z: 2 * Math.PI,
        duration: 5,
        repeat: -1,
        ease: 'none',
      }),
      n = Sn.to(this.animateElements.focusMoveBg.scale, {
        x: 1.5,
        y: 1.5,
        z: 1.5,
        duration: 2.5,
        repeat: -1,
        ease: 'none',
      }),
      i = Sn.to(this.animateElements.focusMoveBg.material, {
        opacity: 0,
        duration: 2.5,
        repeat: -1,
        ease: 'none',
      })
    this.gsapObjects = [t, e, n, i]
  }
  pausedAnimate() {
    this.gsapObjects.map(t => {
      t.paused = !0
    })
  }
  destroy() {
    this.gsapObjects.map(t => {
      t.kill()
    }),
      va(this)
  }
}
var Mb =
  typeof globalThis < 'u'
    ? globalThis
    : typeof window < 'u'
    ? window
    : typeof global < 'u'
    ? global
    : typeof self < 'u'
    ? self
    : {}
function ZF(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, 'default')
    ? r.default
    : r
}
var KF = {
  exports: {},
}
;(function (r) {
  ;(function (t, e, n) {
    r.exports ? (r.exports = n()) : (e[t] = n())
  })('h337', Mb, function () {
    var t = {
        defaultRadius: 40,
        defaultRenderer: 'canvas2d',
        defaultGradient: {
          0.25: 'rgb(0,0,255)',
          0.55: 'rgb(0,255,0)',
          0.85: 'yellow',
          1: 'rgb(255,0,0)',
        },
        defaultMaxOpacity: 1,
        defaultMinOpacity: 0,
        defaultBlur: 0.85,
        defaultXField: 'x',
        defaultYField: 'y',
        defaultValueField: 'value',
        plugins: {},
      },
      e = (function () {
        var u = function (f) {
            ;(this._coordinator = {}),
              (this._data = []),
              (this._radi = []),
              (this._min = 10),
              (this._max = 1),
              (this._xField = f.xField || f.defaultXField),
              (this._yField = f.yField || f.defaultYField),
              (this._valueField = f.valueField || f.defaultValueField),
              f.radius && (this._cfgRadius = f.radius)
          },
          c = t.defaultRadius
        return (
          (u.prototype = {
            _organiseData: function (h, f) {
              var d = h[this._xField],
                p = h[this._yField],
                g = this._radi,
                v = this._data,
                m = this._max,
                y = this._min,
                _ = h[this._valueField] || 1,
                x = h.radius || this._cfgRadius || c
              v[d] || ((v[d] = []), (g[d] = [])),
                v[d][p] ? (v[d][p] += _) : ((v[d][p] = _), (g[d][p] = x))
              var A = v[d][p]
              return A > m
                ? (f ? this.setDataMax(A) : (this._max = A), !1)
                : A < y
                ? (f ? this.setDataMin(A) : (this._min = A), !1)
                : {
                    x: d,
                    y: p,
                    value: _,
                    radius: x,
                    min: y,
                    max: m,
                  }
            },
            _unOrganizeData: function () {
              var h = [],
                f = this._data,
                d = this._radi
              for (var p in f)
                for (var g in f[p])
                  h.push({
                    x: p,
                    y: g,
                    radius: d[p][g],
                    value: f[p][g],
                  })
              return {
                min: this._min,
                max: this._max,
                data: h,
              }
            },
            _onExtremaChange: function () {
              this._coordinator.emit('extremachange', {
                min: this._min,
                max: this._max,
              })
            },
            addData: function () {
              if (arguments[0].length > 0)
                for (var h = arguments[0], f = h.length; f--; )
                  this.addData.call(this, h[f])
              else {
                var d = this._organiseData(arguments[0], !0)
                d &&
                  (this._data.length === 0 && (this._min = this._max = d.value),
                  this._coordinator.emit('renderpartial', {
                    min: this._min,
                    max: this._max,
                    data: [d],
                  }))
              }
              return this
            },
            setData: function (h) {
              var f = h.data,
                d = f.length
              ;(this._data = []), (this._radi = [])
              for (var p = 0; p < d; p++) this._organiseData(f[p], !1)
              return (
                (this._max = h.max),
                (this._min = h.min || 0),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            removeData: function () {},
            setDataMax: function (h) {
              return (
                (this._max = h),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            setDataMin: function (h) {
              return (
                (this._min = h),
                this._onExtremaChange(),
                this._coordinator.emit('renderall', this._getInternalData()),
                this
              )
            },
            setCoordinator: function (h) {
              this._coordinator = h
            },
            _getInternalData: function () {
              return {
                max: this._max,
                min: this._min,
                data: this._data,
                radi: this._radi,
              }
            },
            getData: function () {
              return this._unOrganizeData()
            },
          }),
          u
        )
      })(),
      n = (function () {
        var u = function (d) {
            var p = d.gradient || d.defaultGradient,
              g = document.createElement('canvas'),
              v = g.getContext('2d')
            ;(g.width = 256), (g.height = 1)
            var m = v.createLinearGradient(0, 0, 256, 1)
            for (var y in p) m.addColorStop(y, p[y])
            return (
              (v.fillStyle = m),
              v.fillRect(0, 0, 256, 1),
              v.getImageData(0, 0, 256, 1).data
            )
          },
          c = function (d, p) {
            var g = document.createElement('canvas'),
              v = g.getContext('2d'),
              m = d,
              y = d
            if (((g.width = g.height = d * 2), p == 1))
              v.beginPath(),
                v.arc(m, y, d, 0, 2 * Math.PI, !1),
                (v.fillStyle = 'rgba(0,0,0,1)'),
                v.fill()
            else {
              var _ = v.createRadialGradient(m, y, d * p, m, y, d)
              _.addColorStop(0, 'rgba(0,0,0,1)'),
                _.addColorStop(1, 'rgba(0,0,0,0)'),
                (v.fillStyle = _),
                v.fillRect(0, 0, 2 * d, 2 * d)
            }
            return g
          },
          h = function (y) {
            for (
              var p = [],
                g = y.min,
                v = y.max,
                m = y.radi,
                y = y.data,
                _ = Object.keys(y),
                x = _.length;
              x--;

            )
              for (var A = _[x], S = Object.keys(y[A]), b = S.length; b--; ) {
                var T = S[b],
                  w = y[A][T],
                  M = m[A][T]
                p.push({
                  x: A,
                  y: T,
                  value: w,
                  radius: M,
                })
              }
            return {
              min: g,
              max: v,
              data: p,
            }
          }
        function f(d) {
          var p = d.container,
            g = (this.shadowCanvas = document.createElement('canvas')),
            v = (this.canvas = d.canvas || document.createElement('canvas'))
          this._renderBoundaries = [1e4, 1e4, 0, 0]
          var m = getComputedStyle(d.container) || {}
          ;(v.className = 'heatmap-canvas'),
            (this._width =
              v.width =
              g.width =
                d.width || +m.width.replace(/px/, '')),
            (this._height =
              v.height =
              g.height =
                d.height || +m.height.replace(/px/, '')),
            (this.shadowCtx = g.getContext('2d')),
            (this.ctx = v.getContext('2d')),
            (v.style.cssText = g.style.cssText =
              'position:absolute;left:0;top:0;'),
            (p.style.position = 'relative'),
            p.appendChild(v),
            (this._palette = u(d)),
            (this._templates = {}),
            this._setStyles(d)
        }
        return (
          (f.prototype = {
            renderPartial: function (d) {
              d.data.length > 0 && (this._drawAlpha(d), this._colorize())
            },
            renderAll: function (d) {
              this._clear(),
                d.data.length > 0 && (this._drawAlpha(h(d)), this._colorize())
            },
            _updateGradient: function (d) {
              this._palette = u(d)
            },
            updateConfig: function (d) {
              d.gradient && this._updateGradient(d), this._setStyles(d)
            },
            setDimensions: function (d, p) {
              ;(this._width = d),
                (this._height = p),
                (this.canvas.width = this.shadowCanvas.width = d),
                (this.canvas.height = this.shadowCanvas.height = p)
            },
            _clear: function () {
              this.shadowCtx.clearRect(0, 0, this._width, this._height),
                this.ctx.clearRect(0, 0, this._width, this._height)
            },
            _setStyles: function (d) {
              ;(this._blur = d.blur == 0 ? 0 : d.blur || d.defaultBlur),
                d.backgroundColor &&
                  (this.canvas.style.backgroundColor = d.backgroundColor),
                (this._width =
                  this.canvas.width =
                  this.shadowCanvas.width =
                    d.width || this._width),
                (this._height =
                  this.canvas.height =
                  this.shadowCanvas.height =
                    d.height || this._height),
                (this._opacity = (d.opacity || 0) * 255),
                (this._maxOpacity =
                  (d.maxOpacity || d.defaultMaxOpacity) * 255),
                (this._minOpacity =
                  (d.minOpacity || d.defaultMinOpacity) * 255),
                (this._useGradientOpacity = !!d.useGradientOpacity)
            },
            _drawAlpha: function (v) {
              for (
                var p = (this._min = v.min),
                  g = (this._max = v.max),
                  v = v.data || [],
                  m = v.length,
                  y = 1 - this._blur;
                m--;

              ) {
                var _ = v[m],
                  x = _.x,
                  A = _.y,
                  S = _.radius,
                  b = Math.min(_.value, g),
                  T = x - S,
                  w = A - S,
                  M = this.shadowCtx,
                  C
                this._templates[S]
                  ? (C = this._templates[S])
                  : (this._templates[S] = C = c(S, y))
                var E = (b - p) / (g - p)
                ;(M.globalAlpha = E < 0.01 ? 0.01 : E),
                  M.drawImage(C, T, w),
                  T < this._renderBoundaries[0] &&
                    (this._renderBoundaries[0] = T),
                  w < this._renderBoundaries[1] &&
                    (this._renderBoundaries[1] = w),
                  T + 2 * S > this._renderBoundaries[2] &&
                    (this._renderBoundaries[2] = T + 2 * S),
                  w + 2 * S > this._renderBoundaries[3] &&
                    (this._renderBoundaries[3] = w + 2 * S)
              }
            },
            _colorize: function () {
              var d = this._renderBoundaries[0],
                p = this._renderBoundaries[1],
                g = this._renderBoundaries[2] - d,
                v = this._renderBoundaries[3] - p,
                m = this._width,
                y = this._height,
                _ = this._opacity,
                x = this._maxOpacity,
                A = this._minOpacity,
                S = this._useGradientOpacity
              d < 0 && (d = 0),
                p < 0 && (p = 0),
                d + g > m && (g = m - d),
                p + v > y && (v = y - p)
              for (
                var b = this.shadowCtx.getImageData(d, p, g, v),
                  T = b.data,
                  w = T.length,
                  M = this._palette,
                  C = 3;
                C < w;
                C += 4
              ) {
                var E = T[C],
                  D = E * 4
                if (D) {
                  var P
                  _ > 0
                    ? (P = _)
                    : E < x
                    ? E < A
                      ? (P = A)
                      : (P = E)
                    : (P = x),
                    (T[C - 3] = M[D]),
                    (T[C - 2] = M[D + 1]),
                    (T[C - 1] = M[D + 2]),
                    (T[C] = S ? M[D + 3] : P)
                }
              }
              this.ctx.putImageData(b, d, p),
                (this._renderBoundaries = [1e3, 1e3, 0, 0])
            },
            getValueAt: function (d) {
              var p,
                g = this.shadowCtx,
                v = g.getImageData(d.x, d.y, 1, 1),
                m = v.data[3],
                y = this._max,
                _ = this._min
              return (p = (Math.abs(y - _) * (m / 255)) >> 0), p
            },
            getDataURL: function () {
              return this.canvas.toDataURL()
            },
          }),
          f
        )
      })(),
      i = (function () {
        var u = !1
        return t.defaultRenderer === 'canvas2d' && (u = n), u
      })(),
      a = {
        merge: function () {
          for (var l = {}, u = arguments.length, c = 0; c < u; c++) {
            var h = arguments[c]
            for (var f in h) l[f] = h[f]
          }
          return l
        },
      },
      o = (function () {
        var u = (function () {
            function d() {
              this.cStore = {}
            }
            return (
              (d.prototype = {
                on: function (p, g, v) {
                  var m = this.cStore
                  m[p] || (m[p] = []),
                    m[p].push(function (y) {
                      return g.call(v, y)
                    })
                },
                emit: function (p, g) {
                  var v = this.cStore
                  if (v[p])
                    for (var m = v[p].length, y = 0; y < m; y++) {
                      var _ = v[p][y]
                      _(g)
                    }
                },
              }),
              d
            )
          })(),
          c = function (f) {
            var d = f._renderer,
              p = f._coordinator,
              g = f._store
            p.on('renderpartial', d.renderPartial, d),
              p.on('renderall', d.renderAll, d),
              p.on('extremachange', function (v) {
                f._config.onExtremaChange &&
                  f._config.onExtremaChange({
                    min: v.min,
                    max: v.max,
                    gradient: f._config.gradient || f._config.defaultGradient,
                  })
              }),
              g.setCoordinator(p)
          }
        function h() {
          var f = (this._config = a.merge(t, arguments[0] || {}))
          if (((this._coordinator = new u()), f.plugin)) {
            var d = f.plugin
            if (t.plugins[d]) {
              var p = t.plugins[d]
              ;(this._renderer = new p.renderer(f)),
                (this._store = new p.store(f))
            } else
              throw new Error(
                "Plugin '" + d + "' not found. Maybe it was not registered.",
              )
          } else (this._renderer = new i(f)), (this._store = new e(f))
          c(this)
        }
        return (
          (h.prototype = {
            addData: function () {
              return this._store.addData.apply(this._store, arguments), this
            },
            removeData: function () {
              return (
                this._store.removeData &&
                  this._store.removeData.apply(this._store, arguments),
                this
              )
            },
            setData: function () {
              return this._store.setData.apply(this._store, arguments), this
            },
            setDataMax: function () {
              return this._store.setDataMax.apply(this._store, arguments), this
            },
            setDataMin: function () {
              return this._store.setDataMin.apply(this._store, arguments), this
            },
            configure: function (f) {
              return (
                (this._config = a.merge(this._config, f)),
                this._renderer.updateConfig(this._config),
                this._coordinator.emit(
                  'renderall',
                  this._store._getInternalData(),
                ),
                this
              )
            },
            repaint: function () {
              return (
                this._coordinator.emit(
                  'renderall',
                  this._store._getInternalData(),
                ),
                this
              )
            },
            getData: function () {
              return this._store.getData()
            },
            getDataURL: function () {
              return this._renderer.getDataURL()
            },
            getValueAt: function (f) {
              return this._store.getValueAt
                ? this._store.getValueAt(f)
                : this._renderer.getValueAt
                ? this._renderer.getValueAt(f)
                : null
            },
          }),
          h
        )
      })(),
      s = {
        create: function (l) {
          return new o(l)
        },
        register: function (l, u) {
          t.plugins[l] = u
        },
      }
    return s
  })
})(KF)
var xj = KF.exports
const Sj = ZF(xj)
class Aj extends Fe {
  constructor(t, e) {
    super(),
      (this.self = t),
      (this.config = Object.assign(
        {
          data: [],
          width: 10,
          height: 10,
          z: 1,
          renderOrder: 22,
          showDot: !1,
          radius: 70,
          pointsMaterial: new HM({
            size: 0.2,
            color: 16777215,
          }),
        },
        e,
      )),
      this.init()
  }
  init() {
    const e = this.config.width * 100,
      n = this.config.height * 100,
      i = [],
      a = this.config.data.map(p => {
        let [g, v] = this.self.geoProjection(p)
        return (
          i.push(g, -v, this.config.z),
          {
            value: p.value,
            x: Math.floor(g * 100 + e / 2),
            y: Math.floor(-v * 100 + n / 2),
          }
        )
      })
    let o = $q(a, p => p.value).value,
      s = Yq(a, p => p.value).value
    if (this.config.showDot) {
      const p = new Mn()
      p.setAttribute('position', new nn(i, 3))
      let g = new yB(p, this.config.pointsMaterial)
      g.rotateX(-Math.PI / 2), this.add(g)
    }
    let l = document.createElement('div')
    var u = Sj.create({
      container: l,
      radius: this.config.radius,
      width: e,
      height: n,
      alpha: !0,
    })
    u.setData({
      max: o,
      min: s,
      data: a,
    })
    let c = new Ti(e, n),
      h = new Yn(u._renderer.canvas)
    var f = new on({
      map: h,
      transparent: !0,
      depthWrite: !1,
      side: dr,
      fog: !1,
      wireframe: !1,
    })
    f.map.needsUpdate = !0
    let d = new De(c, f)
    ;(d.renderOrder = this.config.renderOrder),
      d.scale.set(1 / 100, 1 / 100, 1),
      d.position.set(0, this.config.z, 0),
      (d.rotation.x = Math.PI / 2),
      this.add(d)
  }
  destroy() {
    va(this)
  }
}
class bj {
  constructor(t, e) {
    ;(this.shader = null),
      (this.config = Object.assign(
        {
          uColor1: 2781042,
          uColor2: 860197,
          size: 15,
          dir: 'x',
        },
        e,
      )),
      this.init(t)
  }
  init(t) {
    let {uColor1: e, uColor2: n, dir: i, size: a} = this.config,
      o = {
        x: 1,
        y: 2,
        z: 3,
      }
    t.onBeforeCompile = s => {
      ;(this.shader = s),
        (s.uniforms = {
          ...s.uniforms,
          uColor1: {
            value: new qt(e),
          },
          uColor2: {
            value: new qt(n),
          },
          uDir: {
            value: o[i],
          },
          uSize: {
            value: a,
          },
        }),
        (s.vertexShader = s.vertexShader.replace(
          'void main() {',
          `
                attribute float alpha;
                varying vec3 vPosition;
                varying float vAlpha;
                void main() {
                  vAlpha = alpha;
                  vPosition = position;
              `,
        )),
        (s.fragmentShader = s.fragmentShader.replace(
          'void main() {',
          `
                varying vec3 vPosition;
                varying float vAlpha;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform float uDir;
                uniform float uSize;

                void main() {
              `,
        )),
        (s.fragmentShader = s.fragmentShader.replace(
          '#include <opaque_fragment>',
          `
              #ifdef OPAQUE
              diffuseColor.a = 1.0;
              #endif

              // https://github.com/mrdoob/three.js/pull/22425
              #ifdef USE_TRANSMISSION
              diffuseColor.a *= transmissionAlpha + 0.1;
              #endif
              // vec3 gradient = mix(uColor1, uColor2, vPosition.x / 15.0);
              vec3 gradient = vec3(0.0,0.0,0.0);
              if(uDir==1.0){
                gradient = mix(uColor1, uColor2, vPosition.x / uSize /2.0);
                // diffuseColor.a *= 1.0-vPosition.x/ uSize;
              }else if(uDir==2.0){
                gradient = mix(uColor1, uColor2, vPosition.z/ uSize/2.0);
                // diffuseColor.a *= 1.0-vPosition.z/ uSize;
              }else if(uDir==3.0){
                gradient = mix(uColor1, uColor2, vPosition.y/ uSize/2.0);
                // diffuseColor.a *= 1.0-vPosition.y/ uSize;
              }
              outgoingLight = outgoingLight * gradient;


              gl_FragColor = vec4( outgoingLight, diffuseColor.a  );
              `,
        ))
    }
  }
}
const wj = './assets/point-icon-47482592.svg',
  Mj = [
    {
      name: '杭州市',
      enName: 'hangzhou',
      value: 98,
      center: [120.153576, 30.287459],
      centroid: [119.476498, 29.898918],
    },
    {
      name: '宁波市',
      enName: 'ningbo',
      value: 57,
      center: [121.549792, 29.868388],
      centroid: [121.479174, 29.733017],
    },
    {
      name: '温州市',
      enName: 'wenzhou',
      value: 80,
      center: [120.672111, 28.000575],
      centroid: [120.463912, 27.894726],
    },
    {
      name: '嘉兴市',
      enName: 'jiaxing',
      value: 42,
      center: [120.750865, 30.762653],
      centroid: [120.783487, 30.620063],
    },
    {
      name: '湖州市',
      enName: 'huzhou',
      value: 37,
      center: [120.102398, 30.867198],
      centroid: [119.873663, 30.743058],
    },
    {
      name: '绍兴市',
      enName: 'shaoxing',
      value: 24,
      center: [120.582112, 29.997117],
      centroid: [120.640933, 29.732893],
    },
    {
      name: '金华市',
      enName: 'jinghua',
      value: 43,
      center: [119.649506, 29.089524],
      centroid: [119.957007, 29.115117],
    },
    {
      name: '衢州市',
      enName: 'hengzhou',
      value: 46,
      center: [118.87263, 28.941708],
      centroid: [118.679569, 28.932446],
    },
    {
      name: '舟山市',
      enName: 'zhousan',
      value: 37,
      center: [122.106863, 30.016028],
      centroid: [122.146805, 30.056563],
    },
    {
      name: '台州市',
      enName: 'taizhou',
      value: 36,
      center: [121.428599, 28.661378],
      centroid: [121.136679, 28.757098],
    },
    {
      name: '丽水市',
      enName: 'lishui',
      value: 48,
      center: [119.921786, 28.451993],
      centroid: [119.517145, 28.197644],
    },
  ],
  jF = [
    {
      name: '杭州市',
      enName: 'hangzhou',
      value: 45,
      center: [120.153576, 30.287459],
      centroid: [119.476498, 29.898918],
    },
    {
      name: '宁波市',
      enName: 'ningbo',
      value: 57,
      center: [121.549792, 29.868388],
      centroid: [121.479174, 29.733017],
    },
    {
      name: '温州市',
      enName: 'wenzhou',
      value: 80,
      center: [120.672111, 28.000575],
      centroid: [120.463912, 27.894726],
    },
    {
      name: '嘉兴市',
      enName: 'jiaxing',
      value: 42,
      center: [120.750865, 30.762653],
      centroid: [120.783487, 30.620063],
    },
    {
      name: '湖州市',
      enName: 'huzhou',
      value: 37,
      center: [120.102398, 30.867198],
      centroid: [119.873663, 30.743058],
    },
    {
      name: '绍兴市',
      enName: 'shaoxing',
      value: 24,
      center: [120.582112, 29.997117],
      centroid: [120.640933, 29.732893],
    },
    {
      name: '金华市',
      enName: 'jinghua',
      value: 99,
      center: [119.649506, 29.089524],
      centroid: [119.957007, 29.115117],
    },
    {
      name: '衢州市',
      enName: 'hengzhou',
      value: 46,
      center: [118.87263, 28.941708],
      centroid: [118.679569, 28.932446],
    },
    {
      name: '舟山市',
      enName: 'zhousan',
      value: 37,
      center: [122.106863, 30.016028],
      centroid: [122.146805, 30.056563],
    },
    {
      name: '台州市',
      enName: 'taizhou',
      value: 36,
      center: [121.428599, 28.661378],
      centroid: [121.136679, 28.757098],
    },
    {
      name: '丽水市',
      enName: 'lishui',
      value: 48,
      center: [119.921786, 28.451993],
      centroid: [119.517145, 28.197644],
    },
  ],
  Tj = [
    {
      value: 166,
      centroid: [119.24616103, 28.09020241],
    },
    {
      value: 120,
      centroid: [119.18042396, 28.70973428],
    },
    {
      value: 85,
      centroid: [119.18042396, 28.70973428],
    },
    {
      value: 110,
      centroid: [119.12407528, 29.84011268],
    },
    {
      value: 45,
      centroid: [119.73447116, 30.27089934],
    },
    {
      value: 88,
      centroid: [120.11010011, 30.5866928],
    },
    {
      value: 56,
      centroid: [120.87074922, 29.74231644],
    },
    {
      value: 24,
      centroid: [121.00221803, 28.92365701],
    },
    {
      value: 77,
      centroid: [120.70171529, 28.13161692],
    },
    {
      value: 33,
      centroid: [120.35426061, 27.5253857],
    },
    {
      value: 77,
      centroid: [119.55605201, 28.53663036],
    },
    {
      value: 23,
      centroid: [119.89411588, 29.30924506],
    },
    {
      value: 89,
      centroid: [120.58902752, 29.21913061],
    },
    {
      value: 145,
      centroid: [119.63117693, 28.75914002],
    },
  ]
var ST = {
  exports: {},
}
function AT() {}
AT.prototype = {
  on: function (r, t, e) {
    var n = this.e || (this.e = {})
    return (
      (n[r] || (n[r] = [])).push({
        fn: t,
        ctx: e,
      }),
      this
    )
  },
  once: function (r, t, e) {
    var n = this
    function i() {
      n.off(r, i), t.apply(e, arguments)
    }
    return (i._ = t), this.on(r, i, e)
  },
  emit: function (r) {
    var t = [].slice.call(arguments, 1),
      e = ((this.e || (this.e = {}))[r] || []).slice(),
      n = 0,
      i = e.length
    for (n; n < i; n++) e[n].fn.apply(e[n].ctx, t)
    return this
  },
  off: function (r, t) {
    var e = this.e || (this.e = {}),
      n = e[r],
      i = []
    if (n && t)
      for (var a = 0, o = n.length; a < o; a++)
        n[a].fn !== t && n[a].fn._ !== t && i.push(n[a])
    return i.length ? (e[r] = i) : delete e[r], this
  },
}
ST.exports = AT
ST.exports.TinyEmitter = AT
var Cj = ST.exports,
  Ej = Cj,
  Dj = new Ej()
const Cg = ZF(Dj),
  Ee = {
    $on: (...r) => Cg.on(...r),
    $once: (...r) => Cg.once(...r),
    $off: (...r) => Cg.off(...r),
    $emit: (...r) => Cg.emit(...r),
  }
function Lj(r) {
  return new Promise(t => setTimeout(t, r))
}
const Pj = d8()
function zx(r) {
  return r.sort((t, e) => e.value - t.value), r
}
class Rj extends PZ {
  constructor(t, e, n) {
    super(t),
      (this.debug = new GZ(n.debug)),
      (this.geoProjectionCenter = n.geoProjectionCenter || [
        120.109913, 29.181466,
      ]),
      (this.geoProjectionScale = n.geoProjectionScale || 90),
      (this.flyLineCenter = n.flyLineCenter || [120.20341805, 30.23969507]),
      (this.depth = n.depth),
      (this.scene.fog = new zM(0, 1, 50)),
      (this.scene.background = new qt(0)),
      this.camera.instance.position.set(
        -13.767695123014105,
        12.990152163077308,
        39.28228164159694,
      ),
      (this.camera.instance.near = 1),
      (this.camera.instance.far = 1e4),
      (this.camera.controls.enabled = !1),
      (this.interactionManager = new Wq(
        this.renderer.instance,
        this.camera.instance,
        this.canvas,
      )),
      (this.assets = e),
      this.initEnvironment(),
      this.init()
  }
  init() {
    ;(this.pointGroup = new un()),
      (this.pointGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.pointGroup),
      (this.trackGroup = new un()),
      (this.trackGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.trackGroup),
      (this.pathLabelGroup = new un()),
      (this.pathLabelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.pathLabelGroup),
      (this.labelGroup = new un()),
      (this.labelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.labelGroup),
      (this.barLabelGroup = new un()),
      (this.barLabelGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.barLabelGroup),
      (this.hotmapGroup = new un()),
      this.scene.add(this.hotmapGroup),
      (this.label3d = new $Z(this)),
      (this.label2d = new KZ(this)),
      (this.flyLineFocusGroup = new un()),
      (this.flyLineFocusGroup.visible = !0),
      (this.flyLineFocusGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.flyLineFocusGroup),
      (this.eventElement = []),
      (this.defaultMaterial = null),
      (this.defaultLightMaterial = null)
    const t = new un()
    ;(this.barGroup = t),
      this.scene.add(t),
      (this.allBar = []),
      (this.allBarMaterial = []),
      (this.allBarLabel = []),
      (this.allGuangquan = []),
      (this.flylineTexture = this.assets.instance.getResource('mapFlyline')),
      this.createBottomBg(),
      this.createRotateBorder(),
      this.createLabel(),
      this.createMap(),
      this.createDiffuse(),
      this.createFocus(),
      this.createScatter(),
      this.createStorke(),
      this.createEvent()
    let e = Sn.timeline({
      onComplete: () => {},
    })
    e.pause(),
      (this.animateTl = e),
      e.addLabel('focusMap', 1.5),
      e.addLabel('focusMapOpacity', 2),
      e.addLabel('bar', 3),
      e.to(this.camera.instance.position, {
        duration: 2,
        x: 0.0580965177019102,
        y: 8.801522187331752,
        z: 10.106973982833994,
        ease: 'circ.out',
        onComplete: () => {
          Ee.$emit('mapPlayComplete'), this.limitCamera()
        },
      })
  }
  limitCamera() {
    ;(this.camera.controls.enabled = !0),
      (this.camera.controls.maxPolarAngle = Math.PI / 2.2),
      (this.camera.controls.minDistance = 1),
      (this.camera.controls.maxDistance = 15)
  }
  initEnvironment() {
    let t = new PB(16777215, 5)
    this.scene.add(t)
    let e = new Ay(16777215, 5)
    e.position.set(-30, 6, -8),
      (e.castShadow = !0),
      (e.shadow.radius = 20),
      (e.shadow.mapSize.width = 1024),
      (e.shadow.mapSize.height = 1024),
      this.scene.add(e)
  }
  createMap() {
    let t = new un(),
      e = new un()
    this.focusMapGroup = e
    let {map: n, mapTop: i, mapLine: a, mapLineBlack: o} = this.createProvince()
    n.setParent(e),
      i.setParent(e),
      a.setParent(e),
      (this.mapLine = a),
      e.add(o),
      t.add(e),
      (t.rotation.x = -Math.PI / 2),
      t.position.set(0, 0.2, 0),
      this.scene.add(t)
  }
  createProvince() {
    let t = this.assets.instance.getResource('mapJson'),
      e = this.assets.instance.getResource('face')
    if (
      ((e.colorSpace = cn),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(0.732, 0.732),
      e.offset.set(0.137, 1.081),
      this.debug.active)
    ) {
      const f = this.debug.instance.addFolder('face')
      let d = {
        scale: 0.732,
        x: 0.137,
        y: 1.081,
      }
      f.add(d, 'scale', 0, 1, 0.001).onChange(p => {
        let g = Number(p)
        e.repeat.set(g, g)
      }),
        f.add(e.offset, 'x', 0, 2, 0.001),
        f.add(e.offset, 'y', 0, 2, 0.001)
    }
    let [n, i] = this.createProvinceMaterial()
    ;(this.focusMapTopMaterial = n), (this.focusMapSideMaterial = i)
    let a = new tK(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, 0.11),
        data: t,
        depth: this.depth,
        topFaceMaterial: n,
        sideMaterial: i,
        renderOrder: 9,
      }),
      o = new on({
        color: 16777215,
        map: e,
        transparent: !0,
        opacity: 1,
        fog: !1,
      })
    ;(this.defaultMaterial = o),
      (this.defaultLightMaterial = this.defaultMaterial.clone()),
      (this.defaultLightMaterial.opacity = 0.95)
    let s = new QZ(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, this.depth + 0.22),
        data: t,
        material: o,
        renderOrder: 2,
      }),
      {boxSize: l, box3: u} = PD(s.mapGroup)
    s.mapGroup.children.map(f => {
      f.children.map(d => {
        this.eventElement.push(d),
          this.calcUv(d.geometry, l.x, l.y, u.min.x, u.min.y)
      })
    }),
      (this.mapLineMaterial = new dv({
        color: 16777215,
        opacity: 1,
        transparent: !0,
        fog: !1,
      }))
    let c = new Dx(this, {
      geoProjectionCenter: this.geoProjectionCenter,
      geoProjectionScale: this.geoProjectionScale,
      data: t,
      material: this.mapLineMaterial,
      type: 'Line3',
      tubeRadius: 0.02,
      renderOrder: 3,
    })
    c.lineGroup.position.z += this.depth + 0.23
    let h = c.lineGroup.clone()
    return (
      h.scale.set(1, 1, 0.1),
      (h.position.x += 0.01),
      (h.position.y -= -0.01),
      h.traverse(f => {
        f.isMesh &&
          ((f.material = f.material.clone()),
          (f.material.color = new qt(0)),
          (f.material.opacity = 1))
      }),
      {
        map: a,
        mapTop: s,
        mapLine: c,
        mapLineBlack: h,
      }
    )
  }
  calcUv(t, e, n, i, a) {
    const o = t.attributes.position,
      s = t.attributes.uv
    for (let l = 0; l < o.count; l++) {
      const u = o.getX(l),
        c = o.getY(l),
        h = (u - i) / e,
        f = (c - a) / n
      s.setXY(l, h, f)
    }
    ;(s.needsUpdate = !0), t.computeVertexNormals()
  }
  createProvinceMaterial() {
    let t = new CB({
        color: 16777215,
        transparent: !0,
        opacity: 1,
        fog: !1,
        side: dr,
      }),
      e = this.assets.instance.getResource('side')
    ;(e.flipY = !1),
      (e.colorSpace = cn),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(1, 1.8)
    let n = new Th({
      color: 16777215,
      map: e,
      fog: !1,
      opacity: 1,
      side: dr,
    })
    return [t, n]
  }
  createBar(t) {
    let e = this,
      n = zx(jF)
    t && (n = zx(t))
    const i = this.barGroup,
      a = 0.7,
      o = 3 * a,
      s = n[0].value
    n.map((u, c) => {
      let h = o * (u.value / s),
        f = new Th({
          color: 16777215,
          transparent: !0,
          opacity: 0,
          depthTest: !1,
          fog: !1,
        })
      new bj(f, {
        uColor1: c > 0 ? 5291006 : 16506760,
        uColor2: 16776948,
        size: h,
        dir: 'z',
      })
      let d = 0.08 * a
      const p = new $M(d, d, h)
      p.translate(0, h / 2, 0)
      const g = new De(p, f)
      ;(g.castShadow = !0),
        (g.rotation.x = Math.PI / 2),
        (g.renderOrder = 5),
        (g.name = u.name + '-bar')
      let v = g,
        [m, y] = this.geoProjection(u.centroid)
      v.position.set(m, -y, this.depth + 0.45), v.scale.set(1, 0, 1)
      let _ = new JZ(this, {
        size: 1.5,
        color: c > 0 ? 5291006 : 16506760,
      })
      ;(_.renderOrder = 8888),
        _.position.set(m, -y, this.depth + 0.45),
        _.traverse(A => {
          ;(A.renderOrder = 999999), (A.rotation.x = Math.PI / 2)
        }),
        this.barGroup.add(_),
        i.add(v),
        (i.rotation.x = -Math.PI / 2)
      let x = l(u, c, new U(m, -y, this.depth + 0.8 + h))
      this.allBar.push(v),
        this.allBarMaterial.push(f),
        this.allBarLabel.push(x),
        this.allGuangquan.push(_)
    })
    function l(u, c, h) {
      let f = e.label2d.create('', 'bar-label', !1)
      return (
        (f.name = u.name + '-barLabel'),
        f.init(
          `<div class="bar-label-wrap ${c === 0 ? 'cyan' : ''}" >
        <div class="bar-label-icon"><img src="${wj}"></div>
          <div class="bar-label-number">
            ${u.value}<span class="unit">次</span>
          </div>
        </div>`,
          h,
        ),
        f.setParent(e.labelGroup),
        f.element
          .querySelector('.bar-label-wrap')
          .addEventListener('click', d => {
            d.stopPropagation(), Ee.$emit('barLabelClick', u)
          }),
        f
      )
    }
    this.barAnimate()
  }
  clearBar() {
    this.allBarLabel.map(t => {
      t.parent.remove(t)
    }),
      va(this.barGroup),
      (this.allBar = []),
      (this.allBarMaterial = []),
      (this.allBarLabel = [])
  }
  async barAnimate() {
    await Lj(500),
      this.allBar.map((t, e) => {
        Sn.to(t.scale, {
          duration: 1,
          delay: 0.1 * e,
          x: 1,
          y: 1,
          z: 1,
          ease: 'circ.out',
        })
      }),
      this.allBarMaterial.map((t, e) => {
        Sn.to(t, {
          duration: 1,
          delay: 0.1 * e,
          opacity: 1,
          ease: 'circ.out',
        })
      }),
      this.allBarLabel.map((t, e) => {
        let n = t.element.querySelector('.bar-label-wrap')
        Sn.to(n, {
          duration: 1,
          delay: 0.2 * e,
          translateY: 0,
          opacity: 1,
          ease: 'circ.out',
        })
      })
  }
  createEvent() {
    let t = []
    const e = i => {
        i.traverse(a => {
          a.isMesh && (a.material = this.defaultMaterial)
        })
      },
      n = i => {
        i.traverse(a => {
          a.isMesh && (a.material = this.defaultLightMaterial)
        })
      }
    this.eventElement.map(i => {
      this.interactionManager.add(i),
        i.addEventListener('mousedown', a => {
          console.log(a.target.userData.name)
        }),
        i.addEventListener('mouseover', a => {
          t.includes(a.target.parent) || t.push(a.target.parent),
            (document.body.style.cursor = 'pointer'),
            n(a.target.parent)
        }),
        i.addEventListener('mouseout', a => {
          ;(t = t.filter(
            o => o.userData.name !== a.target.parent.userData.name,
          )),
            t.length > 0 && t[t.length - 1],
            e(a.target.parent),
            (document.body.style.cursor = 'default')
        })
    })
  }
  createDiffuse() {
    let t = this.assets.instance.getResource('diffuse')
    ;(t.colorSpace = cn), (t.wrapS = t.wrapT = Jn)
    let e = new Ti(15, 15),
      n = new on({
        color: 11584,
        map: t,
        transparent: !0,
        opacity: 1,
        fog: !0,
        blending: $r,
      }),
      i = new De(e, n)
    ;(i.renderOrder = 3),
      (i.rotation.x = -Math.PI / 2),
      i.scale.set(0, 0, 0),
      i.position.set(0, 0.21, 0),
      this.scene.add(i),
      (i._s = 0),
      this.time.on('tick', (a, o) => {
        ;(i._s += 0.01),
          i.scale.setScalar(i._s),
          i._s >= 1
            ? (i.material.opacity = 1 - (i._s - 1))
            : (i.material.opacity = 1),
          i._s >= 5 && (i._s = 0)
      })
  }
  createBottomBg() {
    let t = new Ti(15.3, 9.59)
    const e = this.assets.instance.getResource('bg')
    ;(e.colorSpace = cn),
      (e.anisotropy = 8),
      (e.wrapS = Jn),
      (e.wrapT = Jn),
      e.repeat.set(1, 1)
    let n = new on({
        map: e,
        opacity: 1,
        fog: !1,
      }),
      i = new De(t, n)
    if (
      ((i.rotation.x = -Math.PI / 2),
      i.position.set(0.51, -0.01, 0),
      i.scale.setScalar(1.46),
      this.scene.add(i),
      this.debug.active)
    ) {
      const a = this.debug.instance.addFolder('bg')
      a.add(i.position, 'x', -10, 10, 0.01),
        a.add(i.position, 'y', -10, 10, 0.01),
        a.add(i.position, 'z', -10, 10, 0.01)
      let o = {
        scale: 1,
      }
      a.add(o, 'scale', 1, 10, 0.01).onChange(s => {
        let l = Number(s)
        i.scale.setScalar(l)
      })
    }
  }
  createLabel() {
    let t = this,
      e = this.labelGroup,
      n = this.label2d
    Mj.map(a => {
      i(a, n, e)
    })
    function i(a, o, s) {
      let l = o.create('', 'province-label', !0)
      l.name = a.name + '-provinceLabel'
      const [u, c] = t.geoProjection(a.center)
      return (
        l.init(
          `<div class="name">${a.name}</div>`,
          new U(u, -c, t.depth * 2 + 0.1),
        ),
        l.setParent(s),
        l
      )
    }
  }
  createCircleQuan({
    width: t,
    speed: e,
    material: n,
    renderOrder: i,
    position: a = new U(0, -0.005, 0),
  }) {
    let o = new jZ(this, {
      width: t,
      needRotate: !0,
      rotateSpeed: e,
      material: n,
      position: a,
    })
    return (
      (o.instance.rotation.x = -Math.PI / 2),
      (o.instance.renderOrder = i),
      o.instance.scale.set(1, 1, 1),
      o.setParent(this.scene),
      o.instance
    )
  }
  createRotateBorder() {
    let t = this.assets.instance.getResource('quan1'),
      e = this.assets.instance.getResource('quan2'),
      n = this.assets.instance.getResource('quan3'),
      i = this.assets.instance.getResource('quan4')
    t.colorSpace = e.colorSpace = n.colorSpace = i.colorSpace = cn
    let a = new on({
        map: t,
        color: 54527,
        transparent: !0,
        opacity: 0.3,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      o = new on({
        map: e,
        transparent: !0,
        opacity: 0.8,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      s = new on({
        map: n,
        transparent: !0,
        depthWrite: !1,
        opacity: 0,
        fog: !1,
        blending: $r,
      }),
      l = new on({
        color: 5425407,
        map: i,
        transparent: !0,
        opacity: 0.02,
        depthWrite: !1,
        fog: !1,
        blending: $r,
      }),
      u = this.createCircleQuan({
        width: 11,
        speed: -0.004,
        material: a,
        renderOrder: 2,
      }),
      c = this.createCircleQuan({
        width: 10,
        speed: 0.005,
        material: o,
        renderOrder: 2,
      })
    this.createCircleQuan({
      width: 7,
      speed: 0.005,
      material: s,
      renderOrder: 2,
    }),
      this.createCircleQuan({
        width: 9,
        speed: 0.005,
        material: l,
        renderOrder: 2,
      }),
      (this.rotateBorder1 = u),
      (this.rotateBorder2 = c)
  }
  createFlyLine(t, e) {
    ;(this.flyLineGroup = new un()), this.scene.add(this.flyLineGroup)
    const n = this.flylineTexture
    ;(n.wrapS = n.wrapT = Jn), (n.colorSpace = cn), n.repeat.set(0.5, 2)
    const i = 0.02,
      a = 32,
      o = 8,
      s = !1
    let [l, u] = this.geoProjection(t.centroid),
      c = new U(l, -u, 0)
    const h = new Th({
        map: n,
        transparent: !0,
        fog: !1,
        opacity: 1,
        depthTest: !1,
        emissiveIntensity: 2,
        blending: $r,
      }),
      f = new on({
        color: 63477,
        transparent: !0,
        fog: !1,
        opacity: 0.05,
        depthTest: !1,
        blending: $r,
      })
    e.map((d, p) => {
      let [g, v] = this.geoProjection(d.centroid),
        m = new U(g, -v, 0)
      const y = new U()
      y.addVectors(c, m).multiplyScalar(0.5), y.setZ(1.5)
      const _ = new YM(c, y, m),
        x = new bp(_, a, 0.08, 2, s),
        A = new bp(_, a, i, o, s),
        S = new De(x, h),
        b = new De(A, f)
      ;(S.name = 'flylineMesh1-' + p),
        (S.rotation.x = -Math.PI / 2),
        S.position.set(0, this.depth + 0.44, 0),
        (S.renderOrder = 21),
        (b.name = 'flylineMesh2-' + p),
        (b.rotation.x = -Math.PI / 2),
        b.position.set(0, this.depth + 0.44, 0),
        (b.renderOrder = 20),
        this.flyLineGroup.add(S, b)
    })
  }
  clearFlyLine() {
    va(this.flyLineGroup)
  }
  createFocus() {
    let t = new _j(this, {
        color1: 12451325,
        color2: 12451325,
      }),
      [e, n] = this.geoProjection(this.flyLineCenter)
    t.position.set(e, -n, this.depth + 0.44),
      t.scale.set(1, 1, 1),
      this.flyLineFocusGroup.add(t)
  }
  destroyFlyFocus() {
    va(this.flyLineGroup), va(this.flyLineFocusGroup)
  }
  createScatter() {
    ;(this.scatterGroup = new un()),
      (this.scatterGroup.rotation.x = -Math.PI / 2),
      this.scene.add(this.scatterGroup)
    const t = this.assets.instance.getResource('arrow'),
      e = new fB({
        map: t,
        color: 16776948,
        fog: !1,
        transparent: !0,
        depthTest: !1,
      })
    let n = zx(Tj),
      i = n[0].value
    n.map(a => {
      const o = new UY(e)
      o.renderOrder = 23
      let s = 0.1 + (a.value / i) * 0.2
      o.scale.set(s, s, s)
      let [l, u] = this.geoProjection(a.centroid)
      o.position.set(l, -u, this.depth + 0.45),
        (o.userData.position = [l, -u, this.depth + 0.45]),
        this.scatterGroup.add(o)
    })
  }
  createStorke() {
    const t = this.assets.instance.getResource('mapStroke'),
      e = this.assets.instance.getResource('pathLine3')
    ;(e.wrapS = e.wrapT = Jn), e.repeat.set(2, 1)
    let n = new Dx(this, {
      geoProjectionCenter: this.geoProjectionCenter,
      geoProjectionScale: this.geoProjectionScale,
      position: new U(0, 0, 0),
      data: t,
      material: new on({
        color: 2868444,
        map: e,
        alphaMap: e,
        fog: !1,
        transparent: !0,
        opacity: 1,
        blending: $r,
      }),
      type: 'Line3',
      renderOrder: 22,
      tubeRadius: 0.03,
    })
    this.focusMapGroup.add(n.lineGroup),
      this.time.on('tick', () => {
        e.offset.x += 0.005
      })
  }
  createPoint(t) {
    let e = this.label2d,
      n = this.pointGroup,
      i = this
    t.map(o => {
      let s = a(o)
      s.element.addEventListener('click', () => {
        Pj(s.userData.name)
      })
    })
    function a(o) {
      let s = e.create('', 'map-label-point')
      const [l, u] = i.geoProjection(o.centroid)
      return (
        s.init(
          `<div class="map-label-point-style ${o.level === '差' ? 'red' : ''}">
          <div class="map-label-point-style-name"> ${o.name} </div>
          <div class="map-label-point-style-icon"> </div>
          <div class="map-label-point-style-icon-arrow"> </div>
        </div>`,
          new U(l, -u, i.depth + 0.4),
        ),
        (s.userData = o),
        e.setLabelStyle(s, 'auto'),
        s.setParent(n),
        s
      )
    }
  }
  destroyPoint() {
    va(this.pointGroup)
  }
  createPath(t) {
    const e = this.assets.instance.getResource('pathLine').clone()
    ;(e.wrapS = e.wrapT = Jn), e.repeat.set(6, 1)
    let i = `{
      "features": [
        {
            "properties": { "_draw_type": "line" },
            "geometry": {
              "type": "LineString",
              "coordinates": ${JSON.stringify(t.coordinates)}
            }
        }
      ]
    }`,
      a = new Dx(this, {
        geoProjectionCenter: this.geoProjectionCenter,
        geoProjectionScale: this.geoProjectionScale,
        position: new U(0, 0, this.depth * 2 + 0.1),
        data: i,
        material: new on({
          map: e,
          fog: !1,
          transparent: !0,
          opacity: 1,
          depthTest: !1,
          blending: $r,
        }),
        type: 'Line3',
        renderOrder: 99,
        tubeRadius: 0.03,
      })
    a.lineGroup.scale.set(1, 1, 1),
      this.trackGroup.add(a.lineGroup),
      this.time.on('tick', () => {
        e.offset.x -= 0.05
      }),
      this.createPathPointEvent(t.startPoint),
      this.createPathPointEvent(t.endPoint)
  }
  createPathPointEvent(t) {
    let [e, n] = this.geoProjection(t.position),
      i = this.label2d.create('', 'path-point-label'),
      a =
        t.type === 'start'
          ? 'path-point-label-icon-start'
          : 'path-point-label-icon-end'
    i.init(
      `
      <div class="path-point-label-wrap">
        <div class="path-point-label-icon ${a}"></div>
        <div class="path-point-label-info">
          <div class="name">${t.name}</div>
          <div class="thumb">
          <img src="../assets/huoche.jpg" />
          </div>
          <div class="info">
            <div class="info-item">载重：${t.weight} 吨</div>
            <div class="info-item">车厢：${t.trainCarriageNum} 节</div>
            <div class="info-item">人员：${t.staffNum}人</div>
            <div class="info-item">货物：${t.goods}</div>
            <div class="info-item">承运：${t.carrierCompany}</div>
          </div>
        </div>
      </div>
      `,
      new U(e, -n, this.depth * 2 + 0.2),
    ),
      i.setParent(this.pathLabelGroup),
      i.element
        .querySelector('.path-point-label-icon')
        .addEventListener('click', () => {
          i.element
            .querySelector('.path-point-label-info')
            .classList.toggle('show'),
            document.querySelectorAll('.path-point-label-info').forEach(o => {
              o !== i.element.querySelector('.path-point-label-info') &&
                o.classList.remove('show')
            })
        })
  }
  destroyPath() {
    va(this.trackGroup), va(this.pathLabelGroup)
  }
  createHeatmap() {
    const t = this.assets.instance.getResource('hotmapData')
    let e = JSON.parse(t)
    e = e.features.map(a => a.geometry.coordinates || [])
    let {boxSize: n} = PD(this.focusMapGroup),
      i = new Aj(this, {
        data: e,
        width: n.x,
        height: n.z,
        z: this.depth * 2 + 0.2,
      })
    this.hotmapGroup.add(i)
  }
  destroyHeatmap() {
    va(this.hotmapGroup)
  }
  geoProjection(t) {
    return V0()
      .center(this.geoProjectionCenter)
      .scale(this.geoProjectionScale)
      .translate([0, 0])(t)
  }
  update(t) {
    super.update(t),
      this.interactionManager && this.interactionManager.update(),
      this.allGuangquan.length &&
        this.allGuangquan.map(e => {
          e.update(t)
        }),
      this.flylineTexture && (this.flylineTexture.offset.x -= 0.006)
  }
  destroy() {
    super.destroy(), this.label3d && this.label3d.destroy()
  }
}
const Ij = [
  {
    name: '杭州市',
    enName: 'hangzhou',
    value: 45,
    center: [120.153576, 30.287459],
    centroid: [119.476498, 29.898918],
  },
  {
    name: '宁波市',
    enName: 'ningbo',
    value: 57,
    center: [121.549792, 29.868388],
    centroid: [121.479174, 29.733017],
  },
  {
    name: '温州市',
    enName: 'wenzhou',
    value: 80,
    center: [120.672111, 28.000575],
    centroid: [120.463912, 27.894726],
  },
  {
    name: '嘉兴市',
    enName: 'jiaxing',
    value: 42,
    center: [120.750865, 30.762653],
    centroid: [120.783487, 30.620063],
  },
  {
    name: '湖州市',
    enName: 'huzhou',
    value: 37,
    center: [120.102398, 30.867198],
    centroid: [119.873663, 30.743058],
  },
  {
    name: '绍兴市',
    enName: 'shaoxing',
    value: 24,
    center: [120.582112, 29.997117],
    centroid: [120.640933, 29.732893],
  },
  {
    name: '金华市',
    enName: 'jinghua',
    value: 99,
    center: [119.649506, 29.089524],
    centroid: [119.957007, 29.115117],
  },
  {
    name: '衢州市',
    enName: 'hengzhou',
    value: 46,
    center: [118.87263, 28.941708],
    centroid: [118.679569, 28.932446],
  },
  {
    name: '舟山市',
    enName: 'zhousan',
    value: 37,
    center: [122.106863, 30.016028],
    centroid: [122.146805, 30.056563],
  },
  {
    name: '台州市',
    enName: 'taizhou',
    value: 36,
    center: [121.428599, 28.661378],
    centroid: [121.136679, 28.757098],
  },
  {
    name: '丽水市',
    enName: 'lishui',
    value: 48,
    center: [119.921786, 28.451993],
    centroid: [119.517145, 28.197644],
  },
]
const Oj = {
    class: 'map',
  },
  Nj = {
    __name: 'map',
    setup(r, {expose: t}) {
      function e(y) {
        return y.sort((_, x) => x.value - _.value), y
      }
      const n = hh(null),
        i = [120.20341805, 30.23969507]
      Ea(() => {
        Ee.$on('loadMap', a),
          Ee.$on('mapPlayComplete', s),
          Ee.$on('createBar', l),
          Ee.$on('destroyBar', u),
          Ee.$on('createPoint', c),
          Ee.$on('destroyPoint', h),
          Ee.$on('createSituation', f),
          Ee.$on('destroySituation', d),
          Ee.$on('createPath', p),
          Ee.$on('destroyPath', g),
          Ee.$on('createHeatmap', v),
          Ee.$on('destroyHeatmap', m)
      }),
        Da(() => {
          n.value && n.value.destroy(),
            Ee.$off('loadMap', a),
            Ee.$off('createBar', l),
            Ee.$off('destroyBar', u),
            Ee.$off('createPoint', c),
            Ee.$off('destroyPoint', h),
            Ee.$off('createSituation', f),
            Ee.$off('destroySituation', d),
            Ee.$off('createPath', p),
            Ee.$off('destroyPath', g),
            Ee.$off('destroyHeatmap', m)
        })
      function a(y) {
        ;(n.value = new Rj(document.getElementById('canvasMap'), y, {
          geoProjectionCenter: [120.109913, 29.181466],
          geoProjectionScale: 90,
          flyLineCenter: i,
          depth: 0.3,
          debug: !1,
        })),
          n.value.time.pause()
      }
      async function o() {
        n.value &&
          (n.value.time.resume(),
          n.value.animateTl.timeScale(1),
          n.value.animateTl.play())
      }
      function s() {
        let y = e(Ij).filter((_, x) => x < 7)
        n.value.createBar(y),
          n.value.createFlyLine(
            {
              centroid: i,
            },
            y,
          )
      }
      function l(y) {
        n.value && n.value.createBar(y)
      }
      function u() {
        n.value && n.value.clearBar()
      }
      function c(y) {
        n.value && n.value.createPoint(y)
      }
      function h() {
        n.value && n.value.destroyPoint()
      }
      function f(y) {
        n.value && n.value.createSituation(y)
      }
      function d() {
        n.value && n.value.destroySituation()
      }
      function p(y) {
        n.value && n.value.createPath(y)
      }
      function g() {
        n.value && n.value.destroyPath()
      }
      function v() {
        n.value && n.value.createHeatmap()
      }
      function m() {
        n.value && n.value.destroyHeatmap()
      }
      return (
        t({
          loadMap: a,
          play: o,
          canvasMap: n,
        }),
        (y, _) => (
          en(),
          sn(
            'div',
            Oj,
            _[0] ||
              (_[0] = [
                wt(
                  'canvas',
                  {
                    id: 'canvasMap',
                  },
                  null,
                  -1,
                ),
              ]),
          )
        )
      )
    },
  }
const X0 = (r, t) => {
    const e = r.__vccOpts || r
    for (const [n, i] of t) e[n] = i
    return e
  },
  kj = {
    name: 'SvglineAnimation',
    props: {
      width: {
        type: Number,
        default: 135,
      },
      height: {
        type: Number,
        default: 150,
      },
      path: {
        type: String,
        default: 'M0 72.5H682L732 0.5H3082',
      },
      color: {
        type: String,
        default: '#0091FF',
      },
      duration: {
        type: Number,
        default: 3,
      },
      length: {
        type: Number,
        default: 100,
      },
      begin: {
        type: Number,
        default: 0,
      },
      dir: {
        type: Array,
        default: () => [0, 1],
      },
      strokeWidth: {
        type: Number,
        default: 4,
      },
    },
    data() {
      let r = 1
      return {
        maskId: 'svgline-' + r,
        radialGradientId: 'radialGradient-' + r,
      }
    },
    mounted() {
      let r = this._.uid
      ;(this.maskId = 'svgline-' + r),
        (this.radialGradientId = 'radialGradient-' + r)
    },
  },
  Bj = {
    class: 'svg-line-animation',
  },
  Fj = ['viewBox'],
  zj = ['id'],
  Uj = ['stop-opacity'],
  Vj = ['stop-opacity'],
  Gj = ['id'],
  Hj = ['r', 'fill'],
  Wj = ['begin', 'dur', 'path', 'keyPoints'],
  Xj = ['d', 'stroke', 'stroke-width', 'mask']
function Yj(r, t, e, n, i, a) {
  return (
    en(),
    sn('div', Bj, [
      (en(),
      sn(
        'svg',
        {
          width: '100%',
          height: '100%',
          viewBox: `0 0 ${e.width} ${e.height}`,
          fill: 'none',
          xmlns: 'http://www.w3.org/2000/svg',
        },
        [
          wt('defs', null, [
            wt(
              'radialGradient',
              {
                id: i.radialGradientId,
                cx: '50%',
                cy: '50%',
                fx: '100%',
                fy: '50%',
                r: '50%',
              },
              [
                wt(
                  'stop',
                  {
                    offset: '0%',
                    'stop-color': '#fff',
                    'stop-opacity': e.dir[1],
                  },
                  null,
                  8,
                  Uj,
                ),
                wt(
                  'stop',
                  {
                    offset: '100%',
                    'stop-color': '#fff',
                    'stop-opacity': e.dir[0],
                  },
                  null,
                  8,
                  Vj,
                ),
              ],
              8,
              zj,
            ),
            wt(
              'mask',
              {
                id: i.maskId,
              },
              [
                wt(
                  'circle',
                  {
                    r: e.length,
                    cx: '0',
                    cy: '0',
                    fill: `url(#${i.radialGradientId})`,
                  },
                  [
                    wt(
                      'animateMotion',
                      {
                        begin: `${e.begin}s`,
                        dur: `${e.duration}s`,
                        path: e.path,
                        rotate: 'auto',
                        keyPoints: `${e.dir[0]};${e.dir[1]}`,
                        keyTimes: '0;1',
                        repeatCount: 'indefinite',
                      },
                      null,
                      8,
                      Wj,
                    ),
                  ],
                  8,
                  Hj,
                ),
              ],
              8,
              Gj,
            ),
          ]),
          wt(
            'path',
            {
              class: 'path-line',
              d: e.path,
              stroke: e.color,
              'stroke-width': e.strokeWidth,
              mask: `url(#${i.maskId})`,
            },
            null,
            8,
            Xj,
          ),
        ],
        8,
        Fj,
      )),
    ])
  )
}
const Oy = X0(kj, [['render', Yj]])
const $j = {
    class: 'm-header',
  },
  qj = {
    class: 'm-header-wrap',
  },
  Zj = {
    class: 'm-header-title',
  },
  Kj = {
    class: 'm-header-subtext',
  },
  jj = {
    class: 'm-header-left',
    style: {
      color: '#fff',
    },
  },
  Jj = {
    class: 'm-header-right',
  },
  Qj = {
    class: 'm-header-line',
  },
  tJ = {
    __name: 'index',
    props: {
      title: {
        type: String,
        default: '数据可视化大屏',
      },
      subText: {
        type: String,
        default: 'Visualization Platform',
      },
    },
    setup(r) {
      return (t, e) => (
        en(),
        sn('div', $j, [
          wt('div', qj, [
            wt('div', Zj, Si(r.title), 1),
            wt('div', Kj, Si(r.subText), 1),
          ]),
          wt('div', jj, [Bh(t.$slots, 'left')]),
          wt('div', Jj, [Bh(t.$slots, 'right')]),
          wt('div', Qj, [
            ye(Oy, {
              class: 'm-header-line-left',
              width: 961,
              height: 79,
              color: '#30DCFF',
              strokeWidth: 2,
              dir: [0, 1],
              length: 100,
              path: 'M1 1.52783L535 25.6808C552.73 26.5835 571.454 31.3851 588.834 39.2194C593.758 41.4385 598.692 43.7289 603.643 46.0273C633.567 59.9182 664.121 74.1016 696.754 74.6262C696.765 74.6264 696.775 74.6265 696.786 74.6267C821.602 76.5993 879.336 78 961 78',
            }),
            ye(Oy, {
              class: 'm-header-line-right',
              width: 961,
              height: 79,
              color: '#30DCFF',
              strokeWidth: 2,
              dir: [0, 1],
              length: 100,
              path: 'M1 1.52783L535 25.6808C552.73 26.5835 571.454 31.3851 588.834 39.2194C593.758 41.4385 598.692 43.7289 603.643 46.0273C633.567 59.9182 664.121 74.1016 696.754 74.6262C696.765 74.6264 696.775 74.6265 696.786 74.6267C821.602 76.5993 879.336 78 961 78',
            }),
          ]),
        ])
      )
    },
  }
let wL = 0
const ML = 'webkit moz ms o'.split(' ')
let Xa, Ya
const eJ = typeof window > 'u'
if (eJ) (Xa = function () {}), (Ya = function () {})
else {
  ;(Xa = window.requestAnimationFrame), (Ya = window.cancelAnimationFrame)
  let r
  for (let t = 0; t < ML.length && !(Xa && Ya); t++)
    (r = ML[t]),
      (Xa = Xa || window[r + 'RequestAnimationFrame']),
      (Ya =
        Ya ||
        window[r + 'CancelAnimationFrame'] ||
        window[r + 'CancelRequestAnimationFrame'])
  ;(!Xa || !Ya) &&
    ((Xa = function (t) {
      const e = new Date().getTime(),
        n = Math.max(0, 16 - (e - wL)),
        i = window.setTimeout(() => {
          t(e + n)
        }, n)
      return (wL = e + n), i
    }),
    (Ya = function (t) {
      window.clearTimeout(t)
    }))
}
const nJ = {
  props: {
    startVal: {
      type: Number,
      required: !1,
      default: 0,
    },
    endVal: {
      type: Number,
      required: !1,
      default: 2017,
    },
    duration: {
      type: Number,
      required: !1,
      default: 3e3,
    },
    autoplay: {
      type: Boolean,
      required: !1,
      default: !0,
    },
    decimals: {
      type: Number,
      required: !1,
      default: 0,
      validator(r) {
        return r >= 0
      },
    },
    decimal: {
      type: String,
      required: !1,
      default: '.',
    },
    separator: {
      type: String,
      required: !1,
      default: ',',
    },
    prefix: {
      type: String,
      required: !1,
      default: '',
    },
    suffix: {
      type: String,
      required: !1,
      default: '',
    },
    useEasing: {
      type: Boolean,
      required: !1,
      default: !0,
    },
    easingFn: {
      type: Function,
      default(r, t, e, n) {
        return (e * (-Math.pow(2, (-10 * r) / n) + 1) * 1024) / 1023 + t
      },
    },
  },
  data() {
    return {
      localStartVal: this.startVal,
      displayValue: this.formatNumber(this.startVal),
      printVal: null,
      paused: !1,
      localDuration: this.duration,
      startTime: null,
      timestamp: null,
      remaining: null,
      rAF: null,
    }
  },
  computed: {
    countDown() {
      return this.startVal > this.endVal
    },
  },
  watch: {
    startVal() {
      this.autoplay && this.start()
    },
    endVal() {
      this.autoplay && this.start()
    },
  },
  mounted() {
    this.autoplay && this.start(), this.$emit('mountedCallback')
  },
  methods: {
    start() {
      ;(this.localStartVal = this.startVal),
        (this.startTime = null),
        (this.localDuration = this.duration),
        (this.paused = !1),
        (this.rAF = Xa(this.count))
    },
    pauseResume() {
      this.paused
        ? (this.resume(), (this.paused = !1))
        : (this.pause(), (this.paused = !0))
    },
    pause() {
      Ya(this.rAF)
    },
    resume() {
      ;(this.startTime = null),
        (this.localDuration = +this.remaining),
        (this.localStartVal = +this.printVal),
        Xa(this.count)
    },
    reset() {
      ;(this.startTime = null),
        Ya(this.rAF),
        (this.displayValue = this.formatNumber(this.startVal))
    },
    count(r) {
      this.startTime || (this.startTime = r), (this.timestamp = r)
      const t = r - this.startTime
      ;(this.remaining = this.localDuration - t),
        this.useEasing
          ? this.countDown
            ? (this.printVal =
                this.localStartVal -
                this.easingFn(
                  t,
                  0,
                  this.localStartVal - this.endVal,
                  this.localDuration,
                ))
            : (this.printVal = this.easingFn(
                t,
                this.localStartVal,
                this.endVal - this.localStartVal,
                this.localDuration,
              ))
          : this.countDown
          ? (this.printVal =
              this.localStartVal -
              (this.localStartVal - this.endVal) * (t / this.localDuration))
          : (this.printVal =
              this.localStartVal +
              (this.endVal - this.localStartVal) * (t / this.localDuration)),
        this.countDown
          ? (this.printVal =
              this.printVal < this.endVal ? this.endVal : this.printVal)
          : (this.printVal =
              this.printVal > this.endVal ? this.endVal : this.printVal),
        (this.displayValue = this.formatNumber(this.printVal)),
        t < this.localDuration
          ? (this.rAF = Xa(this.count))
          : this.$emit('callback')
    },
    isNumber(r) {
      return !isNaN(parseFloat(r))
    },
    formatNumber(r) {
      ;(r = r.toFixed(this.decimals)), (r += '')
      const t = r.split('.')
      let e = t[0]
      const n = t.length > 1 ? this.decimal + t[1] : '',
        i = /(\d+)(\d{3})/
      if (this.separator && !this.isNumber(this.separator))
        for (; i.test(e); ) e = e.replace(i, '$1' + this.separator + '$2')
      return this.prefix + e + n + this.suffix
    },
  },
  destroyed() {
    Ya(this.rAF)
  },
}
function rJ(r, t, e, n, i, a) {
  return en(), sn('span', null, Si(i.displayValue), 1)
}
const bT = X0(nJ, [['render', rJ]])
typeof window < 'u' && window.Vue && window.Vue.component('count-to', bT)
const iJ = {
    class: 'count-card',
  },
  aJ = {
    class: 'count-card-left',
  },
  oJ = {
    class: 'count-card-title',
  },
  sJ = {
    class: 'title-zh',
  },
  lJ = {
    class: 'title-en',
  },
  uJ = {
    class: 'count-card-right',
  },
  cJ = {
    class: 'value',
  },
  hJ = {
    class: 'unit',
  },
  fJ = {
    __name: 'index',
    props: {
      info: {
        type: Object,
        default: () => ({
          icon: 'xiaoshoujine',
          zh: '2023年销售金额',
          en: 'Sales amount in 2023',
          value: 9500,
          unit: '万元',
          decimals: 0,
        }),
      },
    },
    setup(r) {
      function t(e) {
        return e.toUpperCase()
      }
      return (e, n) => (
        en(),
        sn('div', iJ, [
          wt('div', aJ, [
            wt(
              'div',
              {
                class: fh(['count-card-icon', 'icon-' + r.info.icon]),
              },
              null,
              2,
            ),
            wt('div', oJ, [
              wt('div', sJ, Si(r.info.zh), 1),
              wt('div', lJ, Si(t(r.info.en)), 1),
            ]),
          ]),
          wt('div', uJ, [
            wt('div', cJ, [
              ye(
                La(bT),
                {
                  startVal: 0,
                  endVal: r.info.value,
                  decimals: r.info.decimals,
                  duration: 2e3,
                  separator: '',
                  autoplay: !0,
                },
                null,
                8,
                ['endVal', 'decimals'],
              ),
            ]),
            wt('div', hJ, Si(r.info.unit), 1),
          ]),
        ])
      )
    },
  }
const dJ = {
    class: 'm-menu',
  },
  pJ = {
    __name: 'index',
    props: {
      defaultActive: {
        type: [String, Number],
        default: '',
      },
    },
    emits: ['select'],
    setup(r, {emit: t}) {
      const e = t,
        n = r,
        i = je(n.defaultActive)
      return (
        HE('updateActive', o => {
          ;(i.value = o), e('select', o)
        }),
        HE('activeIndex', i),
        Td(
          () => n.defaultActive,
          o => {
            o !== i.value && (i.value = o)
          },
        ),
        (o, s) => (en(), sn('div', dJ, [Bh(o.$slots, 'default')]))
      )
    },
  },
  vJ = './assets/radar-bg-9aa54028.png',
  gJ = './assets/saomiao-456ce626.png'
const mJ = {},
  yJ = {
    class: 'm-radar',
  }
function _J(r, t) {
  return (
    en(),
    sn(
      'div',
      yJ,
      t[0] ||
        (t[0] = [
          wt(
            'img',
            {
              class: 'm-radar-bg',
              src: vJ,
              alt: '',
            },
            null,
            -1,
          ),
          wt(
            'img',
            {
              class: 'm-radar-saomiao',
              src: gJ,
              alt: '',
            },
            null,
            -1,
          ),
        ]),
    )
  )
}
const xJ = X0(mJ, [['render', _J]]),
  Bc = {
    __name: 'index',
    props: {
      index: {
        type: [String, Number],
        required: !0,
      },
    },
    setup(r) {
      const t = r,
        e = dh('updateActive'),
        n = dh('activeIndex'),
        i = () => {
          e(t.index)
        }
      return (a, o) => (
        en(),
        sn(
          'div',
          {
            class: fh([
              'm-menu-item',
              {
                'is-active': r.index === La(n),
              },
            ]),
            onClick: i,
          },
          [Bh(a.$slots, 'default')],
          2,
        )
      )
    },
  }
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Tb = function (r, t) {
  return (
    (Tb =
      Object.setPrototypeOf ||
      ({
        __proto__: [],
      } instanceof Array &&
        function (e, n) {
          e.__proto__ = n
        }) ||
      function (e, n) {
        for (var i in n)
          Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
      }),
    Tb(r, t)
  )
}
function X(r, t) {
  if (typeof t != 'function' && t !== null)
    throw new TypeError(
      'Class extends value ' + String(t) + ' is not a constructor or null',
    )
  Tb(r, t)
  function e() {
    this.constructor = r
  }
  r.prototype =
    t === null ? Object.create(t) : ((e.prototype = t.prototype), new e())
}
var SJ = (function () {
    function r() {
      ;(this.firefox = !1),
        (this.ie = !1),
        (this.edge = !1),
        (this.newEdge = !1),
        (this.weChat = !1)
    }
    return r
  })(),
  AJ = (function () {
    function r() {
      ;(this.browser = new SJ()),
        (this.node = !1),
        (this.wxa = !1),
        (this.worker = !1),
        (this.svgSupported = !1),
        (this.touchEventsSupported = !1),
        (this.pointerEventsSupported = !1),
        (this.domSupported = !1),
        (this.transformSupported = !1),
        (this.transform3dSupported = !1),
        (this.hasGlobalWindow = typeof window < 'u')
    }
    return r
  })(),
  nu = new AJ()
typeof wx == 'object' && typeof wx.getSystemInfoSync == 'function'
  ? ((nu.wxa = !0), (nu.touchEventsSupported = !0))
  : typeof document > 'u' && typeof self < 'u'
  ? (nu.worker = !0)
  : typeof navigator > 'u' || navigator.userAgent.indexOf('Node.js') === 0
  ? ((nu.node = !0), (nu.svgSupported = !0))
  : bJ(navigator.userAgent, nu)
function bJ(r, t) {
  var e = t.browser,
    n = r.match(/Firefox\/([\d.]+)/),
    i = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/),
    a = r.match(/Edge?\/([\d.]+)/),
    o = /micromessenger/i.test(r)
  n && ((e.firefox = !0), (e.version = n[1])),
    i && ((e.ie = !0), (e.version = i[1])),
    a &&
      ((e.edge = !0),
      (e.version = a[1]),
      (e.newEdge = +a[1].split('.')[0] > 18)),
    o && (e.weChat = !0),
    (t.svgSupported = typeof SVGRect < 'u'),
    (t.touchEventsSupported = 'ontouchstart' in window && !e.ie && !e.edge),
    (t.pointerEventsSupported =
      'onpointerdown' in window && (e.edge || (e.ie && +e.version >= 11))),
    (t.domSupported = typeof document < 'u')
  var s = document.documentElement.style
  ;(t.transform3dSupported =
    ((e.ie && 'transition' in s) ||
      e.edge ||
      ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix()) ||
      'MozPerspective' in s) &&
    !('OTransition' in s)),
    (t.transformSupported = t.transform3dSupported || (e.ie && +e.version >= 9))
}
const Se = nu
var wT = 12,
  JF = 'sans-serif',
  nl = wT + 'px ' + JF,
  wJ = 20,
  MJ = 100,
  TJ =
    "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"
function CJ(r) {
  var t = {}
  if (typeof JSON > 'u') return t
  for (var e = 0; e < r.length; e++) {
    var n = String.fromCharCode(e + 32),
      i = (r.charCodeAt(e) - wJ) / MJ
    t[n] = i
  }
  return t
}
var EJ = CJ(TJ),
  rl = {
    createCanvas: function () {
      return typeof document < 'u' && document.createElement('canvas')
    },
    measureText: (function () {
      var r, t
      return function (e, n) {
        if (!r) {
          var i = rl.createCanvas()
          r = i && i.getContext('2d')
        }
        if (r) return t !== n && (t = r.font = n || nl), r.measureText(e)
        ;(e = e || ''), (n = n || nl)
        var a = /((?:\d+)?\.?\d*)px/.exec(n),
          o = (a && +a[1]) || wT,
          s = 0
        if (n.indexOf('mono') >= 0) s = o * e.length
        else
          for (var l = 0; l < e.length; l++) {
            var u = EJ[e[l]]
            s += u == null ? o : u * o
          }
        return {
          width: s,
        }
      }
    })(),
    loadImage: function (r, t, e) {
      var n = new Image()
      return (n.onload = t), (n.onerror = e), (n.src = r), n
    },
  },
  QF = co(
    [
      'Function',
      'RegExp',
      'Date',
      'Error',
      'CanvasGradient',
      'CanvasPattern',
      'Image',
      'Canvas',
    ],
    function (r, t) {
      return (r['[object ' + t + ']'] = !0), r
    },
    {},
  ),
  tz = co(
    [
      'Int8',
      'Uint8',
      'Uint8Clamped',
      'Int16',
      'Uint16',
      'Int32',
      'Uint32',
      'Float32',
      'Float64',
    ],
    function (r, t) {
      return (r['[object ' + t + 'Array]'] = !0), r
    },
    {},
  ),
  vf = Object.prototype.toString,
  Y0 = Array.prototype,
  DJ = Y0.forEach,
  LJ = Y0.filter,
  MT = Y0.slice,
  PJ = Y0.map,
  TL = function () {}.constructor,
  Eg = TL ? TL.prototype : null,
  TT = '__proto__',
  RJ = 2311
function ez() {
  return RJ++
}
function CT() {
  for (var r = [], t = 0; t < arguments.length; t++) r[t] = arguments[t]
  typeof console < 'u' && console.error.apply(console, r)
}
function Vt(r) {
  if (r == null || typeof r != 'object') return r
  var t = r,
    e = vf.call(r)
  if (e === '[object Array]') {
    if (!tp(r)) {
      t = []
      for (var n = 0, i = r.length; n < i; n++) t[n] = Vt(r[n])
    }
  } else if (tz[e]) {
    if (!tp(r)) {
      var a = r.constructor
      if (a.from) t = a.from(r)
      else {
        t = new a(r.length)
        for (var n = 0, i = r.length; n < i; n++) t[n] = r[n]
      }
    }
  } else if (!QF[e] && !tp(r) && !tf(r)) {
    t = {}
    for (var o in r) r.hasOwnProperty(o) && o !== TT && (t[o] = Vt(r[o]))
  }
  return t
}
function te(r, t, e) {
  if (!Ut(t) || !Ut(r)) return e ? Vt(t) : r
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== TT) {
      var i = r[n],
        a = t[n]
      Ut(a) &&
      Ut(i) &&
      !at(a) &&
      !at(i) &&
      !tf(a) &&
      !tf(i) &&
      !CL(a) &&
      !CL(i) &&
      !tp(a) &&
      !tp(i)
        ? te(i, a, e)
        : (e || !(n in r)) && (r[n] = Vt(t[n]))
    }
  return r
}
function ET(r, t) {
  for (var e = r[0], n = 1, i = r.length; n < i; n++) e = te(e, r[n], t)
  return e
}
function Q(r, t) {
  if (Object.assign) Object.assign(r, t)
  else for (var e in t) t.hasOwnProperty(e) && e !== TT && (r[e] = t[e])
  return r
}
function zt(r, t, e) {
  for (var n = pe(t), i = 0; i < n.length; i++) {
    var a = n[i]
    ;(e ? t[a] != null : r[a] == null) && (r[a] = t[a])
  }
  return r
}
function re(r, t) {
  if (r) {
    if (r.indexOf) return r.indexOf(t)
    for (var e = 0, n = r.length; e < n; e++) if (r[e] === t) return e
  }
  return -1
}
function IJ(r, t) {
  var e = r.prototype
  function n() {}
  ;(n.prototype = t.prototype), (r.prototype = new n())
  for (var i in e) e.hasOwnProperty(i) && (r.prototype[i] = e[i])
  ;(r.prototype.constructor = r), (r.superClass = t)
}
function In(r, t, e) {
  if (
    ((r = 'prototype' in r ? r.prototype : r),
    (t = 'prototype' in t ? t.prototype : t),
    Object.getOwnPropertyNames)
  )
    for (var n = Object.getOwnPropertyNames(t), i = 0; i < n.length; i++) {
      var a = n[i]
      a !== 'constructor' && (e ? t[a] != null : r[a] == null) && (r[a] = t[a])
    }
  else zt(r, t, e)
}
function Er(r) {
  return !r || typeof r == 'string' ? !1 : typeof r.length == 'number'
}
function R(r, t, e) {
  if (r && t)
    if (r.forEach && r.forEach === DJ) r.forEach(t, e)
    else if (r.length === +r.length)
      for (var n = 0, i = r.length; n < i; n++) t.call(e, r[n], n, r)
    else for (var a in r) r.hasOwnProperty(a) && t.call(e, r[a], a, r)
}
function st(r, t, e) {
  if (!r) return []
  if (!t) return DT(r)
  if (r.map && r.map === PJ) return r.map(t, e)
  for (var n = [], i = 0, a = r.length; i < a; i++)
    n.push(t.call(e, r[i], i, r))
  return n
}
function co(r, t, e, n) {
  if (r && t) {
    for (var i = 0, a = r.length; i < a; i++) e = t.call(n, e, r[i], i, r)
    return e
  }
}
function Ne(r, t, e) {
  if (!r) return []
  if (!t) return DT(r)
  if (r.filter && r.filter === LJ) return r.filter(t, e)
  for (var n = [], i = 0, a = r.length; i < a; i++)
    t.call(e, r[i], i, r) && n.push(r[i])
  return n
}
function OJ(r, t, e) {
  if (r && t) {
    for (var n = 0, i = r.length; n < i; n++)
      if (t.call(e, r[n], n, r)) return r[n]
  }
}
function pe(r) {
  if (!r) return []
  if (Object.keys) return Object.keys(r)
  var t = []
  for (var e in r) r.hasOwnProperty(e) && t.push(e)
  return t
}
function NJ(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++) e[n - 2] = arguments[n]
  return function () {
    return r.apply(t, e.concat(MT.call(arguments)))
  }
}
var Tt = Eg && Nt(Eg.bind) ? Eg.call.bind(Eg.bind) : NJ
function Zt(r) {
  for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e]
  return function () {
    return r.apply(this, t.concat(MT.call(arguments)))
  }
}
function at(r) {
  return Array.isArray ? Array.isArray(r) : vf.call(r) === '[object Array]'
}
function Nt(r) {
  return typeof r == 'function'
}
function bt(r) {
  return typeof r == 'string'
}
function Cb(r) {
  return vf.call(r) === '[object String]'
}
function be(r) {
  return typeof r == 'number'
}
function Ut(r) {
  var t = typeof r
  return t === 'function' || (!!r && t === 'object')
}
function CL(r) {
  return !!QF[vf.call(r)]
}
function ai(r) {
  return !!tz[vf.call(r)]
}
function tf(r) {
  return (
    typeof r == 'object' &&
    typeof r.nodeType == 'number' &&
    typeof r.ownerDocument == 'object'
  )
}
function $0(r) {
  return r.colorStops != null
}
function kJ(r) {
  return r.image != null
}
function BJ(r) {
  return vf.call(r) === '[object RegExp]'
}
function kp(r) {
  return r !== r
}
function nr() {
  for (var r = [], t = 0; t < arguments.length; t++) r[t] = arguments[t]
  for (var e = 0, n = r.length; e < n; e++) if (r[e] != null) return r[e]
}
function $t(r, t) {
  return r ?? t
}
function ao(r, t, e) {
  return r ?? t ?? e
}
function DT(r) {
  for (var t = [], e = 1; e < arguments.length; e++) t[e - 1] = arguments[e]
  return MT.apply(r, t)
}
function LT(r) {
  if (typeof r == 'number') return [r, r, r, r]
  var t = r.length
  return t === 2
    ? [r[0], r[1], r[0], r[1]]
    : t === 3
    ? [r[0], r[1], r[2], r[1]]
    : r
}
function Gr(r, t) {
  if (!r) throw new Error(t)
}
function xa(r) {
  return r == null
    ? null
    : typeof r.trim == 'function'
    ? r.trim()
    : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
}
var nz = '__ec_primitive__'
function Ny(r) {
  r[nz] = !0
}
function tp(r) {
  return r[nz]
}
var FJ = (function () {
    function r() {
      this.data = {}
    }
    return (
      (r.prototype.delete = function (t) {
        var e = this.has(t)
        return e && delete this.data[t], e
      }),
      (r.prototype.has = function (t) {
        return this.data.hasOwnProperty(t)
      }),
      (r.prototype.get = function (t) {
        return this.data[t]
      }),
      (r.prototype.set = function (t, e) {
        return (this.data[t] = e), this
      }),
      (r.prototype.keys = function () {
        return pe(this.data)
      }),
      (r.prototype.forEach = function (t) {
        var e = this.data
        for (var n in e) e.hasOwnProperty(n) && t(e[n], n)
      }),
      r
    )
  })(),
  rz = typeof Map == 'function'
function zJ() {
  return rz ? new Map() : new FJ()
}
var UJ = (function () {
  function r(t) {
    var e = at(t)
    this.data = zJ()
    var n = this
    t instanceof r ? t.each(i) : t && R(t, i)
    function i(a, o) {
      e ? n.set(a, o) : n.set(o, a)
    }
  }
  return (
    (r.prototype.hasKey = function (t) {
      return this.data.has(t)
    }),
    (r.prototype.get = function (t) {
      return this.data.get(t)
    }),
    (r.prototype.set = function (t, e) {
      return this.data.set(t, e), e
    }),
    (r.prototype.each = function (t, e) {
      this.data.forEach(function (n, i) {
        t.call(e, n, i)
      })
    }),
    (r.prototype.keys = function () {
      var t = this.data.keys()
      return rz ? Array.from(t) : t
    }),
    (r.prototype.removeKey = function (t) {
      this.data.delete(t)
    }),
    r
  )
})()
function Pt(r) {
  return new UJ(r)
}
function ky(r, t) {
  for (var e = new r.constructor(r.length + t.length), n = 0; n < r.length; n++)
    e[n] = r[n]
  for (var i = r.length, n = 0; n < t.length; n++) e[n + i] = t[n]
  return e
}
function q0(r, t) {
  var e
  if (Object.create) e = Object.create(r)
  else {
    var n = function () {}
    ;(n.prototype = r), (e = new n())
  }
  return t && Q(e, t), e
}
function iz(r) {
  var t = r.style
  ;(t.webkitUserSelect = 'none'),
    (t.userSelect = 'none'),
    (t.webkitTapHighlightColor = 'rgba(0,0,0,0)'),
    (t['-webkit-touch-callout'] = 'none')
}
function Et(r, t) {
  return r.hasOwnProperty(t)
}
function wn() {}
var Wm = 180 / Math.PI
function tc(r, t) {
  return r == null && (r = 0), t == null && (t = 0), [r, t]
}
function Nr(r, t) {
  return (r[0] = t[0]), (r[1] = t[1]), r
}
function Go(r) {
  return [r[0], r[1]]
}
function VJ(r, t, e) {
  return (r[0] = t), (r[1] = e), r
}
function EL(r, t, e) {
  return (r[0] = t[0] + e[0]), (r[1] = t[1] + e[1]), r
}
function Eb(r, t, e, n) {
  return (r[0] = t[0] + e[0] * n), (r[1] = t[1] + e[1] * n), r
}
function gu(r, t, e) {
  return (r[0] = t[0] - e[0]), (r[1] = t[1] - e[1]), r
}
function Db(r) {
  return Math.sqrt(GJ(r))
}
function GJ(r) {
  return r[0] * r[0] + r[1] * r[1]
}
function Xm(r, t, e) {
  return (r[0] = t[0] * e), (r[1] = t[1] * e), r
}
function gf(r, t) {
  var e = Db(t)
  return (
    e === 0 ? ((r[0] = 0), (r[1] = 0)) : ((r[0] = t[0] / e), (r[1] = t[1] / e)),
    r
  )
}
function Lb(r, t) {
  return Math.sqrt(
    (r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1]),
  )
}
var ks = Lb
function HJ(r, t) {
  return (r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1])
}
var Lu = HJ
function Ym(r, t, e, n) {
  return (r[0] = t[0] + n * (e[0] - t[0])), (r[1] = t[1] + n * (e[1] - t[1])), r
}
function pr(r, t, e) {
  var n = t[0],
    i = t[1]
  return (
    (r[0] = e[0] * n + e[2] * i + e[4]), (r[1] = e[1] * n + e[3] * i + e[5]), r
  )
}
function Bs(r, t, e) {
  return (r[0] = Math.min(t[0], e[0])), (r[1] = Math.min(t[1], e[1])), r
}
function Fs(r, t, e) {
  return (r[0] = Math.max(t[0], e[0])), (r[1] = Math.max(t[1], e[1])), r
}
var Fc = (function () {
    function r(t, e) {
      ;(this.target = t), (this.topTarget = e && e.topTarget)
    }
    return r
  })(),
  WJ = (function () {
    function r(t) {
      ;(this.handler = t),
        t.on('mousedown', this._dragStart, this),
        t.on('mousemove', this._drag, this),
        t.on('mouseup', this._dragEnd, this)
    }
    return (
      (r.prototype._dragStart = function (t) {
        for (var e = t.target; e && !e.draggable; )
          e = e.parent || e.__hostTarget
        e &&
          ((this._draggingTarget = e),
          (e.dragging = !0),
          (this._x = t.offsetX),
          (this._y = t.offsetY),
          this.handler.dispatchToElement(new Fc(e, t), 'dragstart', t.event))
      }),
      (r.prototype._drag = function (t) {
        var e = this._draggingTarget
        if (e) {
          var n = t.offsetX,
            i = t.offsetY,
            a = n - this._x,
            o = i - this._y
          ;(this._x = n),
            (this._y = i),
            e.drift(a, o, t),
            this.handler.dispatchToElement(new Fc(e, t), 'drag', t.event)
          var s = this.handler.findHover(n, i, e).target,
            l = this._dropTarget
          ;(this._dropTarget = s),
            e !== s &&
              (l &&
                s !== l &&
                this.handler.dispatchToElement(
                  new Fc(l, t),
                  'dragleave',
                  t.event,
                ),
              s &&
                s !== l &&
                this.handler.dispatchToElement(
                  new Fc(s, t),
                  'dragenter',
                  t.event,
                ))
        }
      }),
      (r.prototype._dragEnd = function (t) {
        var e = this._draggingTarget
        e && (e.dragging = !1),
          this.handler.dispatchToElement(new Fc(e, t), 'dragend', t.event),
          this._dropTarget &&
            this.handler.dispatchToElement(
              new Fc(this._dropTarget, t),
              'drop',
              t.event,
            ),
          (this._draggingTarget = null),
          (this._dropTarget = null)
      }),
      r
    )
  })()
const XJ = WJ
var YJ = (function () {
  function r(t) {
    t && (this._$eventProcessor = t)
  }
  return (
    (r.prototype.on = function (t, e, n, i) {
      this._$handlers || (this._$handlers = {})
      var a = this._$handlers
      if ((typeof e == 'function' && ((i = n), (n = e), (e = null)), !n || !t))
        return this
      var o = this._$eventProcessor
      e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)),
        a[t] || (a[t] = [])
      for (var s = 0; s < a[t].length; s++) if (a[t][s].h === n) return this
      var l = {
          h: n,
          query: e,
          ctx: i || this,
          callAtLast: n.zrEventfulCallAtLast,
        },
        u = a[t].length - 1,
        c = a[t][u]
      return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this
    }),
    (r.prototype.isSilent = function (t) {
      var e = this._$handlers
      return !e || !e[t] || !e[t].length
    }),
    (r.prototype.off = function (t, e) {
      var n = this._$handlers
      if (!n) return this
      if (!t) return (this._$handlers = {}), this
      if (e) {
        if (n[t]) {
          for (var i = [], a = 0, o = n[t].length; a < o; a++)
            n[t][a].h !== e && i.push(n[t][a])
          n[t] = i
        }
        n[t] && n[t].length === 0 && delete n[t]
      } else delete n[t]
      return this
    }),
    (r.prototype.trigger = function (t) {
      for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
      if (!this._$handlers) return this
      var i = this._$handlers[t],
        a = this._$eventProcessor
      if (i)
        for (var o = e.length, s = i.length, l = 0; l < s; l++) {
          var u = i[l]
          if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
            switch (o) {
              case 0:
                u.h.call(u.ctx)
                break
              case 1:
                u.h.call(u.ctx, e[0])
                break
              case 2:
                u.h.call(u.ctx, e[0], e[1])
                break
              default:
                u.h.apply(u.ctx, e)
                break
            }
        }
      return a && a.afterTrigger && a.afterTrigger(t), this
    }),
    (r.prototype.triggerWithContext = function (t) {
      for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n]
      if (!this._$handlers) return this
      var i = this._$handlers[t],
        a = this._$eventProcessor
      if (i)
        for (var o = e.length, s = e[o - 1], l = i.length, u = 0; u < l; u++) {
          var c = i[u]
          if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
            switch (o) {
              case 0:
                c.h.call(s)
                break
              case 1:
                c.h.call(s, e[0])
                break
              case 2:
                c.h.call(s, e[0], e[1])
                break
              default:
                c.h.apply(s, e.slice(1, o - 1))
                break
            }
        }
      return a && a.afterTrigger && a.afterTrigger(t), this
    }),
    r
  )
})()
const ra = YJ
var $J = Math.log(2)
function Pb(r, t, e, n, i, a) {
  var o = n + '-' + i,
    s = r.length
  if (a.hasOwnProperty(o)) return a[o]
  if (t === 1) {
    var l = Math.round(Math.log(((1 << s) - 1) & ~i) / $J)
    return r[e][l]
  }
  for (var u = n | (1 << e), c = e + 1; n & (1 << c); ) c++
  for (var h = 0, f = 0, d = 0; f < s; f++) {
    var p = 1 << f
    p & i ||
      ((h += (d % 2 ? -1 : 1) * r[e][f] * Pb(r, t - 1, c, u, i | p, a)), d++)
  }
  return (a[o] = h), h
}
function DL(r, t) {
  var e = [
      [r[0], r[1], 1, 0, 0, 0, -t[0] * r[0], -t[0] * r[1]],
      [0, 0, 0, r[0], r[1], 1, -t[1] * r[0], -t[1] * r[1]],
      [r[2], r[3], 1, 0, 0, 0, -t[2] * r[2], -t[2] * r[3]],
      [0, 0, 0, r[2], r[3], 1, -t[3] * r[2], -t[3] * r[3]],
      [r[4], r[5], 1, 0, 0, 0, -t[4] * r[4], -t[4] * r[5]],
      [0, 0, 0, r[4], r[5], 1, -t[5] * r[4], -t[5] * r[5]],
      [r[6], r[7], 1, 0, 0, 0, -t[6] * r[6], -t[6] * r[7]],
      [0, 0, 0, r[6], r[7], 1, -t[7] * r[6], -t[7] * r[7]],
    ],
    n = {},
    i = Pb(e, 8, 0, 0, 0, n)
  if (i !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0),
          (a[s] +=
            ((((o + s) % 2 ? -1 : 1) *
              Pb(e, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n)) /
              i) *
            t[o])
    return function (l, u, c) {
      var h = u * a[6] + c * a[7] + 1
      ;(l[0] = (u * a[0] + c * a[1] + a[2]) / h),
        (l[1] = (u * a[3] + c * a[4] + a[5]) / h)
    }
  }
}
var LL = '___zrEVENTSAVED',
  Ux = []
function qJ(r, t, e, n, i) {
  return Rb(Ux, t, n, i, !0) && Rb(r, e, Ux[0], Ux[1])
}
function Rb(r, t, e, n, i) {
  if (t.getBoundingClientRect && Se.domSupported && !az(t)) {
    var a = t[LL] || (t[LL] = {}),
      o = ZJ(t, a),
      s = KJ(o, a, i)
    if (s) return s(r, e, n), !0
  }
  return !1
}
function ZJ(r, t) {
  var e = t.markers
  if (e) return e
  e = t.markers = []
  for (var n = ['left', 'right'], i = ['top', 'bottom'], a = 0; a < 4; a++) {
    var o = document.createElement('div'),
      s = o.style,
      l = a % 2,
      u = (a >> 1) % 2
    ;(s.cssText = [
      'position: absolute',
      'visibility: hidden',
      'padding: 0',
      'margin: 0',
      'border-width: 0',
      'user-select: none',
      'width:0',
      'height:0',
      n[l] + ':0',
      i[u] + ':0',
      n[1 - l] + ':auto',
      i[1 - u] + ':auto',
      '',
    ].join('!important;')),
      r.appendChild(o),
      e.push(o)
  }
  return e
}
function KJ(r, t, e) {
  for (
    var n = e ? 'invTrans' : 'trans',
      i = t[n],
      a = t.srcCoords,
      o = [],
      s = [],
      l = !0,
      u = 0;
    u < 4;
    u++
  ) {
    var c = r[u].getBoundingClientRect(),
      h = 2 * u,
      f = c.left,
      d = c.top
    o.push(f, d),
      (l = l && a && f === a[h] && d === a[h + 1]),
      s.push(r[u].offsetLeft, r[u].offsetTop)
  }
  return l && i ? i : ((t.srcCoords = o), (t[n] = e ? DL(s, o) : DL(o, s)))
}
function az(r) {
  return r.nodeName.toUpperCase() === 'CANVAS'
}
var jJ = /([&<>"'])/g,
  JJ = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  }
function Fr(r) {
  return r == null
    ? ''
    : (r + '').replace(jJ, function (t, e) {
        return JJ[e]
      })
}
var QJ = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  Vx = [],
  tQ = Se.browser.firefox && +Se.browser.version.split('.')[0] < 39
function Ib(r, t, e, n) {
  return (
    (e = e || {}),
    n
      ? PL(r, t, e)
      : tQ && t.layerX != null && t.layerX !== t.offsetX
      ? ((e.zrX = t.layerX), (e.zrY = t.layerY))
      : t.offsetX != null
      ? ((e.zrX = t.offsetX), (e.zrY = t.offsetY))
      : PL(r, t, e),
    e
  )
}
function PL(r, t, e) {
  if (Se.domSupported && r.getBoundingClientRect) {
    var n = t.clientX,
      i = t.clientY
    if (az(r)) {
      var a = r.getBoundingClientRect()
      ;(e.zrX = n - a.left), (e.zrY = i - a.top)
      return
    } else if (Rb(Vx, r, n, i)) {
      ;(e.zrX = Vx[0]), (e.zrY = Vx[1])
      return
    }
  }
  e.zrX = e.zrY = 0
}
function PT(r) {
  return r || window.event
}
function Fi(r, t, e) {
  if (((t = PT(t)), t.zrX != null)) return t
  var n = t.type,
    i = n && n.indexOf('touch') >= 0
  if (i) {
    var o = n !== 'touchend' ? t.targetTouches[0] : t.changedTouches[0]
    o && Ib(r, o, t, e)
  } else {
    Ib(r, t, t, e)
    var a = eQ(t)
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3
  }
  var s = t.button
  return (
    t.which == null &&
      s !== void 0 &&
      QJ.test(t.type) &&
      (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0),
    t
  )
}
function eQ(r) {
  var t = r.wheelDelta
  if (t) return t
  var e = r.deltaX,
    n = r.deltaY
  if (e == null || n == null) return t
  var i = Math.abs(n !== 0 ? n : e),
    a = n > 0 ? -1 : n < 0 ? 1 : e > 0 ? -1 : 1
  return 3 * i * a
}
function Ob(r, t, e, n) {
  r.addEventListener(t, e, n)
}
function nQ(r, t, e, n) {
  r.removeEventListener(t, e, n)
}
var jo = function (r) {
  r.preventDefault(), r.stopPropagation(), (r.cancelBubble = !0)
}
function RL(r) {
  return r.which === 2 || r.which === 3
}
var rQ = (function () {
  function r() {
    this._track = []
  }
  return (
    (r.prototype.recognize = function (t, e, n) {
      return this._doTrack(t, e, n), this._recognize(t)
    }),
    (r.prototype.clear = function () {
      return (this._track.length = 0), this
    }),
    (r.prototype._doTrack = function (t, e, n) {
      var i = t.touches
      if (i) {
        for (
          var a = {
              points: [],
              touches: [],
              target: e,
              event: t,
            },
            o = 0,
            s = i.length;
          o < s;
          o++
        ) {
          var l = i[o],
            u = Ib(n, l, {})
          a.points.push([u.zrX, u.zrY]), a.touches.push(l)
        }
        this._track.push(a)
      }
    }),
    (r.prototype._recognize = function (t) {
      for (var e in Gx)
        if (Gx.hasOwnProperty(e)) {
          var n = Gx[e](this._track, t)
          if (n) return n
        }
    }),
    r
  )
})()
function IL(r) {
  var t = r[1][0] - r[0][0],
    e = r[1][1] - r[0][1]
  return Math.sqrt(t * t + e * e)
}
function iQ(r) {
  return [(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2]
}
var Gx = {
  pinch: function (r, t) {
    var e = r.length
    if (e) {
      var n = (r[e - 1] || {}).points,
        i = (r[e - 2] || {}).points || n
      if (i && i.length > 1 && n && n.length > 1) {
        var a = IL(n) / IL(i)
        !isFinite(a) && (a = 1), (t.pinchScale = a)
        var o = iQ(n)
        return (
          (t.pinchX = o[0]),
          (t.pinchY = o[1]),
          {
            type: 'pinch',
            target: r[0].target,
            event: t,
          }
        )
      }
    }
  },
}
function bi() {
  return [1, 0, 0, 1, 0, 0]
}
function Z0(r) {
  return (
    (r[0] = 1), (r[1] = 0), (r[2] = 0), (r[3] = 1), (r[4] = 0), (r[5] = 0), r
  )
}
function RT(r, t) {
  return (
    (r[0] = t[0]),
    (r[1] = t[1]),
    (r[2] = t[2]),
    (r[3] = t[3]),
    (r[4] = t[4]),
    (r[5] = t[5]),
    r
  )
}
function Ho(r, t, e) {
  var n = t[0] * e[0] + t[2] * e[1],
    i = t[1] * e[0] + t[3] * e[1],
    a = t[0] * e[2] + t[2] * e[3],
    o = t[1] * e[2] + t[3] * e[3],
    s = t[0] * e[4] + t[2] * e[5] + t[4],
    l = t[1] * e[4] + t[3] * e[5] + t[5]
  return (
    (r[0] = n), (r[1] = i), (r[2] = a), (r[3] = o), (r[4] = s), (r[5] = l), r
  )
}
function ho(r, t, e) {
  return (
    (r[0] = t[0]),
    (r[1] = t[1]),
    (r[2] = t[2]),
    (r[3] = t[3]),
    (r[4] = t[4] + e[0]),
    (r[5] = t[5] + e[1]),
    r
  )
}
function ec(r, t, e, n) {
  n === void 0 && (n = [0, 0])
  var i = t[0],
    a = t[2],
    o = t[4],
    s = t[1],
    l = t[3],
    u = t[5],
    c = Math.sin(e),
    h = Math.cos(e)
  return (
    (r[0] = i * h + s * c),
    (r[1] = -i * c + s * h),
    (r[2] = a * h + l * c),
    (r[3] = -a * c + h * l),
    (r[4] = h * (o - n[0]) + c * (u - n[1]) + n[0]),
    (r[5] = h * (u - n[1]) - c * (o - n[0]) + n[1]),
    r
  )
}
function IT(r, t, e) {
  var n = e[0],
    i = e[1]
  return (
    (r[0] = t[0] * n),
    (r[1] = t[1] * i),
    (r[2] = t[2] * n),
    (r[3] = t[3] * i),
    (r[4] = t[4] * n),
    (r[5] = t[5] * i),
    r
  )
}
function mf(r, t) {
  var e = t[0],
    n = t[2],
    i = t[4],
    a = t[1],
    o = t[3],
    s = t[5],
    l = e * o - a * n
  return l
    ? ((l = 1 / l),
      (r[0] = o * l),
      (r[1] = -a * l),
      (r[2] = -n * l),
      (r[3] = e * l),
      (r[4] = (n * s - o * i) * l),
      (r[5] = (a * i - e * s) * l),
      r)
    : null
}
function aQ(r) {
  var t = bi()
  return RT(t, r), t
}
var oQ = (function () {
  function r(t, e) {
    ;(this.x = t || 0), (this.y = e || 0)
  }
  return (
    (r.prototype.copy = function (t) {
      return (this.x = t.x), (this.y = t.y), this
    }),
    (r.prototype.clone = function () {
      return new r(this.x, this.y)
    }),
    (r.prototype.set = function (t, e) {
      return (this.x = t), (this.y = e), this
    }),
    (r.prototype.equal = function (t) {
      return t.x === this.x && t.y === this.y
    }),
    (r.prototype.add = function (t) {
      return (this.x += t.x), (this.y += t.y), this
    }),
    (r.prototype.scale = function (t) {
      ;(this.x *= t), (this.y *= t)
    }),
    (r.prototype.scaleAndAdd = function (t, e) {
      ;(this.x += t.x * e), (this.y += t.y * e)
    }),
    (r.prototype.sub = function (t) {
      return (this.x -= t.x), (this.y -= t.y), this
    }),
    (r.prototype.dot = function (t) {
      return this.x * t.x + this.y * t.y
    }),
    (r.prototype.len = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }),
    (r.prototype.lenSquare = function () {
      return this.x * this.x + this.y * this.y
    }),
    (r.prototype.normalize = function () {
      var t = this.len()
      return (this.x /= t), (this.y /= t), this
    }),
    (r.prototype.distance = function (t) {
      var e = this.x - t.x,
        n = this.y - t.y
      return Math.sqrt(e * e + n * n)
    }),
    (r.prototype.distanceSquare = function (t) {
      var e = this.x - t.x,
        n = this.y - t.y
      return e * e + n * n
    }),
    (r.prototype.negate = function () {
      return (this.x = -this.x), (this.y = -this.y), this
    }),
    (r.prototype.transform = function (t) {
      if (t) {
        var e = this.x,
          n = this.y
        return (
          (this.x = t[0] * e + t[2] * n + t[4]),
          (this.y = t[1] * e + t[3] * n + t[5]),
          this
        )
      }
    }),
    (r.prototype.toArray = function (t) {
      return (t[0] = this.x), (t[1] = this.y), t
    }),
    (r.prototype.fromArray = function (t) {
      ;(this.x = t[0]), (this.y = t[1])
    }),
    (r.set = function (t, e, n) {
      ;(t.x = e), (t.y = n)
    }),
    (r.copy = function (t, e) {
      ;(t.x = e.x), (t.y = e.y)
    }),
    (r.len = function (t) {
      return Math.sqrt(t.x * t.x + t.y * t.y)
    }),
    (r.lenSquare = function (t) {
      return t.x * t.x + t.y * t.y
    }),
    (r.dot = function (t, e) {
      return t.x * e.x + t.y * e.y
    }),
    (r.add = function (t, e, n) {
      ;(t.x = e.x + n.x), (t.y = e.y + n.y)
    }),
    (r.sub = function (t, e, n) {
      ;(t.x = e.x - n.x), (t.y = e.y - n.y)
    }),
    (r.scale = function (t, e, n) {
      ;(t.x = e.x * n), (t.y = e.y * n)
    }),
    (r.scaleAndAdd = function (t, e, n, i) {
      ;(t.x = e.x + n.x * i), (t.y = e.y + n.y * i)
    }),
    (r.lerp = function (t, e, n, i) {
      var a = 1 - i
      ;(t.x = a * e.x + i * n.x), (t.y = a * e.y + i * n.y)
    }),
    r
  )
})()
const Qt = oQ
var Dg = Math.min,
  Lg = Math.max,
  Dl = new Qt(),
  Ll = new Qt(),
  Pl = new Qt(),
  Rl = new Qt(),
  Zf = new Qt(),
  Kf = new Qt(),
  sQ = (function () {
    function r(t, e, n, i) {
      n < 0 && ((t = t + n), (n = -n)),
        i < 0 && ((e = e + i), (i = -i)),
        (this.x = t),
        (this.y = e),
        (this.width = n),
        (this.height = i)
    }
    return (
      (r.prototype.union = function (t) {
        var e = Dg(t.x, this.x),
          n = Dg(t.y, this.y)
        isFinite(this.x) && isFinite(this.width)
          ? (this.width = Lg(t.x + t.width, this.x + this.width) - e)
          : (this.width = t.width),
          isFinite(this.y) && isFinite(this.height)
            ? (this.height = Lg(t.y + t.height, this.y + this.height) - n)
            : (this.height = t.height),
          (this.x = e),
          (this.y = n)
      }),
      (r.prototype.applyTransform = function (t) {
        r.applyTransform(this, this, t)
      }),
      (r.prototype.calculateTransform = function (t) {
        var e = this,
          n = t.width / e.width,
          i = t.height / e.height,
          a = bi()
        return ho(a, a, [-e.x, -e.y]), IT(a, a, [n, i]), ho(a, a, [t.x, t.y]), a
      }),
      (r.prototype.intersect = function (t, e) {
        if (!t) return !1
        t instanceof r || (t = r.create(t))
        var n = this,
          i = n.x,
          a = n.x + n.width,
          o = n.y,
          s = n.y + n.height,
          l = t.x,
          u = t.x + t.width,
          c = t.y,
          h = t.y + t.height,
          f = !(a < l || u < i || s < c || h < o)
        if (e) {
          var d = 1 / 0,
            p = 0,
            g = Math.abs(a - l),
            v = Math.abs(u - i),
            m = Math.abs(s - c),
            y = Math.abs(h - o),
            _ = Math.min(g, v),
            x = Math.min(m, y)
          a < l || u < i
            ? _ > p && ((p = _), g < v ? Qt.set(Kf, -g, 0) : Qt.set(Kf, v, 0))
            : _ < d && ((d = _), g < v ? Qt.set(Zf, g, 0) : Qt.set(Zf, -v, 0)),
            s < c || h < o
              ? x > p && ((p = x), m < y ? Qt.set(Kf, 0, -m) : Qt.set(Kf, 0, y))
              : _ < d && ((d = _), m < y ? Qt.set(Zf, 0, m) : Qt.set(Zf, 0, -y))
        }
        return e && Qt.copy(e, f ? Zf : Kf), f
      }),
      (r.prototype.contain = function (t, e) {
        var n = this
        return t >= n.x && t <= n.x + n.width && e >= n.y && e <= n.y + n.height
      }),
      (r.prototype.clone = function () {
        return new r(this.x, this.y, this.width, this.height)
      }),
      (r.prototype.copy = function (t) {
        r.copy(this, t)
      }),
      (r.prototype.plain = function () {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
        }
      }),
      (r.prototype.isFinite = function () {
        return (
          isFinite(this.x) &&
          isFinite(this.y) &&
          isFinite(this.width) &&
          isFinite(this.height)
        )
      }),
      (r.prototype.isZero = function () {
        return this.width === 0 || this.height === 0
      }),
      (r.create = function (t) {
        return new r(t.x, t.y, t.width, t.height)
      }),
      (r.copy = function (t, e) {
        ;(t.x = e.x), (t.y = e.y), (t.width = e.width), (t.height = e.height)
      }),
      (r.applyTransform = function (t, e, n) {
        if (!n) {
          t !== e && r.copy(t, e)
          return
        }
        if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
          var i = n[0],
            a = n[3],
            o = n[4],
            s = n[5]
          ;(t.x = e.x * i + o),
            (t.y = e.y * a + s),
            (t.width = e.width * i),
            (t.height = e.height * a),
            t.width < 0 && ((t.x += t.width), (t.width = -t.width)),
            t.height < 0 && ((t.y += t.height), (t.height = -t.height))
          return
        }
        ;(Dl.x = Pl.x = e.x),
          (Dl.y = Rl.y = e.y),
          (Ll.x = Rl.x = e.x + e.width),
          (Ll.y = Pl.y = e.y + e.height),
          Dl.transform(n),
          Rl.transform(n),
          Ll.transform(n),
          Pl.transform(n),
          (t.x = Dg(Dl.x, Ll.x, Pl.x, Rl.x)),
          (t.y = Dg(Dl.y, Ll.y, Pl.y, Rl.y))
        var l = Lg(Dl.x, Ll.x, Pl.x, Rl.x),
          u = Lg(Dl.y, Ll.y, Pl.y, Rl.y)
        ;(t.width = l - t.x), (t.height = u - t.y)
      }),
      r
    )
  })()
const ee = sQ
var oz = 'silent'
function lQ(r, t, e) {
  return {
    type: r,
    event: e,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: e.zrX,
    offsetY: e.zrY,
    gestureEvent: e.gestureEvent,
    pinchX: e.pinchX,
    pinchY: e.pinchY,
    pinchScale: e.pinchScale,
    wheelDelta: e.zrDelta,
    zrByTouch: e.zrByTouch,
    which: e.which,
    stop: uQ,
  }
}
function uQ() {
  jo(this.event)
}
var cQ = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.handler = null), e
    }
    return (
      (t.prototype.dispose = function () {}),
      (t.prototype.setCursor = function () {}),
      t
    )
  })(ra),
  jf = (function () {
    function r(t, e) {
      ;(this.x = t), (this.y = e)
    }
    return r
  })(),
  hQ = [
    'click',
    'dblclick',
    'mousewheel',
    'mouseout',
    'mouseup',
    'mousedown',
    'mousemove',
    'contextmenu',
  ],
  Hx = new ee(0, 0, 0, 0),
  sz = (function (r) {
    X(t, r)
    function t(e, n, i, a, o) {
      var s = r.call(this) || this
      return (
        (s._hovered = new jf(0, 0)),
        (s.storage = e),
        (s.painter = n),
        (s.painterRoot = a),
        (s._pointerSize = o),
        (i = i || new cQ()),
        (s.proxy = null),
        s.setHandlerProxy(i),
        (s._draggingMgr = new XJ(s)),
        s
      )
    }
    return (
      (t.prototype.setHandlerProxy = function (e) {
        this.proxy && this.proxy.dispose(),
          e &&
            (R(
              hQ,
              function (n) {
                e.on && e.on(n, this[n], this)
              },
              this,
            ),
            (e.handler = this)),
          (this.proxy = e)
      }),
      (t.prototype.mousemove = function (e) {
        var n = e.zrX,
          i = e.zrY,
          a = lz(this, n, i),
          o = this._hovered,
          s = o.target
        s && !s.__zr && ((o = this.findHover(o.x, o.y)), (s = o.target))
        var l = (this._hovered = a ? new jf(n, i) : this.findHover(n, i)),
          u = l.target,
          c = this.proxy
        c.setCursor && c.setCursor(u ? u.cursor : 'default'),
          s && u !== s && this.dispatchToElement(o, 'mouseout', e),
          this.dispatchToElement(l, 'mousemove', e),
          u && u !== s && this.dispatchToElement(l, 'mouseover', e)
      }),
      (t.prototype.mouseout = function (e) {
        var n = e.zrEventControl
        n !== 'only_globalout' &&
          this.dispatchToElement(this._hovered, 'mouseout', e),
          n !== 'no_globalout' &&
            this.trigger('globalout', {
              type: 'globalout',
              event: e,
            })
      }),
      (t.prototype.resize = function () {
        this._hovered = new jf(0, 0)
      }),
      (t.prototype.dispatch = function (e, n) {
        var i = this[e]
        i && i.call(this, n)
      }),
      (t.prototype.dispose = function () {
        this.proxy.dispose(),
          (this.storage = null),
          (this.proxy = null),
          (this.painter = null)
      }),
      (t.prototype.setCursorStyle = function (e) {
        var n = this.proxy
        n.setCursor && n.setCursor(e)
      }),
      (t.prototype.dispatchToElement = function (e, n, i) {
        e = e || {}
        var a = e.target
        if (!(a && a.silent)) {
          for (
            var o = 'on' + n, s = lQ(n, e, i);
            a &&
            (a[o] && (s.cancelBubble = !!a[o].call(a, s)),
            a.trigger(n, s),
            (a = a.__hostTarget ? a.__hostTarget : a.parent),
            !s.cancelBubble);

          );
          s.cancelBubble ||
            (this.trigger(n, s),
            this.painter &&
              this.painter.eachOtherLayer &&
              this.painter.eachOtherLayer(function (l) {
                typeof l[o] == 'function' && l[o].call(l, s),
                  l.trigger && l.trigger(n, s)
              }))
        }
      }),
      (t.prototype.findHover = function (e, n, i) {
        var a = this.storage.getDisplayList(),
          o = new jf(e, n)
        if ((OL(a, o, e, n, i), this._pointerSize && !o.target)) {
          for (
            var s = [],
              l = this._pointerSize,
              u = l / 2,
              c = new ee(e - u, n - u, l, l),
              h = a.length - 1;
            h >= 0;
            h--
          ) {
            var f = a[h]
            f !== i &&
              !f.ignore &&
              !f.ignoreCoarsePointer &&
              (!f.parent || !f.parent.ignoreCoarsePointer) &&
              (Hx.copy(f.getBoundingRect()),
              f.transform && Hx.applyTransform(f.transform),
              Hx.intersect(c) && s.push(f))
          }
          if (s.length)
            for (
              var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0;
              v < u;
              v += d
            )
              for (var m = 0; m < g; m += p) {
                var y = e + v * Math.cos(m),
                  _ = n + v * Math.sin(m)
                if ((OL(s, o, y, _, i), o.target)) return o
              }
        }
        return o
      }),
      (t.prototype.processGesture = function (e, n) {
        this._gestureMgr || (this._gestureMgr = new rQ())
        var i = this._gestureMgr
        n === 'start' && i.clear()
        var a = i.recognize(
          e,
          this.findHover(e.zrX, e.zrY, null).target,
          this.proxy.dom,
        )
        if ((n === 'end' && i.clear(), a)) {
          var o = a.type
          e.gestureEvent = o
          var s = new jf()
          ;(s.target = a.target), this.dispatchToElement(s, o, a.event)
        }
      }),
      t
    )
  })(ra)
R(
  ['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'],
  function (r) {
    sz.prototype[r] = function (t) {
      var e = t.zrX,
        n = t.zrY,
        i = lz(this, e, n),
        a,
        o
      if (
        ((r !== 'mouseup' || !i) &&
          ((a = this.findHover(e, n)), (o = a.target)),
        r === 'mousedown')
      )
        (this._downEl = o), (this._downPoint = [t.zrX, t.zrY]), (this._upEl = o)
      else if (r === 'mouseup') this._upEl = o
      else if (r === 'click') {
        if (
          this._downEl !== this._upEl ||
          !this._downPoint ||
          ks(this._downPoint, [t.zrX, t.zrY]) > 4
        )
          return
        this._downPoint = null
      }
      this.dispatchToElement(a, r, t)
    }
  },
)
function fQ(r, t, e) {
  if (r[r.rectHover ? 'rectContain' : 'contain'](t, e)) {
    for (var n = r, i = void 0, a = !1; n; ) {
      if ((n.ignoreClip && (a = !0), !a)) {
        var o = n.getClipPath()
        if (o && !o.contain(t, e)) return !1
      }
      n.silent && (i = !0)
      var s = n.__hostTarget
      n = s || n.parent
    }
    return i ? oz : !0
  }
  return !1
}
function OL(r, t, e, n, i) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a],
      s = void 0
    if (
      o !== i &&
      !o.ignore &&
      (s = fQ(o, e, n)) &&
      (!t.topTarget && (t.topTarget = o), s !== oz)
    ) {
      t.target = o
      break
    }
  }
}
function lz(r, t, e) {
  var n = r.painter
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight()
}
const dQ = sz
var uz = 32,
  Jf = 7
function pQ(r) {
  for (var t = 0; r >= uz; ) (t |= r & 1), (r >>= 1)
  return r + t
}
function NL(r, t, e, n) {
  var i = t + 1
  if (i === e) return 1
  if (n(r[i++], r[t]) < 0) {
    for (; i < e && n(r[i], r[i - 1]) < 0; ) i++
    vQ(r, t, i)
  } else for (; i < e && n(r[i], r[i - 1]) >= 0; ) i++
  return i - t
}
function vQ(r, t, e) {
  for (e--; t < e; ) {
    var n = r[t]
    ;(r[t++] = r[e]), (r[e--] = n)
  }
}
function kL(r, t, e, n, i) {
  for (n === t && n++; n < e; n++) {
    for (var a = r[n], o = t, s = n, l; o < s; )
      (l = (o + s) >>> 1), i(a, r[l]) < 0 ? (s = l) : (o = l + 1)
    var u = n - o
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2]
      case 2:
        r[o + 2] = r[o + 1]
      case 1:
        r[o + 1] = r[o]
        break
      default:
        for (; u > 0; ) (r[o + u] = r[o + u - 1]), u--
    }
    r[o] = a
  }
}
function Wx(r, t, e, n, i, a) {
  var o = 0,
    s = 0,
    l = 1
  if (a(r, t[e + i]) > 0) {
    for (s = n - i; l < s && a(r, t[e + i + l]) > 0; )
      (o = l), (l = (l << 1) + 1), l <= 0 && (l = s)
    l > s && (l = s), (o += i), (l += i)
  } else {
    for (s = i + 1; l < s && a(r, t[e + i - l]) <= 0; )
      (o = l), (l = (l << 1) + 1), l <= 0 && (l = s)
    l > s && (l = s)
    var u = o
    ;(o = i - l), (l = i - u)
  }
  for (o++; o < l; ) {
    var c = o + ((l - o) >>> 1)
    a(r, t[e + c]) > 0 ? (o = c + 1) : (l = c)
  }
  return l
}
function Xx(r, t, e, n, i, a) {
  var o = 0,
    s = 0,
    l = 1
  if (a(r, t[e + i]) < 0) {
    for (s = i + 1; l < s && a(r, t[e + i - l]) < 0; )
      (o = l), (l = (l << 1) + 1), l <= 0 && (l = s)
    l > s && (l = s)
    var u = o
    ;(o = i - l), (l = i - u)
  } else {
    for (s = n - i; l < s && a(r, t[e + i + l]) >= 0; )
      (o = l), (l = (l << 1) + 1), l <= 0 && (l = s)
    l > s && (l = s), (o += i), (l += i)
  }
  for (o++; o < l; ) {
    var c = o + ((l - o) >>> 1)
    a(r, t[e + c]) < 0 ? (l = c) : (o = c + 1)
  }
  return l
}
function gQ(r, t) {
  var e = Jf,
    n,
    i,
    a = 0,
    o = []
  ;(n = []), (i = [])
  function s(d, p) {
    ;(n[a] = d), (i[a] = p), (a += 1)
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2
      if (
        (d >= 1 && i[d - 1] <= i[d] + i[d + 1]) ||
        (d >= 2 && i[d - 2] <= i[d] + i[d - 1])
      )
        i[d - 1] < i[d + 1] && d--
      else if (i[d] > i[d + 1]) break
      c(d)
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2
      d > 0 && i[d - 1] < i[d + 1] && d--, c(d)
    }
  }
  function c(d) {
    var p = n[d],
      g = i[d],
      v = n[d + 1],
      m = i[d + 1]
    ;(i[d] = g + m),
      d === a - 3 && ((n[d + 1] = n[d + 2]), (i[d + 1] = i[d + 2])),
      a--
    var y = Xx(r[v], r, p, g, 0, t)
    ;(p += y),
      (g -= y),
      g !== 0 &&
        ((m = Wx(r[p + g - 1], r, v, m, m - 1, t)),
        m !== 0 && (g <= m ? h(p, g, v, m) : f(p, g, v, m)))
  }
  function h(d, p, g, v) {
    var m = 0
    for (m = 0; m < p; m++) o[m] = r[d + m]
    var y = 0,
      _ = g,
      x = d
    if (((r[x++] = r[_++]), --v === 0)) {
      for (m = 0; m < p; m++) r[x + m] = o[y + m]
      return
    }
    if (p === 1) {
      for (m = 0; m < v; m++) r[x + m] = r[_ + m]
      r[x + v] = o[y]
      return
    }
    for (var A = e, S, b, T; ; ) {
      ;(S = 0), (b = 0), (T = !1)
      do
        if (t(r[_], o[y]) < 0) {
          if (((r[x++] = r[_++]), b++, (S = 0), --v === 0)) {
            T = !0
            break
          }
        } else if (((r[x++] = o[y++]), S++, (b = 0), --p === 1)) {
          T = !0
          break
        }
      while ((S | b) < A)
      if (T) break
      do {
        if (((S = Xx(r[_], o, y, p, 0, t)), S !== 0)) {
          for (m = 0; m < S; m++) r[x + m] = o[y + m]
          if (((x += S), (y += S), (p -= S), p <= 1)) {
            T = !0
            break
          }
        }
        if (((r[x++] = r[_++]), --v === 0)) {
          T = !0
          break
        }
        if (((b = Wx(o[y], r, _, v, 0, t)), b !== 0)) {
          for (m = 0; m < b; m++) r[x + m] = r[_ + m]
          if (((x += b), (_ += b), (v -= b), v === 0)) {
            T = !0
            break
          }
        }
        if (((r[x++] = o[y++]), --p === 1)) {
          T = !0
          break
        }
        A--
      } while (S >= Jf || b >= Jf)
      if (T) break
      A < 0 && (A = 0), (A += 2)
    }
    if (((e = A), e < 1 && (e = 1), p === 1)) {
      for (m = 0; m < v; m++) r[x + m] = r[_ + m]
      r[x + v] = o[y]
    } else {
      if (p === 0) throw new Error()
      for (m = 0; m < p; m++) r[x + m] = o[y + m]
    }
  }
  function f(d, p, g, v) {
    var m = 0
    for (m = 0; m < v; m++) o[m] = r[g + m]
    var y = d + p - 1,
      _ = v - 1,
      x = g + v - 1,
      A = 0,
      S = 0
    if (((r[x--] = r[y--]), --p === 0)) {
      for (A = x - (v - 1), m = 0; m < v; m++) r[A + m] = o[m]
      return
    }
    if (v === 1) {
      for (x -= p, y -= p, S = x + 1, A = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[A + m]
      r[x] = o[_]
      return
    }
    for (var b = e; ; ) {
      var T = 0,
        w = 0,
        M = !1
      do
        if (t(o[_], r[y]) < 0) {
          if (((r[x--] = r[y--]), T++, (w = 0), --p === 0)) {
            M = !0
            break
          }
        } else if (((r[x--] = o[_--]), w++, (T = 0), --v === 1)) {
          M = !0
          break
        }
      while ((T | w) < b)
      if (M) break
      do {
        if (((T = p - Xx(o[_], r, d, p, p - 1, t)), T !== 0)) {
          for (
            x -= T, y -= T, p -= T, S = x + 1, A = y + 1, m = T - 1;
            m >= 0;
            m--
          )
            r[S + m] = r[A + m]
          if (p === 0) {
            M = !0
            break
          }
        }
        if (((r[x--] = o[_--]), --v === 1)) {
          M = !0
          break
        }
        if (((w = v - Wx(r[y], o, 0, v, v - 1, t)), w !== 0)) {
          for (x -= w, _ -= w, v -= w, S = x + 1, A = _ + 1, m = 0; m < w; m++)
            r[S + m] = o[A + m]
          if (v <= 1) {
            M = !0
            break
          }
        }
        if (((r[x--] = r[y--]), --p === 0)) {
          M = !0
          break
        }
        b--
      } while (T >= Jf || w >= Jf)
      if (M) break
      b < 0 && (b = 0), (b += 2)
    }
    if (((e = b), e < 1 && (e = 1), v === 1)) {
      for (x -= p, y -= p, S = x + 1, A = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[A + m]
      r[x] = o[_]
    } else {
      if (v === 0) throw new Error()
      for (A = x - (v - 1), m = 0; m < v; m++) r[A + m] = o[m]
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s,
  }
}
function $m(r, t, e, n) {
  e || (e = 0), n || (n = r.length)
  var i = n - e
  if (!(i < 2)) {
    var a = 0
    if (i < uz) {
      ;(a = NL(r, e, n, t)), kL(r, e, n, e + a, t)
      return
    }
    var o = gQ(r, t),
      s = pQ(i)
    do {
      if (((a = NL(r, e, n, t)), a < s)) {
        var l = i
        l > s && (l = s), kL(r, e, e + l, e + a, t), (a = l)
      }
      o.pushRun(e, a), o.mergeRuns(), (i -= a), (e += a)
    } while (i !== 0)
    o.forceMergeRuns()
  }
}
var yi = 1,
  Od = 2,
  oh = 4,
  BL = !1
function Yx() {
  BL ||
    ((BL = !0),
    console.warn(
      'z / z2 / zlevel of displayable is invalid, which may cause unexpected errors',
    ))
}
function FL(r, t) {
  return r.zlevel === t.zlevel
    ? r.z === t.z
      ? r.z2 - t.z2
      : r.z - t.z
    : r.zlevel - t.zlevel
}
var mQ = (function () {
  function r() {
    ;(this._roots = []),
      (this._displayList = []),
      (this._displayListLen = 0),
      (this.displayableSortFunc = FL)
  }
  return (
    (r.prototype.traverse = function (t, e) {
      for (var n = 0; n < this._roots.length; n++) this._roots[n].traverse(t, e)
    }),
    (r.prototype.getDisplayList = function (t, e) {
      e = e || !1
      var n = this._displayList
      return (t || !n.length) && this.updateDisplayList(e), n
    }),
    (r.prototype.updateDisplayList = function (t) {
      this._displayListLen = 0
      for (
        var e = this._roots, n = this._displayList, i = 0, a = e.length;
        i < a;
        i++
      )
        this._updateAndAddDisplayable(e[i], null, t)
      ;(n.length = this._displayListLen), $m(n, FL)
    }),
    (r.prototype._updateAndAddDisplayable = function (t, e, n) {
      if (!(t.ignore && !n)) {
        t.beforeUpdate(), t.update(), t.afterUpdate()
        var i = t.getClipPath()
        if (t.ignoreClip) e = null
        else if (i) {
          e ? (e = e.slice()) : (e = [])
          for (var a = i, o = t; a; )
            (a.parent = o),
              a.updateTransform(),
              e.push(a),
              (o = a),
              (a = a.getClipPath())
        }
        if (t.childrenRef) {
          for (var s = t.childrenRef(), l = 0; l < s.length; l++) {
            var u = s[l]
            t.__dirty && (u.__dirty |= yi),
              this._updateAndAddDisplayable(u, e, n)
          }
          t.__dirty = 0
        } else {
          var c = t
          e && e.length
            ? (c.__clipPaths = e)
            : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []),
            isNaN(c.z) && (Yx(), (c.z = 0)),
            isNaN(c.z2) && (Yx(), (c.z2 = 0)),
            isNaN(c.zlevel) && (Yx(), (c.zlevel = 0)),
            (this._displayList[this._displayListLen++] = c)
        }
        var h = t.getDecalElement && t.getDecalElement()
        h && this._updateAndAddDisplayable(h, e, n)
        var f = t.getTextGuideLine()
        f && this._updateAndAddDisplayable(f, e, n)
        var d = t.getTextContent()
        d && this._updateAndAddDisplayable(d, e, n)
      }
    }),
    (r.prototype.addRoot = function (t) {
      ;(t.__zr && t.__zr.storage === this) || this._roots.push(t)
    }),
    (r.prototype.delRoot = function (t) {
      if (t instanceof Array) {
        for (var e = 0, n = t.length; e < n; e++) this.delRoot(t[e])
        return
      }
      var i = re(this._roots, t)
      i >= 0 && this._roots.splice(i, 1)
    }),
    (r.prototype.delAllRoots = function () {
      ;(this._roots = []), (this._displayList = []), (this._displayListLen = 0)
    }),
    (r.prototype.getRoots = function () {
      return this._roots
    }),
    (r.prototype.dispose = function () {
      ;(this._displayList = null), (this._roots = null)
    }),
    r
  )
})()
const yQ = mQ
var cz
cz =
  (Se.hasGlobalWindow &&
    ((window.requestAnimationFrame &&
      window.requestAnimationFrame.bind(window)) ||
      (window.msRequestAnimationFrame &&
        window.msRequestAnimationFrame.bind(window)) ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame)) ||
  function (r) {
    return setTimeout(r, 16)
  }
const Nb = cz
var qm = {
  linear: function (r) {
    return r
  },
  quadraticIn: function (r) {
    return r * r
  },
  quadraticOut: function (r) {
    return r * (2 - r)
  },
  quadraticInOut: function (r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1)
  },
  cubicIn: function (r) {
    return r * r * r
  },
  cubicOut: function (r) {
    return --r * r * r + 1
  },
  cubicInOut: function (r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2)
  },
  quarticIn: function (r) {
    return r * r * r * r
  },
  quarticOut: function (r) {
    return 1 - --r * r * r * r
  },
  quarticInOut: function (r) {
    return (r *= 2) < 1
      ? 0.5 * r * r * r * r
      : -0.5 * ((r -= 2) * r * r * r - 2)
  },
  quinticIn: function (r) {
    return r * r * r * r * r
  },
  quinticOut: function (r) {
    return --r * r * r * r * r + 1
  },
  quinticInOut: function (r) {
    return (r *= 2) < 1
      ? 0.5 * r * r * r * r * r
      : 0.5 * ((r -= 2) * r * r * r * r + 2)
  },
  sinusoidalIn: function (r) {
    return 1 - Math.cos((r * Math.PI) / 2)
  },
  sinusoidalOut: function (r) {
    return Math.sin((r * Math.PI) / 2)
  },
  sinusoidalInOut: function (r) {
    return 0.5 * (1 - Math.cos(Math.PI * r))
  },
  exponentialIn: function (r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1)
  },
  exponentialOut: function (r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r)
  },
  exponentialInOut: function (r) {
    return r === 0
      ? 0
      : r === 1
      ? 1
      : (r *= 2) < 1
      ? 0.5 * Math.pow(1024, r - 1)
      : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2)
  },
  circularIn: function (r) {
    return 1 - Math.sqrt(1 - r * r)
  },
  circularOut: function (r) {
    return Math.sqrt(1 - --r * r)
  },
  circularInOut: function (r) {
    return (r *= 2) < 1
      ? -0.5 * (Math.sqrt(1 - r * r) - 1)
      : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1)
  },
  elasticIn: function (r) {
    var t,
      e = 0.1,
      n = 0.4
    return r === 0
      ? 0
      : r === 1
      ? 1
      : (!e || e < 1
          ? ((e = 1), (t = n / 4))
          : (t = (n * Math.asin(1 / e)) / (2 * Math.PI)),
        -(
          e *
          Math.pow(2, 10 * (r -= 1)) *
          Math.sin(((r - t) * (2 * Math.PI)) / n)
        ))
  },
  elasticOut: function (r) {
    var t,
      e = 0.1,
      n = 0.4
    return r === 0
      ? 0
      : r === 1
      ? 1
      : (!e || e < 1
          ? ((e = 1), (t = n / 4))
          : (t = (n * Math.asin(1 / e)) / (2 * Math.PI)),
        e * Math.pow(2, -10 * r) * Math.sin(((r - t) * (2 * Math.PI)) / n) + 1)
  },
  elasticInOut: function (r) {
    var t,
      e = 0.1,
      n = 0.4
    return r === 0
      ? 0
      : r === 1
      ? 1
      : (!e || e < 1
          ? ((e = 1), (t = n / 4))
          : (t = (n * Math.asin(1 / e)) / (2 * Math.PI)),
        (r *= 2) < 1
          ? -0.5 *
            (e *
              Math.pow(2, 10 * (r -= 1)) *
              Math.sin(((r - t) * (2 * Math.PI)) / n))
          : e *
              Math.pow(2, -10 * (r -= 1)) *
              Math.sin(((r - t) * (2 * Math.PI)) / n) *
              0.5 +
            1)
  },
  backIn: function (r) {
    var t = 1.70158
    return r * r * ((t + 1) * r - t)
  },
  backOut: function (r) {
    var t = 1.70158
    return --r * r * ((t + 1) * r + t) + 1
  },
  backInOut: function (r) {
    var t = 2.5949095
    return (r *= 2) < 1
      ? 0.5 * (r * r * ((t + 1) * r - t))
      : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2)
  },
  bounceIn: function (r) {
    return 1 - qm.bounceOut(1 - r)
  },
  bounceOut: function (r) {
    return r < 1 / 2.75
      ? 7.5625 * r * r
      : r < 2 / 2.75
      ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75
      : r < 2.5 / 2.75
      ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375
      : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375
  },
  bounceInOut: function (r) {
    return r < 0.5
      ? qm.bounceIn(r * 2) * 0.5
      : qm.bounceOut(r * 2 - 1) * 0.5 + 0.5
  },
}
const hz = qm
var Pg = Math.pow,
  Ks = Math.sqrt,
  By = 1e-8,
  fz = 1e-4,
  zL = Ks(3),
  Rg = 1 / 3,
  Ka = tc(),
  Gi = tc(),
  Ph = tc()
function zs(r) {
  return r > -By && r < By
}
function dz(r) {
  return r > By || r < -By
}
function Wn(r, t, e, n, i) {
  var a = 1 - i
  return a * a * (a * r + 3 * i * t) + i * i * (i * n + 3 * a * e)
}
function UL(r, t, e, n, i) {
  var a = 1 - i
  return 3 * (((t - r) * a + 2 * (e - t) * i) * a + (n - e) * i * i)
}
function Fy(r, t, e, n, i, a) {
  var o = n + 3 * (t - e) - r,
    s = 3 * (e - t * 2 + r),
    l = 3 * (t - r),
    u = r - i,
    c = s * s - 3 * o * l,
    h = s * l - 9 * o * u,
    f = l * l - 3 * s * u,
    d = 0
  if (zs(c) && zs(h))
    if (zs(s)) a[0] = 0
    else {
      var p = -l / s
      p >= 0 && p <= 1 && (a[d++] = p)
    }
  else {
    var g = h * h - 4 * c * f
    if (zs(g)) {
      var v = h / c,
        p = -s / o + v,
        m = -v / 2
      p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m)
    } else if (g > 0) {
      var y = Ks(g),
        _ = c * s + 1.5 * o * (-h + y),
        x = c * s + 1.5 * o * (-h - y)
      _ < 0 ? (_ = -Pg(-_, Rg)) : (_ = Pg(_, Rg)),
        x < 0 ? (x = -Pg(-x, Rg)) : (x = Pg(x, Rg))
      var p = (-s - (_ + x)) / (3 * o)
      p >= 0 && p <= 1 && (a[d++] = p)
    } else {
      var A = (2 * c * s - 3 * o * h) / (2 * Ks(c * c * c)),
        S = Math.acos(A) / 3,
        b = Ks(c),
        T = Math.cos(S),
        p = (-s - 2 * b * T) / (3 * o),
        m = (-s + b * (T + zL * Math.sin(S))) / (3 * o),
        w = (-s + b * (T - zL * Math.sin(S))) / (3 * o)
      p >= 0 && p <= 1 && (a[d++] = p),
        m >= 0 && m <= 1 && (a[d++] = m),
        w >= 0 && w <= 1 && (a[d++] = w)
    }
  }
  return d
}
function pz(r, t, e, n, i) {
  var a = 6 * e - 12 * t + 6 * r,
    o = 9 * t + 3 * n - 3 * r - 9 * e,
    s = 3 * t - 3 * r,
    l = 0
  if (zs(o)) {
    if (dz(a)) {
      var u = -s / a
      u >= 0 && u <= 1 && (i[l++] = u)
    }
  } else {
    var c = a * a - 4 * o * s
    if (zs(c)) i[0] = -a / (2 * o)
    else if (c > 0) {
      var h = Ks(c),
        u = (-a + h) / (2 * o),
        f = (-a - h) / (2 * o)
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f)
    }
  }
  return l
}
function il(r, t, e, n, i, a) {
  var o = (t - r) * i + r,
    s = (e - t) * i + t,
    l = (n - e) * i + e,
    u = (s - o) * i + o,
    c = (l - s) * i + s,
    h = (c - u) * i + u
  ;(a[0] = r),
    (a[1] = o),
    (a[2] = u),
    (a[3] = h),
    (a[4] = h),
    (a[5] = c),
    (a[6] = l),
    (a[7] = n)
}
function vz(r, t, e, n, i, a, o, s, l, u, c) {
  var h,
    f = 0.005,
    d = 1 / 0,
    p,
    g,
    v,
    m
  ;(Ka[0] = l), (Ka[1] = u)
  for (var y = 0; y < 1; y += 0.05)
    (Gi[0] = Wn(r, e, i, o, y)),
      (Gi[1] = Wn(t, n, a, s, y)),
      (v = Lu(Ka, Gi)),
      v < d && ((h = y), (d = v))
  d = 1 / 0
  for (var _ = 0; _ < 32 && !(f < fz); _++)
    (p = h - f),
      (g = h + f),
      (Gi[0] = Wn(r, e, i, o, p)),
      (Gi[1] = Wn(t, n, a, s, p)),
      (v = Lu(Gi, Ka)),
      p >= 0 && v < d
        ? ((h = p), (d = v))
        : ((Ph[0] = Wn(r, e, i, o, g)),
          (Ph[1] = Wn(t, n, a, s, g)),
          (m = Lu(Ph, Ka)),
          g <= 1 && m < d ? ((h = g), (d = m)) : (f *= 0.5))
  return c && ((c[0] = Wn(r, e, i, o, h)), (c[1] = Wn(t, n, a, s, h))), Ks(d)
}
function _Q(r, t, e, n, i, a, o, s, l) {
  for (var u = r, c = t, h = 0, f = 1 / l, d = 1; d <= l; d++) {
    var p = d * f,
      g = Wn(r, e, i, o, p),
      v = Wn(t, n, a, s, p),
      m = g - u,
      y = v - c
    ;(h += Math.sqrt(m * m + y * y)), (u = g), (c = v)
  }
  return h
}
function tr(r, t, e, n) {
  var i = 1 - n
  return i * (i * r + 2 * n * t) + n * n * e
}
function kb(r, t, e, n) {
  return 2 * ((1 - n) * (t - r) + n * (e - t))
}
function xQ(r, t, e, n, i) {
  var a = r - 2 * t + e,
    o = 2 * (t - r),
    s = r - n,
    l = 0
  if (zs(a)) {
    if (dz(o)) {
      var u = -s / o
      u >= 0 && u <= 1 && (i[l++] = u)
    }
  } else {
    var c = o * o - 4 * a * s
    if (zs(c)) {
      var u = -o / (2 * a)
      u >= 0 && u <= 1 && (i[l++] = u)
    } else if (c > 0) {
      var h = Ks(c),
        u = (-o + h) / (2 * a),
        f = (-o - h) / (2 * a)
      u >= 0 && u <= 1 && (i[l++] = u), f >= 0 && f <= 1 && (i[l++] = f)
    }
  }
  return l
}
function gz(r, t, e) {
  var n = r + e - 2 * t
  return n === 0 ? 0.5 : (r - t) / n
}
function Bp(r, t, e, n, i) {
  var a = (t - r) * n + r,
    o = (e - t) * n + t,
    s = (o - a) * n + a
  ;(i[0] = r), (i[1] = a), (i[2] = s), (i[3] = s), (i[4] = o), (i[5] = e)
}
function mz(r, t, e, n, i, a, o, s, l) {
  var u,
    c = 0.005,
    h = 1 / 0
  ;(Ka[0] = o), (Ka[1] = s)
  for (var f = 0; f < 1; f += 0.05) {
    ;(Gi[0] = tr(r, e, i, f)), (Gi[1] = tr(t, n, a, f))
    var d = Lu(Ka, Gi)
    d < h && ((u = f), (h = d))
  }
  h = 1 / 0
  for (var p = 0; p < 32 && !(c < fz); p++) {
    var g = u - c,
      v = u + c
    ;(Gi[0] = tr(r, e, i, g)), (Gi[1] = tr(t, n, a, g))
    var d = Lu(Gi, Ka)
    if (g >= 0 && d < h) (u = g), (h = d)
    else {
      ;(Ph[0] = tr(r, e, i, v)), (Ph[1] = tr(t, n, a, v))
      var m = Lu(Ph, Ka)
      v <= 1 && m < h ? ((u = v), (h = m)) : (c *= 0.5)
    }
  }
  return l && ((l[0] = tr(r, e, i, u)), (l[1] = tr(t, n, a, u))), Ks(h)
}
function SQ(r, t, e, n, i, a, o) {
  for (var s = r, l = t, u = 0, c = 1 / o, h = 1; h <= o; h++) {
    var f = h * c,
      d = tr(r, e, i, f),
      p = tr(t, n, a, f),
      g = d - s,
      v = p - l
    ;(u += Math.sqrt(g * g + v * v)), (s = d), (l = p)
  }
  return u
}
var AQ = /cubic-bezier\(([0-9,\.e ]+)\)/
function OT(r) {
  var t = r && AQ.exec(r)
  if (t) {
    var e = t[1].split(','),
      n = +xa(e[0]),
      i = +xa(e[1]),
      a = +xa(e[2]),
      o = +xa(e[3])
    if (isNaN(n + i + a + o)) return
    var s = []
    return function (l) {
      return l <= 0
        ? 0
        : l >= 1
        ? 1
        : Fy(0, n, a, 1, l, s) && Wn(0, i, o, 1, s[0])
    }
  }
}
var bQ = (function () {
  function r(t) {
    ;(this._inited = !1),
      (this._startTime = 0),
      (this._pausedTime = 0),
      (this._paused = !1),
      (this._life = t.life || 1e3),
      (this._delay = t.delay || 0),
      (this.loop = t.loop || !1),
      (this.onframe = t.onframe || wn),
      (this.ondestroy = t.ondestroy || wn),
      (this.onrestart = t.onrestart || wn),
      t.easing && this.setEasing(t.easing)
  }
  return (
    (r.prototype.step = function (t, e) {
      if (
        (this._inited ||
          ((this._startTime = t + this._delay), (this._inited = !0)),
        this._paused)
      ) {
        this._pausedTime += e
        return
      }
      var n = this._life,
        i = t - this._startTime - this._pausedTime,
        a = i / n
      a < 0 && (a = 0), (a = Math.min(a, 1))
      var o = this.easingFunc,
        s = o ? o(a) : a
      if ((this.onframe(s), a === 1))
        if (this.loop) {
          var l = i % n
          ;(this._startTime = t - l), (this._pausedTime = 0), this.onrestart()
        } else return !0
      return !1
    }),
    (r.prototype.pause = function () {
      this._paused = !0
    }),
    (r.prototype.resume = function () {
      this._paused = !1
    }),
    (r.prototype.setEasing = function (t) {
      ;(this.easing = t), (this.easingFunc = Nt(t) ? t : hz[t] || OT(t))
    }),
    r
  )
})()
const wQ = bQ
var yz = (function () {
    function r(t) {
      this.value = t
    }
    return r
  })(),
  MQ = (function () {
    function r() {
      this._len = 0
    }
    return (
      (r.prototype.insert = function (t) {
        var e = new yz(t)
        return this.insertEntry(e), e
      }),
      (r.prototype.insertEntry = function (t) {
        this.head
          ? ((this.tail.next = t),
            (t.prev = this.tail),
            (t.next = null),
            (this.tail = t))
          : (this.head = this.tail = t),
          this._len++
      }),
      (r.prototype.remove = function (t) {
        var e = t.prev,
          n = t.next
        e ? (e.next = n) : (this.head = n),
          n ? (n.prev = e) : (this.tail = e),
          (t.next = t.prev = null),
          this._len--
      }),
      (r.prototype.len = function () {
        return this._len
      }),
      (r.prototype.clear = function () {
        ;(this.head = this.tail = null), (this._len = 0)
      }),
      r
    )
  })(),
  TQ = (function () {
    function r(t) {
      ;(this._list = new MQ()),
        (this._maxSize = 10),
        (this._map = {}),
        (this._maxSize = t)
    }
    return (
      (r.prototype.put = function (t, e) {
        var n = this._list,
          i = this._map,
          a = null
        if (i[t] == null) {
          var o = n.len(),
            s = this._lastRemovedEntry
          if (o >= this._maxSize && o > 0) {
            var l = n.head
            n.remove(l),
              delete i[l.key],
              (a = l.value),
              (this._lastRemovedEntry = l)
          }
          s ? (s.value = e) : (s = new yz(e)),
            (s.key = t),
            n.insertEntry(s),
            (i[t] = s)
        }
        return a
      }),
      (r.prototype.get = function (t) {
        var e = this._map[t],
          n = this._list
        if (e != null)
          return e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value
      }),
      (r.prototype.clear = function () {
        this._list.clear(), (this._map = {})
      }),
      (r.prototype.len = function () {
        return this._list.len()
      }),
      r
    )
  })()
const gv = TQ
var VL = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1],
}
function Aa(r) {
  return (r = Math.round(r)), r < 0 ? 0 : r > 255 ? 255 : r
}
function CQ(r) {
  return (r = Math.round(r)), r < 0 ? 0 : r > 360 ? 360 : r
}
function Fp(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r
}
function $x(r) {
  var t = r
  return t.length && t.charAt(t.length - 1) === '%'
    ? Aa((parseFloat(t) / 100) * 255)
    : Aa(parseInt(t, 10))
}
function Pu(r) {
  var t = r
  return t.length && t.charAt(t.length - 1) === '%'
    ? Fp(parseFloat(t) / 100)
    : Fp(parseFloat(t))
}
function qx(r, t, e) {
  return (
    e < 0 ? (e += 1) : e > 1 && (e -= 1),
    e * 6 < 1
      ? r + (t - r) * e * 6
      : e * 2 < 1
      ? t
      : e * 3 < 2
      ? r + (t - r) * (2 / 3 - e) * 6
      : r
  )
}
function Us(r, t, e) {
  return r + (t - r) * e
}
function Ni(r, t, e, n, i) {
  return (r[0] = t), (r[1] = e), (r[2] = n), (r[3] = i), r
}
function Bb(r, t) {
  return (r[0] = t[0]), (r[1] = t[1]), (r[2] = t[2]), (r[3] = t[3]), r
}
var _z = new gv(20),
  Ig = null
function zc(r, t) {
  Ig && Bb(Ig, t), (Ig = _z.put(r, Ig || t.slice()))
}
function wi(r, t) {
  if (r) {
    t = t || []
    var e = _z.get(r)
    if (e) return Bb(t, e)
    r = r + ''
    var n = r.replace(/ /g, '').toLowerCase()
    if (n in VL) return Bb(t, VL[n]), zc(r, t), t
    var i = n.length
    if (n.charAt(0) === '#') {
      if (i === 4 || i === 5) {
        var a = parseInt(n.slice(1, 4), 16)
        if (!(a >= 0 && a <= 4095)) {
          Ni(t, 0, 0, 0, 1)
          return
        }
        return (
          Ni(
            t,
            ((a & 3840) >> 4) | ((a & 3840) >> 8),
            (a & 240) | ((a & 240) >> 4),
            (a & 15) | ((a & 15) << 4),
            i === 5 ? parseInt(n.slice(4), 16) / 15 : 1,
          ),
          zc(r, t),
          t
        )
      } else if (i === 7 || i === 9) {
        var a = parseInt(n.slice(1, 7), 16)
        if (!(a >= 0 && a <= 16777215)) {
          Ni(t, 0, 0, 0, 1)
          return
        }
        return (
          Ni(
            t,
            (a & 16711680) >> 16,
            (a & 65280) >> 8,
            a & 255,
            i === 9 ? parseInt(n.slice(7), 16) / 255 : 1,
          ),
          zc(r, t),
          t
        )
      }
      return
    }
    var o = n.indexOf('('),
      s = n.indexOf(')')
    if (o !== -1 && s + 1 === i) {
      var l = n.substr(0, o),
        u = n.substr(o + 1, s - (o + 1)).split(','),
        c = 1
      switch (l) {
        case 'rgba':
          if (u.length !== 4)
            return u.length === 3
              ? Ni(t, +u[0], +u[1], +u[2], 1)
              : Ni(t, 0, 0, 0, 1)
          c = Pu(u.pop())
        case 'rgb':
          if (u.length >= 3)
            return (
              Ni(
                t,
                $x(u[0]),
                $x(u[1]),
                $x(u[2]),
                u.length === 3 ? c : Pu(u[3]),
              ),
              zc(r, t),
              t
            )
          Ni(t, 0, 0, 0, 1)
          return
        case 'hsla':
          if (u.length !== 4) {
            Ni(t, 0, 0, 0, 1)
            return
          }
          return (u[3] = Pu(u[3])), Fb(u, t), zc(r, t), t
        case 'hsl':
          if (u.length !== 3) {
            Ni(t, 0, 0, 0, 1)
            return
          }
          return Fb(u, t), zc(r, t), t
        default:
          return
      }
    }
    Ni(t, 0, 0, 0, 1)
  }
}
function Fb(r, t) {
  var e = (((parseFloat(r[0]) % 360) + 360) % 360) / 360,
    n = Pu(r[1]),
    i = Pu(r[2]),
    a = i <= 0.5 ? i * (n + 1) : i + n - i * n,
    o = i * 2 - a
  return (
    (t = t || []),
    Ni(
      t,
      Aa(qx(o, a, e + 1 / 3) * 255),
      Aa(qx(o, a, e) * 255),
      Aa(qx(o, a, e - 1 / 3) * 255),
      1,
    ),
    r.length === 4 && (t[3] = r[3]),
    t
  )
}
function EQ(r) {
  if (r) {
    var t = r[0] / 255,
      e = r[1] / 255,
      n = r[2] / 255,
      i = Math.min(t, e, n),
      a = Math.max(t, e, n),
      o = a - i,
      s = (a + i) / 2,
      l,
      u
    if (o === 0) (l = 0), (u = 0)
    else {
      s < 0.5 ? (u = o / (a + i)) : (u = o / (2 - a - i))
      var c = ((a - t) / 6 + o / 2) / o,
        h = ((a - e) / 6 + o / 2) / o,
        f = ((a - n) / 6 + o / 2) / o
      t === a
        ? (l = f - h)
        : e === a
        ? (l = 1 / 3 + c - f)
        : n === a && (l = 2 / 3 + h - c),
        l < 0 && (l += 1),
        l > 1 && (l -= 1)
    }
    var d = [l * 360, u, s]
    return r[3] != null && d.push(r[3]), d
  }
}
function zb(r, t) {
  var e = wi(r)
  if (e) {
    for (var n = 0; n < 3; n++)
      t < 0
        ? (e[n] = (e[n] * (1 - t)) | 0)
        : (e[n] = ((255 - e[n]) * t + e[n]) | 0),
        e[n] > 255 ? (e[n] = 255) : e[n] < 0 && (e[n] = 0)
    return Wo(e, e.length === 4 ? 'rgba' : 'rgb')
  }
}
function Zx(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    e = e || []
    var n = r * (t.length - 1),
      i = Math.floor(n),
      a = Math.ceil(n),
      o = t[i],
      s = t[a],
      l = n - i
    return (
      (e[0] = Aa(Us(o[0], s[0], l))),
      (e[1] = Aa(Us(o[1], s[1], l))),
      (e[2] = Aa(Us(o[2], s[2], l))),
      (e[3] = Fp(Us(o[3], s[3], l))),
      e
    )
  }
}
function DQ(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    var n = r * (t.length - 1),
      i = Math.floor(n),
      a = Math.ceil(n),
      o = wi(t[i]),
      s = wi(t[a]),
      l = n - i,
      u = Wo(
        [
          Aa(Us(o[0], s[0], l)),
          Aa(Us(o[1], s[1], l)),
          Aa(Us(o[2], s[2], l)),
          Fp(Us(o[3], s[3], l)),
        ],
        'rgba',
      )
    return e
      ? {
          color: u,
          leftIndex: i,
          rightIndex: a,
          value: n,
        }
      : u
  }
}
function ep(r, t, e, n) {
  var i = wi(r)
  if (r)
    return (
      (i = EQ(i)),
      t != null && (i[0] = CQ(t)),
      e != null && (i[1] = Pu(e)),
      n != null && (i[2] = Pu(n)),
      Wo(Fb(i), 'rgba')
    )
}
function zy(r, t) {
  var e = wi(r)
  if (e && t != null) return (e[3] = Fp(t)), Wo(e, 'rgba')
}
function Wo(r, t) {
  if (!(!r || !r.length)) {
    var e = r[0] + ',' + r[1] + ',' + r[2]
    return (
      (t === 'rgba' || t === 'hsva' || t === 'hsla') && (e += ',' + r[3]),
      t + '(' + e + ')'
    )
  }
}
function Uy(r, t) {
  var e = wi(r)
  return e
    ? ((0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3]) / 255 +
        (1 - e[3]) * t
    : 0
}
var GL = new gv(100)
function Ub(r) {
  if (bt(r)) {
    var t = GL.get(r)
    return t || ((t = zb(r, -0.1)), GL.put(r, t)), t
  } else if ($0(r)) {
    var e = Q({}, r)
    return (
      (e.colorStops = st(r.colorStops, function (n) {
        return {
          offset: n.offset,
          color: zb(n.color, -0.1),
        }
      })),
      e
    )
  }
  return r
}
var Vy = Math.round
function zp(r) {
  var t
  if (!r || r === 'transparent') r = 'none'
  else if (typeof r == 'string' && r.indexOf('rgba') > -1) {
    var e = wi(r)
    e && ((r = 'rgb(' + e[0] + ',' + e[1] + ',' + e[2] + ')'), (t = e[3]))
  }
  return {
    color: r,
    opacity: t ?? 1,
  }
}
var HL = 1e-4
function Vs(r) {
  return r < HL && r > -HL
}
function Og(r) {
  return Vy(r * 1e3) / 1e3
}
function Vb(r) {
  return Vy(r * 1e4) / 1e4
}
function LQ(r) {
  return (
    'matrix(' +
    Og(r[0]) +
    ',' +
    Og(r[1]) +
    ',' +
    Og(r[2]) +
    ',' +
    Og(r[3]) +
    ',' +
    Vb(r[4]) +
    ',' +
    Vb(r[5]) +
    ')'
  )
}
var PQ = {
  left: 'start',
  right: 'end',
  center: 'middle',
  middle: 'middle',
}
function RQ(r, t, e) {
  return e === 'top' ? (r += t / 2) : e === 'bottom' && (r -= t / 2), r
}
function IQ(r) {
  return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY)
}
function OQ(r) {
  var t = r.style,
    e = r.getGlobalScale()
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    e[0],
    e[1],
  ].join(',')
}
function xz(r) {
  return r && !!r.image
}
function NQ(r) {
  return r && !!r.svgElement
}
function NT(r) {
  return xz(r) || NQ(r)
}
function Sz(r) {
  return r.type === 'linear'
}
function Az(r) {
  return r.type === 'radial'
}
function bz(r) {
  return r && (r.type === 'linear' || r.type === 'radial')
}
function K0(r) {
  return 'url(#' + r + ')'
}
function wz(r) {
  var t = r.getGlobalScale(),
    e = Math.max(t[0], t[1])
  return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1)
}
function Mz(r) {
  var t = r.x || 0,
    e = r.y || 0,
    n = (r.rotation || 0) * Wm,
    i = $t(r.scaleX, 1),
    a = $t(r.scaleY, 1),
    o = r.skewX || 0,
    s = r.skewY || 0,
    l = []
  return (
    (t || e) && l.push('translate(' + t + 'px,' + e + 'px)'),
    n && l.push('rotate(' + n + ')'),
    (i !== 1 || a !== 1) && l.push('scale(' + i + ',' + a + ')'),
    (o || s) && l.push('skew(' + Vy(o * Wm) + 'deg, ' + Vy(s * Wm) + 'deg)'),
    l.join(' ')
  )
}
var kQ = (function () {
    return Se.hasGlobalWindow && Nt(window.btoa)
      ? function (r) {
          return window.btoa(unescape(encodeURIComponent(r)))
        }
      : typeof Buffer < 'u'
      ? function (r) {
          return Buffer.from(r).toString('base64')
        }
      : function (r) {
          return null
        }
  })(),
  Gb = Array.prototype.slice
function Oo(r, t, e) {
  return (t - r) * e + r
}
function Kx(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++) r[a] = Oo(t[a], e[a], n)
  return r
}
function BQ(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = [])
    for (var s = 0; s < a; s++) r[o][s] = Oo(t[o][s], e[o][s], n)
  }
  return r
}
function Ng(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++) r[a] = t[a] + e[a] * n
  return r
}
function WL(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = [])
    for (var s = 0; s < a; s++) r[o][s] = t[o][s] + e[o][s] * n
  }
  return r
}
function FQ(r, t) {
  for (
    var e = r.length,
      n = t.length,
      i = e > n ? t : r,
      a = Math.min(e, n),
      o = i[a - 1] || {
        color: [0, 0, 0, 0],
        offset: 0,
      },
      s = a;
    s < Math.max(e, n);
    s++
  )
    i.push({
      offset: o.offset,
      color: o.color.slice(),
    })
}
function zQ(r, t, e) {
  var n = r,
    i = t
  if (!(!n.push || !i.push)) {
    var a = n.length,
      o = i.length
    if (a !== o) {
      var s = a > o
      if (s) n.length = o
      else for (var l = a; l < o; l++) n.push(e === 1 ? i[l] : Gb.call(i[l]))
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (e === 1) isNaN(n[l]) && (n[l] = i[l])
      else for (var c = 0; c < u; c++) isNaN(n[l][c]) && (n[l][c] = i[l][c])
  }
}
function np(r) {
  if (Er(r)) {
    var t = r.length
    if (Er(r[0])) {
      for (var e = [], n = 0; n < t; n++) e.push(Gb.call(r[n]))
      return e
    }
    return Gb.call(r)
  }
  return r
}
function Zm(r) {
  return (
    (r[0] = Math.floor(r[0]) || 0),
    (r[1] = Math.floor(r[1]) || 0),
    (r[2] = Math.floor(r[2]) || 0),
    (r[3] = r[3] == null ? 1 : r[3]),
    'rgba(' + r.join(',') + ')'
  )
}
function UQ(r) {
  return Er(r && r[0]) ? 2 : 1
}
var kg = 0,
  Km = 1,
  Tz = 2,
  Nd = 3,
  Hb = 4,
  Wb = 5,
  XL = 6
function YL(r) {
  return r === Hb || r === Wb
}
function Bg(r) {
  return r === Km || r === Tz
}
var Qf = [0, 0, 0, 0],
  VQ = (function () {
    function r(t) {
      ;(this.keyframes = []),
        (this.discrete = !1),
        (this._invalid = !1),
        (this._needsSort = !1),
        (this._lastFr = 0),
        (this._lastFrP = 0),
        (this.propName = t)
    }
    return (
      (r.prototype.isFinished = function () {
        return this._finished
      }),
      (r.prototype.setFinished = function () {
        ;(this._finished = !0),
          this._additiveTrack && this._additiveTrack.setFinished()
      }),
      (r.prototype.needsAnimate = function () {
        return this.keyframes.length >= 1
      }),
      (r.prototype.getAdditiveTrack = function () {
        return this._additiveTrack
      }),
      (r.prototype.addKeyframe = function (t, e, n) {
        this._needsSort = !0
        var i = this.keyframes,
          a = i.length,
          o = !1,
          s = XL,
          l = e
        if (Er(e)) {
          var u = UQ(e)
          ;(s = u),
            ((u === 1 && !be(e[0])) || (u === 2 && !be(e[0][0]))) && (o = !0)
        } else if (be(e) && !kp(e)) s = kg
        else if (bt(e))
          if (!isNaN(+e)) s = kg
          else {
            var c = wi(e)
            c && ((l = c), (s = Nd))
          }
        else if ($0(e)) {
          var h = Q({}, l)
          ;(h.colorStops = st(e.colorStops, function (d) {
            return {
              offset: d.offset,
              color: wi(d.color),
            }
          })),
            Sz(e) ? (s = Hb) : Az(e) && (s = Wb),
            (l = h)
        }
        a === 0
          ? (this.valType = s)
          : (s !== this.valType || s === XL) && (o = !0),
          (this.discrete = this.discrete || o)
        var f = {
          time: t,
          value: l,
          rawValue: e,
          percent: 0,
        }
        return (
          n && ((f.easing = n), (f.easingFunc = Nt(n) ? n : hz[n] || OT(n))),
          i.push(f),
          f
        )
      }),
      (r.prototype.prepare = function (t, e) {
        var n = this.keyframes
        this._needsSort &&
          n.sort(function (g, v) {
            return g.time - v.time
          })
        for (
          var i = this.valType,
            a = n.length,
            o = n[a - 1],
            s = this.discrete,
            l = Bg(i),
            u = YL(i),
            c = 0;
          c < a;
          c++
        ) {
          var h = n[c],
            f = h.value,
            d = o.value
          ;(h.percent = h.time / t),
            s ||
              (l && c !== a - 1
                ? zQ(f, d, i)
                : u && FQ(f.colorStops, d.colorStops))
        }
        if (
          !s &&
          i !== Wb &&
          e &&
          this.needsAnimate() &&
          e.needsAnimate() &&
          i === e.valType &&
          !e._finished
        ) {
          this._additiveTrack = e
          for (var p = n[0].value, c = 0; c < a; c++)
            i === kg
              ? (n[c].additiveValue = n[c].value - p)
              : i === Nd
              ? (n[c].additiveValue = Ng([], n[c].value, p, -1))
              : Bg(i) &&
                (n[c].additiveValue =
                  i === Km
                    ? Ng([], n[c].value, p, -1)
                    : WL([], n[c].value, p, -1))
        }
      }),
      (r.prototype.step = function (t, e) {
        if (!this._finished) {
          this._additiveTrack &&
            this._additiveTrack._finished &&
            (this._additiveTrack = null)
          var n = this._additiveTrack != null,
            i = n ? 'additiveValue' : 'value',
            a = this.valType,
            o = this.keyframes,
            s = o.length,
            l = this.propName,
            u = a === Nd,
            c,
            h = this._lastFr,
            f = Math.min,
            d,
            p
          if (s === 1) d = p = o[0]
          else {
            if (e < 0) c = 0
            else if (e < this._lastFrP) {
              var g = f(h + 1, s - 1)
              for (c = g; c >= 0 && !(o[c].percent <= e); c--);
              c = f(c, s - 2)
            } else {
              for (c = h; c < s && !(o[c].percent > e); c++);
              c = f(c - 1, s - 2)
            }
            ;(p = o[c + 1]), (d = o[c])
          }
          if (d && p) {
            ;(this._lastFr = c), (this._lastFrP = e)
            var v = p.percent - d.percent,
              m = v === 0 ? 1 : f((e - d.percent) / v, 1)
            p.easingFunc && (m = p.easingFunc(m))
            var y = n ? this._additiveValue : u ? Qf : t[l]
            if (
              ((Bg(a) || u) && !y && (y = this._additiveValue = []),
              this.discrete)
            )
              t[l] = m < 1 ? d.rawValue : p.rawValue
            else if (Bg(a))
              a === Km ? Kx(y, d[i], p[i], m) : BQ(y, d[i], p[i], m)
            else if (YL(a)) {
              var _ = d[i],
                x = p[i],
                A = a === Hb
              ;(t[l] = {
                type: A ? 'linear' : 'radial',
                x: Oo(_.x, x.x, m),
                y: Oo(_.y, x.y, m),
                colorStops: st(_.colorStops, function (b, T) {
                  var w = x.colorStops[T]
                  return {
                    offset: Oo(b.offset, w.offset, m),
                    color: Zm(Kx([], b.color, w.color, m)),
                  }
                }),
                global: x.global,
              }),
                A
                  ? ((t[l].x2 = Oo(_.x2, x.x2, m)),
                    (t[l].y2 = Oo(_.y2, x.y2, m)))
                  : (t[l].r = Oo(_.r, x.r, m))
            } else if (u) Kx(y, d[i], p[i], m), n || (t[l] = Zm(y))
            else {
              var S = Oo(d[i], p[i], m)
              n ? (this._additiveValue = S) : (t[l] = S)
            }
            n && this._addToTarget(t)
          }
        }
      }),
      (r.prototype._addToTarget = function (t) {
        var e = this.valType,
          n = this.propName,
          i = this._additiveValue
        e === kg
          ? (t[n] = t[n] + i)
          : e === Nd
          ? (wi(t[n], Qf), Ng(Qf, Qf, i, 1), (t[n] = Zm(Qf)))
          : e === Km
          ? Ng(t[n], t[n], i, 1)
          : e === Tz && WL(t[n], t[n], i, 1)
      }),
      r
    )
  })(),
  kT = (function () {
    function r(t, e, n, i) {
      if (
        ((this._tracks = {}),
        (this._trackKeys = []),
        (this._maxTime = 0),
        (this._started = 0),
        (this._clip = null),
        (this._target = t),
        (this._loop = e),
        e && i)
      ) {
        CT("Can' use additive animation on looped animation.")
        return
      }
      ;(this._additiveAnimators = i), (this._allowDiscrete = n)
    }
    return (
      (r.prototype.getMaxTime = function () {
        return this._maxTime
      }),
      (r.prototype.getDelay = function () {
        return this._delay
      }),
      (r.prototype.getLoop = function () {
        return this._loop
      }),
      (r.prototype.getTarget = function () {
        return this._target
      }),
      (r.prototype.changeTarget = function (t) {
        this._target = t
      }),
      (r.prototype.when = function (t, e, n) {
        return this.whenWithKeys(t, e, pe(e), n)
      }),
      (r.prototype.whenWithKeys = function (t, e, n, i) {
        for (var a = this._tracks, o = 0; o < n.length; o++) {
          var s = n[o],
            l = a[s]
          if (!l) {
            l = a[s] = new VQ(s)
            var u = void 0,
              c = this._getAdditiveTrack(s)
            if (c) {
              var h = c.keyframes,
                f = h[h.length - 1]
              ;(u = f && f.value), c.valType === Nd && u && (u = Zm(u))
            } else u = this._target[s]
            if (u == null) continue
            t > 0 && l.addKeyframe(0, np(u), i), this._trackKeys.push(s)
          }
          l.addKeyframe(t, np(e[s]), i)
        }
        return (this._maxTime = Math.max(this._maxTime, t)), this
      }),
      (r.prototype.pause = function () {
        this._clip.pause(), (this._paused = !0)
      }),
      (r.prototype.resume = function () {
        this._clip.resume(), (this._paused = !1)
      }),
      (r.prototype.isPaused = function () {
        return !!this._paused
      }),
      (r.prototype.duration = function (t) {
        return (this._maxTime = t), (this._force = !0), this
      }),
      (r.prototype._doneCallback = function () {
        this._setTracksFinished(), (this._clip = null)
        var t = this._doneCbs
        if (t) for (var e = t.length, n = 0; n < e; n++) t[n].call(this)
      }),
      (r.prototype._abortedCallback = function () {
        this._setTracksFinished()
        var t = this.animation,
          e = this._abortedCbs
        if ((t && t.removeClip(this._clip), (this._clip = null), e))
          for (var n = 0; n < e.length; n++) e[n].call(this)
      }),
      (r.prototype._setTracksFinished = function () {
        for (
          var t = this._tracks, e = this._trackKeys, n = 0;
          n < e.length;
          n++
        )
          t[e[n]].setFinished()
      }),
      (r.prototype._getAdditiveTrack = function (t) {
        var e,
          n = this._additiveAnimators
        if (n)
          for (var i = 0; i < n.length; i++) {
            var a = n[i].getTrack(t)
            a && (e = a)
          }
        return e
      }),
      (r.prototype.start = function (t) {
        if (!(this._started > 0)) {
          this._started = 1
          for (
            var e = this, n = [], i = this._maxTime || 0, a = 0;
            a < this._trackKeys.length;
            a++
          ) {
            var o = this._trackKeys[a],
              s = this._tracks[o],
              l = this._getAdditiveTrack(o),
              u = s.keyframes,
              c = u.length
            if ((s.prepare(i, l), s.needsAnimate()))
              if (!this._allowDiscrete && s.discrete) {
                var h = u[c - 1]
                h && (e._target[s.propName] = h.rawValue), s.setFinished()
              } else n.push(s)
          }
          if (n.length || this._force) {
            var f = new wQ({
              life: i,
              loop: this._loop,
              delay: this._delay || 0,
              onframe: function (d) {
                e._started = 2
                var p = e._additiveAnimators
                if (p) {
                  for (var g = !1, v = 0; v < p.length; v++)
                    if (p[v]._clip) {
                      g = !0
                      break
                    }
                  g || (e._additiveAnimators = null)
                }
                for (var v = 0; v < n.length; v++) n[v].step(e._target, d)
                var m = e._onframeCbs
                if (m) for (var v = 0; v < m.length; v++) m[v](e._target, d)
              },
              ondestroy: function () {
                e._doneCallback()
              },
            })
            ;(this._clip = f),
              this.animation && this.animation.addClip(f),
              t && f.setEasing(t)
          } else this._doneCallback()
          return this
        }
      }),
      (r.prototype.stop = function (t) {
        if (this._clip) {
          var e = this._clip
          t && e.onframe(1), this._abortedCallback()
        }
      }),
      (r.prototype.delay = function (t) {
        return (this._delay = t), this
      }),
      (r.prototype.during = function (t) {
        return (
          t &&
            (this._onframeCbs || (this._onframeCbs = []),
            this._onframeCbs.push(t)),
          this
        )
      }),
      (r.prototype.done = function (t) {
        return (
          t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)),
          this
        )
      }),
      (r.prototype.aborted = function (t) {
        return (
          t &&
            (this._abortedCbs || (this._abortedCbs = []),
            this._abortedCbs.push(t)),
          this
        )
      }),
      (r.prototype.getClip = function () {
        return this._clip
      }),
      (r.prototype.getTrack = function (t) {
        return this._tracks[t]
      }),
      (r.prototype.getTracks = function () {
        var t = this
        return st(this._trackKeys, function (e) {
          return t._tracks[e]
        })
      }),
      (r.prototype.stopTracks = function (t, e) {
        if (!t.length || !this._clip) return !0
        for (
          var n = this._tracks, i = this._trackKeys, a = 0;
          a < t.length;
          a++
        ) {
          var o = n[t[a]]
          o &&
            !o.isFinished() &&
            (e
              ? o.step(this._target, 1)
              : this._started === 1 && o.step(this._target, 0),
            o.setFinished())
        }
        for (var s = !0, a = 0; a < i.length; a++)
          if (!n[i[a]].isFinished()) {
            s = !1
            break
          }
        return s && this._abortedCallback(), s
      }),
      (r.prototype.saveTo = function (t, e, n) {
        if (t) {
          e = e || this._trackKeys
          for (var i = 0; i < e.length; i++) {
            var a = e[i],
              o = this._tracks[a]
            if (!(!o || o.isFinished())) {
              var s = o.keyframes,
                l = s[n ? 0 : s.length - 1]
              l && (t[a] = np(l.rawValue))
            }
          }
        }
      }),
      (r.prototype.__changeFinalValue = function (t, e) {
        e = e || pe(t)
        for (var n = 0; n < e.length; n++) {
          var i = e[n],
            a = this._tracks[i]
          if (a) {
            var o = a.keyframes
            if (o.length > 1) {
              var s = o.pop()
              a.addKeyframe(s.time, t[i]),
                a.prepare(this._maxTime, a.getAdditiveTrack())
            }
          }
        }
      }),
      r
    )
  })()
function yh() {
  return new Date().getTime()
}
var GQ = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this) || this
    return (
      (n._running = !1),
      (n._time = 0),
      (n._pausedTime = 0),
      (n._pauseStart = 0),
      (n._paused = !1),
      (e = e || {}),
      (n.stage = e.stage || {}),
      n
    )
  }
  return (
    (t.prototype.addClip = function (e) {
      e.animation && this.removeClip(e),
        this._head
          ? ((this._tail.next = e),
            (e.prev = this._tail),
            (e.next = null),
            (this._tail = e))
          : (this._head = this._tail = e),
        (e.animation = this)
    }),
    (t.prototype.addAnimator = function (e) {
      e.animation = this
      var n = e.getClip()
      n && this.addClip(n)
    }),
    (t.prototype.removeClip = function (e) {
      if (e.animation) {
        var n = e.prev,
          i = e.next
        n ? (n.next = i) : (this._head = i),
          i ? (i.prev = n) : (this._tail = n),
          (e.next = e.prev = e.animation = null)
      }
    }),
    (t.prototype.removeAnimator = function (e) {
      var n = e.getClip()
      n && this.removeClip(n), (e.animation = null)
    }),
    (t.prototype.update = function (e) {
      for (
        var n = yh() - this._pausedTime, i = n - this._time, a = this._head;
        a;

      ) {
        var o = a.next,
          s = a.step(n, i)
        s && (a.ondestroy(), this.removeClip(a)), (a = o)
      }
      ;(this._time = n),
        e ||
          (this.trigger('frame', i), this.stage.update && this.stage.update())
    }),
    (t.prototype._startLoop = function () {
      var e = this
      this._running = !0
      function n() {
        e._running && (Nb(n), !e._paused && e.update())
      }
      Nb(n)
    }),
    (t.prototype.start = function () {
      this._running ||
        ((this._time = yh()), (this._pausedTime = 0), this._startLoop())
    }),
    (t.prototype.stop = function () {
      this._running = !1
    }),
    (t.prototype.pause = function () {
      this._paused || ((this._pauseStart = yh()), (this._paused = !0))
    }),
    (t.prototype.resume = function () {
      this._paused &&
        ((this._pausedTime += yh() - this._pauseStart), (this._paused = !1))
    }),
    (t.prototype.clear = function () {
      for (var e = this._head; e; ) {
        var n = e.next
        ;(e.prev = e.next = e.animation = null), (e = n)
      }
      this._head = this._tail = null
    }),
    (t.prototype.isFinished = function () {
      return this._head == null
    }),
    (t.prototype.animate = function (e, n) {
      ;(n = n || {}), this.start()
      var i = new kT(e, n.loop)
      return this.addAnimator(i), i
    }),
    t
  )
})(ra)
const HQ = GQ
var WQ = 300,
  jx = Se.domSupported,
  Jx = (function () {
    var r = [
        'click',
        'dblclick',
        'mousewheel',
        'wheel',
        'mouseout',
        'mouseup',
        'mousedown',
        'mousemove',
        'contextmenu',
      ],
      t = ['touchstart', 'touchend', 'touchmove'],
      e = {
        pointerdown: 1,
        pointerup: 1,
        pointermove: 1,
        pointerout: 1,
      },
      n = st(r, function (i) {
        var a = i.replace('mouse', 'pointer')
        return e.hasOwnProperty(a) ? a : i
      })
    return {
      mouse: r,
      touch: t,
      pointer: n,
    }
  })(),
  $L = {
    mouse: ['mousemove', 'mouseup'],
    pointer: ['pointermove', 'pointerup'],
  },
  qL = !1
function Xb(r) {
  var t = r.pointerType
  return t === 'pen' || t === 'touch'
}
function XQ(r) {
  ;(r.touching = !0),
    r.touchTimer != null && (clearTimeout(r.touchTimer), (r.touchTimer = null)),
    (r.touchTimer = setTimeout(function () {
      ;(r.touching = !1), (r.touchTimer = null)
    }, 700))
}
function Qx(r) {
  r && (r.zrByTouch = !0)
}
function YQ(r, t) {
  return Fi(r.dom, new $Q(r, t), !0)
}
function Cz(r, t) {
  for (
    var e = t, n = !1;
    e &&
    e.nodeType !== 9 &&
    !(n = e.domBelongToZr || (e !== t && e === r.painterRoot));

  )
    e = e.parentNode
  return n
}
var $Q = (function () {
    function r(t, e) {
      ;(this.stopPropagation = wn),
        (this.stopImmediatePropagation = wn),
        (this.preventDefault = wn),
        (this.type = e.type),
        (this.target = this.currentTarget = t.dom),
        (this.pointerType = e.pointerType),
        (this.clientX = e.clientX),
        (this.clientY = e.clientY)
    }
    return r
  })(),
  da = {
    mousedown: function (r) {
      ;(r = Fi(this.dom, r)),
        (this.__mayPointerCapture = [r.zrX, r.zrY]),
        this.trigger('mousedown', r)
    },
    mousemove: function (r) {
      r = Fi(this.dom, r)
      var t = this.__mayPointerCapture
      t &&
        (r.zrX !== t[0] || r.zrY !== t[1]) &&
        this.__togglePointerCapture(!0),
        this.trigger('mousemove', r)
    },
    mouseup: function (r) {
      ;(r = Fi(this.dom, r)),
        this.__togglePointerCapture(!1),
        this.trigger('mouseup', r)
    },
    mouseout: function (r) {
      r = Fi(this.dom, r)
      var t = r.toElement || r.relatedTarget
      Cz(this, t) ||
        (this.__pointerCapturing && (r.zrEventControl = 'no_globalout'),
        this.trigger('mouseout', r))
    },
    wheel: function (r) {
      ;(qL = !0), (r = Fi(this.dom, r)), this.trigger('mousewheel', r)
    },
    mousewheel: function (r) {
      qL || ((r = Fi(this.dom, r)), this.trigger('mousewheel', r))
    },
    touchstart: function (r) {
      ;(r = Fi(this.dom, r)),
        Qx(r),
        (this.__lastTouchMoment = new Date()),
        this.handler.processGesture(r, 'start'),
        da.mousemove.call(this, r),
        da.mousedown.call(this, r)
    },
    touchmove: function (r) {
      ;(r = Fi(this.dom, r)),
        Qx(r),
        this.handler.processGesture(r, 'change'),
        da.mousemove.call(this, r)
    },
    touchend: function (r) {
      ;(r = Fi(this.dom, r)),
        Qx(r),
        this.handler.processGesture(r, 'end'),
        da.mouseup.call(this, r),
        +new Date() - +this.__lastTouchMoment < WQ && da.click.call(this, r)
    },
    pointerdown: function (r) {
      da.mousedown.call(this, r)
    },
    pointermove: function (r) {
      Xb(r) || da.mousemove.call(this, r)
    },
    pointerup: function (r) {
      da.mouseup.call(this, r)
    },
    pointerout: function (r) {
      Xb(r) || da.mouseout.call(this, r)
    },
  }
R(['click', 'dblclick', 'contextmenu'], function (r) {
  da[r] = function (t) {
    ;(t = Fi(this.dom, t)), this.trigger(r, t)
  }
})
var Yb = {
  pointermove: function (r) {
    Xb(r) || Yb.mousemove.call(this, r)
  },
  pointerup: function (r) {
    Yb.mouseup.call(this, r)
  },
  mousemove: function (r) {
    this.trigger('mousemove', r)
  },
  mouseup: function (r) {
    var t = this.__pointerCapturing
    this.__togglePointerCapture(!1),
      this.trigger('mouseup', r),
      t && ((r.zrEventControl = 'only_globalout'), this.trigger('mouseout', r))
  },
}
function qQ(r, t) {
  var e = t.domHandlers
  Se.pointerEventsSupported
    ? R(Jx.pointer, function (n) {
        jm(t, n, function (i) {
          e[n].call(r, i)
        })
      })
    : (Se.touchEventsSupported &&
        R(Jx.touch, function (n) {
          jm(t, n, function (i) {
            e[n].call(r, i), XQ(t)
          })
        }),
      R(Jx.mouse, function (n) {
        jm(t, n, function (i) {
          ;(i = PT(i)), t.touching || e[n].call(r, i)
        })
      }))
}
function ZQ(r, t) {
  Se.pointerEventsSupported
    ? R($L.pointer, e)
    : Se.touchEventsSupported || R($L.mouse, e)
  function e(n) {
    function i(a) {
      ;(a = PT(a)),
        Cz(r, a.target) || ((a = YQ(r, a)), t.domHandlers[n].call(r, a))
    }
    jm(t, n, i, {
      capture: !0,
    })
  }
}
function jm(r, t, e, n) {
  ;(r.mounted[t] = e), (r.listenerOpts[t] = n), Ob(r.domTarget, t, e, n)
}
function t1(r) {
  var t = r.mounted
  for (var e in t)
    t.hasOwnProperty(e) && nQ(r.domTarget, e, t[e], r.listenerOpts[e])
  r.mounted = {}
}
var ZL = (function () {
    function r(t, e) {
      ;(this.mounted = {}),
        (this.listenerOpts = {}),
        (this.touching = !1),
        (this.domTarget = t),
        (this.domHandlers = e)
    }
    return r
  })(),
  KQ = (function (r) {
    X(t, r)
    function t(e, n) {
      var i = r.call(this) || this
      return (
        (i.__pointerCapturing = !1),
        (i.dom = e),
        (i.painterRoot = n),
        (i._localHandlerScope = new ZL(e, da)),
        jx && (i._globalHandlerScope = new ZL(document, Yb)),
        qQ(i, i._localHandlerScope),
        i
      )
    }
    return (
      (t.prototype.dispose = function () {
        t1(this._localHandlerScope), jx && t1(this._globalHandlerScope)
      }),
      (t.prototype.setCursor = function (e) {
        this.dom.style && (this.dom.style.cursor = e || 'default')
      }),
      (t.prototype.__togglePointerCapture = function (e) {
        if (
          ((this.__mayPointerCapture = null),
          jx && +this.__pointerCapturing ^ +e)
        ) {
          this.__pointerCapturing = e
          var n = this._globalHandlerScope
          e ? ZQ(this, n) : t1(n)
        }
      }),
      t
    )
  })(ra)
const jQ = KQ
var Ez = 1
Se.hasGlobalWindow &&
  (Ez = Math.max(
    window.devicePixelRatio ||
      (window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI) ||
      1,
    1,
  ))
var Gy = Ez,
  $b = 0.4,
  qb = '#333',
  Zb = '#ccc',
  JQ = '#eee',
  KL = Z0,
  jL = 5e-5
function Il(r) {
  return r > jL || r < -jL
}
var Ol = [],
  Uc = [],
  e1 = bi(),
  n1 = Math.abs,
  QQ = (function () {
    function r() {}
    return (
      (r.prototype.getLocalTransform = function (t) {
        return r.getLocalTransform(this, t)
      }),
      (r.prototype.setPosition = function (t) {
        ;(this.x = t[0]), (this.y = t[1])
      }),
      (r.prototype.setScale = function (t) {
        ;(this.scaleX = t[0]), (this.scaleY = t[1])
      }),
      (r.prototype.setSkew = function (t) {
        ;(this.skewX = t[0]), (this.skewY = t[1])
      }),
      (r.prototype.setOrigin = function (t) {
        ;(this.originX = t[0]), (this.originY = t[1])
      }),
      (r.prototype.needLocalTransform = function () {
        return (
          Il(this.rotation) ||
          Il(this.x) ||
          Il(this.y) ||
          Il(this.scaleX - 1) ||
          Il(this.scaleY - 1) ||
          Il(this.skewX) ||
          Il(this.skewY)
        )
      }),
      (r.prototype.updateTransform = function () {
        var t = this.parent && this.parent.transform,
          e = this.needLocalTransform(),
          n = this.transform
        if (!(e || t)) {
          n && (KL(n), (this.invTransform = null))
          return
        }
        ;(n = n || bi()),
          e ? this.getLocalTransform(n) : KL(n),
          t && (e ? Ho(n, t, n) : RT(n, t)),
          (this.transform = n),
          this._resolveGlobalScaleRatio(n)
      }),
      (r.prototype._resolveGlobalScaleRatio = function (t) {
        var e = this.globalScaleRatio
        if (e != null && e !== 1) {
          this.getGlobalScale(Ol)
          var n = Ol[0] < 0 ? -1 : 1,
            i = Ol[1] < 0 ? -1 : 1,
            a = ((Ol[0] - n) * e + n) / Ol[0] || 0,
            o = ((Ol[1] - i) * e + i) / Ol[1] || 0
          ;(t[0] *= a), (t[1] *= a), (t[2] *= o), (t[3] *= o)
        }
        ;(this.invTransform = this.invTransform || bi()),
          mf(this.invTransform, t)
      }),
      (r.prototype.getComputedTransform = function () {
        for (var t = this, e = []; t; ) e.push(t), (t = t.parent)
        for (; (t = e.pop()); ) t.updateTransform()
        return this.transform
      }),
      (r.prototype.setLocalTransform = function (t) {
        if (t) {
          var e = t[0] * t[0] + t[1] * t[1],
            n = t[2] * t[2] + t[3] * t[3],
            i = Math.atan2(t[1], t[0]),
            a = Math.PI / 2 + i - Math.atan2(t[3], t[2])
          ;(n = Math.sqrt(n) * Math.cos(a)),
            (e = Math.sqrt(e)),
            (this.skewX = a),
            (this.skewY = 0),
            (this.rotation = -i),
            (this.x = +t[4]),
            (this.y = +t[5]),
            (this.scaleX = e),
            (this.scaleY = n),
            (this.originX = 0),
            (this.originY = 0)
        }
      }),
      (r.prototype.decomposeTransform = function () {
        if (this.transform) {
          var t = this.parent,
            e = this.transform
          t &&
            t.transform &&
            ((t.invTransform = t.invTransform || bi()),
            Ho(Uc, t.invTransform, e),
            (e = Uc))
          var n = this.originX,
            i = this.originY
          ;(n || i) &&
            ((e1[4] = n),
            (e1[5] = i),
            Ho(Uc, e, e1),
            (Uc[4] -= n),
            (Uc[5] -= i),
            (e = Uc)),
            this.setLocalTransform(e)
        }
      }),
      (r.prototype.getGlobalScale = function (t) {
        var e = this.transform
        return (
          (t = t || []),
          e
            ? ((t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1])),
              (t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3])),
              e[0] < 0 && (t[0] = -t[0]),
              e[3] < 0 && (t[1] = -t[1]),
              t)
            : ((t[0] = 1), (t[1] = 1), t)
        )
      }),
      (r.prototype.transformCoordToLocal = function (t, e) {
        var n = [t, e],
          i = this.invTransform
        return i && pr(n, n, i), n
      }),
      (r.prototype.transformCoordToGlobal = function (t, e) {
        var n = [t, e],
          i = this.transform
        return i && pr(n, n, i), n
      }),
      (r.prototype.getLineScale = function () {
        var t = this.transform
        return t && n1(t[0] - 1) > 1e-10 && n1(t[3] - 1) > 1e-10
          ? Math.sqrt(n1(t[0] * t[3] - t[2] * t[1]))
          : 1
      }),
      (r.prototype.copyTransform = function (t) {
        Dz(this, t)
      }),
      (r.getLocalTransform = function (t, e) {
        e = e || []
        var n = t.originX || 0,
          i = t.originY || 0,
          a = t.scaleX,
          o = t.scaleY,
          s = t.anchorX,
          l = t.anchorY,
          u = t.rotation || 0,
          c = t.x,
          h = t.y,
          f = t.skewX ? Math.tan(t.skewX) : 0,
          d = t.skewY ? Math.tan(-t.skewY) : 0
        if (n || i || s || l) {
          var p = n + s,
            g = i + l
          ;(e[4] = -p * a - f * g * o), (e[5] = -g * o - d * p * a)
        } else e[4] = e[5] = 0
        return (
          (e[0] = a),
          (e[3] = o),
          (e[1] = d * a),
          (e[2] = f * o),
          u && ec(e, e, u),
          (e[4] += n + c),
          (e[5] += i + h),
          e
        )
      }),
      (r.initDefaultProps = (function () {
        var t = r.prototype
        ;(t.scaleX = t.scaleY = t.globalScaleRatio = 1),
          (t.x =
            t.y =
            t.originX =
            t.originY =
            t.skewX =
            t.skewY =
            t.rotation =
            t.anchorX =
            t.anchorY =
              0)
      })()),
      r
    )
  })(),
  fo = [
    'x',
    'y',
    'originX',
    'originY',
    'anchorX',
    'anchorY',
    'rotation',
    'scaleX',
    'scaleY',
    'skewX',
    'skewY',
  ]
function Dz(r, t) {
  for (var e = 0; e < fo.length; e++) {
    var n = fo[e]
    r[n] = t[n]
  }
}
const Uo = QQ
var JL = {}
function Mi(r, t) {
  t = t || nl
  var e = JL[t]
  e || (e = JL[t] = new gv(500))
  var n = e.get(r)
  return n == null && ((n = rl.measureText(r, t).width), e.put(r, n)), n
}
function QL(r, t, e, n) {
  var i = Mi(r, t),
    a = j0(t),
    o = kd(0, i, e),
    s = sh(0, a, n),
    l = new ee(o, s, i, a)
  return l
}
function mv(r, t, e, n) {
  var i = ((r || '') + '').split(`
`),
    a = i.length
  if (a === 1) return QL(i[0], t, e, n)
  for (var o = new ee(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = QL(i[s], t, e, n)
    s === 0 ? o.copy(l) : o.union(l)
  }
  return o
}
function kd(r, t, e) {
  return e === 'right' ? (r -= t) : e === 'center' && (r -= t / 2), r
}
function sh(r, t, e) {
  return e === 'middle' ? (r -= t / 2) : e === 'bottom' && (r -= t), r
}
function j0(r) {
  return Mi('国', r)
}
function Ta(r, t) {
  return typeof r == 'string'
    ? r.lastIndexOf('%') >= 0
      ? (parseFloat(r) / 100) * t
      : parseFloat(r)
    : r
}
function Hy(r, t, e) {
  var n = t.position || 'inside',
    i = t.distance != null ? t.distance : 5,
    a = e.height,
    o = e.width,
    s = a / 2,
    l = e.x,
    u = e.y,
    c = 'left',
    h = 'top'
  if (n instanceof Array)
    (l += Ta(n[0], e.width)), (u += Ta(n[1], e.height)), (c = null), (h = null)
  else
    switch (n) {
      case 'left':
        ;(l -= i), (u += s), (c = 'right'), (h = 'middle')
        break
      case 'right':
        ;(l += i + o), (u += s), (h = 'middle')
        break
      case 'top':
        ;(l += o / 2), (u -= i), (c = 'center'), (h = 'bottom')
        break
      case 'bottom':
        ;(l += o / 2), (u += a + i), (c = 'center')
        break
      case 'inside':
        ;(l += o / 2), (u += s), (c = 'center'), (h = 'middle')
        break
      case 'insideLeft':
        ;(l += i), (u += s), (h = 'middle')
        break
      case 'insideRight':
        ;(l += o - i), (u += s), (c = 'right'), (h = 'middle')
        break
      case 'insideTop':
        ;(l += o / 2), (u += i), (c = 'center')
        break
      case 'insideBottom':
        ;(l += o / 2), (u += a - i), (c = 'center'), (h = 'bottom')
        break
      case 'insideTopLeft':
        ;(l += i), (u += i)
        break
      case 'insideTopRight':
        ;(l += o - i), (u += i), (c = 'right')
        break
      case 'insideBottomLeft':
        ;(l += i), (u += a - i), (h = 'bottom')
        break
      case 'insideBottomRight':
        ;(l += o - i), (u += a - i), (c = 'right'), (h = 'bottom')
        break
    }
  return (
    (r = r || {}), (r.x = l), (r.y = u), (r.align = c), (r.verticalAlign = h), r
  )
}
var r1 = '__zr_normal__',
  i1 = fo.concat(['ignore']),
  ttt = co(
    fo,
    function (r, t) {
      return (r[t] = !0), r
    },
    {
      ignore: !1,
    },
  ),
  Vc = {},
  ett = new ee(0, 0, 0, 0),
  BT = (function () {
    function r(t) {
      ;(this.id = ez()),
        (this.animators = []),
        (this.currentStates = []),
        (this.states = {}),
        this._init(t)
    }
    return (
      (r.prototype._init = function (t) {
        this.attr(t)
      }),
      (r.prototype.drift = function (t, e, n) {
        switch (this.draggable) {
          case 'horizontal':
            e = 0
            break
          case 'vertical':
            t = 0
            break
        }
        var i = this.transform
        i || (i = this.transform = [1, 0, 0, 1, 0, 0]),
          (i[4] += t),
          (i[5] += e),
          this.decomposeTransform(),
          this.markRedraw()
      }),
      (r.prototype.beforeUpdate = function () {}),
      (r.prototype.afterUpdate = function () {}),
      (r.prototype.update = function () {
        this.updateTransform(), this.__dirty && this.updateInnerText()
      }),
      (r.prototype.updateInnerText = function (t) {
        var e = this._textContent
        if (e && (!e.ignore || t)) {
          this.textConfig || (this.textConfig = {})
          var n = this.textConfig,
            i = n.local,
            a = e.innerTransformable,
            o = void 0,
            s = void 0,
            l = !1
          a.parent = i ? this : null
          var u = !1
          if ((a.copyTransform(e), n.position != null)) {
            var c = ett
            n.layoutRect
              ? c.copy(n.layoutRect)
              : c.copy(this.getBoundingRect()),
              i || c.applyTransform(this.transform),
              this.calculateTextPosition
                ? this.calculateTextPosition(Vc, n, c)
                : Hy(Vc, n, c),
              (a.x = Vc.x),
              (a.y = Vc.y),
              (o = Vc.align),
              (s = Vc.verticalAlign)
            var h = n.origin
            if (h && n.rotation != null) {
              var f = void 0,
                d = void 0
              h === 'center'
                ? ((f = c.width * 0.5), (d = c.height * 0.5))
                : ((f = Ta(h[0], c.width)), (d = Ta(h[1], c.height))),
                (u = !0),
                (a.originX = -a.x + f + (i ? 0 : c.x)),
                (a.originY = -a.y + d + (i ? 0 : c.y))
            }
          }
          n.rotation != null && (a.rotation = n.rotation)
          var p = n.offset
          p &&
            ((a.x += p[0]),
            (a.y += p[1]),
            u || ((a.originX = -p[0]), (a.originY = -p[1])))
          var g =
              n.inside == null
                ? typeof n.position == 'string' &&
                  n.position.indexOf('inside') >= 0
                : n.inside,
            v =
              this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}),
            m = void 0,
            y = void 0,
            _ = void 0
          g && this.canBeInsideText()
            ? ((m = n.insideFill),
              (y = n.insideStroke),
              (m == null || m === 'auto') && (m = this.getInsideTextFill()),
              (y == null || y === 'auto') &&
                ((y = this.getInsideTextStroke(m)), (_ = !0)))
            : ((m = n.outsideFill),
              (y = n.outsideStroke),
              (m == null || m === 'auto') && (m = this.getOutsideFill()),
              (y == null || y === 'auto') &&
                ((y = this.getOutsideStroke(m)), (_ = !0))),
            (m = m || '#000'),
            (m !== v.fill ||
              y !== v.stroke ||
              _ !== v.autoStroke ||
              o !== v.align ||
              s !== v.verticalAlign) &&
              ((l = !0),
              (v.fill = m),
              (v.stroke = y),
              (v.autoStroke = _),
              (v.align = o),
              (v.verticalAlign = s),
              e.setDefaultTextStyle(v)),
            (e.__dirty |= yi),
            l && e.dirtyStyle(!0)
        }
      }),
      (r.prototype.canBeInsideText = function () {
        return !0
      }),
      (r.prototype.getInsideTextFill = function () {
        return '#fff'
      }),
      (r.prototype.getInsideTextStroke = function (t) {
        return '#000'
      }),
      (r.prototype.getOutsideFill = function () {
        return this.__zr && this.__zr.isDarkMode() ? Zb : qb
      }),
      (r.prototype.getOutsideStroke = function (t) {
        var e = this.__zr && this.__zr.getBackgroundColor(),
          n = typeof e == 'string' && wi(e)
        n || (n = [255, 255, 255, 1])
        for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
          n[o] = n[o] * i + (a ? 0 : 255) * (1 - i)
        return (n[3] = 1), Wo(n, 'rgba')
      }),
      (r.prototype.traverse = function (t, e) {}),
      (r.prototype.attrKV = function (t, e) {
        t === 'textConfig'
          ? this.setTextConfig(e)
          : t === 'textContent'
          ? this.setTextContent(e)
          : t === 'clipPath'
          ? this.setClipPath(e)
          : t === 'extra'
          ? ((this.extra = this.extra || {}), Q(this.extra, e))
          : (this[t] = e)
      }),
      (r.prototype.hide = function () {
        ;(this.ignore = !0), this.markRedraw()
      }),
      (r.prototype.show = function () {
        ;(this.ignore = !1), this.markRedraw()
      }),
      (r.prototype.attr = function (t, e) {
        if (typeof t == 'string') this.attrKV(t, e)
        else if (Ut(t))
          for (var n = t, i = pe(n), a = 0; a < i.length; a++) {
            var o = i[a]
            this.attrKV(o, t[o])
          }
        return this.markRedraw(), this
      }),
      (r.prototype.saveCurrentToNormalState = function (t) {
        this._innerSaveToNormal(t)
        for (var e = this._normalState, n = 0; n < this.animators.length; n++) {
          var i = this.animators[n],
            a = i.__fromStateTransition
          if (!(i.getLoop() || (a && a !== r1))) {
            var o = i.targetName,
              s = o ? e[o] : e
            i.saveTo(s)
          }
        }
      }),
      (r.prototype._innerSaveToNormal = function (t) {
        var e = this._normalState
        e || (e = this._normalState = {}),
          t.textConfig && !e.textConfig && (e.textConfig = this.textConfig),
          this._savePrimaryToNormal(t, e, i1)
      }),
      (r.prototype._savePrimaryToNormal = function (t, e, n) {
        for (var i = 0; i < n.length; i++) {
          var a = n[i]
          t[a] != null && !(a in e) && (e[a] = this[a])
        }
      }),
      (r.prototype.hasState = function () {
        return this.currentStates.length > 0
      }),
      (r.prototype.getState = function (t) {
        return this.states[t]
      }),
      (r.prototype.ensureState = function (t) {
        var e = this.states
        return e[t] || (e[t] = {}), e[t]
      }),
      (r.prototype.clearStates = function (t) {
        this.useState(r1, !1, t)
      }),
      (r.prototype.useState = function (t, e, n, i) {
        var a = t === r1,
          o = this.hasState()
        if (!(!o && a)) {
          var s = this.currentStates,
            l = this.stateTransition
          if (!(re(s, t) >= 0 && (e || s.length === 1))) {
            var u
            if (
              (this.stateProxy && !a && (u = this.stateProxy(t)),
              u || (u = this.states && this.states[t]),
              !u && !a)
            ) {
              CT('State ' + t + ' not exists.')
              return
            }
            a || this.saveCurrentToNormalState(u)
            var c = !!((u && u.hoverLayer) || i)
            c && this._toggleHoverLayerFlag(!0),
              this._applyStateObj(
                t,
                u,
                this._normalState,
                e,
                !n && !this.__inHover && l && l.duration > 0,
                l,
              )
            var h = this._textContent,
              f = this._textGuide
            return (
              h && h.useState(t, e, n, c),
              f && f.useState(t, e, n, c),
              a
                ? ((this.currentStates = []), (this._normalState = {}))
                : e
                ? this.currentStates.push(t)
                : (this.currentStates = [t]),
              this._updateAnimationTargets(),
              this.markRedraw(),
              !c &&
                this.__inHover &&
                (this._toggleHoverLayerFlag(!1), (this.__dirty &= ~yi)),
              u
            )
          }
        }
      }),
      (r.prototype.useStates = function (t, e, n) {
        if (!t.length) this.clearStates()
        else {
          var i = [],
            a = this.currentStates,
            o = t.length,
            s = o === a.length
          if (s) {
            for (var l = 0; l < o; l++)
              if (t[l] !== a[l]) {
                s = !1
                break
              }
          }
          if (s) return
          for (var l = 0; l < o; l++) {
            var u = t[l],
              c = void 0
            this.stateProxy && (c = this.stateProxy(u, t)),
              c || (c = this.states[u]),
              c && i.push(c)
          }
          var h = i[o - 1],
            f = !!((h && h.hoverLayer) || n)
          f && this._toggleHoverLayerFlag(!0)
          var d = this._mergeStates(i),
            p = this.stateTransition
          this.saveCurrentToNormalState(d),
            this._applyStateObj(
              t.join(','),
              d,
              this._normalState,
              !1,
              !e && !this.__inHover && p && p.duration > 0,
              p,
            )
          var g = this._textContent,
            v = this._textGuide
          g && g.useStates(t, e, f),
            v && v.useStates(t, e, f),
            this._updateAnimationTargets(),
            (this.currentStates = t.slice()),
            this.markRedraw(),
            !f &&
              this.__inHover &&
              (this._toggleHoverLayerFlag(!1), (this.__dirty &= ~yi))
        }
      }),
      (r.prototype.isSilent = function () {
        for (var t = this.silent, e = this.parent; !t && e; ) {
          if (e.silent) {
            t = !0
            break
          }
          e = e.parent
        }
        return t
      }),
      (r.prototype._updateAnimationTargets = function () {
        for (var t = 0; t < this.animators.length; t++) {
          var e = this.animators[t]
          e.targetName && e.changeTarget(this[e.targetName])
        }
      }),
      (r.prototype.removeState = function (t) {
        var e = re(this.currentStates, t)
        if (e >= 0) {
          var n = this.currentStates.slice()
          n.splice(e, 1), this.useStates(n)
        }
      }),
      (r.prototype.replaceState = function (t, e, n) {
        var i = this.currentStates.slice(),
          a = re(i, t),
          o = re(i, e) >= 0
        a >= 0 ? (o ? i.splice(a, 1) : (i[a] = e)) : n && !o && i.push(e),
          this.useStates(i)
      }),
      (r.prototype.toggleState = function (t, e) {
        e ? this.useState(t, !0) : this.removeState(t)
      }),
      (r.prototype._mergeStates = function (t) {
        for (var e = {}, n, i = 0; i < t.length; i++) {
          var a = t[i]
          Q(e, a), a.textConfig && ((n = n || {}), Q(n, a.textConfig))
        }
        return n && (e.textConfig = n), e
      }),
      (r.prototype._applyStateObj = function (t, e, n, i, a, o) {
        var s = !(e && i)
        e && e.textConfig
          ? ((this.textConfig = Q({}, i ? this.textConfig : n.textConfig)),
            Q(this.textConfig, e.textConfig))
          : s && n.textConfig && (this.textConfig = n.textConfig)
        for (var l = {}, u = !1, c = 0; c < i1.length; c++) {
          var h = i1[c],
            f = a && ttt[h]
          e && e[h] != null
            ? f
              ? ((u = !0), (l[h] = e[h]))
              : (this[h] = e[h])
            : s &&
              n[h] != null &&
              (f ? ((u = !0), (l[h] = n[h])) : (this[h] = n[h]))
        }
        if (!a)
          for (var c = 0; c < this.animators.length; c++) {
            var d = this.animators[c],
              p = d.targetName
            d.getLoop() || d.__changeFinalValue(p ? (e || n)[p] : e || n)
          }
        u && this._transitionState(t, l, o)
      }),
      (r.prototype._attachComponent = function (t) {
        if (!(t.__zr && !t.__hostTarget) && t !== this) {
          var e = this.__zr
          e && t.addSelfToZr(e), (t.__zr = e), (t.__hostTarget = this)
        }
      }),
      (r.prototype._detachComponent = function (t) {
        t.__zr && t.removeSelfFromZr(t.__zr),
          (t.__zr = null),
          (t.__hostTarget = null)
      }),
      (r.prototype.getClipPath = function () {
        return this._clipPath
      }),
      (r.prototype.setClipPath = function (t) {
        this._clipPath && this._clipPath !== t && this.removeClipPath(),
          this._attachComponent(t),
          (this._clipPath = t),
          this.markRedraw()
      }),
      (r.prototype.removeClipPath = function () {
        var t = this._clipPath
        t &&
          (this._detachComponent(t), (this._clipPath = null), this.markRedraw())
      }),
      (r.prototype.getTextContent = function () {
        return this._textContent
      }),
      (r.prototype.setTextContent = function (t) {
        var e = this._textContent
        e !== t &&
          (e && e !== t && this.removeTextContent(),
          (t.innerTransformable = new Uo()),
          this._attachComponent(t),
          (this._textContent = t),
          this.markRedraw())
      }),
      (r.prototype.setTextConfig = function (t) {
        this.textConfig || (this.textConfig = {}),
          Q(this.textConfig, t),
          this.markRedraw()
      }),
      (r.prototype.removeTextConfig = function () {
        ;(this.textConfig = null), this.markRedraw()
      }),
      (r.prototype.removeTextContent = function () {
        var t = this._textContent
        t &&
          ((t.innerTransformable = null),
          this._detachComponent(t),
          (this._textContent = null),
          (this._innerTextDefaultStyle = null),
          this.markRedraw())
      }),
      (r.prototype.getTextGuideLine = function () {
        return this._textGuide
      }),
      (r.prototype.setTextGuideLine = function (t) {
        this._textGuide && this._textGuide !== t && this.removeTextGuideLine(),
          this._attachComponent(t),
          (this._textGuide = t),
          this.markRedraw()
      }),
      (r.prototype.removeTextGuideLine = function () {
        var t = this._textGuide
        t &&
          (this._detachComponent(t),
          (this._textGuide = null),
          this.markRedraw())
      }),
      (r.prototype.markRedraw = function () {
        this.__dirty |= yi
        var t = this.__zr
        t && (this.__inHover ? t.refreshHover() : t.refresh()),
          this.__hostTarget && this.__hostTarget.markRedraw()
      }),
      (r.prototype.dirty = function () {
        this.markRedraw()
      }),
      (r.prototype._toggleHoverLayerFlag = function (t) {
        this.__inHover = t
        var e = this._textContent,
          n = this._textGuide
        e && (e.__inHover = t), n && (n.__inHover = t)
      }),
      (r.prototype.addSelfToZr = function (t) {
        if (this.__zr !== t) {
          this.__zr = t
          var e = this.animators
          if (e)
            for (var n = 0; n < e.length; n++) t.animation.addAnimator(e[n])
          this._clipPath && this._clipPath.addSelfToZr(t),
            this._textContent && this._textContent.addSelfToZr(t),
            this._textGuide && this._textGuide.addSelfToZr(t)
        }
      }),
      (r.prototype.removeSelfFromZr = function (t) {
        if (this.__zr) {
          this.__zr = null
          var e = this.animators
          if (e)
            for (var n = 0; n < e.length; n++) t.animation.removeAnimator(e[n])
          this._clipPath && this._clipPath.removeSelfFromZr(t),
            this._textContent && this._textContent.removeSelfFromZr(t),
            this._textGuide && this._textGuide.removeSelfFromZr(t)
        }
      }),
      (r.prototype.animate = function (t, e, n) {
        var i = t ? this[t] : this,
          a = new kT(i, e, n)
        return t && (a.targetName = t), this.addAnimator(a, t), a
      }),
      (r.prototype.addAnimator = function (t, e) {
        var n = this.__zr,
          i = this
        t
          .during(function () {
            i.updateDuringAnimation(e)
          })
          .done(function () {
            var a = i.animators,
              o = re(a, t)
            o >= 0 && a.splice(o, 1)
          }),
          this.animators.push(t),
          n && n.animation.addAnimator(t),
          n && n.wakeUp()
      }),
      (r.prototype.updateDuringAnimation = function (t) {
        this.markRedraw()
      }),
      (r.prototype.stopAnimation = function (t, e) {
        for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
          var s = n[o]
          !t || t === s.scope ? s.stop(e) : a.push(s)
        }
        return (this.animators = a), this
      }),
      (r.prototype.animateTo = function (t, e, n) {
        a1(this, t, e, n)
      }),
      (r.prototype.animateFrom = function (t, e, n) {
        a1(this, t, e, n, !0)
      }),
      (r.prototype._transitionState = function (t, e, n, i) {
        for (var a = a1(this, e, n, i), o = 0; o < a.length; o++)
          a[o].__fromStateTransition = t
      }),
      (r.prototype.getBoundingRect = function () {
        return null
      }),
      (r.prototype.getPaintRect = function () {
        return null
      }),
      (r.initDefaultProps = (function () {
        var t = r.prototype
        ;(t.type = 'element'),
          (t.name = ''),
          (t.ignore =
            t.silent =
            t.isGroup =
            t.draggable =
            t.dragging =
            t.ignoreClip =
            t.__inHover =
              !1),
          (t.__dirty = yi)
        function e(n, i, a, o) {
          Object.defineProperty(t, n, {
            get: function () {
              if (!this[i]) {
                var l = (this[i] = [])
                s(this, l)
              }
              return this[i]
            },
            set: function (l) {
              ;(this[a] = l[0]), (this[o] = l[1]), (this[i] = l), s(this, l)
            },
          })
          function s(l, u) {
            Object.defineProperty(u, 0, {
              get: function () {
                return l[a]
              },
              set: function (c) {
                l[a] = c
              },
            }),
              Object.defineProperty(u, 1, {
                get: function () {
                  return l[o]
                },
                set: function (c) {
                  l[o] = c
                },
              })
          }
        }
        Object.defineProperty &&
          (e('position', '_legacyPos', 'x', 'y'),
          e('scale', '_legacyScale', 'scaleX', 'scaleY'),
          e('origin', '_legacyOrigin', 'originX', 'originY'))
      })()),
      r
    )
  })()
In(BT, ra)
In(BT, Uo)
function a1(r, t, e, n, i) {
  e = e || {}
  var a = []
  Lz(r, '', r, t, e, n, a, i)
  var o = a.length,
    s = !1,
    l = e.done,
    u = e.aborted,
    c = function () {
      ;(s = !0), o--, o <= 0 && (s ? l && l() : u && u())
    },
    h = function () {
      o--, o <= 0 && (s ? l && l() : u && u())
    }
  o || (l && l()),
    a.length > 0 &&
      e.during &&
      a[0].during(function (p, g) {
        e.during(g)
      })
  for (var f = 0; f < a.length; f++) {
    var d = a[f]
    c && d.done(c),
      h && d.aborted(h),
      e.force && d.duration(e.duration),
      d.start(e.easing)
  }
  return a
}
function o1(r, t, e) {
  for (var n = 0; n < e; n++) r[n] = t[n]
}
function ntt(r) {
  return Er(r[0])
}
function rtt(r, t, e) {
  if (Er(t[e]))
    if ((Er(r[e]) || (r[e] = []), ai(t[e]))) {
      var n = t[e].length
      r[e].length !== n && ((r[e] = new t[e].constructor(n)), o1(r[e], t[e], n))
    } else {
      var i = t[e],
        a = r[e],
        o = i.length
      if (ntt(i))
        for (var s = i[0].length, l = 0; l < o; l++)
          a[l] ? o1(a[l], i[l], s) : (a[l] = Array.prototype.slice.call(i[l]))
      else o1(a, i, o)
      a.length = i.length
    }
  else r[e] = t[e]
}
function itt(r, t) {
  return r === t || (Er(r) && Er(t) && att(r, t))
}
function att(r, t) {
  var e = r.length
  if (e !== t.length) return !1
  for (var n = 0; n < e; n++) if (r[n] !== t[n]) return !1
  return !0
}
function Lz(r, t, e, n, i, a, o, s) {
  for (
    var l = pe(n),
      u = i.duration,
      c = i.delay,
      h = i.additive,
      f = i.setToFinal,
      d = !Ut(a),
      p = r.animators,
      g = [],
      v = 0;
    v < l.length;
    v++
  ) {
    var m = l[v],
      y = n[m]
    if (y != null && e[m] != null && (d || a[m]))
      if (Ut(y) && !Er(y) && !$0(y)) {
        if (t) {
          s || ((e[m] = y), r.updateDuringAnimation(t))
          continue
        }
        Lz(r, m, e[m], y, i, a && a[m], o, s)
      } else g.push(m)
    else s || ((e[m] = y), r.updateDuringAnimation(t), g.push(m))
  }
  var _ = g.length
  if (!h && _)
    for (var x = 0; x < p.length; x++) {
      var A = p[x]
      if (A.targetName === t) {
        var S = A.stopTracks(g)
        if (S) {
          var b = re(p, A)
          p.splice(b, 1)
        }
      }
    }
  if (
    (i.force ||
      ((g = Ne(g, function (C) {
        return !itt(n[C], e[C])
      })),
      (_ = g.length)),
    _ > 0 || (i.force && !o.length))
  ) {
    var T = void 0,
      w = void 0,
      M = void 0
    if (s) {
      ;(w = {}), f && (T = {})
      for (var x = 0; x < _; x++) {
        var m = g[x]
        ;(w[m] = e[m]), f ? (T[m] = n[m]) : (e[m] = n[m])
      }
    } else if (f) {
      M = {}
      for (var x = 0; x < _; x++) {
        var m = g[x]
        ;(M[m] = np(e[m])), rtt(e, n, m)
      }
    }
    var A = new kT(
      e,
      !1,
      !1,
      h
        ? Ne(p, function (E) {
            return E.targetName === t
          })
        : null,
    )
    ;(A.targetName = t),
      i.scope && (A.scope = i.scope),
      f && T && A.whenWithKeys(0, T, g),
      M && A.whenWithKeys(0, M, g),
      A.whenWithKeys(u ?? 500, s ? w : n, g).delay(c || 0),
      r.addAnimator(A, t),
      o.push(A)
  }
}
const Pz = BT
var Rz = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this) || this
    return (n.isGroup = !0), (n._children = []), n.attr(e), n
  }
  return (
    (t.prototype.childrenRef = function () {
      return this._children
    }),
    (t.prototype.children = function () {
      return this._children.slice()
    }),
    (t.prototype.childAt = function (e) {
      return this._children[e]
    }),
    (t.prototype.childOfName = function (e) {
      for (var n = this._children, i = 0; i < n.length; i++)
        if (n[i].name === e) return n[i]
    }),
    (t.prototype.childCount = function () {
      return this._children.length
    }),
    (t.prototype.add = function (e) {
      return (
        e &&
          e !== this &&
          e.parent !== this &&
          (this._children.push(e), this._doAdd(e)),
        this
      )
    }),
    (t.prototype.addBefore = function (e, n) {
      if (e && e !== this && e.parent !== this && n && n.parent === this) {
        var i = this._children,
          a = i.indexOf(n)
        a >= 0 && (i.splice(a, 0, e), this._doAdd(e))
      }
      return this
    }),
    (t.prototype.replace = function (e, n) {
      var i = re(this._children, e)
      return i >= 0 && this.replaceAt(n, i), this
    }),
    (t.prototype.replaceAt = function (e, n) {
      var i = this._children,
        a = i[n]
      if (e && e !== this && e.parent !== this && e !== a) {
        ;(i[n] = e), (a.parent = null)
        var o = this.__zr
        o && a.removeSelfFromZr(o), this._doAdd(e)
      }
      return this
    }),
    (t.prototype._doAdd = function (e) {
      e.parent && e.parent.remove(e), (e.parent = this)
      var n = this.__zr
      n && n !== e.__zr && e.addSelfToZr(n), n && n.refresh()
    }),
    (t.prototype.remove = function (e) {
      var n = this.__zr,
        i = this._children,
        a = re(i, e)
      return a < 0
        ? this
        : (i.splice(a, 1),
          (e.parent = null),
          n && e.removeSelfFromZr(n),
          n && n.refresh(),
          this)
    }),
    (t.prototype.removeAll = function () {
      for (var e = this._children, n = this.__zr, i = 0; i < e.length; i++) {
        var a = e[i]
        n && a.removeSelfFromZr(n), (a.parent = null)
      }
      return (e.length = 0), this
    }),
    (t.prototype.eachChild = function (e, n) {
      for (var i = this._children, a = 0; a < i.length; a++) {
        var o = i[a]
        e.call(n, o, a)
      }
      return this
    }),
    (t.prototype.traverse = function (e, n) {
      for (var i = 0; i < this._children.length; i++) {
        var a = this._children[i],
          o = e.call(n, a)
        a.isGroup && !o && a.traverse(e, n)
      }
      return this
    }),
    (t.prototype.addSelfToZr = function (e) {
      r.prototype.addSelfToZr.call(this, e)
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n]
        i.addSelfToZr(e)
      }
    }),
    (t.prototype.removeSelfFromZr = function (e) {
      r.prototype.removeSelfFromZr.call(this, e)
      for (var n = 0; n < this._children.length; n++) {
        var i = this._children[n]
        i.removeSelfFromZr(e)
      }
    }),
    (t.prototype.getBoundingRect = function (e) {
      for (
        var n = new ee(0, 0, 0, 0),
          i = e || this._children,
          a = [],
          o = null,
          s = 0;
        s < i.length;
        s++
      ) {
        var l = i[s]
        if (!(l.ignore || l.invisible)) {
          var u = l.getBoundingRect(),
            c = l.getLocalTransform(a)
          c
            ? (ee.applyTransform(n, u, c), (o = o || n.clone()), o.union(n))
            : ((o = o || u.clone()), o.union(u))
        }
      }
      return o || n
    }),
    t
  )
})(Pz)
Rz.prototype.type = 'group'
const Ht = Rz
/*!
 * ZRender, a high performance 2d drawing library.
 *
 * Copyright (c) 2013, Baidu Inc.
 * All rights reserved.
 *
 * LICENSE
 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
 */
var Jm = {},
  Iz = {}
function ott(r) {
  delete Iz[r]
}
function stt(r) {
  if (!r) return !1
  if (typeof r == 'string') return Uy(r, 1) < $b
  if (r.colorStops) {
    for (var t = r.colorStops, e = 0, n = t.length, i = 0; i < n; i++)
      e += Uy(t[i].color, 1)
    return (e /= n), e < $b
  }
  return !1
}
var ltt = (function () {
  function r(t, e, n) {
    var i = this
    ;(this._sleepAfterStill = 10),
      (this._stillFrameAccum = 0),
      (this._needsRefresh = !0),
      (this._needsRefreshHover = !0),
      (this._darkMode = !1),
      (n = n || {}),
      (this.dom = e),
      (this.id = t)
    var a = new yQ(),
      o = n.renderer || 'canvas'
    Jm[o] || (o = pe(Jm)[0]),
      (n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect)
    var s = new Jm[o](e, a, n, t),
      l = n.ssr || s.ssrOnly
    ;(this.storage = a), (this.painter = s)
    var u =
        !Se.node && !Se.worker && !l
          ? new jQ(s.getViewportRoot(), s.root)
          : null,
      c = n.useCoarsePointer,
      h = c == null || c === 'auto' ? Se.touchEventsSupported : !!c,
      f = 44,
      d
    h && (d = $t(n.pointerSize, f)),
      (this.handler = new dQ(a, s, u, s.root, d)),
      (this.animation = new HQ({
        stage: {
          update: l
            ? null
            : function () {
                return i._flush(!0)
              },
        },
      })),
      l || this.animation.start()
  }
  return (
    (r.prototype.add = function (t) {
      this._disposed ||
        !t ||
        (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh())
    }),
    (r.prototype.remove = function (t) {
      this._disposed ||
        !t ||
        (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh())
    }),
    (r.prototype.configLayer = function (t, e) {
      this._disposed ||
        (this.painter.configLayer && this.painter.configLayer(t, e),
        this.refresh())
    }),
    (r.prototype.setBackgroundColor = function (t) {
      this._disposed ||
        (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t),
        this.refresh(),
        (this._backgroundColor = t),
        (this._darkMode = stt(t)))
    }),
    (r.prototype.getBackgroundColor = function () {
      return this._backgroundColor
    }),
    (r.prototype.setDarkMode = function (t) {
      this._darkMode = t
    }),
    (r.prototype.isDarkMode = function () {
      return this._darkMode
    }),
    (r.prototype.refreshImmediately = function (t) {
      this._disposed ||
        (t || this.animation.update(!0),
        (this._needsRefresh = !1),
        this.painter.refresh(),
        (this._needsRefresh = !1))
    }),
    (r.prototype.refresh = function () {
      this._disposed || ((this._needsRefresh = !0), this.animation.start())
    }),
    (r.prototype.flush = function () {
      this._disposed || this._flush(!1)
    }),
    (r.prototype._flush = function (t) {
      var e,
        n = yh()
      this._needsRefresh && ((e = !0), this.refreshImmediately(t)),
        this._needsRefreshHover && ((e = !0), this.refreshHoverImmediately())
      var i = yh()
      e
        ? ((this._stillFrameAccum = 0),
          this.trigger('rendered', {
            elapsedTime: i - n,
          }))
        : this._sleepAfterStill > 0 &&
          (this._stillFrameAccum++,
          this._stillFrameAccum > this._sleepAfterStill &&
            this.animation.stop())
    }),
    (r.prototype.setSleepAfterStill = function (t) {
      this._sleepAfterStill = t
    }),
    (r.prototype.wakeUp = function () {
      this._disposed || (this.animation.start(), (this._stillFrameAccum = 0))
    }),
    (r.prototype.refreshHover = function () {
      this._needsRefreshHover = !0
    }),
    (r.prototype.refreshHoverImmediately = function () {
      this._disposed ||
        ((this._needsRefreshHover = !1),
        this.painter.refreshHover &&
          this.painter.getType() === 'canvas' &&
          this.painter.refreshHover())
    }),
    (r.prototype.resize = function (t) {
      this._disposed ||
        ((t = t || {}),
        this.painter.resize(t.width, t.height),
        this.handler.resize())
    }),
    (r.prototype.clearAnimation = function () {
      this._disposed || this.animation.clear()
    }),
    (r.prototype.getWidth = function () {
      if (!this._disposed) return this.painter.getWidth()
    }),
    (r.prototype.getHeight = function () {
      if (!this._disposed) return this.painter.getHeight()
    }),
    (r.prototype.setCursorStyle = function (t) {
      this._disposed || this.handler.setCursorStyle(t)
    }),
    (r.prototype.findHover = function (t, e) {
      if (!this._disposed) return this.handler.findHover(t, e)
    }),
    (r.prototype.on = function (t, e, n) {
      return this._disposed || this.handler.on(t, e, n), this
    }),
    (r.prototype.off = function (t, e) {
      this._disposed || this.handler.off(t, e)
    }),
    (r.prototype.trigger = function (t, e) {
      this._disposed || this.handler.trigger(t, e)
    }),
    (r.prototype.clear = function () {
      if (!this._disposed) {
        for (var t = this.storage.getRoots(), e = 0; e < t.length; e++)
          t[e] instanceof Ht && t[e].removeSelfFromZr(this)
        this.storage.delAllRoots(), this.painter.clear()
      }
    }),
    (r.prototype.dispose = function () {
      this._disposed ||
        (this.animation.stop(),
        this.clear(),
        this.storage.dispose(),
        this.painter.dispose(),
        this.handler.dispose(),
        (this.animation = this.storage = this.painter = this.handler = null),
        (this._disposed = !0),
        ott(this.id))
    }),
    r
  )
})()
function tP(r, t) {
  var e = new ltt(ez(), r, t)
  return (Iz[e.id] = e), e
}
function utt(r, t) {
  Jm[r] = t
}
var Kb
function ctt(r) {
  if (typeof Kb == 'function') return Kb(r)
}
function htt(r) {
  Kb = r
}
var eP = 1e-4,
  Oz = 20
function ftt(r) {
  return r.replace(/^\s+|\s+$/g, '')
}
function Re(r, t, e, n) {
  var i = t[0],
    a = t[1],
    o = e[0],
    s = e[1],
    l = a - i,
    u = s - o
  if (l === 0) return u === 0 ? o : (o + s) / 2
  if (n)
    if (l > 0) {
      if (r <= i) return o
      if (r >= a) return s
    } else {
      if (r >= i) return o
      if (r <= a) return s
    }
  else {
    if (r === i) return o
    if (r === a) return s
  }
  return ((r - i) / l) * u + o
}
function _t(r, t) {
  switch (r) {
    case 'center':
    case 'middle':
      r = '50%'
      break
    case 'left':
    case 'top':
      r = '0%'
      break
    case 'right':
    case 'bottom':
      r = '100%'
      break
  }
  return bt(r)
    ? ftt(r).match(/%$/)
      ? (parseFloat(r) / 100) * t
      : parseFloat(r)
    : r == null
    ? NaN
    : +r
}
function mn(r, t, e) {
  return (
    t == null && (t = 10),
    (t = Math.min(Math.max(0, t), Oz)),
    (r = (+r).toFixed(t)),
    e ? r : +r
  )
}
function Zi(r) {
  return (
    r.sort(function (t, e) {
      return t - e
    }),
    r
  )
}
function Qa(r) {
  if (((r = +r), isNaN(r))) return 0
  if (r > 1e-14) {
    for (var t = 1, e = 0; e < 15; e++, t *= 10)
      if (Math.round(r * t) / t === r) return e
  }
  return dtt(r)
}
function dtt(r) {
  var t = r.toString().toLowerCase(),
    e = t.indexOf('e'),
    n = e > 0 ? +t.slice(e + 1) : 0,
    i = e > 0 ? e : t.length,
    a = t.indexOf('.'),
    o = a < 0 ? 0 : i - 1 - a
  return Math.max(0, o - n)
}
function Nz(r, t) {
  var e = Math.log,
    n = Math.LN10,
    i = Math.floor(e(r[1] - r[0]) / n),
    a = Math.round(e(Math.abs(t[1] - t[0])) / n),
    o = Math.min(Math.max(-i + a, 0), 20)
  return isFinite(o) ? o : 20
}
function ptt(r, t) {
  var e = co(
    r,
    function (d, p) {
      return d + (isNaN(p) ? 0 : p)
    },
    0,
  )
  if (e === 0) return []
  for (
    var n = Math.pow(10, t),
      i = st(r, function (d) {
        return ((isNaN(d) ? 0 : d) / e) * n * 100
      }),
      a = n * 100,
      o = st(i, function (d) {
        return Math.floor(d)
      }),
      s = co(
        o,
        function (d, p) {
          return d + p
        },
        0,
      ),
      l = st(i, function (d, p) {
        return d - o[p]
      });
    s < a;

  ) {
    for (
      var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length;
      h < f;
      ++h
    )
      l[h] > u && ((u = l[h]), (c = h))
    ++o[c], (l[c] = 0), ++s
  }
  return st(o, function (d) {
    return d / n
  })
}
function vtt(r, t) {
  var e = Math.max(Qa(r), Qa(t)),
    n = r + t
  return e > Oz ? n : mn(n, e)
}
var nP = 9007199254740991
function kz(r) {
  var t = Math.PI * 2
  return ((r % t) + t) % t
}
function Up(r) {
  return r > -eP && r < eP
}
var gtt =
  /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/
function po(r) {
  if (r instanceof Date) return r
  if (bt(r)) {
    var t = gtt.exec(r)
    if (!t) return new Date(NaN)
    if (t[8]) {
      var e = +t[4] || 0
      return (
        t[8].toUpperCase() !== 'Z' && (e -= +t[8].slice(0, 3)),
        new Date(
          Date.UTC(
            +t[1],
            +(t[2] || 1) - 1,
            +t[3] || 1,
            e,
            +(t[5] || 0),
            +t[6] || 0,
            t[7] ? +t[7].substring(0, 3) : 0,
          ),
        )
      )
    } else
      return new Date(
        +t[1],
        +(t[2] || 1) - 1,
        +t[3] || 1,
        +t[4] || 0,
        +(t[5] || 0),
        +t[6] || 0,
        t[7] ? +t[7].substring(0, 3) : 0,
      )
  } else if (r == null) return new Date(NaN)
  return new Date(Math.round(r))
}
function mtt(r) {
  return Math.pow(10, FT(r))
}
function FT(r) {
  if (r === 0) return 0
  var t = Math.floor(Math.log(r) / Math.LN10)
  return r / Math.pow(10, t) >= 10 && t++, t
}
function Bz(r, t) {
  var e = FT(r),
    n = Math.pow(10, e),
    i = r / n,
    a
  return (
    t
      ? i < 1.5
        ? (a = 1)
        : i < 2.5
        ? (a = 2)
        : i < 4
        ? (a = 3)
        : i < 7
        ? (a = 5)
        : (a = 10)
      : i < 1
      ? (a = 1)
      : i < 2
      ? (a = 2)
      : i < 3
      ? (a = 3)
      : i < 5
      ? (a = 5)
      : (a = 10),
    (r = a * n),
    e >= -20 ? +r.toFixed(e < 0 ? -e : 0) : r
  )
}
function s1(r, t) {
  var e = (r.length - 1) * t + 1,
    n = Math.floor(e),
    i = +r[n - 1],
    a = e - n
  return a ? i + a * (r[n] - i) : i
}
function rP(r) {
  r.sort(function (l, u) {
    return s(l, u, 0) ? -1 : 1
  })
  for (var t = -1 / 0, e = 1, n = 0; n < r.length; ) {
    for (var i = r[n].interval, a = r[n].close, o = 0; o < 2; o++)
      i[o] <= t && ((i[o] = t), (a[o] = o ? 1 : 1 - e)), (t = i[o]), (e = a[o])
    i[0] === i[1] && a[0] * a[1] !== 1 ? r.splice(n, 1) : n++
  }
  return r
  function s(l, u, c) {
    return (
      l.interval[c] < u.interval[c] ||
      (l.interval[c] === u.interval[c] &&
        (l.close[c] - u.close[c] === (c ? -1 : 1) || (!c && s(l, u, 1))))
    )
  }
}
function Jo(r) {
  var t = parseFloat(r)
  return t == r && (t !== 0 || !bt(r) || r.indexOf('x') <= 0) ? t : NaN
}
function Fz(r) {
  return !isNaN(Jo(r))
}
function zz() {
  return Math.round(Math.random() * 9)
}
function Uz(r, t) {
  return t === 0 ? r : Uz(t, r % t)
}
function iP(r, t) {
  return r == null ? t : t == null ? r : (r * t) / Uz(r, t)
}
function Ce(r) {
  throw new Error(r)
}
function aP(r, t, e) {
  return (t - r) * e + r
}
var Vz = 'series\0',
  Gz = '\0_ec_\0'
function ke(r) {
  return r instanceof Array ? r : r == null ? [] : [r]
}
function Xu(r, t, e) {
  if (r) {
    ;(r[t] = r[t] || {}),
      (r.emphasis = r.emphasis || {}),
      (r.emphasis[t] = r.emphasis[t] || {})
    for (var n = 0, i = e.length; n < i; n++) {
      var a = e[n]
      !r.emphasis[t].hasOwnProperty(a) &&
        r[t].hasOwnProperty(a) &&
        (r.emphasis[t][a] = r[t][a])
    }
  }
}
var oP = [
  'fontStyle',
  'fontWeight',
  'fontSize',
  'fontFamily',
  'rich',
  'tag',
  'color',
  'textBorderColor',
  'textBorderWidth',
  'width',
  'height',
  'lineHeight',
  'align',
  'verticalAlign',
  'baseline',
  'shadowColor',
  'shadowBlur',
  'shadowOffsetX',
  'shadowOffsetY',
  'textShadowColor',
  'textShadowBlur',
  'textShadowOffsetX',
  'textShadowOffsetY',
  'backgroundColor',
  'borderColor',
  'borderWidth',
  'borderRadius',
  'padding',
]
function yf(r) {
  return Ut(r) && !at(r) && !(r instanceof Date) ? r.value : r
}
function ytt(r) {
  return Ut(r) && !(r instanceof Array)
}
function Hz(r, t, e) {
  var n = e === 'normalMerge',
    i = e === 'replaceMerge',
    a = e === 'replaceAll'
  ;(r = r || []), (t = (t || []).slice())
  var o = Pt()
  R(t, function (l, u) {
    if (!Ut(l)) {
      t[u] = null
      return
    }
  })
  var s = _tt(r, o, e)
  return (
    (n || i) && xtt(s, r, o, t),
    n && Stt(s, t),
    n || i ? Att(s, t, i) : a && btt(s, t),
    wtt(s),
    s
  )
}
function _tt(r, t, e) {
  var n = []
  if (e === 'replaceAll') return n
  for (var i = 0; i < r.length; i++) {
    var a = r[i]
    a && a.id != null && t.set(a.id, i),
      n.push({
        existing: e === 'replaceMerge' || Vp(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null,
      })
  }
  return n
}
function xtt(r, t, e, n) {
  R(n, function (i, a) {
    if (!(!i || i.id == null)) {
      var o = rp(i.id),
        s = e.get(o)
      if (s != null) {
        var l = r[s]
        Gr(!l.newOption, 'Duplicated option on id "' + o + '".'),
          (l.newOption = i),
          (l.existing = t[s]),
          (n[a] = null)
      }
    }
  })
}
function Stt(r, t) {
  R(t, function (e, n) {
    if (!(!e || e.name == null))
      for (var i = 0; i < r.length; i++) {
        var a = r[i].existing
        if (
          !r[i].newOption &&
          a &&
          (a.id == null || e.id == null) &&
          !Vp(e) &&
          !Vp(a) &&
          Wz('name', a, e)
        ) {
          ;(r[i].newOption = e), (t[n] = null)
          return
        }
      }
  })
}
function Att(r, t, e) {
  R(t, function (n) {
    if (n) {
      for (
        var i, a = 0;
        (i = r[a]) &&
        (i.newOption ||
          Vp(i.existing) ||
          (i.existing && n.id != null && !Wz('id', n, i.existing)));

      )
        a++
      i
        ? ((i.newOption = n), (i.brandNew = e))
        : r.push({
            newOption: n,
            brandNew: e,
            existing: null,
            keyInfo: null,
          }),
        a++
    }
  })
}
function btt(r, t) {
  R(t, function (e) {
    r.push({
      newOption: e,
      brandNew: !0,
      existing: null,
      keyInfo: null,
    })
  })
}
function wtt(r) {
  var t = Pt()
  R(r, function (e) {
    var n = e.existing
    n && t.set(n.id, e)
  }),
    R(r, function (e) {
      var n = e.newOption
      Gr(
        !n || n.id == null || !t.get(n.id) || t.get(n.id) === e,
        'id duplicates: ' + (n && n.id),
      ),
        n && n.id != null && t.set(n.id, e),
        !e.keyInfo && (e.keyInfo = {})
    }),
    R(r, function (e, n) {
      var i = e.existing,
        a = e.newOption,
        o = e.keyInfo
      if (Ut(a)) {
        if (((o.name = a.name != null ? rp(a.name) : i ? i.name : Vz + n), i))
          o.id = rp(i.id)
        else if (a.id != null) o.id = rp(a.id)
        else {
          var s = 0
          do o.id = '\0' + o.name + '\0' + s++
          while (t.get(o.id))
        }
        t.set(o.id, e)
      }
    })
}
function Wz(r, t, e) {
  var n = Un(t[r], null),
    i = Un(e[r], null)
  return n != null && i != null && n === i
}
function rp(r) {
  return Un(r, '')
}
function Un(r, t) {
  return r == null ? t : bt(r) ? r : be(r) || Cb(r) ? r + '' : t
}
function zT(r) {
  var t = r.name
  return !!(t && t.indexOf(Vz))
}
function Vp(r) {
  return r && r.id != null && rp(r.id).indexOf(Gz) === 0
}
function Mtt(r) {
  return Gz + r
}
function Ttt(r, t, e) {
  R(r, function (n) {
    var i = n.newOption
    Ut(i) &&
      ((n.keyInfo.mainType = t), (n.keyInfo.subType = Ctt(t, i, n.existing, e)))
  })
}
function Ctt(r, t, e, n) {
  var i = t.type ? t.type : e ? e.subType : n.determineSubType(r, t)
  return i
}
function Ett(r, t) {
  var e = {},
    n = {}
  return i(r || [], e), i(t || [], n, e), [a(e), a(n)]
  function i(o, s, l) {
    for (var u = 0, c = o.length; u < c; u++) {
      var h = Un(o[u].seriesId, null)
      if (h == null) return
      for (
        var f = ke(o[u].dataIndex), d = l && l[h], p = 0, g = f.length;
        p < g;
        p++
      ) {
        var v = f[p]
        d && d[v] ? (d[v] = null) : ((s[h] || (s[h] = {}))[v] = 1)
      }
    }
  }
  function a(o, s) {
    var l = []
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s) l.push(+u)
        else {
          var c = a(o[u], !0)
          c.length &&
            l.push({
              seriesId: u,
              dataIndex: c,
            })
        }
    return l
  }
}
function Yu(r, t) {
  if (t.dataIndexInside != null) return t.dataIndexInside
  if (t.dataIndex != null)
    return at(t.dataIndex)
      ? st(t.dataIndex, function (e) {
          return r.indexOfRawIndex(e)
        })
      : r.indexOfRawIndex(t.dataIndex)
  if (t.name != null)
    return at(t.name)
      ? st(t.name, function (e) {
          return r.indexOfName(e)
        })
      : r.indexOfName(t.name)
}
function ve() {
  var r = '__ec_inner_' + Dtt++
  return function (t) {
    return t[r] || (t[r] = {})
  }
}
var Dtt = zz()
function ip(r, t, e) {
  var n = UT(t, e),
    i = n.mainTypeSpecified,
    a = n.queryOptionMap,
    o = n.others,
    s = o,
    l = e ? e.defaultMainType : null
  return (
    !i && l && a.set(l, {}),
    a.each(function (u, c) {
      var h = yv(r, c, u, {
        useDefault: l === c,
        enableAll: e && e.enableAll != null ? e.enableAll : !0,
        enableNone: e && e.enableNone != null ? e.enableNone : !0,
      })
      ;(s[c + 'Models'] = h.models), (s[c + 'Model'] = h.models[0])
    }),
    s
  )
}
function UT(r, t) {
  var e
  if (bt(r)) {
    var n = {}
    ;(n[r + 'Index'] = 0), (e = n)
  } else e = r
  var i = Pt(),
    a = {},
    o = !1
  return (
    R(e, function (s, l) {
      if (l === 'dataIndex' || l === 'dataIndexInside') {
        a[l] = s
        return
      }
      var u = l.match(/^(\w+)(Index|Id|Name)$/) || [],
        c = u[1],
        h = (u[2] || '').toLowerCase()
      if (
        !(
          !c ||
          !h ||
          (t && t.includeMainTypes && re(t.includeMainTypes, c) < 0)
        )
      ) {
        o = o || !!c
        var f = i.get(c) || i.set(c, {})
        f[h] = s
      }
    }),
    {
      mainTypeSpecified: o,
      queryOptionMap: i,
      others: a,
    }
  )
}
var Pn = {
    useDefault: !0,
    enableAll: !1,
    enableNone: !1,
  },
  Ltt = {
    useDefault: !1,
    enableAll: !0,
    enableNone: !0,
  }
function yv(r, t, e, n) {
  n = n || Pn
  var i = e.index,
    a = e.id,
    o = e.name,
    s = {
      models: null,
      specified: i != null || a != null || o != null,
    }
  if (!s.specified) {
    var l = void 0
    return (s.models = n.useDefault && (l = r.getComponent(t)) ? [l] : []), s
  }
  return i === 'none' || i === !1
    ? (Gr(
        n.enableNone,
        '`"none"` or `false` is not a valid value on index option.',
      ),
      (s.models = []),
      s)
    : (i === 'all' &&
        (Gr(n.enableAll, '`"all"` is not a valid value on index option.'),
        (i = a = o = null)),
      (s.models = r.queryComponents({
        mainType: t,
        index: i,
        id: a,
        name: o,
      })),
      s)
}
function Xz(r, t, e) {
  r.setAttribute ? r.setAttribute(t, e) : (r[t] = e)
}
function Ptt(r, t) {
  return r.getAttribute ? r.getAttribute(t) : r[t]
}
function Rtt(r) {
  return r === 'auto' ? (Se.domSupported ? 'html' : 'richText') : r || 'html'
}
function jb(r, t) {
  var e = Pt(),
    n = []
  return (
    R(r, function (i) {
      var a = t(i)
      ;(e.get(a) || (n.push(a), e.set(a, []))).push(i)
    }),
    {
      keys: n,
      buckets: e,
    }
  )
}
function Yz(r, t, e, n, i) {
  var a = t == null || t === 'auto'
  if (n == null) return n
  if (be(n)) {
    var o = aP(e || 0, n, i)
    return mn(o, a ? Math.max(Qa(e || 0), Qa(n)) : t)
  } else {
    if (bt(n)) return i < 1 ? e : n
    for (
      var s = [], l = e, u = n, c = Math.max(l ? l.length : 0, u.length), h = 0;
      h < c;
      ++h
    ) {
      var f = r.getDimensionInfo(h)
      if (f && f.type === 'ordinal') s[h] = (i < 1 && l ? l : u)[h]
      else {
        var d = l && l[h] ? l[h] : 0,
          p = u[h],
          o = aP(d, p, i)
        s[h] = mn(o, a ? Math.max(Qa(d), Qa(p)) : t)
      }
    }
    return s
  }
}
var Itt = '.',
  Nl = '___EC__COMPONENT__CONTAINER___',
  $z = '___EC__EXTENDED_CLASS___'
function to(r) {
  var t = {
    main: '',
    sub: '',
  }
  if (r) {
    var e = r.split(Itt)
    ;(t.main = e[0] || ''), (t.sub = e[1] || '')
  }
  return t
}
function Ott(r) {
  Gr(
    /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r),
    'componentType "' + r + '" illegal',
  )
}
function Ntt(r) {
  return !!(r && r[$z])
}
function VT(r, t) {
  ;(r.$constructor = r),
    (r.extend = function (e) {
      var n = this,
        i
      return (
        ktt(n)
          ? (i = (function (a) {
              X(o, a)
              function o() {
                return a.apply(this, arguments) || this
              }
              return o
            })(n))
          : ((i = function () {
              ;(e.$constructor || n).apply(this, arguments)
            }),
            IJ(i, this)),
        Q(i.prototype, e),
        (i[$z] = !0),
        (i.extend = this.extend),
        (i.superCall = ztt),
        (i.superApply = Utt),
        (i.superClass = n),
        i
      )
    })
}
function ktt(r) {
  return Nt(r) && /^class\s/.test(Function.prototype.toString.call(r))
}
function qz(r, t) {
  r.extend = t.extend
}
var Btt = Math.round(Math.random() * 10)
function Ftt(r) {
  var t = ['__\0is_clz', Btt++].join('_')
  ;(r.prototype[t] = !0),
    (r.isInstance = function (e) {
      return !!(e && e[t])
    })
}
function ztt(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++) e[n - 2] = arguments[n]
  return this.superClass.prototype[t].apply(r, e)
}
function Utt(r, t, e) {
  return this.superClass.prototype[t].apply(r, e)
}
function J0(r) {
  var t = {}
  ;(r.registerClass = function (n) {
    var i = n.type || n.prototype.type
    if (i) {
      Ott(i), (n.prototype.type = i)
      var a = to(i)
      if (!a.sub) t[a.main] = n
      else if (a.sub !== Nl) {
        var o = e(a)
        o[a.sub] = n
      }
    }
    return n
  }),
    (r.getClass = function (n, i, a) {
      var o = t[n]
      if ((o && o[Nl] && (o = i ? o[i] : null), a && !o))
        throw new Error(
          i
            ? 'Component ' + n + '.' + (i || '') + ' is used but not imported.'
            : n + '.type should be specified.',
        )
      return o
    }),
    (r.getClassesByMainType = function (n) {
      var i = to(n),
        a = [],
        o = t[i.main]
      return (
        o && o[Nl]
          ? R(o, function (s, l) {
              l !== Nl && a.push(s)
            })
          : a.push(o),
        a
      )
    }),
    (r.hasClass = function (n) {
      var i = to(n)
      return !!t[i.main]
    }),
    (r.getAllClassMainTypes = function () {
      var n = []
      return (
        R(t, function (i, a) {
          n.push(a)
        }),
        n
      )
    }),
    (r.hasSubTypes = function (n) {
      var i = to(n),
        a = t[i.main]
      return a && a[Nl]
    })
  function e(n) {
    var i = t[n.main]
    return (!i || !i[Nl]) && ((i = t[n.main] = {}), (i[Nl] = !0)), i
  }
}
function $u(r, t) {
  for (var e = 0; e < r.length; e++) r[e][1] || (r[e][1] = r[e][0])
  return (
    (t = t || !1),
    function (n, i, a) {
      for (var o = {}, s = 0; s < r.length; s++) {
        var l = r[s][1]
        if (!((i && re(i, l) >= 0) || (a && re(a, l) < 0))) {
          var u = n.getShallow(l, t)
          u != null && (o[r[s][0]] = u)
        }
      }
      return o
    }
  )
}
var Vtt = [
    ['fill', 'color'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['opacity'],
    ['shadowColor'],
  ],
  Gtt = $u(Vtt),
  Htt = (function () {
    function r() {}
    return (
      (r.prototype.getAreaStyle = function (t, e) {
        return Gtt(this, t, e)
      }),
      r
    )
  })(),
  Jb = new gv(50)
function Wtt(r) {
  if (typeof r == 'string') {
    var t = Jb.get(r)
    return t && t.image
  } else return r
}
function GT(r, t, e, n, i) {
  if (r)
    if (typeof r == 'string') {
      if ((t && t.__zrImageSrc === r) || !e) return t
      var a = Jb.get(r),
        o = {
          hostEl: e,
          cb: n,
          cbPayload: i,
        }
      return (
        a
          ? ((t = a.image), !Q0(t) && a.pending.push(o))
          : ((t = rl.loadImage(r, sP, sP)),
            (t.__zrImageSrc = r),
            Jb.put(
              r,
              (t.__cachedImgObj = {
                image: t,
                pending: [o],
              }),
            )),
        t
      )
    } else return r
  else return t
}
function sP() {
  var r = this.__cachedImgObj
  this.onload = this.onerror = this.__cachedImgObj = null
  for (var t = 0; t < r.pending.length; t++) {
    var e = r.pending[t],
      n = e.cb
    n && n(this, e.cbPayload), e.hostEl.dirty()
  }
  r.pending.length = 0
}
function Q0(r) {
  return r && r.width && r.height
}
var l1 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g
function Xtt(r, t, e, n, i) {
  if (!t) return ''
  var a = (r + '').split(`
`)
  i = Zz(t, e, n, i)
  for (var o = 0, s = a.length; o < s; o++) a[o] = Kz(a[o], i)
  return a.join(`
`)
}
function Zz(r, t, e, n) {
  n = n || {}
  var i = Q({}, n)
  ;(i.font = t), (e = $t(e, '...')), (i.maxIterations = $t(n.maxIterations, 2))
  var a = (i.minChar = $t(n.minChar, 0))
  i.cnCharWidth = Mi('国', t)
  var o = (i.ascCharWidth = Mi('a', t))
  i.placeholder = $t(n.placeholder, '')
  for (var s = (r = Math.max(0, r - 1)), l = 0; l < a && s >= o; l++) s -= o
  var u = Mi(e, t)
  return (
    u > s && ((e = ''), (u = 0)),
    (s = r - u),
    (i.ellipsis = e),
    (i.ellipsisWidth = u),
    (i.contentWidth = s),
    (i.containerWidth = r),
    i
  )
}
function Kz(r, t) {
  var e = t.containerWidth,
    n = t.font,
    i = t.contentWidth
  if (!e) return ''
  var a = Mi(r, n)
  if (a <= e) return r
  for (var o = 0; ; o++) {
    if (a <= i || o >= t.maxIterations) {
      r += t.ellipsis
      break
    }
    var s =
      o === 0
        ? Ytt(r, i, t.ascCharWidth, t.cnCharWidth)
        : a > 0
        ? Math.floor((r.length * i) / a)
        : 0
    ;(r = r.substr(0, s)), (a = Mi(r, n))
  }
  return r === '' && (r = t.placeholder), r
}
function Ytt(r, t, e, n) {
  for (var i = 0, a = 0, o = r.length; a < o && i < t; a++) {
    var s = r.charCodeAt(a)
    i += 0 <= s && s <= 127 ? e : n
  }
  return a
}
function $tt(r, t) {
  r != null && (r += '')
  var e = t.overflow,
    n = t.padding,
    i = t.font,
    a = e === 'truncate',
    o = j0(i),
    s = $t(t.lineHeight, o),
    l = !!t.backgroundColor,
    u = t.lineOverflow === 'truncate',
    c = t.width,
    h
  c != null && (e === 'break' || e === 'breakAll')
    ? (h = r ? jz(r, t.font, c, e === 'breakAll', 0).lines : [])
    : (h = r
        ? r.split(`
`)
        : [])
  var f = h.length * s,
    d = $t(t.height, f)
  if (f > d && u) {
    var p = Math.floor(d / s)
    h = h.slice(0, p)
  }
  if (r && a && c != null)
    for (
      var g = Zz(c, i, t.ellipsis, {
          minChar: t.truncateMinChar,
          placeholder: t.placeholder,
        }),
        v = 0;
      v < h.length;
      v++
    )
      h[v] = Kz(h[v], g)
  for (var m = d, y = 0, v = 0; v < h.length; v++) y = Math.max(Mi(h[v], i), y)
  c == null && (c = y)
  var _ = y
  return (
    n && ((m += n[0] + n[2]), (_ += n[1] + n[3]), (c += n[1] + n[3])),
    l && (_ = c),
    {
      lines: h,
      height: d,
      outerWidth: _,
      outerHeight: m,
      lineHeight: s,
      calculatedLineHeight: o,
      contentWidth: y,
      contentHeight: f,
      width: c,
    }
  )
}
var qtt = (function () {
    function r() {}
    return r
  })(),
  lP = (function () {
    function r(t) {
      ;(this.tokens = []), t && (this.tokens = t)
    }
    return r
  })(),
  Ztt = (function () {
    function r() {
      ;(this.width = 0),
        (this.height = 0),
        (this.contentWidth = 0),
        (this.contentHeight = 0),
        (this.outerWidth = 0),
        (this.outerHeight = 0),
        (this.lines = [])
    }
    return r
  })()
function Ktt(r, t) {
  var e = new Ztt()
  if ((r != null && (r += ''), !r)) return e
  for (
    var n = t.width,
      i = t.height,
      a = t.overflow,
      o =
        (a === 'break' || a === 'breakAll') && n != null
          ? {
              width: n,
              accumWidth: 0,
              breakAll: a === 'breakAll',
            }
          : null,
      s = (l1.lastIndex = 0),
      l;
    (l = l1.exec(r)) != null;

  ) {
    var u = l.index
    u > s && u1(e, r.substring(s, u), t, o),
      u1(e, l[2], t, o, l[1]),
      (s = l1.lastIndex)
  }
  s < r.length && u1(e, r.substring(s, r.length), t, o)
  var c = [],
    h = 0,
    f = 0,
    d = t.padding,
    p = a === 'truncate',
    g = t.lineOverflow === 'truncate'
  function v(k, V, H) {
    ;(k.width = V), (k.lineHeight = H), (h += H), (f = Math.max(f, V))
  }
  t: for (var m = 0; m < e.lines.length; m++) {
    for (var y = e.lines[m], _ = 0, x = 0, A = 0; A < y.tokens.length; A++) {
      var S = y.tokens[A],
        b = (S.styleName && t.rich[S.styleName]) || {},
        T = (S.textPadding = b.padding),
        w = T ? T[1] + T[3] : 0,
        M = (S.font = b.font || t.font)
      S.contentHeight = j0(M)
      var C = $t(b.height, S.contentHeight)
      if (
        ((S.innerHeight = C),
        T && (C += T[0] + T[2]),
        (S.height = C),
        (S.lineHeight = ao(b.lineHeight, t.lineHeight, C)),
        (S.align = (b && b.align) || t.align),
        (S.verticalAlign = (b && b.verticalAlign) || 'middle'),
        g && i != null && h + S.lineHeight > i)
      ) {
        A > 0
          ? ((y.tokens = y.tokens.slice(0, A)),
            v(y, x, _),
            (e.lines = e.lines.slice(0, m + 1)))
          : (e.lines = e.lines.slice(0, m))
        break t
      }
      var E = b.width,
        D = E == null || E === 'auto'
      if (typeof E == 'string' && E.charAt(E.length - 1) === '%')
        (S.percentWidth = E), c.push(S), (S.contentWidth = Mi(S.text, M))
      else {
        if (D) {
          var P = b.backgroundColor,
            L = P && P.image
          L &&
            ((L = Wtt(L)),
            Q0(L) && (S.width = Math.max(S.width, (L.width * C) / L.height)))
        }
        var I = p && n != null ? n - x : null
        I != null && I < S.width
          ? !D || I < w
            ? ((S.text = ''), (S.width = S.contentWidth = 0))
            : ((S.text = Xtt(S.text, I - w, M, t.ellipsis, {
                minChar: t.truncateMinChar,
              })),
              (S.width = S.contentWidth = Mi(S.text, M)))
          : (S.contentWidth = Mi(S.text, M))
      }
      ;(S.width += w), (x += S.width), b && (_ = Math.max(_, S.lineHeight))
    }
    v(y, x, _)
  }
  ;(e.outerWidth = e.width = $t(n, f)),
    (e.outerHeight = e.height = $t(i, h)),
    (e.contentHeight = h),
    (e.contentWidth = f),
    d && ((e.outerWidth += d[1] + d[3]), (e.outerHeight += d[0] + d[2]))
  for (var m = 0; m < c.length; m++) {
    var S = c[m],
      F = S.percentWidth
    S.width = (parseInt(F, 10) / 100) * e.width
  }
  return e
}
function u1(r, t, e, n, i) {
  var a = t === '',
    o = (i && e.rich[i]) || {},
    s = r.lines,
    l = o.font || e.font,
    u = !1,
    c,
    h
  if (n) {
    var f = o.padding,
      d = f ? f[1] + f[3] : 0
    if (o.width != null && o.width !== 'auto') {
      var p = Ta(o.width, n.width) + d
      s.length > 0 &&
        p + n.accumWidth > n.width &&
        ((c = t.split(`
`)),
        (u = !0)),
        (n.accumWidth = p)
    } else {
      var g = jz(t, l, n.width, n.breakAll, n.accumWidth)
      ;(n.accumWidth = g.accumWidth + d), (h = g.linesWidths), (c = g.lines)
    }
  } else
    c = t.split(`
`)
  for (var v = 0; v < c.length; v++) {
    var m = c[v],
      y = new qtt()
    if (
      ((y.styleName = i),
      (y.text = m),
      (y.isLineHolder = !m && !a),
      typeof o.width == 'number'
        ? (y.width = o.width)
        : (y.width = h ? h[v] : Mi(m, l)),
      !v && !u)
    ) {
      var _ = (s[s.length - 1] || (s[0] = new lP())).tokens,
        x = _.length
      x === 1 && _[0].isLineHolder ? (_[0] = y) : (m || !x || a) && _.push(y)
    } else s.push(new lP([y]))
  }
}
function jtt(r) {
  var t = r.charCodeAt(0)
  return (
    (t >= 32 && t <= 591) ||
    (t >= 880 && t <= 4351) ||
    (t >= 4608 && t <= 5119) ||
    (t >= 7680 && t <= 8303)
  )
}
var Jtt = co(
  ',&?/;] '.split(''),
  function (r, t) {
    return (r[t] = !0), r
  },
  {},
)
function Qtt(r) {
  return jtt(r) ? !!Jtt[r] : !0
}
function jz(r, t, e, n, i) {
  for (
    var a = [], o = [], s = '', l = '', u = 0, c = 0, h = 0;
    h < r.length;
    h++
  ) {
    var f = r.charAt(h)
    if (
      f ===
      `
`
    ) {
      l && ((s += l), (c += u)),
        a.push(s),
        o.push(c),
        (s = ''),
        (l = ''),
        (u = 0),
        (c = 0)
      continue
    }
    var d = Mi(f, t),
      p = n ? !1 : !Qtt(f)
    if (a.length ? c + d > e : i + c + d > e) {
      c
        ? (s || l) &&
          (p
            ? (s || ((s = l), (l = ''), (u = 0), (c = u)),
              a.push(s),
              o.push(c - u),
              (l += f),
              (u += d),
              (s = ''),
              (c = u))
            : (l && ((s += l), (l = ''), (u = 0)),
              a.push(s),
              o.push(c),
              (s = f),
              (c = d)))
        : p
        ? (a.push(l), o.push(u), (l = f), (u = d))
        : (a.push(f), o.push(d))
      continue
    }
    ;(c += d),
      p ? ((l += f), (u += d)) : (l && ((s += l), (l = ''), (u = 0)), (s += f))
  }
  return (
    !a.length && !s && ((s = r), (l = ''), (u = 0)),
    l && (s += l),
    s && (a.push(s), o.push(c)),
    a.length === 1 && (c += i),
    {
      accumWidth: c,
      lines: a,
      linesWidths: o,
    }
  )
}
var Qb = '__zr_style_' + Math.round(Math.random() * 10),
  Ru = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: '#000',
    opacity: 1,
    blend: 'source-over',
  },
  t_ = {
    style: {
      shadowBlur: !0,
      shadowOffsetX: !0,
      shadowOffsetY: !0,
      shadowColor: !0,
      opacity: !0,
    },
  }
Ru[Qb] = !0
var uP = ['z', 'z2', 'invisible'],
  tet = ['invisible'],
  eet = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype._init = function (e) {
        for (var n = pe(e), i = 0; i < n.length; i++) {
          var a = n[i]
          a === 'style'
            ? this.useStyle(e[a])
            : r.prototype.attrKV.call(this, a, e[a])
        }
        this.style || this.useStyle({})
      }),
      (t.prototype.beforeBrush = function () {}),
      (t.prototype.afterBrush = function () {}),
      (t.prototype.innerBeforeBrush = function () {}),
      (t.prototype.innerAfterBrush = function () {}),
      (t.prototype.shouldBePainted = function (e, n, i, a) {
        var o = this.transform
        if (
          this.ignore ||
          this.invisible ||
          this.style.opacity === 0 ||
          (this.culling && net(this, e, n)) ||
          (o && !o[0] && !o[3])
        )
          return !1
        if (i && this.__clipPaths) {
          for (var s = 0; s < this.__clipPaths.length; ++s)
            if (this.__clipPaths[s].isZeroArea()) return !1
        }
        if (a && this.parent)
          for (var l = this.parent; l; ) {
            if (l.ignore) return !1
            l = l.parent
          }
        return !0
      }),
      (t.prototype.contain = function (e, n) {
        return this.rectContain(e, n)
      }),
      (t.prototype.traverse = function (e, n) {
        e.call(n, this)
      }),
      (t.prototype.rectContain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        return a.contain(i[0], i[1])
      }),
      (t.prototype.getPaintRect = function () {
        var e = this._paintRect
        if (!this._paintRect || this.__dirty) {
          var n = this.transform,
            i = this.getBoundingRect(),
            a = this.style,
            o = a.shadowBlur || 0,
            s = a.shadowOffsetX || 0,
            l = a.shadowOffsetY || 0
          ;(e = this._paintRect || (this._paintRect = new ee(0, 0, 0, 0))),
            n ? ee.applyTransform(e, i, n) : e.copy(i),
            (o || s || l) &&
              ((e.width += o * 2 + Math.abs(s)),
              (e.height += o * 2 + Math.abs(l)),
              (e.x = Math.min(e.x, e.x + s - o)),
              (e.y = Math.min(e.y, e.y + l - o)))
          var u = this.dirtyRectTolerance
          e.isZero() ||
            ((e.x = Math.floor(e.x - u)),
            (e.y = Math.floor(e.y - u)),
            (e.width = Math.ceil(e.width + 1 + u * 2)),
            (e.height = Math.ceil(e.height + 1 + u * 2)))
        }
        return e
      }),
      (t.prototype.setPrevPaintRect = function (e) {
        e
          ? ((this._prevPaintRect = this._prevPaintRect || new ee(0, 0, 0, 0)),
            this._prevPaintRect.copy(e))
          : (this._prevPaintRect = null)
      }),
      (t.prototype.getPrevPaintRect = function () {
        return this._prevPaintRect
      }),
      (t.prototype.animateStyle = function (e) {
        return this.animate('style', e)
      }),
      (t.prototype.updateDuringAnimation = function (e) {
        e === 'style' ? this.dirtyStyle() : this.markRedraw()
      }),
      (t.prototype.attrKV = function (e, n) {
        e !== 'style'
          ? r.prototype.attrKV.call(this, e, n)
          : this.style
          ? this.setStyle(n)
          : this.useStyle(n)
      }),
      (t.prototype.setStyle = function (e, n) {
        return (
          typeof e == 'string' ? (this.style[e] = n) : Q(this.style, e),
          this.dirtyStyle(),
          this
        )
      }),
      (t.prototype.dirtyStyle = function (e) {
        e || this.markRedraw(),
          (this.__dirty |= Od),
          this._rect && (this._rect = null)
      }),
      (t.prototype.dirty = function () {
        this.dirtyStyle()
      }),
      (t.prototype.styleChanged = function () {
        return !!(this.__dirty & Od)
      }),
      (t.prototype.styleUpdated = function () {
        this.__dirty &= ~Od
      }),
      (t.prototype.createStyle = function (e) {
        return q0(Ru, e)
      }),
      (t.prototype.useStyle = function (e) {
        e[Qb] || (e = this.createStyle(e)),
          this.__inHover ? (this.__hoverStyle = e) : (this.style = e),
          this.dirtyStyle()
      }),
      (t.prototype.isStyleObject = function (e) {
        return e[Qb]
      }),
      (t.prototype._innerSaveToNormal = function (e) {
        r.prototype._innerSaveToNormal.call(this, e)
        var n = this._normalState
        e.style &&
          !n.style &&
          (n.style = this._mergeStyle(this.createStyle(), this.style)),
          this._savePrimaryToNormal(e, n, uP)
      }),
      (t.prototype._applyStateObj = function (e, n, i, a, o, s) {
        r.prototype._applyStateObj.call(this, e, n, i, a, o, s)
        var l = !(n && a),
          u
        if (
          (n && n.style
            ? o
              ? a
                ? (u = n.style)
                : ((u = this._mergeStyle(this.createStyle(), i.style)),
                  this._mergeStyle(u, n.style))
              : ((u = this._mergeStyle(
                  this.createStyle(),
                  a ? this.style : i.style,
                )),
                this._mergeStyle(u, n.style))
            : l && (u = i.style),
          u)
        )
          if (o) {
            var c = this.style
            if (((this.style = this.createStyle(l ? {} : c)), l))
              for (var h = pe(c), f = 0; f < h.length; f++) {
                var d = h[f]
                d in u && ((u[d] = u[d]), (this.style[d] = c[d]))
              }
            for (var p = pe(u), f = 0; f < p.length; f++) {
              var d = p[f]
              this.style[d] = this.style[d]
            }
            this._transitionState(
              e,
              {
                style: u,
              },
              s,
              this.getAnimationStyleProps(),
            )
          } else this.useStyle(u)
        for (var g = this.__inHover ? tet : uP, f = 0; f < g.length; f++) {
          var d = g[f]
          n && n[d] != null
            ? (this[d] = n[d])
            : l && i[d] != null && (this[d] = i[d])
        }
      }),
      (t.prototype._mergeStates = function (e) {
        for (
          var n = r.prototype._mergeStates.call(this, e), i, a = 0;
          a < e.length;
          a++
        ) {
          var o = e[a]
          o.style && ((i = i || {}), this._mergeStyle(i, o.style))
        }
        return i && (n.style = i), n
      }),
      (t.prototype._mergeStyle = function (e, n) {
        return Q(e, n), e
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return t_
      }),
      (t.initDefaultProps = (function () {
        var e = t.prototype
        ;(e.type = 'displayable'),
          (e.invisible = !1),
          (e.z = 0),
          (e.z2 = 0),
          (e.zlevel = 0),
          (e.culling = !1),
          (e.cursor = 'pointer'),
          (e.rectHover = !1),
          (e.incremental = !1),
          (e._rect = null),
          (e.dirtyRectTolerance = 0),
          (e.__dirty = yi | Od)
      })()),
      t
    )
  })(Pz),
  c1 = new ee(0, 0, 0, 0),
  h1 = new ee(0, 0, 0, 0)
function net(r, t, e) {
  return (
    c1.copy(r.getBoundingRect()),
    r.transform && c1.applyTransform(r.transform),
    (h1.width = t),
    (h1.height = e),
    !c1.intersect(h1)
  )
}
const ea = eet
var Zr = Math.min,
  Kr = Math.max,
  f1 = Math.sin,
  d1 = Math.cos,
  kl = Math.PI * 2,
  Fg = tc(),
  zg = tc(),
  Ug = tc()
function e_(r, t, e) {
  if (r.length !== 0) {
    for (
      var n = r[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1;
      l < r.length;
      l++
    )
      (n = r[l]),
        (i = Zr(i, n[0])),
        (a = Kr(a, n[0])),
        (o = Zr(o, n[1])),
        (s = Kr(s, n[1]))
    ;(t[0] = i), (t[1] = o), (e[0] = a), (e[1] = s)
  }
}
function cP(r, t, e, n, i, a) {
  ;(i[0] = Zr(r, e)), (i[1] = Zr(t, n)), (a[0] = Kr(r, e)), (a[1] = Kr(t, n))
}
var hP = [],
  fP = []
function ret(r, t, e, n, i, a, o, s, l, u) {
  var c = pz,
    h = Wn,
    f = c(r, e, i, o, hP)
  ;(l[0] = 1 / 0), (l[1] = 1 / 0), (u[0] = -1 / 0), (u[1] = -1 / 0)
  for (var d = 0; d < f; d++) {
    var p = h(r, e, i, o, hP[d])
    ;(l[0] = Zr(p, l[0])), (u[0] = Kr(p, u[0]))
  }
  f = c(t, n, a, s, fP)
  for (var d = 0; d < f; d++) {
    var g = h(t, n, a, s, fP[d])
    ;(l[1] = Zr(g, l[1])), (u[1] = Kr(g, u[1]))
  }
  ;(l[0] = Zr(r, l[0])),
    (u[0] = Kr(r, u[0])),
    (l[0] = Zr(o, l[0])),
    (u[0] = Kr(o, u[0])),
    (l[1] = Zr(t, l[1])),
    (u[1] = Kr(t, u[1])),
    (l[1] = Zr(s, l[1])),
    (u[1] = Kr(s, u[1]))
}
function iet(r, t, e, n, i, a, o, s) {
  var l = gz,
    u = tr,
    c = Kr(Zr(l(r, e, i), 1), 0),
    h = Kr(Zr(l(t, n, a), 1), 0),
    f = u(r, e, i, c),
    d = u(t, n, a, h)
  ;(o[0] = Zr(r, i, f)),
    (o[1] = Zr(t, a, d)),
    (s[0] = Kr(r, i, f)),
    (s[1] = Kr(t, a, d))
}
function aet(r, t, e, n, i, a, o, s, l) {
  var u = Bs,
    c = Fs,
    h = Math.abs(i - a)
  if (h % kl < 1e-4 && h > 1e-4) {
    ;(s[0] = r - e), (s[1] = t - n), (l[0] = r + e), (l[1] = t + n)
    return
  }
  if (
    ((Fg[0] = d1(i) * e + r),
    (Fg[1] = f1(i) * n + t),
    (zg[0] = d1(a) * e + r),
    (zg[1] = f1(a) * n + t),
    u(s, Fg, zg),
    c(l, Fg, zg),
    (i = i % kl),
    i < 0 && (i = i + kl),
    (a = a % kl),
    a < 0 && (a = a + kl),
    i > a && !o ? (a += kl) : i < a && o && (i += kl),
    o)
  ) {
    var f = a
    ;(a = i), (i = f)
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > i &&
      ((Ug[0] = d1(d) * e + r),
      (Ug[1] = f1(d) * n + t),
      u(s, Ug, s),
      c(l, Ug, l))
}
var Ge = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7,
  },
  Bl = [],
  Fl = [],
  ka = [],
  gs = [],
  Ba = [],
  Fa = [],
  p1 = Math.min,
  v1 = Math.max,
  zl = Math.cos,
  Ul = Math.sin,
  Eo = Math.abs,
  tw = Math.PI,
  Ms = tw * 2,
  g1 = typeof Float32Array < 'u',
  td = []
function m1(r) {
  var t = Math.round((r / tw) * 1e8) / 1e8
  return (t % 2) * tw
}
function HT(r, t) {
  var e = m1(r[0])
  e < 0 && (e += Ms)
  var n = e - r[0],
    i = r[1]
  ;(i += n),
    !t && i - e >= Ms
      ? (i = e + Ms)
      : t && e - i >= Ms
      ? (i = e - Ms)
      : !t && e > i
      ? (i = e + (Ms - m1(e - i)))
      : t && e < i && (i = e - (Ms - m1(i - e))),
    (r[0] = e),
    (r[1] = i)
}
var vo = (function () {
  function r(t) {
    ;(this.dpr = 1),
      (this._xi = 0),
      (this._yi = 0),
      (this._x0 = 0),
      (this._y0 = 0),
      (this._len = 0),
      t && (this._saveData = !1),
      this._saveData && (this.data = [])
  }
  return (
    (r.prototype.increaseVersion = function () {
      this._version++
    }),
    (r.prototype.getVersion = function () {
      return this._version
    }),
    (r.prototype.setScale = function (t, e, n) {
      ;(n = n || 0),
        n > 0 &&
          ((this._ux = Eo(n / Gy / t) || 0), (this._uy = Eo(n / Gy / e) || 0))
    }),
    (r.prototype.setDPR = function (t) {
      this.dpr = t
    }),
    (r.prototype.setContext = function (t) {
      this._ctx = t
    }),
    (r.prototype.getContext = function () {
      return this._ctx
    }),
    (r.prototype.beginPath = function () {
      return this._ctx && this._ctx.beginPath(), this.reset(), this
    }),
    (r.prototype.reset = function () {
      this._saveData && (this._len = 0),
        this._pathSegLen && ((this._pathSegLen = null), (this._pathLen = 0)),
        this._version++
    }),
    (r.prototype.moveTo = function (t, e) {
      return (
        this._drawPendingPt(),
        this.addData(Ge.M, t, e),
        this._ctx && this._ctx.moveTo(t, e),
        (this._x0 = t),
        (this._y0 = e),
        (this._xi = t),
        (this._yi = e),
        this
      )
    }),
    (r.prototype.lineTo = function (t, e) {
      var n = Eo(t - this._xi),
        i = Eo(e - this._yi),
        a = n > this._ux || i > this._uy
      if (
        (this.addData(Ge.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a)
      )
        (this._xi = t), (this._yi = e), (this._pendingPtDist = 0)
      else {
        var o = n * n + i * i
        o > this._pendingPtDist &&
          ((this._pendingPtX = t),
          (this._pendingPtY = e),
          (this._pendingPtDist = o))
      }
      return this
    }),
    (r.prototype.bezierCurveTo = function (t, e, n, i, a, o) {
      return (
        this._drawPendingPt(),
        this.addData(Ge.C, t, e, n, i, a, o),
        this._ctx && this._ctx.bezierCurveTo(t, e, n, i, a, o),
        (this._xi = a),
        (this._yi = o),
        this
      )
    }),
    (r.prototype.quadraticCurveTo = function (t, e, n, i) {
      return (
        this._drawPendingPt(),
        this.addData(Ge.Q, t, e, n, i),
        this._ctx && this._ctx.quadraticCurveTo(t, e, n, i),
        (this._xi = n),
        (this._yi = i),
        this
      )
    }),
    (r.prototype.arc = function (t, e, n, i, a, o) {
      this._drawPendingPt(),
        (td[0] = i),
        (td[1] = a),
        HT(td, o),
        (i = td[0]),
        (a = td[1])
      var s = a - i
      return (
        this.addData(Ge.A, t, e, n, n, i, s, 0, o ? 0 : 1),
        this._ctx && this._ctx.arc(t, e, n, i, a, o),
        (this._xi = zl(a) * n + t),
        (this._yi = Ul(a) * n + e),
        this
      )
    }),
    (r.prototype.arcTo = function (t, e, n, i, a) {
      return (
        this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, n, i, a), this
      )
    }),
    (r.prototype.rect = function (t, e, n, i) {
      return (
        this._drawPendingPt(),
        this._ctx && this._ctx.rect(t, e, n, i),
        this.addData(Ge.R, t, e, n, i),
        this
      )
    }),
    (r.prototype.closePath = function () {
      this._drawPendingPt(), this.addData(Ge.Z)
      var t = this._ctx,
        e = this._x0,
        n = this._y0
      return t && t.closePath(), (this._xi = e), (this._yi = n), this
    }),
    (r.prototype.fill = function (t) {
      t && t.fill(), this.toStatic()
    }),
    (r.prototype.stroke = function (t) {
      t && t.stroke(), this.toStatic()
    }),
    (r.prototype.len = function () {
      return this._len
    }),
    (r.prototype.setData = function (t) {
      var e = t.length
      !(this.data && this.data.length === e) &&
        g1 &&
        (this.data = new Float32Array(e))
      for (var n = 0; n < e; n++) this.data[n] = t[n]
      this._len = e
    }),
    (r.prototype.appendPath = function (t) {
      t instanceof Array || (t = [t])
      for (var e = t.length, n = 0, i = this._len, a = 0; a < e; a++)
        n += t[a].len()
      g1 &&
        this.data instanceof Float32Array &&
        (this.data = new Float32Array(i + n))
      for (var a = 0; a < e; a++)
        for (var o = t[a].data, s = 0; s < o.length; s++) this.data[i++] = o[s]
      this._len = i
    }),
    (r.prototype.addData = function (t, e, n, i, a, o, s, l, u) {
      if (this._saveData) {
        var c = this.data
        this._len + arguments.length > c.length &&
          (this._expandData(), (c = this.data))
        for (var h = 0; h < arguments.length; h++) c[this._len++] = arguments[h]
      }
    }),
    (r.prototype._drawPendingPt = function () {
      this._pendingPtDist > 0 &&
        (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY),
        (this._pendingPtDist = 0))
    }),
    (r.prototype._expandData = function () {
      if (!(this.data instanceof Array)) {
        for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e]
        this.data = t
      }
    }),
    (r.prototype.toStatic = function () {
      if (this._saveData) {
        this._drawPendingPt()
        var t = this.data
        t instanceof Array &&
          ((t.length = this._len),
          g1 && this._len > 11 && (this.data = new Float32Array(t)))
      }
    }),
    (r.prototype.getBoundingRect = function () {
      ;(ka[0] = ka[1] = Ba[0] = Ba[1] = Number.MAX_VALUE),
        (gs[0] = gs[1] = Fa[0] = Fa[1] = -Number.MAX_VALUE)
      var t = this.data,
        e = 0,
        n = 0,
        i = 0,
        a = 0,
        o
      for (o = 0; o < this._len; ) {
        var s = t[o++],
          l = o === 1
        switch ((l && ((e = t[o]), (n = t[o + 1]), (i = e), (a = n)), s)) {
          case Ge.M:
            ;(e = i = t[o++]),
              (n = a = t[o++]),
              (Ba[0] = i),
              (Ba[1] = a),
              (Fa[0] = i),
              (Fa[1] = a)
            break
          case Ge.L:
            cP(e, n, t[o], t[o + 1], Ba, Fa), (e = t[o++]), (n = t[o++])
            break
          case Ge.C:
            ret(e, n, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Ba, Fa),
              (e = t[o++]),
              (n = t[o++])
            break
          case Ge.Q:
            iet(e, n, t[o++], t[o++], t[o], t[o + 1], Ba, Fa),
              (e = t[o++]),
              (n = t[o++])
            break
          case Ge.A:
            var u = t[o++],
              c = t[o++],
              h = t[o++],
              f = t[o++],
              d = t[o++],
              p = t[o++] + d
            o += 1
            var g = !t[o++]
            l && ((i = zl(d) * h + u), (a = Ul(d) * f + c)),
              aet(u, c, h, f, d, p, g, Ba, Fa),
              (e = zl(p) * h + u),
              (n = Ul(p) * f + c)
            break
          case Ge.R:
            ;(i = e = t[o++]), (a = n = t[o++])
            var v = t[o++],
              m = t[o++]
            cP(i, a, i + v, a + m, Ba, Fa)
            break
          case Ge.Z:
            ;(e = i), (n = a)
            break
        }
        Bs(ka, ka, Ba), Fs(gs, gs, Fa)
      }
      return (
        o === 0 && (ka[0] = ka[1] = gs[0] = gs[1] = 0),
        new ee(ka[0], ka[1], gs[0] - ka[0], gs[1] - ka[1])
      )
    }),
    (r.prototype._calculateLength = function () {
      var t = this.data,
        e = this._len,
        n = this._ux,
        i = this._uy,
        a = 0,
        o = 0,
        s = 0,
        l = 0
      this._pathSegLen || (this._pathSegLen = [])
      for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < e; ) {
        var d = t[f++],
          p = f === 1
        p && ((a = t[f]), (o = t[f + 1]), (s = a), (l = o))
        var g = -1
        switch (d) {
          case Ge.M:
            ;(a = s = t[f++]), (o = l = t[f++])
            break
          case Ge.L: {
            var v = t[f++],
              m = t[f++],
              y = v - a,
              _ = m - o
            ;(Eo(y) > n || Eo(_) > i || f === e - 1) &&
              ((g = Math.sqrt(y * y + _ * _)), (a = v), (o = m))
            break
          }
          case Ge.C: {
            var x = t[f++],
              A = t[f++],
              v = t[f++],
              m = t[f++],
              S = t[f++],
              b = t[f++]
            ;(g = _Q(a, o, x, A, v, m, S, b, 10)), (a = S), (o = b)
            break
          }
          case Ge.Q: {
            var x = t[f++],
              A = t[f++],
              v = t[f++],
              m = t[f++]
            ;(g = SQ(a, o, x, A, v, m, 10)), (a = v), (o = m)
            break
          }
          case Ge.A:
            var T = t[f++],
              w = t[f++],
              M = t[f++],
              C = t[f++],
              E = t[f++],
              D = t[f++],
              P = D + E
            ;(f += 1),
              p && ((s = zl(E) * M + T), (l = Ul(E) * C + w)),
              (g = v1(M, C) * p1(Ms, Math.abs(D))),
              (a = zl(P) * M + T),
              (o = Ul(P) * C + w)
            break
          case Ge.R: {
            ;(s = a = t[f++]), (l = o = t[f++])
            var L = t[f++],
              I = t[f++]
            g = L * 2 + I * 2
            break
          }
          case Ge.Z: {
            var y = s - a,
              _ = l - o
            ;(g = Math.sqrt(y * y + _ * _)), (a = s), (o = l)
            break
          }
        }
        g >= 0 && ((u[h++] = g), (c += g))
      }
      return (this._pathLen = c), c
    }),
    (r.prototype.rebuildPath = function (t, e) {
      var n = this.data,
        i = this._ux,
        a = this._uy,
        o = this._len,
        s,
        l,
        u,
        c,
        h,
        f,
        d = e < 1,
        p,
        g,
        v = 0,
        m = 0,
        y,
        _ = 0,
        x,
        A
      if (
        !(
          d &&
          (this._pathSegLen || this._calculateLength(),
          (p = this._pathSegLen),
          (g = this._pathLen),
          (y = e * g),
          !y)
        )
      )
        t: for (var S = 0; S < o; ) {
          var b = n[S++],
            T = S === 1
          switch (
            (T && ((u = n[S]), (c = n[S + 1]), (s = u), (l = c)),
            b !== Ge.L && _ > 0 && (t.lineTo(x, A), (_ = 0)),
            b)
          ) {
            case Ge.M:
              ;(s = u = n[S++]), (l = c = n[S++]), t.moveTo(u, c)
              break
            case Ge.L: {
              ;(h = n[S++]), (f = n[S++])
              var w = Eo(h - u),
                M = Eo(f - c)
              if (w > i || M > a) {
                if (d) {
                  var C = p[m++]
                  if (v + C > y) {
                    var E = (y - v) / C
                    t.lineTo(u * (1 - E) + h * E, c * (1 - E) + f * E)
                    break t
                  }
                  v += C
                }
                t.lineTo(h, f), (u = h), (c = f), (_ = 0)
              } else {
                var D = w * w + M * M
                D > _ && ((x = h), (A = f), (_ = D))
              }
              break
            }
            case Ge.C: {
              var P = n[S++],
                L = n[S++],
                I = n[S++],
                F = n[S++],
                k = n[S++],
                V = n[S++]
              if (d) {
                var C = p[m++]
                if (v + C > y) {
                  var E = (y - v) / C
                  il(u, P, I, k, E, Bl),
                    il(c, L, F, V, E, Fl),
                    t.bezierCurveTo(Bl[1], Fl[1], Bl[2], Fl[2], Bl[3], Fl[3])
                  break t
                }
                v += C
              }
              t.bezierCurveTo(P, L, I, F, k, V), (u = k), (c = V)
              break
            }
            case Ge.Q: {
              var P = n[S++],
                L = n[S++],
                I = n[S++],
                F = n[S++]
              if (d) {
                var C = p[m++]
                if (v + C > y) {
                  var E = (y - v) / C
                  Bp(u, P, I, E, Bl),
                    Bp(c, L, F, E, Fl),
                    t.quadraticCurveTo(Bl[1], Fl[1], Bl[2], Fl[2])
                  break t
                }
                v += C
              }
              t.quadraticCurveTo(P, L, I, F), (u = I), (c = F)
              break
            }
            case Ge.A:
              var H = n[S++],
                Y = n[S++],
                K = n[S++],
                ut = n[S++],
                W = n[S++],
                Z = n[S++],
                ft = n[S++],
                lt = !n[S++],
                ct = K > ut ? K : ut,
                At = Eo(K - ut) > 0.001,
                gt = W + Z,
                dt = !1
              if (d) {
                var C = p[m++]
                v + C > y && ((gt = W + (Z * (y - v)) / C), (dt = !0)), (v += C)
              }
              if (
                (At && t.ellipse
                  ? t.ellipse(H, Y, K, ut, ft, W, gt, lt)
                  : t.arc(H, Y, ct, W, gt, lt),
                dt)
              )
                break t
              T && ((s = zl(W) * K + H), (l = Ul(W) * ut + Y)),
                (u = zl(gt) * K + H),
                (c = Ul(gt) * ut + Y)
              break
            case Ge.R:
              ;(s = u = n[S]), (l = c = n[S + 1]), (h = n[S++]), (f = n[S++])
              var B = n[S++],
                ht = n[S++]
              if (d) {
                var C = p[m++]
                if (v + C > y) {
                  var it = y - v
                  t.moveTo(h, f),
                    t.lineTo(h + p1(it, B), f),
                    (it -= B),
                    it > 0 && t.lineTo(h + B, f + p1(it, ht)),
                    (it -= ht),
                    it > 0 && t.lineTo(h + v1(B - it, 0), f + ht),
                    (it -= B),
                    it > 0 && t.lineTo(h, f + v1(ht - it, 0))
                  break t
                }
                v += C
              }
              t.rect(h, f, B, ht)
              break
            case Ge.Z:
              if (d) {
                var C = p[m++]
                if (v + C > y) {
                  var E = (y - v) / C
                  t.lineTo(u * (1 - E) + s * E, c * (1 - E) + l * E)
                  break t
                }
                v += C
              }
              t.closePath(), (u = s), (c = l)
          }
        }
    }),
    (r.prototype.clone = function () {
      var t = new r(),
        e = this.data
      return (
        (t.data = e.slice ? e.slice() : Array.prototype.slice.call(e)),
        (t._len = this._len),
        t
      )
    }),
    (r.CMD = Ge),
    (r.initDefaultProps = (function () {
      var t = r.prototype
      ;(t._saveData = !0),
        (t._ux = 0),
        (t._uy = 0),
        (t._pendingPtDist = 0),
        (t._version = 0)
    })()),
    r
  )
})()
function Es(r, t, e, n, i, a, o) {
  if (i === 0) return !1
  var s = i,
    l = 0,
    u = r
  if (
    (o > t + s && o > n + s) ||
    (o < t - s && o < n - s) ||
    (a > r + s && a > e + s) ||
    (a < r - s && a < e - s)
  )
    return !1
  if (r !== e) (l = (t - n) / (r - e)), (u = (r * n - e * t) / (r - e))
  else return Math.abs(a - r) <= s / 2
  var c = l * a - o + u,
    h = (c * c) / (l * l + 1)
  return h <= ((s / 2) * s) / 2
}
function oet(r, t, e, n, i, a, o, s, l, u, c) {
  if (l === 0) return !1
  var h = l
  if (
    (c > t + h && c > n + h && c > a + h && c > s + h) ||
    (c < t - h && c < n - h && c < a - h && c < s - h) ||
    (u > r + h && u > e + h && u > i + h && u > o + h) ||
    (u < r - h && u < e - h && u < i - h && u < o - h)
  )
    return !1
  var f = vz(r, t, e, n, i, a, o, s, u, c, null)
  return f <= h / 2
}
function Jz(r, t, e, n, i, a, o, s, l) {
  if (o === 0) return !1
  var u = o
  if (
    (l > t + u && l > n + u && l > a + u) ||
    (l < t - u && l < n - u && l < a - u) ||
    (s > r + u && s > e + u && s > i + u) ||
    (s < r - u && s < e - u && s < i - u)
  )
    return !1
  var c = mz(r, t, e, n, i, a, s, l, null)
  return c <= u / 2
}
var dP = Math.PI * 2
function xi(r) {
  return (r %= dP), r < 0 && (r += dP), r
}
var ed = Math.PI * 2
function set(r, t, e, n, i, a, o, s, l) {
  if (o === 0) return !1
  var u = o
  ;(s -= r), (l -= t)
  var c = Math.sqrt(s * s + l * l)
  if (c - u > e || c + u < e) return !1
  if (Math.abs(n - i) % ed < 1e-4) return !0
  if (a) {
    var h = n
    ;(n = xi(i)), (i = xi(h))
  } else (n = xi(n)), (i = xi(i))
  n > i && (i += ed)
  var f = Math.atan2(l, s)
  return f < 0 && (f += ed), (f >= n && f <= i) || (f + ed >= n && f + ed <= i)
}
function No(r, t, e, n, i, a) {
  if ((a > t && a > n) || (a < t && a < n) || n === t) return 0
  var o = (a - t) / (n - t),
    s = n < t ? 1 : -1
  ;(o === 1 || o === 0) && (s = n < t ? 0.5 : -0.5)
  var l = o * (e - r) + r
  return l === i ? 1 / 0 : l > i ? s : 0
}
var ms = vo.CMD,
  Vl = Math.PI * 2,
  uet = 1e-4
function cet(r, t) {
  return Math.abs(r - t) < uet
}
var kr = [-1, -1, -1],
  Ui = [-1, -1]
function het() {
  var r = Ui[0]
  ;(Ui[0] = Ui[1]), (Ui[1] = r)
}
function fet(r, t, e, n, i, a, o, s, l, u) {
  if ((u > t && u > n && u > a && u > s) || (u < t && u < n && u < a && u < s))
    return 0
  var c = Fy(t, n, a, s, u, kr)
  if (c === 0) return 0
  for (var h = 0, f = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
    var v = kr[g],
      m = v === 0 || v === 1 ? 0.5 : 1,
      y = Wn(r, e, i, o, v)
    y < l ||
      (f < 0 &&
        ((f = pz(t, n, a, s, Ui)),
        Ui[1] < Ui[0] && f > 1 && het(),
        (d = Wn(t, n, a, s, Ui[0])),
        f > 1 && (p = Wn(t, n, a, s, Ui[1]))),
      f === 2
        ? v < Ui[0]
          ? (h += d < t ? m : -m)
          : v < Ui[1]
          ? (h += p < d ? m : -m)
          : (h += s < p ? m : -m)
        : v < Ui[0]
        ? (h += d < t ? m : -m)
        : (h += s < d ? m : -m))
  }
  return h
}
function det(r, t, e, n, i, a, o, s) {
  if ((s > t && s > n && s > a) || (s < t && s < n && s < a)) return 0
  var l = xQ(t, n, a, s, kr)
  if (l === 0) return 0
  var u = gz(t, n, a)
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = tr(t, n, a, u), f = 0; f < l; f++) {
      var d = kr[f] === 0 || kr[f] === 1 ? 0.5 : 1,
        p = tr(r, e, i, kr[f])
      p < o || (kr[f] < u ? (c += h < t ? d : -d) : (c += a < h ? d : -d))
    }
    return c
  } else {
    var d = kr[0] === 0 || kr[0] === 1 ? 0.5 : 1,
      p = tr(r, e, i, kr[0])
    return p < o ? 0 : a < t ? d : -d
  }
}
function pet(r, t, e, n, i, a, o, s) {
  if (((s -= t), s > e || s < -e)) return 0
  var l = Math.sqrt(e * e - s * s)
  ;(kr[0] = -l), (kr[1] = l)
  var u = Math.abs(n - i)
  if (u < 1e-4) return 0
  if (u >= Vl - 1e-4) {
    ;(n = 0), (i = Vl)
    var c = a ? 1 : -1
    return o >= kr[0] + r && o <= kr[1] + r ? c : 0
  }
  if (n > i) {
    var h = n
    ;(n = i), (i = h)
  }
  n < 0 && ((n += Vl), (i += Vl))
  for (var f = 0, d = 0; d < 2; d++) {
    var p = kr[d]
    if (p + r > o) {
      var g = Math.atan2(s, p),
        c = a ? 1 : -1
      g < 0 && (g = Vl + g),
        ((g >= n && g <= i) || (g + Vl >= n && g + Vl <= i)) &&
          (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), (f += c))
    }
  }
  return f
}
function Qz(r, t, e, n, i) {
  for (
    var a = r.data, o = r.len(), s = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0;
    p < o;

  ) {
    var g = a[p++],
      v = p === 1
    switch (
      (g === ms.M && p > 1 && (e || (s += No(l, u, c, h, n, i))),
      v && ((l = a[p]), (u = a[p + 1]), (c = l), (h = u)),
      g)
    ) {
      case ms.M:
        ;(c = a[p++]), (h = a[p++]), (l = c), (u = h)
        break
      case ms.L:
        if (e) {
          if (Es(l, u, a[p], a[p + 1], t, n, i)) return !0
        } else s += No(l, u, a[p], a[p + 1], n, i) || 0
        ;(l = a[p++]), (u = a[p++])
        break
      case ms.C:
        if (e) {
          if (
            oet(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], t, n, i)
          )
            return !0
        } else
          s +=
            fet(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], n, i) || 0
        ;(l = a[p++]), (u = a[p++])
        break
      case ms.Q:
        if (e) {
          if (Jz(l, u, a[p++], a[p++], a[p], a[p + 1], t, n, i)) return !0
        } else s += det(l, u, a[p++], a[p++], a[p], a[p + 1], n, i) || 0
        ;(l = a[p++]), (u = a[p++])
        break
      case ms.A:
        var m = a[p++],
          y = a[p++],
          _ = a[p++],
          x = a[p++],
          A = a[p++],
          S = a[p++]
        p += 1
        var b = !!(1 - a[p++])
        ;(f = Math.cos(A) * _ + m),
          (d = Math.sin(A) * x + y),
          v ? ((c = f), (h = d)) : (s += No(l, u, f, d, n, i))
        var T = ((n - m) * x) / _ + m
        if (e) {
          if (set(m, y, x, A, A + S, b, t, T, i)) return !0
        } else s += pet(m, y, x, A, A + S, b, T, i)
        ;(l = Math.cos(A + S) * _ + m), (u = Math.sin(A + S) * x + y)
        break
      case ms.R:
        ;(c = l = a[p++]), (h = u = a[p++])
        var w = a[p++],
          M = a[p++]
        if (((f = c + w), (d = h + M), e)) {
          if (
            Es(c, h, f, h, t, n, i) ||
            Es(f, h, f, d, t, n, i) ||
            Es(f, d, c, d, t, n, i) ||
            Es(c, d, c, h, t, n, i)
          )
            return !0
        } else (s += No(f, h, f, d, n, i)), (s += No(c, d, c, h, n, i))
        break
      case ms.Z:
        if (e) {
          if (Es(l, u, c, h, t, n, i)) return !0
        } else s += No(l, u, c, h, n, i)
        ;(l = c), (u = h)
        break
    }
  }
  return !e && !cet(u, h) && (s += No(l, u, c, h, n, i) || 0), s !== 0
}
function vet(r, t, e) {
  return Qz(r, 0, !1, t, e)
}
function get(r, t, e, n) {
  return Qz(r, t, !0, e, n)
}
var Wy = zt(
    {
      fill: '#000',
      stroke: null,
      strokePercent: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDashOffset: 0,
      lineWidth: 1,
      lineCap: 'butt',
      miterLimit: 10,
      strokeNoScale: !1,
      strokeFirst: !1,
    },
    Ru,
  ),
  met = {
    style: zt(
      {
        fill: !0,
        stroke: !0,
        strokePercent: !0,
        fillOpacity: !0,
        strokeOpacity: !0,
        lineDashOffset: !0,
        lineWidth: !0,
        miterLimit: !0,
      },
      t_.style,
    ),
  },
  y1 = fo.concat(['invisible', 'culling', 'z', 'z2', 'zlevel', 'parent']),
  yet = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.update = function () {
        var e = this
        r.prototype.update.call(this)
        var n = this.style
        if (n.decal) {
          var i = (this._decalEl = this._decalEl || new t())
          i.buildPath === t.prototype.buildPath &&
            (i.buildPath = function (l) {
              e.buildPath(l, e.shape)
            }),
            (i.silent = !0)
          var a = i.style
          for (var o in n) a[o] !== n[o] && (a[o] = n[o])
          ;(a.fill = n.fill ? n.decal : null),
            (a.decal = null),
            (a.shadowColor = null),
            n.strokeFirst && (a.stroke = null)
          for (var s = 0; s < y1.length; ++s) i[y1[s]] = this[y1[s]]
          i.__dirty |= yi
        } else this._decalEl && (this._decalEl = null)
      }),
      (t.prototype.getDecalElement = function () {
        return this._decalEl
      }),
      (t.prototype._init = function (e) {
        var n = pe(e)
        this.shape = this.getDefaultShape()
        var i = this.getDefaultStyle()
        i && this.useStyle(i)
        for (var a = 0; a < n.length; a++) {
          var o = n[a],
            s = e[o]
          o === 'style'
            ? this.style
              ? Q(this.style, s)
              : this.useStyle(s)
            : o === 'shape'
            ? Q(this.shape, s)
            : r.prototype.attrKV.call(this, o, s)
        }
        this.style || this.useStyle({})
      }),
      (t.prototype.getDefaultStyle = function () {
        return null
      }),
      (t.prototype.getDefaultShape = function () {
        return {}
      }),
      (t.prototype.canBeInsideText = function () {
        return this.hasFill()
      }),
      (t.prototype.getInsideTextFill = function () {
        var e = this.style.fill
        if (e !== 'none') {
          if (bt(e)) {
            var n = Uy(e, 0)
            return n > 0.5 ? qb : n > 0.2 ? JQ : Zb
          } else if (e) return Zb
        }
        return qb
      }),
      (t.prototype.getInsideTextStroke = function (e) {
        var n = this.style.fill
        if (bt(n)) {
          var i = this.__zr,
            a = !!(i && i.isDarkMode()),
            o = Uy(e, 0) < $b
          if (a === o) return n
        }
      }),
      (t.prototype.buildPath = function (e, n, i) {}),
      (t.prototype.pathUpdated = function () {
        this.__dirty &= ~oh
      }),
      (t.prototype.getUpdatedPathProxy = function (e) {
        return (
          !this.path && this.createPathProxy(),
          this.path.beginPath(),
          this.buildPath(this.path, this.shape, e),
          this.path
        )
      }),
      (t.prototype.createPathProxy = function () {
        this.path = new vo(!1)
      }),
      (t.prototype.hasStroke = function () {
        var e = this.style,
          n = e.stroke
        return !(n == null || n === 'none' || !(e.lineWidth > 0))
      }),
      (t.prototype.hasFill = function () {
        var e = this.style,
          n = e.fill
        return n != null && n !== 'none'
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect,
          n = this.style,
          i = !e
        if (i) {
          var a = !1
          this.path || ((a = !0), this.createPathProxy())
          var o = this.path
          ;(a || this.__dirty & oh) &&
            (o.beginPath(),
            this.buildPath(o, this.shape, !1),
            this.pathUpdated()),
            (e = o.getBoundingRect())
        }
        if (
          ((this._rect = e),
          this.hasStroke() && this.path && this.path.len() > 0)
        ) {
          var s = this._rectStroke || (this._rectStroke = e.clone())
          if (this.__dirty || i) {
            s.copy(e)
            var l = n.strokeNoScale ? this.getLineScale() : 1,
              u = n.lineWidth
            if (!this.hasFill()) {
              var c = this.strokeContainThreshold
              u = Math.max(u, c ?? 4)
            }
            l > 1e-10 &&
              ((s.width += u / l),
              (s.height += u / l),
              (s.x -= u / l / 2),
              (s.y -= u / l / 2))
          }
          return s
        }
        return e
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect(),
          o = this.style
        if (((e = i[0]), (n = i[1]), a.contain(e, n))) {
          var s = this.path
          if (this.hasStroke()) {
            var l = o.lineWidth,
              u = o.strokeNoScale ? this.getLineScale() : 1
            if (
              u > 1e-10 &&
              (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)),
              get(s, l / u, e, n))
            )
              return !0
          }
          if (this.hasFill()) return vet(s, e, n)
        }
        return !1
      }),
      (t.prototype.dirtyShape = function () {
        ;(this.__dirty |= oh),
          this._rect && (this._rect = null),
          this._decalEl && this._decalEl.dirtyShape(),
          this.markRedraw()
      }),
      (t.prototype.dirty = function () {
        this.dirtyStyle(), this.dirtyShape()
      }),
      (t.prototype.animateShape = function (e) {
        return this.animate('shape', e)
      }),
      (t.prototype.updateDuringAnimation = function (e) {
        e === 'style'
          ? this.dirtyStyle()
          : e === 'shape'
          ? this.dirtyShape()
          : this.markRedraw()
      }),
      (t.prototype.attrKV = function (e, n) {
        e === 'shape' ? this.setShape(n) : r.prototype.attrKV.call(this, e, n)
      }),
      (t.prototype.setShape = function (e, n) {
        var i = this.shape
        return (
          i || (i = this.shape = {}),
          typeof e == 'string' ? (i[e] = n) : Q(i, e),
          this.dirtyShape(),
          this
        )
      }),
      (t.prototype.shapeChanged = function () {
        return !!(this.__dirty & oh)
      }),
      (t.prototype.createStyle = function (e) {
        return q0(Wy, e)
      }),
      (t.prototype._innerSaveToNormal = function (e) {
        r.prototype._innerSaveToNormal.call(this, e)
        var n = this._normalState
        e.shape && !n.shape && (n.shape = Q({}, this.shape))
      }),
      (t.prototype._applyStateObj = function (e, n, i, a, o, s) {
        r.prototype._applyStateObj.call(this, e, n, i, a, o, s)
        var l = !(n && a),
          u
        if (
          (n && n.shape
            ? o
              ? a
                ? (u = n.shape)
                : ((u = Q({}, i.shape)), Q(u, n.shape))
              : ((u = Q({}, a ? this.shape : i.shape)), Q(u, n.shape))
            : l && (u = i.shape),
          u)
        )
          if (o) {
            this.shape = Q({}, this.shape)
            for (var c = {}, h = pe(u), f = 0; f < h.length; f++) {
              var d = h[f]
              typeof u[d] == 'object' ? (this.shape[d] = u[d]) : (c[d] = u[d])
            }
            this._transitionState(
              e,
              {
                shape: c,
              },
              s,
            )
          } else (this.shape = u), this.dirtyShape()
      }),
      (t.prototype._mergeStates = function (e) {
        for (
          var n = r.prototype._mergeStates.call(this, e), i, a = 0;
          a < e.length;
          a++
        ) {
          var o = e[a]
          o.shape && ((i = i || {}), this._mergeStyle(i, o.shape))
        }
        return i && (n.shape = i), n
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return met
      }),
      (t.prototype.isZeroArea = function () {
        return !1
      }),
      (t.extend = function (e) {
        var n = (function (a) {
          X(o, a)
          function o(s) {
            var l = a.call(this, s) || this
            return e.init && e.init.call(l, s), l
          }
          return (
            (o.prototype.getDefaultStyle = function () {
              return Vt(e.style)
            }),
            (o.prototype.getDefaultShape = function () {
              return Vt(e.shape)
            }),
            o
          )
        })(t)
        for (var i in e) typeof e[i] == 'function' && (n.prototype[i] = e[i])
        return n
      }),
      (t.initDefaultProps = (function () {
        var e = t.prototype
        ;(e.type = 'path'),
          (e.strokeContainThreshold = 5),
          (e.segmentIgnoreThreshold = 0),
          (e.subPixelOptimize = !1),
          (e.autoBatch = !1),
          (e.__dirty = yi | Od | oh)
      })()),
      t
    )
  })(ea)
const oe = yet
var _et = zt(
    {
      strokeFirst: !0,
      font: nl,
      x: 0,
      y: 0,
      textAlign: 'left',
      textBaseline: 'top',
      miterLimit: 2,
    },
    Wy,
  ),
  tU = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.hasStroke = function () {
        var e = this.style,
          n = e.stroke
        return n != null && n !== 'none' && e.lineWidth > 0
      }),
      (t.prototype.hasFill = function () {
        var e = this.style,
          n = e.fill
        return n != null && n !== 'none'
      }),
      (t.prototype.createStyle = function (e) {
        return q0(_et, e)
      }),
      (t.prototype.setBoundingRect = function (e) {
        this._rect = e
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this.style
        if (!this._rect) {
          var n = e.text
          n != null ? (n += '') : (n = '')
          var i = mv(n, e.font, e.textAlign, e.textBaseline)
          if (((i.x += e.x || 0), (i.y += e.y || 0), this.hasStroke())) {
            var a = e.lineWidth
            ;(i.x -= a / 2), (i.y -= a / 2), (i.width += a), (i.height += a)
          }
          this._rect = i
        }
        return this._rect
      }),
      (t.initDefaultProps = (function () {
        var e = t.prototype
        e.dirtyRectTolerance = 10
      })()),
      t
    )
  })(ea)
tU.prototype.type = 'tspan'
const Gp = tU
var xet = zt(
    {
      x: 0,
      y: 0,
    },
    Ru,
  ),
  Aet = {
    style: zt(
      {
        x: !0,
        y: !0,
        width: !0,
        height: !0,
        sx: !0,
        sy: !0,
        sWidth: !0,
        sHeight: !0,
      },
      t_.style,
    ),
  }
function bet(r) {
  return !!(r && typeof r != 'string' && r.width && r.height)
}
var eU = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.createStyle = function (e) {
      return q0(xet, e)
    }),
    (t.prototype._getSize = function (e) {
      var n = this.style,
        i = n[e]
      if (i != null) return i
      var a = bet(n.image) ? n.image : this.__image
      if (!a) return 0
      var o = e === 'width' ? 'height' : 'width',
        s = n[o]
      return s == null ? a[e] : (a[e] / a[o]) * s
    }),
    (t.prototype.getWidth = function () {
      return this._getSize('width')
    }),
    (t.prototype.getHeight = function () {
      return this._getSize('height')
    }),
    (t.prototype.getAnimationStyleProps = function () {
      return Aet
    }),
    (t.prototype.getBoundingRect = function () {
      var e = this.style
      return (
        this._rect ||
          (this._rect = new ee(
            e.x || 0,
            e.y || 0,
            this.getWidth(),
            this.getHeight(),
          )),
        this._rect
      )
    }),
    t
  )
})(ea)
eU.prototype.type = 'image'
const yr = eU
function wet(r, t) {
  var e = t.x,
    n = t.y,
    i = t.width,
    a = t.height,
    o = t.r,
    s,
    l,
    u,
    c
  i < 0 && ((e = e + i), (i = -i)),
    a < 0 && ((n = n + a), (a = -a)),
    typeof o == 'number'
      ? (s = l = u = c = o)
      : o instanceof Array
      ? o.length === 1
        ? (s = l = u = c = o[0])
        : o.length === 2
        ? ((s = u = o[0]), (l = c = o[1]))
        : o.length === 3
        ? ((s = o[0]), (l = c = o[1]), (u = o[2]))
        : ((s = o[0]), (l = o[1]), (u = o[2]), (c = o[3]))
      : (s = l = u = c = 0)
  var h
  s + l > i && ((h = s + l), (s *= i / h), (l *= i / h)),
    u + c > i && ((h = u + c), (u *= i / h), (c *= i / h)),
    l + u > a && ((h = l + u), (l *= a / h), (u *= a / h)),
    s + c > a && ((h = s + c), (s *= a / h), (c *= a / h)),
    r.moveTo(e + s, n),
    r.lineTo(e + i - l, n),
    l !== 0 && r.arc(e + i - l, n + l, l, -Math.PI / 2, 0),
    r.lineTo(e + i, n + a - u),
    u !== 0 && r.arc(e + i - u, n + a - u, u, 0, Math.PI / 2),
    r.lineTo(e + c, n + a),
    c !== 0 && r.arc(e + c, n + a - c, c, Math.PI / 2, Math.PI),
    r.lineTo(e, n + s),
    s !== 0 && r.arc(e + s, n + s, s, Math.PI, Math.PI * 1.5)
}
var _h = Math.round
function nU(r, t, e) {
  if (t) {
    var n = t.x1,
      i = t.x2,
      a = t.y1,
      o = t.y2
    ;(r.x1 = n), (r.x2 = i), (r.y1 = a), (r.y2 = o)
    var s = e && e.lineWidth
    return (
      s &&
        (_h(n * 2) === _h(i * 2) && (r.x1 = r.x2 = mu(n, s, !0)),
        _h(a * 2) === _h(o * 2) && (r.y1 = r.y2 = mu(a, s, !0))),
      r
    )
  }
}
function rU(r, t, e) {
  if (t) {
    var n = t.x,
      i = t.y,
      a = t.width,
      o = t.height
    ;(r.x = n), (r.y = i), (r.width = a), (r.height = o)
    var s = e && e.lineWidth
    return (
      s &&
        ((r.x = mu(n, s, !0)),
        (r.y = mu(i, s, !0)),
        (r.width = Math.max(mu(n + a, s, !1) - r.x, a === 0 ? 0 : 1)),
        (r.height = Math.max(mu(i + o, s, !1) - r.y, o === 0 ? 0 : 1))),
      r
    )
  }
}
function mu(r, t, e) {
  if (!t) return r
  var n = _h(r * 2)
  return (n + _h(t)) % 2 === 0 ? n / 2 : (n + (e ? 1 : -1)) / 2
}
var Met = (function () {
    function r() {
      ;(this.x = 0), (this.y = 0), (this.width = 0), (this.height = 0)
    }
    return r
  })(),
  Tet = {},
  iU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new Met()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i, a, o, s
        if (this.subPixelOptimize) {
          var l = rU(Tet, n, this.style)
          ;(i = l.x),
            (a = l.y),
            (o = l.width),
            (s = l.height),
            (l.r = n.r),
            (n = l)
        } else (i = n.x), (a = n.y), (o = n.width), (s = n.height)
        n.r ? wet(e, n) : e.rect(i, a, o, s)
      }),
      (t.prototype.isZeroArea = function () {
        return !this.shape.width || !this.shape.height
      }),
      t
    )
  })(oe)
iU.prototype.type = 'rect'
const ge = iU
var pP = {
    fill: '#000',
  },
  vP = 2,
  Cet = {
    style: zt(
      {
        fill: !0,
        stroke: !0,
        fillOpacity: !0,
        strokeOpacity: !0,
        lineWidth: !0,
        fontSize: !0,
        lineHeight: !0,
        width: !0,
        height: !0,
        textShadowColor: !0,
        textShadowBlur: !0,
        textShadowOffsetX: !0,
        textShadowOffsetY: !0,
        backgroundColor: !0,
        padding: !0,
        borderColor: !0,
        borderWidth: !0,
        borderRadius: !0,
      },
      t_.style,
    ),
  },
  aU = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this) || this
      return (
        (n.type = 'text'),
        (n._children = []),
        (n._defaultStyle = pP),
        n.attr(e),
        n
      )
    }
    return (
      (t.prototype.childrenRef = function () {
        return this._children
      }),
      (t.prototype.update = function () {
        r.prototype.update.call(this),
          this.styleChanged() && this._updateSubTexts()
        for (var e = 0; e < this._children.length; e++) {
          var n = this._children[e]
          ;(n.zlevel = this.zlevel),
            (n.z = this.z),
            (n.z2 = this.z2),
            (n.culling = this.culling),
            (n.cursor = this.cursor),
            (n.invisible = this.invisible)
        }
      }),
      (t.prototype.updateTransform = function () {
        var e = this.innerTransformable
        e
          ? (e.updateTransform(), e.transform && (this.transform = e.transform))
          : r.prototype.updateTransform.call(this)
      }),
      (t.prototype.getLocalTransform = function (e) {
        var n = this.innerTransformable
        return n
          ? n.getLocalTransform(e)
          : r.prototype.getLocalTransform.call(this, e)
      }),
      (t.prototype.getComputedTransform = function () {
        return (
          this.__hostTarget &&
            (this.__hostTarget.getComputedTransform(),
            this.__hostTarget.updateInnerText(!0)),
          r.prototype.getComputedTransform.call(this)
        )
      }),
      (t.prototype._updateSubTexts = function () {
        ;(this._childCursor = 0),
          Let(this.style),
          this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(),
          (this._children.length = this._childCursor),
          this.styleUpdated()
      }),
      (t.prototype.addSelfToZr = function (e) {
        r.prototype.addSelfToZr.call(this, e)
        for (var n = 0; n < this._children.length; n++)
          this._children[n].__zr = e
      }),
      (t.prototype.removeSelfFromZr = function (e) {
        r.prototype.removeSelfFromZr.call(this, e)
        for (var n = 0; n < this._children.length; n++)
          this._children[n].__zr = null
      }),
      (t.prototype.getBoundingRect = function () {
        if ((this.styleChanged() && this._updateSubTexts(), !this._rect)) {
          for (
            var e = new ee(0, 0, 0, 0),
              n = this._children,
              i = [],
              a = null,
              o = 0;
            o < n.length;
            o++
          ) {
            var s = n[o],
              l = s.getBoundingRect(),
              u = s.getLocalTransform(i)
            u
              ? (e.copy(l),
                e.applyTransform(u),
                (a = a || e.clone()),
                a.union(e))
              : ((a = a || l.clone()), a.union(l))
          }
          this._rect = a || e
        }
        return this._rect
      }),
      (t.prototype.setDefaultTextStyle = function (e) {
        this._defaultStyle = e || pP
      }),
      (t.prototype.setTextContent = function (e) {}),
      (t.prototype._mergeStyle = function (e, n) {
        if (!n) return e
        var i = n.rich,
          a = e.rich || (i && {})
        return (
          Q(e, n),
          i && a ? (this._mergeRich(a, i), (e.rich = a)) : a && (e.rich = a),
          e
        )
      }),
      (t.prototype._mergeRich = function (e, n) {
        for (var i = pe(n), a = 0; a < i.length; a++) {
          var o = i[a]
          ;(e[o] = e[o] || {}), Q(e[o], n[o])
        }
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return Cet
      }),
      (t.prototype._getOrCreateChild = function (e) {
        var n = this._children[this._childCursor]
        return (
          (!n || !(n instanceof e)) && (n = new e()),
          (this._children[this._childCursor++] = n),
          (n.__zr = this.__zr),
          (n.parent = this),
          n
        )
      }),
      (t.prototype._updatePlainTexts = function () {
        var e = this.style,
          n = e.font || nl,
          i = e.padding,
          a = AP(e),
          o = $tt(a, e),
          s = _1(e),
          l = !!e.backgroundColor,
          u = o.outerHeight,
          c = o.outerWidth,
          h = o.contentWidth,
          f = o.lines,
          d = o.lineHeight,
          p = this._defaultStyle,
          g = e.x || 0,
          v = e.y || 0,
          m = e.align || p.align || 'left',
          y = e.verticalAlign || p.verticalAlign || 'top',
          _ = g,
          x = sh(v, o.contentHeight, y)
        if (s || i) {
          var A = kd(g, c, m),
            S = sh(v, u, y)
          s && this._renderBackground(e, e, A, S, c, u)
        }
        ;(x += d / 2),
          i &&
            ((_ = SP(g, m, i)),
            y === 'top' ? (x += i[0]) : y === 'bottom' && (x -= i[2]))
        for (
          var b = 0,
            T = !1,
            w = xP(('fill' in e) ? e.fill : ((T = !0), p.fill)),
            M = _P(
              ('stroke' in e)
                ? e.stroke
                : !l && (!p.autoStroke || T)
                ? ((b = vP), p.stroke)
                : null,
            ),
            C = e.textShadowBlur > 0,
            E =
              e.width != null &&
              (e.overflow === 'truncate' ||
                e.overflow === 'break' ||
                e.overflow === 'breakAll'),
            D = o.calculatedLineHeight,
            P = 0;
          P < f.length;
          P++
        ) {
          var L = this._getOrCreateChild(Gp),
            I = L.createStyle()
          L.useStyle(I),
            (I.text = f[P]),
            (I.x = _),
            (I.y = x),
            m && (I.textAlign = m),
            (I.textBaseline = 'middle'),
            (I.opacity = e.opacity),
            (I.strokeFirst = !0),
            C &&
              ((I.shadowBlur = e.textShadowBlur || 0),
              (I.shadowColor = e.textShadowColor || 'transparent'),
              (I.shadowOffsetX = e.textShadowOffsetX || 0),
              (I.shadowOffsetY = e.textShadowOffsetY || 0)),
            (I.stroke = M),
            (I.fill = w),
            M &&
              ((I.lineWidth = e.lineWidth || b),
              (I.lineDash = e.lineDash),
              (I.lineDashOffset = e.lineDashOffset || 0)),
            (I.font = n),
            mP(I, e),
            (x += d),
            E &&
              L.setBoundingRect(
                new ee(
                  kd(I.x, e.width, I.textAlign),
                  sh(I.y, D, I.textBaseline),
                  h,
                  D,
                ),
              )
        }
      }),
      (t.prototype._updateRichTexts = function () {
        var e = this.style,
          n = AP(e),
          i = Ktt(n, e),
          a = i.width,
          o = i.outerWidth,
          s = i.outerHeight,
          l = e.padding,
          u = e.x || 0,
          c = e.y || 0,
          h = this._defaultStyle,
          f = e.align || h.align,
          d = e.verticalAlign || h.verticalAlign,
          p = kd(u, o, f),
          g = sh(c, s, d),
          v = p,
          m = g
        l && ((v += l[3]), (m += l[0]))
        var y = v + a
        _1(e) && this._renderBackground(e, e, p, g, o, s)
        for (var _ = !!e.backgroundColor, x = 0; x < i.lines.length; x++) {
          for (
            var A = i.lines[x],
              S = A.tokens,
              b = S.length,
              T = A.lineHeight,
              w = A.width,
              M = 0,
              C = v,
              E = y,
              D = b - 1,
              P = void 0;
            M < b && ((P = S[M]), !P.align || P.align === 'left');

          )
            this._placeToken(P, e, T, m, C, 'left', _),
              (w -= P.width),
              (C += P.width),
              M++
          for (; D >= 0 && ((P = S[D]), P.align === 'right'); )
            this._placeToken(P, e, T, m, E, 'right', _),
              (w -= P.width),
              (E -= P.width),
              D--
          for (C += (a - (C - v) - (y - E) - w) / 2; M <= D; )
            (P = S[M]),
              this._placeToken(P, e, T, m, C + P.width / 2, 'center', _),
              (C += P.width),
              M++
          m += T
        }
      }),
      (t.prototype._placeToken = function (e, n, i, a, o, s, l) {
        var u = n.rich[e.styleName] || {}
        u.text = e.text
        var c = e.verticalAlign,
          h = a + i / 2
        c === 'top'
          ? (h = a + e.height / 2)
          : c === 'bottom' && (h = a + i - e.height / 2)
        var f = !e.isLineHolder && _1(u)
        f &&
          this._renderBackground(
            u,
            n,
            s === 'right' ? o - e.width : s === 'center' ? o - e.width / 2 : o,
            h - e.height / 2,
            e.width,
            e.height,
          )
        var d = !!u.backgroundColor,
          p = e.textPadding
        p && ((o = SP(o, s, p)), (h -= e.height / 2 - p[0] - e.innerHeight / 2))
        var g = this._getOrCreateChild(Gp),
          v = g.createStyle()
        g.useStyle(v)
        var m = this._defaultStyle,
          y = !1,
          _ = 0,
          x = xP(
            'fill' in u ? u.fill : 'fill' in n ? n.fill : ((y = !0), m.fill),
          ),
          A = _P(
            'stroke' in u
              ? u.stroke
              : 'stroke' in n
              ? n.stroke
              : !d && !l && (!m.autoStroke || y)
              ? ((_ = vP), m.stroke)
              : null,
          ),
          S = u.textShadowBlur > 0 || n.textShadowBlur > 0
        ;(v.text = e.text),
          (v.x = o),
          (v.y = h),
          S &&
            ((v.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0),
            (v.shadowColor =
              u.textShadowColor || n.textShadowColor || 'transparent'),
            (v.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0),
            (v.shadowOffsetY =
              u.textShadowOffsetY || n.textShadowOffsetY || 0)),
          (v.textAlign = s),
          (v.textBaseline = 'middle'),
          (v.font = e.font || nl),
          (v.opacity = ao(u.opacity, n.opacity, 1)),
          mP(v, u),
          A &&
            ((v.lineWidth = ao(u.lineWidth, n.lineWidth, _)),
            (v.lineDash = $t(u.lineDash, n.lineDash)),
            (v.lineDashOffset = n.lineDashOffset || 0),
            (v.stroke = A)),
          x && (v.fill = x)
        var b = e.contentWidth,
          T = e.contentHeight
        g.setBoundingRect(
          new ee(kd(v.x, b, v.textAlign), sh(v.y, T, v.textBaseline), b, T),
        )
      }),
      (t.prototype._renderBackground = function (e, n, i, a, o, s) {
        var l = e.backgroundColor,
          u = e.borderWidth,
          c = e.borderColor,
          h = l && l.image,
          f = l && !h,
          d = e.borderRadius,
          p = this,
          g,
          v
        if (f || e.lineHeight || (u && c)) {
          ;(g = this._getOrCreateChild(ge)),
            g.useStyle(g.createStyle()),
            (g.style.fill = null)
          var m = g.shape
          ;(m.x = i),
            (m.y = a),
            (m.width = o),
            (m.height = s),
            (m.r = d),
            g.dirtyShape()
        }
        if (f) {
          var y = g.style
          ;(y.fill = l || null), (y.fillOpacity = $t(e.fillOpacity, 1))
        } else if (h) {
          ;(v = this._getOrCreateChild(yr)),
            (v.onload = function () {
              p.dirtyStyle()
            })
          var _ = v.style
          ;(_.image = l.image),
            (_.x = i),
            (_.y = a),
            (_.width = o),
            (_.height = s)
        }
        if (u && c) {
          var y = g.style
          ;(y.lineWidth = u),
            (y.stroke = c),
            (y.strokeOpacity = $t(e.strokeOpacity, 1)),
            (y.lineDash = e.borderDash),
            (y.lineDashOffset = e.borderDashOffset || 0),
            (g.strokeContainThreshold = 0),
            g.hasFill() &&
              g.hasStroke() &&
              ((y.strokeFirst = !0), (y.lineWidth *= 2))
        }
        var x = (g || v).style
        ;(x.shadowBlur = e.shadowBlur || 0),
          (x.shadowColor = e.shadowColor || 'transparent'),
          (x.shadowOffsetX = e.shadowOffsetX || 0),
          (x.shadowOffsetY = e.shadowOffsetY || 0),
          (x.opacity = ao(e.opacity, n.opacity, 1))
      }),
      (t.makeFont = function (e) {
        var n = ''
        return (
          sU(e) &&
            (n = [
              e.fontStyle,
              e.fontWeight,
              oU(e.fontSize),
              e.fontFamily || 'sans-serif',
            ].join(' ')),
          (n && xa(n)) || e.textFont || e.font
        )
      }),
      t
    )
  })(ea),
  Eet = {
    left: !0,
    right: 1,
    center: 1,
  },
  Det = {
    top: 1,
    bottom: 1,
    middle: 1,
  },
  gP = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily']
function oU(r) {
  return typeof r == 'string' &&
    (r.indexOf('px') !== -1 ||
      r.indexOf('rem') !== -1 ||
      r.indexOf('em') !== -1)
    ? r
    : isNaN(+r)
    ? wT + 'px'
    : r + 'px'
}
function mP(r, t) {
  for (var e = 0; e < gP.length; e++) {
    var n = gP[e],
      i = t[n]
    i != null && (r[n] = i)
  }
}
function sU(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight
}
function Let(r) {
  return yP(r), R(r.rich, yP), r
}
function yP(r) {
  if (r) {
    r.font = aU.makeFont(r)
    var t = r.align
    t === 'middle' && (t = 'center'),
      (r.align = t == null || Eet[t] ? t : 'left')
    var e = r.verticalAlign
    e === 'center' && (e = 'middle'),
      (r.verticalAlign = e == null || Det[e] ? e : 'top')
    var n = r.padding
    n && (r.padding = LT(r.padding))
  }
}
function _P(r, t) {
  return r == null || t <= 0 || r === 'transparent' || r === 'none'
    ? null
    : r.image || r.colorStops
    ? '#000'
    : r
}
function xP(r) {
  return r == null || r === 'none' ? null : r.image || r.colorStops ? '#000' : r
}
function SP(r, t, e) {
  return t === 'right'
    ? r - e[1]
    : t === 'center'
    ? r + e[3] / 2 - e[1] / 2
    : r + e[3]
}
function AP(r) {
  var t = r.text
  return t != null && (t += ''), t
}
function _1(r) {
  return !!(
    r.backgroundColor ||
    r.lineHeight ||
    (r.borderWidth && r.borderColor)
  )
}
const Ae = aU
var Wt = ve(),
  ew = function (r, t, e, n) {
    if (n) {
      var i = Wt(n)
      ;(i.dataIndex = e),
        (i.dataType = t),
        (i.seriesIndex = r),
        (i.ssrType = 'chart'),
        n.type === 'group' &&
          n.traverse(function (a) {
            var o = Wt(a)
            ;(o.seriesIndex = r),
              (o.dataIndex = e),
              (o.dataType = t),
              (o.ssrType = 'chart')
          })
    }
  },
  bP = 1,
  wP = {},
  lU = ve(),
  WT = ve(),
  XT = 0,
  _v = 1,
  n_ = 2,
  Hr = ['emphasis', 'blur', 'select'],
  Hp = ['normal', 'emphasis', 'blur', 'select'],
  _f = 10,
  Pet = 9,
  Iu = 'highlight',
  Qm = 'downplay',
  ap = 'select',
  ty = 'unselect',
  op = 'toggleSelect'
function Gc(r) {
  return r != null && r !== 'none'
}
function r_(r, t, e) {
  r.onHoverStateChange && (r.hoverState || 0) !== e && r.onHoverStateChange(t),
    (r.hoverState = e)
}
function uU(r) {
  r_(r, 'emphasis', n_)
}
function cU(r) {
  r.hoverState === n_ && r_(r, 'normal', XT)
}
function YT(r) {
  r_(r, 'blur', _v)
}
function hU(r) {
  r.hoverState === _v && r_(r, 'normal', XT)
}
function Ret(r) {
  r.selected = !0
}
function Iet(r) {
  r.selected = !1
}
function MP(r, t, e) {
  t(r, e)
}
function is(r, t, e) {
  MP(r, t, e),
    r.isGroup &&
      r.traverse(function (n) {
        MP(n, t, e)
      })
}
function Xy(r, t) {
  switch (t) {
    case 'emphasis':
      r.hoverState = n_
      break
    case 'normal':
      r.hoverState = XT
      break
    case 'blur':
      r.hoverState = _v
      break
    case 'select':
      r.selected = !0
  }
}
function Oet(r, t, e, n) {
  for (var i = r.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o],
      l = i[s]
    a[s] = l ?? (n && n[s])
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o]
    u.__fromStateTransition &&
      u.__fromStateTransition.indexOf(e) < 0 &&
      u.targetName === 'style' &&
      u.saveTo(a, t)
  }
  return a
}
function Net(r, t, e, n) {
  var i = e && re(e, 'select') >= 0,
    a = !1
  if (r instanceof oe) {
    var o = lU(r),
      s = (i && o.selectFill) || o.normalFill,
      l = (i && o.selectStroke) || o.normalStroke
    if (Gc(s) || Gc(l)) {
      n = n || {}
      var u = n.style || {}
      u.fill === 'inherit'
        ? ((a = !0), (n = Q({}, n)), (u = Q({}, u)), (u.fill = s))
        : !Gc(u.fill) && Gc(s)
        ? ((a = !0), (n = Q({}, n)), (u = Q({}, u)), (u.fill = Ub(s)))
        : !Gc(u.stroke) &&
          Gc(l) &&
          (a || ((n = Q({}, n)), (u = Q({}, u))), (u.stroke = Ub(l))),
        (n.style = u)
    }
  }
  if (n && n.z2 == null) {
    a || (n = Q({}, n))
    var c = r.z2EmphasisLift
    n.z2 = r.z2 + (c ?? _f)
  }
  return n
}
function ket(r, t, e) {
  if (e && e.z2 == null) {
    e = Q({}, e)
    var n = r.z2SelectLift
    e.z2 = r.z2 + (n ?? Pet)
  }
  return e
}
function Bet(r, t, e) {
  var n = re(r.currentStates, t) >= 0,
    i = r.style.opacity,
    a = n
      ? null
      : Oet(r, ['opacity'], t, {
          opacity: 1,
        })
  e = e || {}
  var o = e.style || {}
  return (
    o.opacity == null &&
      ((e = Q({}, e)),
      (o = Q(
        {
          opacity: n ? i : a.opacity * 0.1,
        },
        o,
      )),
      (e.style = o)),
    e
  )
}
function x1(r, t) {
  var e = this.states[r]
  if (this.style) {
    if (r === 'emphasis') return Net(this, r, t, e)
    if (r === 'blur') return Bet(this, r, e)
    if (r === 'select') return ket(this, r, e)
  }
  return e
}
function qu(r) {
  r.stateProxy = x1
  var t = r.getTextContent(),
    e = r.getTextGuideLine()
  t && (t.stateProxy = x1), e && (e.stateProxy = x1)
}
function TP(r, t) {
  !vU(r, t) && !r.__highByOuter && is(r, uU)
}
function CP(r, t) {
  !vU(r, t) && !r.__highByOuter && is(r, cU)
}
function Qo(r, t) {
  ;(r.__highByOuter |= 1 << (t || 0)), is(r, uU)
}
function ts(r, t) {
  !(r.__highByOuter &= ~(1 << (t || 0))) && is(r, cU)
}
function fU(r) {
  is(r, YT)
}
function $T(r) {
  is(r, hU)
}
function dU(r) {
  is(r, Ret)
}
function pU(r) {
  is(r, Iet)
}
function vU(r, t) {
  return r.__highDownSilentOnTouch && t.zrByTouch
}
function gU(r) {
  var t = r.getModel(),
    e = [],
    n = []
  t.eachComponent(function (i, a) {
    var o = WT(a),
      s = i === 'series',
      l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a)
    !s && n.push(l),
      o.isBlured &&
        (l.group.traverse(function (u) {
          hU(u)
        }),
        s && e.push(a)),
      (o.isBlured = !1)
  }),
    R(n, function (i) {
      i && i.toggleBlurSeries && i.toggleBlurSeries(e, !1, t)
    })
}
function nw(r, t, e, n) {
  var i = n.getModel()
  e = e || 'coordinateSystem'
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var f = u.getItemGraphicEl(c[h])
      f && $T(f)
    }
  }
  if (r != null && !(!t || t === 'none')) {
    var o = i.getSeriesByIndex(r),
      s = o.coordinateSystem
    s && s.master && (s = s.master)
    var l = []
    i.eachSeries(function (u) {
      var c = o === u,
        h = u.coordinateSystem
      h && h.master && (h = h.master)
      var f = h && s ? h === s : c
      if (
        !(
          (e === 'series' && !c) ||
          (e === 'coordinateSystem' && !f) ||
          (t === 'series' && c)
        )
      ) {
        var d = n.getViewOfSeriesModel(u)
        if (
          (d.group.traverse(function (v) {
            ;(v.__highByOuter && c && t === 'self') || YT(v)
          }),
          Er(t))
        )
          a(u.getData(), t)
        else if (Ut(t))
          for (var p = pe(t), g = 0; g < p.length; g++)
            a(u.getData(p[g]), t[p[g]])
        l.push(u), (WT(u).isBlured = !0)
      }
    }),
      i.eachComponent(function (u, c) {
        if (u !== 'series') {
          var h = n.getViewOfComponentModel(c)
          h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, i)
        }
      })
  }
}
function rw(r, t, e) {
  if (!(r == null || t == null)) {
    var n = e.getModel().getComponent(r, t)
    if (n) {
      WT(n).isBlured = !0
      var i = e.getViewOfComponentModel(n)
      !i ||
        !i.focusBlurEnabled ||
        i.group.traverse(function (a) {
          YT(a)
        })
    }
  }
}
function Fet(r, t, e) {
  var n = r.seriesIndex,
    i = r.getData(t.dataType)
  if (i) {
    var a = Yu(i, t)
    a = (at(a) ? a[0] : a) || 0
    var o = i.getItemGraphicEl(a)
    if (!o)
      for (var s = i.count(), l = 0; !o && l < s; ) o = i.getItemGraphicEl(l++)
    if (o) {
      var u = Wt(o)
      nw(n, u.focus, u.blurScope, e)
    } else {
      var c = r.get(['emphasis', 'focus']),
        h = r.get(['emphasis', 'blurScope'])
      c != null && nw(n, c, h, e)
    }
  }
}
function qT(r, t, e, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null,
  }
  if (r == null || r === 'series' || t == null || e == null) return i
  var a = n.getModel().getComponent(r, t)
  if (!a) return i
  var o = n.getViewOfComponentModel(a)
  if (!o || !o.findHighDownDispatchers) return i
  for (var s = o.findHighDownDispatchers(e), l, u = 0; u < s.length; u++)
    if (Wt(s[u]).focus === 'self') {
      l = !0
      break
    }
  return {
    focusSelf: l,
    dispatchers: s,
  }
}
function zet(r, t, e) {
  var n = Wt(r),
    i = qT(n.componentMainType, n.componentIndex, n.componentHighDownName, e),
    a = i.dispatchers,
    o = i.focusSelf
  a
    ? (o && rw(n.componentMainType, n.componentIndex, e),
      R(a, function (s) {
        return TP(s, t)
      }))
    : (nw(n.seriesIndex, n.focus, n.blurScope, e),
      n.focus === 'self' && rw(n.componentMainType, n.componentIndex, e),
      TP(r, t))
}
function Uet(r, t, e) {
  gU(e)
  var n = Wt(r),
    i = qT(
      n.componentMainType,
      n.componentIndex,
      n.componentHighDownName,
      e,
    ).dispatchers
  i
    ? R(i, function (a) {
        return CP(a, t)
      })
    : CP(r, t)
}
function Vet(r, t, e) {
  if (aw(t)) {
    var n = t.dataType,
      i = r.getData(n),
      a = Yu(i, t)
    at(a) || (a = [a]),
      r[t.type === op ? 'toggleSelect' : t.type === ap ? 'select' : 'unselect'](
        a,
        n,
      )
  }
}
function EP(r) {
  var t = r.getAllData()
  R(t, function (e) {
    var n = e.data,
      i = e.type
    n.eachItemGraphicEl(function (a, o) {
      r.isSelected(o, i) ? dU(a) : pU(a)
    })
  })
}
function Get(r) {
  var t = []
  return (
    r.eachSeries(function (e) {
      var n = e.getAllData()
      R(n, function (i) {
        i.data
        var a = i.type,
          o = e.getSelectedDataIndices()
        if (o.length > 0) {
          var s = {
            dataIndex: o,
            seriesIndex: e.seriesIndex,
          }
          a != null && (s.dataType = a), t.push(s)
        }
      })
    }),
    t
  )
}
function Ou(r, t, e) {
  yu(r, !0), is(r, qu), iw(r, t, e)
}
function Het(r) {
  yu(r, !1)
}
function fn(r, t, e, n) {
  n ? Het(r) : Ou(r, t, e)
}
function iw(r, t, e) {
  var n = Wt(r)
  t != null ? ((n.focus = t), (n.blurScope = e)) : n.focus && (n.focus = null)
}
var DP = ['emphasis', 'blur', 'select'],
  Wet = {
    itemStyle: 'getItemStyle',
    lineStyle: 'getLineStyle',
    areaStyle: 'getAreaStyle',
  }
function gr(r, t, e, n) {
  e = e || 'itemStyle'
  for (var i = 0; i < DP.length; i++) {
    var a = DP[i],
      o = t.getModel([a, e]),
      s = r.ensureState(a)
    s.style = n ? n(o) : o[Wet[e]]()
  }
}
function yu(r, t) {
  var e = t === !1,
    n = r
  r.highDownSilentOnTouch &&
    (n.__highDownSilentOnTouch = r.highDownSilentOnTouch),
    (!e || n.__highDownDispatcher) &&
      ((n.__highByOuter = n.__highByOuter || 0), (n.__highDownDispatcher = !e))
}
function Wp(r) {
  return !!(r && r.__highDownDispatcher)
}
function Xet(r, t, e) {
  var n = Wt(r)
  ;(n.componentMainType = t.mainType),
    (n.componentIndex = t.componentIndex),
    (n.componentHighDownName = e)
}
function Yet(r) {
  var t = wP[r]
  return t == null && bP <= 32 && (t = wP[r] = bP++), t
}
function aw(r) {
  var t = r.type
  return t === ap || t === ty || t === op
}
function LP(r) {
  var t = r.type
  return t === Iu || t === Qm
}
function $et(r) {
  var t = lU(r)
  ;(t.normalFill = r.style.fill), (t.normalStroke = r.style.stroke)
  var e = r.states.select || {}
  ;(t.selectFill = (e.style && e.style.fill) || null),
    (t.selectStroke = (e.style && e.style.stroke) || null)
}
var Hc = vo.CMD,
  qet = [[], [], []],
  PP = Math.sqrt,
  Zet = Math.atan2
function mU(r, t) {
  if (t) {
    var e = r.data,
      n = r.len(),
      i,
      a,
      o,
      s,
      l,
      u,
      c = Hc.M,
      h = Hc.C,
      f = Hc.L,
      d = Hc.R,
      p = Hc.A,
      g = Hc.Q
    for (o = 0, s = 0; o < n; ) {
      switch (((i = e[o++]), (s = o), (a = 0), i)) {
        case c:
          a = 1
          break
        case f:
          a = 1
          break
        case h:
          a = 3
          break
        case g:
          a = 2
          break
        case p:
          var v = t[4],
            m = t[5],
            y = PP(t[0] * t[0] + t[1] * t[1]),
            _ = PP(t[2] * t[2] + t[3] * t[3]),
            x = Zet(-t[1] / _, t[0] / y)
          ;(e[o] *= y),
            (e[o++] += v),
            (e[o] *= _),
            (e[o++] += m),
            (e[o++] *= y),
            (e[o++] *= _),
            (e[o++] += x),
            (e[o++] += x),
            (o += 2),
            (s = o)
          break
        case d:
          ;(u[0] = e[o++]),
            (u[1] = e[o++]),
            pr(u, u, t),
            (e[s++] = u[0]),
            (e[s++] = u[1]),
            (u[0] += e[o++]),
            (u[1] += e[o++]),
            pr(u, u, t),
            (e[s++] = u[0]),
            (e[s++] = u[1])
      }
      for (l = 0; l < a; l++) {
        var A = qet[l]
        ;(A[0] = e[o++]),
          (A[1] = e[o++]),
          pr(A, A, t),
          (e[s++] = A[0]),
          (e[s++] = A[1])
      }
    }
    r.increaseVersion()
  }
}
var S1 = Math.sqrt,
  Vg = Math.sin,
  Gg = Math.cos,
  nd = Math.PI
function RP(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1])
}
function ow(r, t) {
  return (r[0] * t[0] + r[1] * t[1]) / (RP(r) * RP(t))
}
function IP(r, t) {
  return (r[0] * t[1] < r[1] * t[0] ? -1 : 1) * Math.acos(ow(r, t))
}
function OP(r, t, e, n, i, a, o, s, l, u, c) {
  var h = l * (nd / 180),
    f = (Gg(h) * (r - e)) / 2 + (Vg(h) * (t - n)) / 2,
    d = (-1 * Vg(h) * (r - e)) / 2 + (Gg(h) * (t - n)) / 2,
    p = (f * f) / (o * o) + (d * d) / (s * s)
  p > 1 && ((o *= S1(p)), (s *= S1(p)))
  var g =
      (i === a ? -1 : 1) *
        S1(
          (o * o * (s * s) - o * o * (d * d) - s * s * (f * f)) /
            (o * o * (d * d) + s * s * (f * f)),
        ) || 0,
    v = (g * o * d) / s,
    m = (g * -s * f) / o,
    y = (r + e) / 2 + Gg(h) * v - Vg(h) * m,
    _ = (t + n) / 2 + Vg(h) * v + Gg(h) * m,
    x = IP([1, 0], [(f - v) / o, (d - m) / s]),
    A = [(f - v) / o, (d - m) / s],
    S = [(-1 * f - v) / o, (-1 * d - m) / s],
    b = IP(A, S)
  if ((ow(A, S) <= -1 && (b = nd), ow(A, S) >= 1 && (b = 0), b < 0)) {
    var T = Math.round((b / nd) * 1e6) / 1e6
    b = nd * 2 + (T % 2) * nd
  }
  c.addData(u, y, _, o, s, x, b, h, a)
}
var Ket = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,
  jet = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
function Jet(r) {
  var t = new vo()
  if (!r) return t
  var e = 0,
    n = 0,
    i = e,
    a = n,
    o,
    s = vo.CMD,
    l = r.match(Ket)
  if (!l) return t
  for (var u = 0; u < l.length; u++) {
    for (
      var c = l[u],
        h = c.charAt(0),
        f = void 0,
        d = c.match(jet) || [],
        p = d.length,
        g = 0;
      g < p;
      g++
    )
      d[g] = parseFloat(d[g])
    for (var v = 0; v < p; ) {
      var m = void 0,
        y = void 0,
        _ = void 0,
        x = void 0,
        A = void 0,
        S = void 0,
        b = void 0,
        T = e,
        w = n,
        M = void 0,
        C = void 0
      switch (h) {
        case 'l':
          ;(e += d[v++]), (n += d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'L':
          ;(e = d[v++]), (n = d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'm':
          ;(e += d[v++]),
            (n += d[v++]),
            (f = s.M),
            t.addData(f, e, n),
            (i = e),
            (a = n),
            (h = 'l')
          break
        case 'M':
          ;(e = d[v++]),
            (n = d[v++]),
            (f = s.M),
            t.addData(f, e, n),
            (i = e),
            (a = n),
            (h = 'L')
          break
        case 'h':
          ;(e += d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'H':
          ;(e = d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'v':
          ;(n += d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'V':
          ;(n = d[v++]), (f = s.L), t.addData(f, e, n)
          break
        case 'C':
          ;(f = s.C),
            t.addData(f, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]),
            (e = d[v - 2]),
            (n = d[v - 1])
          break
        case 'c':
          ;(f = s.C),
            t.addData(
              f,
              d[v++] + e,
              d[v++] + n,
              d[v++] + e,
              d[v++] + n,
              d[v++] + e,
              d[v++] + n,
            ),
            (e += d[v - 2]),
            (n += d[v - 1])
          break
        case 'S':
          ;(m = e),
            (y = n),
            (M = t.len()),
            (C = t.data),
            o === s.C && ((m += e - C[M - 4]), (y += n - C[M - 3])),
            (f = s.C),
            (T = d[v++]),
            (w = d[v++]),
            (e = d[v++]),
            (n = d[v++]),
            t.addData(f, m, y, T, w, e, n)
          break
        case 's':
          ;(m = e),
            (y = n),
            (M = t.len()),
            (C = t.data),
            o === s.C && ((m += e - C[M - 4]), (y += n - C[M - 3])),
            (f = s.C),
            (T = e + d[v++]),
            (w = n + d[v++]),
            (e += d[v++]),
            (n += d[v++]),
            t.addData(f, m, y, T, w, e, n)
          break
        case 'Q':
          ;(T = d[v++]),
            (w = d[v++]),
            (e = d[v++]),
            (n = d[v++]),
            (f = s.Q),
            t.addData(f, T, w, e, n)
          break
        case 'q':
          ;(T = d[v++] + e),
            (w = d[v++] + n),
            (e += d[v++]),
            (n += d[v++]),
            (f = s.Q),
            t.addData(f, T, w, e, n)
          break
        case 'T':
          ;(m = e),
            (y = n),
            (M = t.len()),
            (C = t.data),
            o === s.Q && ((m += e - C[M - 4]), (y += n - C[M - 3])),
            (e = d[v++]),
            (n = d[v++]),
            (f = s.Q),
            t.addData(f, m, y, e, n)
          break
        case 't':
          ;(m = e),
            (y = n),
            (M = t.len()),
            (C = t.data),
            o === s.Q && ((m += e - C[M - 4]), (y += n - C[M - 3])),
            (e += d[v++]),
            (n += d[v++]),
            (f = s.Q),
            t.addData(f, m, y, e, n)
          break
        case 'A':
          ;(_ = d[v++]),
            (x = d[v++]),
            (A = d[v++]),
            (S = d[v++]),
            (b = d[v++]),
            (T = e),
            (w = n),
            (e = d[v++]),
            (n = d[v++]),
            (f = s.A),
            OP(T, w, e, n, S, b, _, x, A, f, t)
          break
        case 'a':
          ;(_ = d[v++]),
            (x = d[v++]),
            (A = d[v++]),
            (S = d[v++]),
            (b = d[v++]),
            (T = e),
            (w = n),
            (e += d[v++]),
            (n += d[v++]),
            (f = s.A),
            OP(T, w, e, n, S, b, _, x, A, f, t)
          break
      }
    }
    ;(h === 'z' || h === 'Z') && ((f = s.Z), t.addData(f), (e = i), (n = a)),
      (o = f)
  }
  return t.toStatic(), t
}
var yU = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (t.prototype.applyTransform = function (e) {}), t
})(oe)
function _U(r) {
  return r.setData != null
}
function xU(r, t) {
  var e = Jet(r),
    n = Q({}, t)
  return (
    (n.buildPath = function (i) {
      if (_U(i)) {
        i.setData(e.data)
        var a = i.getContext()
        a && i.rebuildPath(a, 1)
      } else {
        var a = i
        e.rebuildPath(a, 1)
      }
    }),
    (n.applyTransform = function (i) {
      mU(e, i), this.dirtyShape()
    }),
    n
  )
}
function SU(r, t) {
  return new yU(xU(r, t))
}
function Qet(r, t) {
  var e = xU(r, t),
    n = (function (i) {
      X(a, i)
      function a(o) {
        var s = i.call(this, o) || this
        return (
          (s.applyTransform = e.applyTransform), (s.buildPath = e.buildPath), s
        )
      }
      return a
    })(yU)
  return n
}
function tnt(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++) {
    var a = r[i]
    e.push(a.getUpdatedPathProxy(!0))
  }
  var o = new oe(t)
  return (
    o.createPathProxy(),
    (o.buildPath = function (s) {
      if (_U(s)) {
        s.appendPath(e)
        var l = s.getContext()
        l && s.rebuildPath(l, 1)
      }
    }),
    o
  )
}
function ZT(r, t) {
  t = t || {}
  var e = new oe()
  return (
    r.shape && e.setShape(r.shape),
    e.setStyle(r.style),
    t.bakeTransform
      ? mU(e.path, r.getComputedTransform())
      : t.toLocal
      ? e.setLocalTransform(r.getComputedTransform())
      : e.copyTransform(r),
    (e.buildPath = r.buildPath),
    (e.applyTransform = e.applyTransform),
    (e.z = r.z),
    (e.z2 = r.z2),
    (e.zlevel = r.zlevel),
    e
  )
}
var ent = (function () {
    function r() {
      ;(this.cx = 0), (this.cy = 0), (this.r = 0)
    }
    return r
  })(),
  AU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new ent()
      }),
      (t.prototype.buildPath = function (e, n) {
        e.moveTo(n.cx + n.r, n.cy), e.arc(n.cx, n.cy, n.r, 0, Math.PI * 2)
      }),
      t
    )
  })(oe)
AU.prototype.type = 'circle'
const pl = AU
var nnt = (function () {
    function r() {
      ;(this.cx = 0), (this.cy = 0), (this.rx = 0), (this.ry = 0)
    }
    return r
  })(),
  bU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new nnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = 0.5522848,
          a = n.cx,
          o = n.cy,
          s = n.rx,
          l = n.ry,
          u = s * i,
          c = l * i
        e.moveTo(a - s, o),
          e.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l),
          e.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o),
          e.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l),
          e.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o),
          e.closePath()
      }),
      t
    )
  })(oe)
bU.prototype.type = 'ellipse'
const KT = bU
var wU = Math.PI,
  A1 = wU * 2,
  Gl = Math.sin,
  Wc = Math.cos,
  rnt = Math.acos,
  Sr = Math.atan2,
  NP = Math.abs,
  sp = Math.sqrt,
  Bd = Math.max,
  za = Math.min,
  fa = 1e-4
function int(r, t, e, n, i, a, o, s) {
  var l = e - r,
    u = n - t,
    c = o - i,
    h = s - a,
    f = h * l - c * u
  if (!(f * f < fa))
    return (f = (c * (t - a) - h * (r - i)) / f), [r + f * l, t + f * u]
}
function Hg(r, t, e, n, i, a, o) {
  var s = r - e,
    l = t - n,
    u = (o ? a : -a) / sp(s * s + l * l),
    c = u * l,
    h = -u * s,
    f = r + c,
    d = t + h,
    p = e + c,
    g = n + h,
    v = (f + p) / 2,
    m = (d + g) / 2,
    y = p - f,
    _ = g - d,
    x = y * y + _ * _,
    A = i - a,
    S = f * g - p * d,
    b = (_ < 0 ? -1 : 1) * sp(Bd(0, A * A * x - S * S)),
    T = (S * _ - y * b) / x,
    w = (-S * y - _ * b) / x,
    M = (S * _ + y * b) / x,
    C = (-S * y + _ * b) / x,
    E = T - v,
    D = w - m,
    P = M - v,
    L = C - m
  return (
    E * E + D * D > P * P + L * L && ((T = M), (w = C)),
    {
      cx: T,
      cy: w,
      x0: -c,
      y0: -h,
      x1: T * (i / A - 1),
      y1: w * (i / A - 1),
    }
  )
}
function ant(r) {
  var t
  if (at(r)) {
    var e = r.length
    if (!e) return r
    e === 1
      ? (t = [r[0], r[0], 0, 0])
      : e === 2
      ? (t = [r[0], r[0], r[1], r[1]])
      : e === 3
      ? (t = r.concat(r[2]))
      : (t = r)
  } else t = [r, r, r, r]
  return t
}
function ont(r, t) {
  var e,
    n = Bd(t.r, 0),
    i = Bd(t.r0 || 0, 0),
    a = n > 0,
    o = i > 0
  if (!(!a && !o)) {
    if ((a || ((n = i), (i = 0)), i > n)) {
      var s = n
      ;(n = i), (i = s)
    }
    var l = t.startAngle,
      u = t.endAngle
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx,
        h = t.cy,
        f = !!t.clockwise,
        d = NP(u - l),
        p = d > A1 && d % A1
      if ((p > fa && (d = p), !(n > fa))) r.moveTo(c, h)
      else if (d > A1 - fa)
        r.moveTo(c + n * Wc(l), h + n * Gl(l)),
          r.arc(c, h, n, l, u, !f),
          i > fa &&
            (r.moveTo(c + i * Wc(u), h + i * Gl(u)), r.arc(c, h, i, u, l, f))
      else {
        var g = void 0,
          v = void 0,
          m = void 0,
          y = void 0,
          _ = void 0,
          x = void 0,
          A = void 0,
          S = void 0,
          b = void 0,
          T = void 0,
          w = void 0,
          M = void 0,
          C = void 0,
          E = void 0,
          D = void 0,
          P = void 0,
          L = n * Wc(l),
          I = n * Gl(l),
          F = i * Wc(u),
          k = i * Gl(u),
          V = d > fa
        if (V) {
          var H = t.cornerRadius
          H && ((e = ant(H)), (g = e[0]), (v = e[1]), (m = e[2]), (y = e[3]))
          var Y = NP(n - i) / 2
          if (
            ((_ = za(Y, m)),
            (x = za(Y, y)),
            (A = za(Y, g)),
            (S = za(Y, v)),
            (w = b = Bd(_, x)),
            (M = T = Bd(A, S)),
            (b > fa || T > fa) &&
              ((C = n * Wc(u)),
              (E = n * Gl(u)),
              (D = i * Wc(l)),
              (P = i * Gl(l)),
              d < wU))
          ) {
            var K = int(L, I, D, P, C, E, F, k)
            if (K) {
              var ut = L - K[0],
                W = I - K[1],
                Z = C - K[0],
                ft = E - K[1],
                lt =
                  1 /
                  Gl(
                    rnt(
                      (ut * Z + W * ft) /
                        (sp(ut * ut + W * W) * sp(Z * Z + ft * ft)),
                    ) / 2,
                  ),
                ct = sp(K[0] * K[0] + K[1] * K[1])
              ;(w = za(b, (n - ct) / (lt + 1))),
                (M = za(T, (i - ct) / (lt - 1)))
            }
          }
        }
        if (!V) r.moveTo(c + L, h + I)
        else if (w > fa) {
          var At = za(m, w),
            gt = za(y, w),
            dt = Hg(D, P, L, I, n, At, f),
            B = Hg(C, E, F, k, n, gt, f)
          r.moveTo(c + dt.cx + dt.x0, h + dt.cy + dt.y0),
            w < b && At === gt
              ? r.arc(
                  c + dt.cx,
                  h + dt.cy,
                  w,
                  Sr(dt.y0, dt.x0),
                  Sr(B.y0, B.x0),
                  !f,
                )
              : (At > 0 &&
                  r.arc(
                    c + dt.cx,
                    h + dt.cy,
                    At,
                    Sr(dt.y0, dt.x0),
                    Sr(dt.y1, dt.x1),
                    !f,
                  ),
                r.arc(
                  c,
                  h,
                  n,
                  Sr(dt.cy + dt.y1, dt.cx + dt.x1),
                  Sr(B.cy + B.y1, B.cx + B.x1),
                  !f,
                ),
                gt > 0 &&
                  r.arc(
                    c + B.cx,
                    h + B.cy,
                    gt,
                    Sr(B.y1, B.x1),
                    Sr(B.y0, B.x0),
                    !f,
                  ))
        } else r.moveTo(c + L, h + I), r.arc(c, h, n, l, u, !f)
        if (!(i > fa) || !V) r.lineTo(c + F, h + k)
        else if (M > fa) {
          var At = za(g, M),
            gt = za(v, M),
            dt = Hg(F, k, C, E, i, -gt, f),
            B = Hg(L, I, D, P, i, -At, f)
          r.lineTo(c + dt.cx + dt.x0, h + dt.cy + dt.y0),
            M < T && At === gt
              ? r.arc(
                  c + dt.cx,
                  h + dt.cy,
                  M,
                  Sr(dt.y0, dt.x0),
                  Sr(B.y0, B.x0),
                  !f,
                )
              : (gt > 0 &&
                  r.arc(
                    c + dt.cx,
                    h + dt.cy,
                    gt,
                    Sr(dt.y0, dt.x0),
                    Sr(dt.y1, dt.x1),
                    !f,
                  ),
                r.arc(
                  c,
                  h,
                  i,
                  Sr(dt.cy + dt.y1, dt.cx + dt.x1),
                  Sr(B.cy + B.y1, B.cx + B.x1),
                  f,
                ),
                At > 0 &&
                  r.arc(
                    c + B.cx,
                    h + B.cy,
                    At,
                    Sr(B.y1, B.x1),
                    Sr(B.y0, B.x0),
                    !f,
                  ))
        } else r.lineTo(c + F, h + k), r.arc(c, h, i, u, l, f)
      }
      r.closePath()
    }
  }
}
var snt = (function () {
    function r() {
      ;(this.cx = 0),
        (this.cy = 0),
        (this.r0 = 0),
        (this.r = 0),
        (this.startAngle = 0),
        (this.endAngle = Math.PI * 2),
        (this.clockwise = !0),
        (this.cornerRadius = 0)
    }
    return r
  })(),
  MU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new snt()
      }),
      (t.prototype.buildPath = function (e, n) {
        ont(e, n)
      }),
      (t.prototype.isZeroArea = function () {
        return (
          this.shape.startAngle === this.shape.endAngle ||
          this.shape.r === this.shape.r0
        )
      }),
      t
    )
  })(oe)
MU.prototype.type = 'sector'
const oi = MU
var lnt = (function () {
    function r() {
      ;(this.cx = 0), (this.cy = 0), (this.r = 0), (this.r0 = 0)
    }
    return r
  })(),
  TU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new lnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.cx,
          a = n.cy,
          o = Math.PI * 2
        e.moveTo(i + n.r, a),
          e.arc(i, a, n.r, 0, o, !1),
          e.moveTo(i + n.r0, a),
          e.arc(i, a, n.r0, 0, o, !0)
      }),
      t
    )
  })(oe)
TU.prototype.type = 'ring'
const i_ = TU
function unt(r, t, e, n) {
  var i = [],
    a = [],
    o = [],
    s = [],
    l,
    u,
    c,
    h
  if (n) {
    ;(c = [1 / 0, 1 / 0]), (h = [-1 / 0, -1 / 0])
    for (var f = 0, d = r.length; f < d; f++) Bs(c, c, r[f]), Fs(h, h, r[f])
    Bs(c, c, n[0]), Fs(h, h, n[1])
  }
  for (var f = 0, d = r.length; f < d; f++) {
    var p = r[f]
    if (e) (l = r[f ? f - 1 : d - 1]), (u = r[(f + 1) % d])
    else if (f === 0 || f === d - 1) {
      i.push(Go(r[f]))
      continue
    } else (l = r[f - 1]), (u = r[f + 1])
    gu(a, u, l), Xm(a, a, t)
    var g = Lb(p, l),
      v = Lb(p, u),
      m = g + v
    m !== 0 && ((g /= m), (v /= m)), Xm(o, a, -g), Xm(s, a, v)
    var y = EL([], p, o),
      _ = EL([], p, s)
    n && (Fs(y, y, c), Bs(y, y, h), Fs(_, _, c), Bs(_, _, h)),
      i.push(y),
      i.push(_)
  }
  return e && i.push(i.shift()), i
}
function CU(r, t, e) {
  var n = t.smooth,
    i = t.points
  if (i && i.length >= 2) {
    if (n) {
      var a = unt(i, n, e, t.smoothConstraint)
      r.moveTo(i[0][0], i[0][1])
      for (var o = i.length, s = 0; s < (e ? o : o - 1); s++) {
        var l = a[s * 2],
          u = a[s * 2 + 1],
          c = i[(s + 1) % o]
        r.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1])
      }
    } else {
      r.moveTo(i[0][0], i[0][1])
      for (var s = 1, h = i.length; s < h; s++) r.lineTo(i[s][0], i[s][1])
    }
    e && r.closePath()
  }
}
var cnt = (function () {
    function r() {
      ;(this.points = null), (this.smooth = 0), (this.smoothConstraint = null)
    }
    return r
  })(),
  EU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new cnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        CU(e, n, !0)
      }),
      t
    )
  })(oe)
EU.prototype.type = 'polygon'
const si = EU
var hnt = (function () {
    function r() {
      ;(this.points = null),
        (this.percent = 1),
        (this.smooth = 0),
        (this.smoothConstraint = null)
    }
    return r
  })(),
  DU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new hnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        CU(e, n, !1)
      }),
      t
    )
  })(oe)
DU.prototype.type = 'polyline'
const li = DU
var fnt = {},
  dnt = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.percent = 1)
    }
    return r
  })(),
  LU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new dnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i, a, o, s
        if (this.subPixelOptimize) {
          var l = nU(fnt, n, this.style)
          ;(i = l.x1), (a = l.y1), (o = l.x2), (s = l.y2)
        } else (i = n.x1), (a = n.y1), (o = n.x2), (s = n.y2)
        var u = n.percent
        u !== 0 &&
          (e.moveTo(i, a),
          u < 1 && ((o = i * (1 - u) + o * u), (s = a * (1 - u) + s * u)),
          e.lineTo(o, s))
      }),
      (t.prototype.pointAt = function (e) {
        var n = this.shape
        return [n.x1 * (1 - e) + n.x2 * e, n.y1 * (1 - e) + n.y2 * e]
      }),
      t
    )
  })(oe)
LU.prototype.type = 'line'
const rr = LU
var Xr = [],
  pnt = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.cpx1 = 0),
        (this.cpy1 = 0),
        (this.percent = 1)
    }
    return r
  })()
function kP(r, t, e) {
  var n = r.cpx2,
    i = r.cpy2
  return n != null || i != null
    ? [
        (e ? UL : Wn)(r.x1, r.cpx1, r.cpx2, r.x2, t),
        (e ? UL : Wn)(r.y1, r.cpy1, r.cpy2, r.y2, t),
      ]
    : [
        (e ? kb : tr)(r.x1, r.cpx1, r.x2, t),
        (e ? kb : tr)(r.y1, r.cpy1, r.y2, t),
      ]
}
var PU = (function (r) {
  X(t, r)
  function t(e) {
    return r.call(this, e) || this
  }
  return (
    (t.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null,
      }
    }),
    (t.prototype.getDefaultShape = function () {
      return new pnt()
    }),
    (t.prototype.buildPath = function (e, n) {
      var i = n.x1,
        a = n.y1,
        o = n.x2,
        s = n.y2,
        l = n.cpx1,
        u = n.cpy1,
        c = n.cpx2,
        h = n.cpy2,
        f = n.percent
      f !== 0 &&
        (e.moveTo(i, a),
        c == null || h == null
          ? (f < 1 &&
              (Bp(i, l, o, f, Xr),
              (l = Xr[1]),
              (o = Xr[2]),
              Bp(a, u, s, f, Xr),
              (u = Xr[1]),
              (s = Xr[2])),
            e.quadraticCurveTo(l, u, o, s))
          : (f < 1 &&
              (il(i, l, c, o, f, Xr),
              (l = Xr[1]),
              (c = Xr[2]),
              (o = Xr[3]),
              il(a, u, h, s, f, Xr),
              (u = Xr[1]),
              (h = Xr[2]),
              (s = Xr[3])),
            e.bezierCurveTo(l, u, c, h, o, s)))
    }),
    (t.prototype.pointAt = function (e) {
      return kP(this.shape, e, !1)
    }),
    (t.prototype.tangentAt = function (e) {
      var n = kP(this.shape, e, !0)
      return gf(n, n)
    }),
    t
  )
})(oe)
PU.prototype.type = 'bezier-curve'
const a_ = PU
var vnt = (function () {
    function r() {
      ;(this.cx = 0),
        (this.cy = 0),
        (this.r = 0),
        (this.startAngle = 0),
        (this.endAngle = Math.PI * 2),
        (this.clockwise = !0)
    }
    return r
  })(),
  RU = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new vnt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.cx,
          a = n.cy,
          o = Math.max(n.r, 0),
          s = n.startAngle,
          l = n.endAngle,
          u = n.clockwise,
          c = Math.cos(s),
          h = Math.sin(s)
        e.moveTo(c * o + i, h * o + a), e.arc(i, a, o, s, l, !u)
      }),
      t
    )
  })(oe)
RU.prototype.type = 'arc'
const jT = RU
var gnt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = 'compound'), e
  }
  return (
    (t.prototype._updatePathDirty = function () {
      for (
        var e = this.shape.paths, n = this.shapeChanged(), i = 0;
        i < e.length;
        i++
      )
        n = n || e[i].shapeChanged()
      n && this.dirtyShape()
    }),
    (t.prototype.beforeBrush = function () {
      this._updatePathDirty()
      for (
        var e = this.shape.paths || [], n = this.getGlobalScale(), i = 0;
        i < e.length;
        i++
      )
        e[i].path || e[i].createPathProxy(),
          e[i].path.setScale(n[0], n[1], e[i].segmentIgnoreThreshold)
    }),
    (t.prototype.buildPath = function (e, n) {
      for (var i = n.paths || [], a = 0; a < i.length; a++)
        i[a].buildPath(e, i[a].shape, !0)
    }),
    (t.prototype.afterBrush = function () {
      for (var e = this.shape.paths || [], n = 0; n < e.length; n++)
        e[n].pathUpdated()
    }),
    (t.prototype.getBoundingRect = function () {
      return (
        this._updatePathDirty.call(this),
        oe.prototype.getBoundingRect.call(this)
      )
    }),
    t
  )
})(oe)
const JT = gnt
var mnt = (function () {
  function r(t) {
    this.colorStops = t || []
  }
  return (
    (r.prototype.addColorStop = function (t, e) {
      this.colorStops.push({
        offset: t,
        color: e,
      })
    }),
    r
  )
})()
const IU = mnt
var ynt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o, s) {
    var l = r.call(this, o) || this
    return (
      (l.x = e ?? 0),
      (l.y = n ?? 0),
      (l.x2 = i ?? 1),
      (l.y2 = a ?? 0),
      (l.type = 'linear'),
      (l.global = s || !1),
      l
    )
  }
  return t
})(IU)
const He = ynt
var _nt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o) {
    var s = r.call(this, a) || this
    return (
      (s.x = e ?? 0.5),
      (s.y = n ?? 0.5),
      (s.r = i ?? 0.5),
      (s.type = 'radial'),
      (s.global = o || !1),
      s
    )
  }
  return t
})(IU)
const OU = _nt
var Hl = [0, 0],
  Wl = [0, 0],
  Wg = new Qt(),
  Xg = new Qt(),
  xnt = (function () {
    function r(t, e) {
      ;(this._corners = []), (this._axes = []), (this._origin = [0, 0])
      for (var n = 0; n < 4; n++) this._corners[n] = new Qt()
      for (var n = 0; n < 2; n++) this._axes[n] = new Qt()
      t && this.fromBoundingRect(t, e)
    }
    return (
      (r.prototype.fromBoundingRect = function (t, e) {
        var n = this._corners,
          i = this._axes,
          a = t.x,
          o = t.y,
          s = a + t.width,
          l = o + t.height
        if ((n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), e))
          for (var u = 0; u < 4; u++) n[u].transform(e)
        Qt.sub(i[0], n[1], n[0]),
          Qt.sub(i[1], n[3], n[0]),
          i[0].normalize(),
          i[1].normalize()
        for (var u = 0; u < 2; u++) this._origin[u] = i[u].dot(n[0])
      }),
      (r.prototype.intersect = function (t, e) {
        var n = !0,
          i = !e
        return (
          Wg.set(1 / 0, 1 / 0),
          Xg.set(0, 0),
          (!this._intersectCheckOneSide(this, t, Wg, Xg, i, 1) &&
            ((n = !1), i)) ||
            (!this._intersectCheckOneSide(t, this, Wg, Xg, i, -1) &&
              ((n = !1), i)) ||
            i ||
            Qt.copy(e, n ? Wg : Xg),
          n
        )
      }),
      (r.prototype._intersectCheckOneSide = function (t, e, n, i, a, o) {
        for (var s = !0, l = 0; l < 2; l++) {
          var u = this._axes[l]
          if (
            (this._getProjMinMaxOnAxis(l, t._corners, Hl),
            this._getProjMinMaxOnAxis(l, e._corners, Wl),
            Hl[1] < Wl[0] || Hl[0] > Wl[1])
          ) {
            if (((s = !1), a)) return s
            var c = Math.abs(Wl[0] - Hl[1]),
              h = Math.abs(Hl[0] - Wl[1])
            Math.min(c, h) > i.len() &&
              (c < h ? Qt.scale(i, u, -c * o) : Qt.scale(i, u, h * o))
          } else if (n) {
            var c = Math.abs(Wl[0] - Hl[1]),
              h = Math.abs(Hl[0] - Wl[1])
            Math.min(c, h) < n.len() &&
              (c < h ? Qt.scale(n, u, c * o) : Qt.scale(n, u, -h * o))
          }
        }
        return s
      }),
      (r.prototype._getProjMinMaxOnAxis = function (t, e, n) {
        for (
          var i = this._axes[t],
            a = this._origin,
            o = e[0].dot(i) + a[t],
            s = o,
            l = o,
            u = 1;
          u < e.length;
          u++
        ) {
          var c = e[u].dot(i) + a[t]
          ;(s = Math.min(c, s)), (l = Math.max(c, l))
        }
        ;(n[0] = s), (n[1] = l)
      }),
      r
    )
  })()
const Yy = xnt
var Snt = [],
  Ant = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.notClear = !0),
        (e.incremental = !0),
        (e._displayables = []),
        (e._temporaryDisplayables = []),
        (e._cursor = 0),
        e
      )
    }
    return (
      (t.prototype.traverse = function (e, n) {
        e.call(n, this)
      }),
      (t.prototype.useStyle = function () {
        this.style = {}
      }),
      (t.prototype.getCursor = function () {
        return this._cursor
      }),
      (t.prototype.innerAfterBrush = function () {
        this._cursor = this._displayables.length
      }),
      (t.prototype.clearDisplaybles = function () {
        ;(this._displayables = []),
          (this._temporaryDisplayables = []),
          (this._cursor = 0),
          this.markRedraw(),
          (this.notClear = !1)
      }),
      (t.prototype.clearTemporalDisplayables = function () {
        this._temporaryDisplayables = []
      }),
      (t.prototype.addDisplayable = function (e, n) {
        n ? this._temporaryDisplayables.push(e) : this._displayables.push(e),
          this.markRedraw()
      }),
      (t.prototype.addDisplayables = function (e, n) {
        n = n || !1
        for (var i = 0; i < e.length; i++) this.addDisplayable(e[i], n)
      }),
      (t.prototype.getDisplayables = function () {
        return this._displayables
      }),
      (t.prototype.getTemporalDisplayables = function () {
        return this._temporaryDisplayables
      }),
      (t.prototype.eachPendingDisplayable = function (e) {
        for (var n = this._cursor; n < this._displayables.length; n++)
          e && e(this._displayables[n])
        for (var n = 0; n < this._temporaryDisplayables.length; n++)
          e && e(this._temporaryDisplayables[n])
      }),
      (t.prototype.update = function () {
        this.updateTransform()
        for (var e = this._cursor; e < this._displayables.length; e++) {
          var n = this._displayables[e]
          ;(n.parent = this), n.update(), (n.parent = null)
        }
        for (var e = 0; e < this._temporaryDisplayables.length; e++) {
          var n = this._temporaryDisplayables[e]
          ;(n.parent = this), n.update(), (n.parent = null)
        }
      }),
      (t.prototype.getBoundingRect = function () {
        if (!this._rect) {
          for (
            var e = new ee(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0;
            n < this._displayables.length;
            n++
          ) {
            var i = this._displayables[n],
              a = i.getBoundingRect().clone()
            i.needLocalTransform() &&
              a.applyTransform(i.getLocalTransform(Snt)),
              e.union(a)
          }
          this._rect = e
        }
        return this._rect
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        if (a.contain(i[0], i[1]))
          for (var o = 0; o < this._displayables.length; o++) {
            var s = this._displayables[o]
            if (s.contain(e, n)) return !0
          }
        return !1
      }),
      t
    )
  })(ea)
const bnt = Ant
var NU = ve()
function xf(r, t, e, n, i) {
  var a
  if (t && t.ecModel) {
    var o = t.ecModel.getUpdatePayload()
    a = o && o.animation
  }
  var s = t && t.isAnimationEnabled(),
    l = r === 'update'
  if (s) {
    var u = void 0,
      c = void 0,
      h = void 0
    n
      ? ((u = $t(n.duration, 200)), (c = $t(n.easing, 'cubicOut')), (h = 0))
      : ((u = t.getShallow(
          l ? 'animationDurationUpdate' : 'animationDuration',
        )),
        (c = t.getShallow(l ? 'animationEasingUpdate' : 'animationEasing')),
        (h = t.getShallow(l ? 'animationDelayUpdate' : 'animationDelay'))),
      a &&
        (a.duration != null && (u = a.duration),
        a.easing != null && (c = a.easing),
        a.delay != null && (h = a.delay)),
      Nt(h) && (h = h(e, i)),
      Nt(u) && (u = u(e))
    var f = {
      duration: u || 0,
      delay: h,
      easing: c,
    }
    return f
  } else return null
}
function QT(r, t, e, n, i, a, o) {
  var s = !1,
    l
  Nt(i)
    ? ((o = a), (a = i), (i = null))
    : Ut(i) &&
      ((a = i.cb),
      (o = i.during),
      (s = i.isFrom),
      (l = i.removeOpt),
      (i = i.dataIndex))
  var u = r === 'leave'
  u || t.stopAnimation('leave')
  var c = xf(
    r,
    n,
    i,
    u ? l || {} : null,
    n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, i) : null,
  )
  if (c && c.duration > 0) {
    var h = c.duration,
      f = c.delay,
      d = c.easing,
      p = {
        duration: h,
        delay: f || 0,
        easing: d,
        done: a,
        force: !!a || !!o,
        setToFinal: !u,
        scope: r,
        during: o,
      }
    s ? t.animateFrom(e, p) : t.animateTo(e, p)
  } else t.stopAnimation(), !s && t.attr(e), o && o(1), a && a()
}
function we(r, t, e, n, i, a) {
  QT('update', r, t, e, n, i, a)
}
function Je(r, t, e, n, i, a) {
  QT('enter', r, t, e, n, i, a)
}
function Rh(r) {
  if (!r.__zr) return !0
  for (var t = 0; t < r.animators.length; t++) {
    var e = r.animators[t]
    if (e.scope === 'leave') return !0
  }
  return !1
}
function al(r, t, e, n, i, a) {
  Rh(r) || QT('leave', r, t, e, n, i, a)
}
function BP(r, t, e, n) {
  r.removeTextContent(),
    r.removeTextGuideLine(),
    al(
      r,
      {
        style: {
          opacity: 0,
        },
      },
      t,
      e,
      n,
    )
}
function Xp(r, t, e) {
  function n() {
    r.parent && r.parent.remove(r)
  }
  r.isGroup
    ? r.traverse(function (i) {
        i.isGroup || BP(i, t, e, n)
      })
    : BP(r, t, e, n)
}
function Ca(r) {
  NU(r).oldStyle = r.style
}
function wnt(r) {
  return NU(r).oldStyle
}
var $y = Math.max,
  qy = Math.min,
  sw = {}
function Mnt(r) {
  return oe.extend(r)
}
var Tnt = Qet
function Cnt(r, t) {
  return Tnt(r, t)
}
function Pa(r, t) {
  sw[r] = t
}
function tC(r) {
  if (sw.hasOwnProperty(r)) return sw[r]
}
function o_(r, t, e, n) {
  var i = SU(r, t)
  return e && (n === 'center' && (e = BU(e, i.getBoundingRect())), FU(i, e)), i
}
function kU(r, t, e) {
  var n = new yr({
    style: {
      image: r,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
    },
    onload: function (i) {
      if (e === 'center') {
        var a = {
          width: i.width,
          height: i.height,
        }
        n.setStyle(BU(t, a))
      }
    },
  })
  return n
}
function BU(r, t) {
  var e = t.width / t.height,
    n = r.height * e,
    i
  n <= r.width ? (i = r.height) : ((n = r.width), (i = n / e))
  var a = r.x + r.width / 2,
    o = r.y + r.height / 2
  return {
    x: a - n / 2,
    y: o - i / 2,
    width: n,
    height: i,
  }
}
var Wi = tnt
function FU(r, t) {
  if (r.applyTransform) {
    var e = r.getBoundingRect(),
      n = e.calculateTransform(t)
    r.applyTransform(n)
  }
}
function ef(r, t) {
  return (
    nU(r, r, {
      lineWidth: t,
    }),
    r
  )
}
function Ent(r) {
  return rU(r.shape, r.shape, r.style), r
}
var ey = mu
function Nu(r, t) {
  for (var e = Z0([]); r && r !== t; )
    Ho(e, r.getLocalTransform(), e), (r = r.parent)
  return e
}
function ba(r, t, e) {
  return (
    t && !Er(t) && (t = Uo.getLocalTransform(t)),
    e && (t = mf([], t)),
    pr([], r, t)
  )
}
function s_(r, t, e) {
  var n =
      t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs((2 * t[4]) / t[0]),
    i =
      t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs((2 * t[4]) / t[2]),
    a = [
      r === 'left' ? -n : r === 'right' ? n : 0,
      r === 'top' ? -i : r === 'bottom' ? i : 0,
    ]
  return (
    (a = ba(a, t, e)),
    Math.abs(a[0]) > Math.abs(a[1])
      ? a[0] > 0
        ? 'right'
        : 'left'
      : a[1] > 0
      ? 'bottom'
      : 'top'
  )
}
function FP(r) {
  return !r.isGroup
}
function Dnt(r) {
  return r.shape != null
}
function xv(r, t, e) {
  if (!r || !t) return
  function n(o) {
    var s = {}
    return (
      o.traverse(function (l) {
        FP(l) && l.anid && (s[l.anid] = l)
      }),
      s
    )
  }
  function i(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation,
    }
    return Dnt(o) && (s.shape = Q({}, o.shape)), s
  }
  var a = n(r)
  t.traverse(function (o) {
    if (FP(o) && o.anid) {
      var s = a[o.anid]
      if (s) {
        var l = i(o)
        o.attr(i(s)), we(o, l, e, Wt(o).dataIndex)
      }
    }
  })
}
function zU(r, t) {
  return st(r, function (e) {
    var n = e[0]
    ;(n = $y(n, t.x)), (n = qy(n, t.x + t.width))
    var i = e[1]
    return (i = $y(i, t.y)), (i = qy(i, t.y + t.height)), [n, i]
  })
}
function Lnt(r, t) {
  var e = $y(r.x, t.x),
    n = qy(r.x + r.width, t.x + t.width),
    i = $y(r.y, t.y),
    a = qy(r.y + r.height, t.y + t.height)
  if (n >= e && a >= i)
    return {
      x: e,
      y: i,
      width: n - e,
      height: a - i,
    }
}
function Sv(r, t, e) {
  var n = Q(
      {
        rectHover: !0,
      },
      t,
    ),
    i = (n.style = {
      strokeNoScale: !0,
    })
  if (
    ((e = e || {
      x: -1,
      y: -1,
      width: 2,
      height: 2,
    }),
    r)
  )
    return r.indexOf('image://') === 0
      ? ((i.image = r.slice(8)), zt(i, e), new yr(n))
      : o_(r.replace('path://', ''), n, e, 'center')
}
function Fd(r, t, e, n, i) {
  for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
    var s = i[a]
    if (UU(r, t, e, n, s[0], s[1], o[0], o[1])) return !0
    o = s
  }
}
function UU(r, t, e, n, i, a, o, s) {
  var l = e - r,
    u = n - t,
    c = o - i,
    h = s - a,
    f = b1(c, h, l, u)
  if (Pnt(f)) return !1
  var d = r - i,
    p = t - a,
    g = b1(d, p, l, u) / f
  if (g < 0 || g > 1) return !1
  var v = b1(d, p, c, h) / f
  return !(v < 0 || v > 1)
}
function b1(r, t, e, n) {
  return r * n - e * t
}
function Pnt(r) {
  return r <= 1e-6 && r >= -1e-6
}
function Sf(r) {
  var t = r.itemTooltipOption,
    e = r.componentModel,
    n = r.itemName,
    i = bt(t)
      ? {
          formatter: t,
        }
      : t,
    a = e.mainType,
    o = e.componentIndex,
    s = {
      componentType: a,
      name: n,
      $vars: ['name'],
    }
  s[a + 'Index'] = o
  var l = r.formatterParamsExtra
  l &&
    R(pe(l), function (c) {
      Et(s, c) || ((s[c] = l[c]), s.$vars.push(c))
    })
  var u = Wt(r.el)
  ;(u.componentMainType = a),
    (u.componentIndex = o),
    (u.tooltipConfig = {
      name: n,
      option: zt(
        {
          content: n,
          encodeHTMLContent: !0,
          formatterParams: s,
        },
        i,
      ),
    })
}
function zP(r, t) {
  var e
  r.isGroup && (e = t(r)), e || r.traverse(t)
}
function vl(r, t) {
  if (r)
    if (at(r)) for (var e = 0; e < r.length; e++) zP(r[e], t)
    else zP(r, t)
}
Pa('circle', pl)
Pa('ellipse', KT)
Pa('sector', oi)
Pa('ring', i_)
Pa('polygon', si)
Pa('polyline', li)
Pa('rect', ge)
Pa('line', rr)
Pa('bezierCurve', a_)
Pa('arc', jT)
const nc = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      Arc: jT,
      BezierCurve: a_,
      BoundingRect: ee,
      Circle: pl,
      CompoundPath: JT,
      Ellipse: KT,
      Group: Ht,
      Image: yr,
      IncrementalDisplayable: bnt,
      Line: rr,
      LinearGradient: He,
      OrientedBoundingRect: Yy,
      Path: oe,
      Point: Qt,
      Polygon: si,
      Polyline: li,
      RadialGradient: OU,
      Rect: ge,
      Ring: i_,
      Sector: oi,
      Text: Ae,
      applyTransform: ba,
      clipPointsByRect: zU,
      clipRectByRect: Lnt,
      createIcon: Sv,
      extendPath: Cnt,
      extendShape: Mnt,
      getShapeClass: tC,
      getTransform: Nu,
      groupTransition: xv,
      initProps: Je,
      isElementRemoved: Rh,
      lineLineIntersect: UU,
      linePolygonIntersect: Fd,
      makeImage: kU,
      makePath: o_,
      mergePath: Wi,
      registerShape: Pa,
      removeElement: al,
      removeElementWithFadeOut: Xp,
      resizePath: FU,
      setTooltipConfig: Sf,
      subPixelOptimize: ey,
      subPixelOptimizeLine: ef,
      subPixelOptimizeRect: Ent,
      transformDirection: s_,
      traverseElements: vl,
      updateProps: we,
    },
    Symbol.toStringTag,
    {
      value: 'Module',
    },
  ),
)
var l_ = {}
function VU(r, t) {
  for (var e = 0; e < Hr.length; e++) {
    var n = Hr[e],
      i = t[n],
      a = r.ensureState(n)
    ;(a.style = a.style || {}), (a.style.text = i)
  }
  var o = r.currentStates.slice()
  r.clearStates(!0),
    r.setStyle({
      text: t.normal,
    }),
    r.useStates(o, !0)
}
function lw(r, t, e) {
  var n = r.labelFetcher,
    i = r.labelDataIndex,
    a = r.labelDimIndex,
    o = t.normal,
    s
  n &&
    (s = n.getFormattedLabel(
      i,
      'normal',
      null,
      a,
      o && o.get('formatter'),
      e != null
        ? {
            interpolatedValue: e,
          }
        : null,
    )),
    s == null &&
      (s = Nt(r.defaultText) ? r.defaultText(i, r, e) : r.defaultText)
  for (
    var l = {
        normal: s,
      },
      u = 0;
    u < Hr.length;
    u++
  ) {
    var c = Hr[u],
      h = t[c]
    l[c] = $t(
      n ? n.getFormattedLabel(i, c, null, a, h && h.get('formatter')) : null,
      s,
    )
  }
  return l
}
function mr(r, t, e, n) {
  e = e || l_
  for (var i = r instanceof Ae, a = !1, o = 0; o < Hp.length; o++) {
    var s = t[Hp[o]]
    if (s && s.getShallow('show')) {
      a = !0
      break
    }
  }
  var l = i ? r : r.getTextContent()
  if (a) {
    i ||
      (l || ((l = new Ae()), r.setTextContent(l)),
      r.stateProxy && (l.stateProxy = r.stateProxy))
    var u = lw(e, t),
      c = t.normal,
      h = !!c.getShallow('show'),
      f = $e(c, n && n.normal, e, !1, !i)
    ;(f.text = u.normal), i || r.setTextConfig(Zy(c, e, !1))
    for (var o = 0; o < Hr.length; o++) {
      var d = Hr[o],
        s = t[d]
      if (s) {
        var p = l.ensureState(d),
          g = !!$t(s.getShallow('show'), h)
        if (
          (g !== h && (p.ignore = !g),
          (p.style = $e(s, n && n[d], e, !0, !i)),
          (p.style.text = u[d]),
          !i)
        ) {
          var v = r.ensureState(d)
          v.textConfig = Zy(s, e, !0)
        }
      }
    }
    ;(l.silent = !!c.getShallow('silent')),
      l.style.x != null && (f.x = l.style.x),
      l.style.y != null && (f.y = l.style.y),
      (l.ignore = !h),
      l.useStyle(f),
      l.dirty(),
      e.enableTextSetter &&
        (Af(l).setLabelText = function (m) {
          var y = lw(e, t, m)
          VU(l, y)
        })
  } else l && (l.ignore = !0)
  r.dirty()
}
function Zn(r, t) {
  t = t || 'label'
  for (
    var e = {
        normal: r.getModel(t),
      },
      n = 0;
    n < Hr.length;
    n++
  ) {
    var i = Hr[n]
    e[i] = r.getModel([i, t])
  }
  return e
}
function $e(r, t, e, n, i) {
  var a = {}
  return Rnt(a, r, e, n, i), t && Q(a, t), a
}
function Zy(r, t, e) {
  t = t || {}
  var n = {},
    i,
    a = r.getShallow('rotate'),
    o = $t(r.getShallow('distance'), e ? null : 5),
    s = r.getShallow('offset')
  return (
    (i = r.getShallow('position') || (e ? null : 'inside')),
    i === 'outside' && (i = t.defaultOutsidePosition || 'top'),
    i != null && (n.position = i),
    s != null && (n.offset = s),
    a != null && ((a *= Math.PI / 180), (n.rotation = a)),
    o != null && (n.distance = o),
    (n.outsideFill =
      r.get('color') === 'inherit' ? t.inheritColor || null : 'auto'),
    n
  )
}
function Rnt(r, t, e, n, i) {
  e = e || l_
  var a = t.ecModel,
    o = a && a.option.textStyle,
    s = Int(t),
    l
  if (s) {
    l = {}
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = t.getModel(['rich', u])
        HP((l[u] = {}), c, o, e, n, i, !1, !0)
      }
  }
  l && (r.rich = l)
  var h = t.get('overflow')
  h && (r.overflow = h)
  var f = t.get('minMargin')
  f != null && (r.margin = f), HP(r, t, o, e, n, i, !0, !1)
}
function Int(r) {
  for (var t; r && r !== r.ecModel; ) {
    var e = (r.option || l_).rich
    if (e) {
      t = t || {}
      for (var n = pe(e), i = 0; i < n.length; i++) {
        var a = n[i]
        t[a] = 1
      }
    }
    r = r.parentModel
  }
  return t
}
var UP = [
    'fontStyle',
    'fontWeight',
    'fontSize',
    'fontFamily',
    'textShadowColor',
    'textShadowBlur',
    'textShadowOffsetX',
    'textShadowOffsetY',
  ],
  VP = [
    'align',
    'lineHeight',
    'width',
    'height',
    'tag',
    'verticalAlign',
    'ellipsis',
  ],
  GP = [
    'padding',
    'borderWidth',
    'borderRadius',
    'borderDashOffset',
    'backgroundColor',
    'borderColor',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
  ]
function HP(r, t, e, n, i, a, o, s) {
  e = (!i && e) || l_
  var l = n && n.inheritColor,
    u = t.getShallow('color'),
    c = t.getShallow('textBorderColor'),
    h = $t(t.getShallow('opacity'), e.opacity)
  ;(u === 'inherit' || u === 'auto') && (l ? (u = l) : (u = null)),
    (c === 'inherit' || c === 'auto') && (l ? (c = l) : (c = null)),
    a || ((u = u || e.color), (c = c || e.textBorderColor)),
    u != null && (r.fill = u),
    c != null && (r.stroke = c)
  var f = $t(t.getShallow('textBorderWidth'), e.textBorderWidth)
  f != null && (r.lineWidth = f)
  var d = $t(t.getShallow('textBorderType'), e.textBorderType)
  d != null && (r.lineDash = d)
  var p = $t(t.getShallow('textBorderDashOffset'), e.textBorderDashOffset)
  p != null && (r.lineDashOffset = p),
    !i && h == null && !s && (h = n && n.defaultOpacity),
    h != null && (r.opacity = h),
    !i && !a && r.fill == null && n.inheritColor && (r.fill = n.inheritColor)
  for (var g = 0; g < UP.length; g++) {
    var v = UP[g],
      m = $t(t.getShallow(v), e[v])
    m != null && (r[v] = m)
  }
  for (var g = 0; g < VP.length; g++) {
    var v = VP[g],
      m = t.getShallow(v)
    m != null && (r[v] = m)
  }
  if (r.verticalAlign == null) {
    var y = t.getShallow('baseline')
    y != null && (r.verticalAlign = y)
  }
  if (!o || !n.disableBox) {
    for (var g = 0; g < GP.length; g++) {
      var v = GP[g],
        m = t.getShallow(v)
      m != null && (r[v] = m)
    }
    var _ = t.getShallow('borderType')
    _ != null && (r.borderDash = _),
      (r.backgroundColor === 'auto' || r.backgroundColor === 'inherit') &&
        l &&
        (r.backgroundColor = l),
      (r.borderColor === 'auto' || r.borderColor === 'inherit') &&
        l &&
        (r.borderColor = l)
  }
}
function eC(r, t) {
  var e = t && t.getModel('textStyle')
  return xa(
    [
      r.fontStyle || (e && e.getShallow('fontStyle')) || '',
      r.fontWeight || (e && e.getShallow('fontWeight')) || '',
      (r.fontSize || (e && e.getShallow('fontSize')) || 12) + 'px',
      r.fontFamily || (e && e.getShallow('fontFamily')) || 'sans-serif',
    ].join(' '),
  )
}
var Af = ve()
function GU(r, t, e, n) {
  if (r) {
    var i = Af(r)
    ;(i.prevValue = i.value), (i.value = e)
    var a = t.normal
    ;(i.valueAnimation = a.get('valueAnimation')),
      i.valueAnimation &&
        ((i.precision = a.get('precision')),
        (i.defaultInterpolatedText = n),
        (i.statesModels = t))
  }
}
function HU(r, t, e, n, i) {
  var a = Af(r)
  if (!a.valueAnimation || a.prevValue === a.value) return
  var o = a.defaultInterpolatedText,
    s = $t(a.interpolatedValue, a.prevValue),
    l = a.value
  function u(c) {
    var h = Yz(e, a.precision, s, l, c)
    a.interpolatedValue = c === 1 ? null : h
    var f = lw(
      {
        labelDataIndex: t,
        labelFetcher: i,
        defaultText: o ? o(h) : h + '',
      },
      a.statesModels,
      h,
    )
    VU(r, f)
  }
  ;(r.percent = 0),
    (a.prevValue == null ? Je : we)(
      r,
      {
        percent: 1,
      },
      n,
      t,
      null,
      u,
    )
}
var Ont = ['textStyle', 'color'],
  w1 = [
    'fontStyle',
    'fontWeight',
    'fontSize',
    'fontFamily',
    'padding',
    'lineHeight',
    'rich',
    'width',
    'height',
    'overflow',
  ],
  M1 = new Ae(),
  Nnt = (function () {
    function r() {}
    return (
      (r.prototype.getTextColor = function (t) {
        var e = this.ecModel
        return this.getShallow('color') || (!t && e ? e.get(Ont) : null)
      }),
      (r.prototype.getFont = function () {
        return eC(
          {
            fontStyle: this.getShallow('fontStyle'),
            fontWeight: this.getShallow('fontWeight'),
            fontSize: this.getShallow('fontSize'),
            fontFamily: this.getShallow('fontFamily'),
          },
          this.ecModel,
        )
      }),
      (r.prototype.getTextRect = function (t) {
        for (
          var e = {
              text: t,
              verticalAlign:
                this.getShallow('verticalAlign') || this.getShallow('baseline'),
            },
            n = 0;
          n < w1.length;
          n++
        )
          e[w1[n]] = this.getShallow(w1[n])
        return M1.useStyle(e), M1.update(), M1.getBoundingRect()
      }),
      r
    )
  })()
const knt = Nnt
var WU = [
    ['lineWidth', 'width'],
    ['stroke', 'color'],
    ['opacity'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
    ['lineDash', 'type'],
    ['lineDashOffset', 'dashOffset'],
    ['lineCap', 'cap'],
    ['lineJoin', 'join'],
    ['miterLimit'],
  ],
  Bnt = $u(WU),
  Fnt = (function () {
    function r() {}
    return (
      (r.prototype.getLineStyle = function (t) {
        return Bnt(this, t)
      }),
      r
    )
  })(),
  XU = [
    ['fill', 'color'],
    ['stroke', 'borderColor'],
    ['lineWidth', 'borderWidth'],
    ['opacity'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
    ['lineDash', 'borderType'],
    ['lineDashOffset', 'borderDashOffset'],
    ['lineCap', 'borderCap'],
    ['lineJoin', 'borderJoin'],
    ['miterLimit', 'borderMiterLimit'],
  ],
  znt = $u(XU),
  Unt = (function () {
    function r() {}
    return (
      (r.prototype.getItemStyle = function (t, e) {
        return znt(this, t, e)
      }),
      r
    )
  })(),
  rc = (function () {
    function r(t, e, n) {
      ;(this.parentModel = e), (this.ecModel = n), (this.option = t)
    }
    return (
      (r.prototype.init = function (t, e, n) {}),
      (r.prototype.mergeOption = function (t, e) {
        te(this.option, t, !0)
      }),
      (r.prototype.get = function (t, e) {
        return t == null
          ? this.option
          : this._doGet(this.parsePath(t), !e && this.parentModel)
      }),
      (r.prototype.getShallow = function (t, e) {
        var n = this.option,
          i = n == null ? n : n[t]
        if (i == null && !e) {
          var a = this.parentModel
          a && (i = a.getShallow(t))
        }
        return i
      }),
      (r.prototype.getModel = function (t, e) {
        var n = t != null,
          i = n ? this.parsePath(t) : null,
          a = n ? this._doGet(i) : this.option
        return (
          (e =
            e ||
            (this.parentModel &&
              this.parentModel.getModel(this.resolveParentPath(i)))),
          new r(a, e, this.ecModel)
        )
      }),
      (r.prototype.isEmpty = function () {
        return this.option == null
      }),
      (r.prototype.restoreData = function () {}),
      (r.prototype.clone = function () {
        var t = this.constructor
        return new t(Vt(this.option))
      }),
      (r.prototype.parsePath = function (t) {
        return typeof t == 'string' ? t.split('.') : t
      }),
      (r.prototype.resolveParentPath = function (t) {
        return t
      }),
      (r.prototype.isAnimationEnabled = function () {
        if (!Se.node && this.option) {
          if (this.option.animation != null) return !!this.option.animation
          if (this.parentModel) return this.parentModel.isAnimationEnabled()
        }
      }),
      (r.prototype._doGet = function (t, e) {
        var n = this.option
        if (!t) return n
        for (
          var i = 0;
          i < t.length &&
          !(
            t[i] &&
            ((n = n && typeof n == 'object' ? n[t[i]] : null), n == null)
          );
          i++
        );
        return (
          n == null &&
            e &&
            (n = e._doGet(this.resolveParentPath(t), e.parentModel)),
          n
        )
      }),
      r
    )
  })()
VT(rc)
Ftt(rc)
In(rc, Fnt)
In(rc, Unt)
In(rc, Htt)
In(rc, knt)
const qe = rc
var Vnt = Math.round(Math.random() * 10)
function bf(r) {
  return [r || '', Vnt++].join('_')
}
function Gnt(r) {
  var t = {}
  ;(r.registerSubTypeDefaulter = function (e, n) {
    var i = to(e)
    t[i.main] = n
  }),
    (r.determineSubType = function (e, n) {
      var i = n.type
      if (!i) {
        var a = to(e).main
        r.hasSubTypes(e) && t[a] && (i = t[a](n))
      }
      return i
    })
}
function Hnt(r, t) {
  r.topologicalTravel = function (a, o, s, l) {
    if (!a.length) return
    var u = e(o),
      c = u.graph,
      h = u.noEntryList,
      f = {}
    for (
      R(a, function (y) {
        f[y] = !0
      });
      h.length;

    ) {
      var d = h.pop(),
        p = c[d],
        g = !!f[d]
      g && (s.call(l, d, p.originalDeps.slice()), delete f[d]),
        R(p.successor, g ? m : v)
    }
    R(f, function () {
      var y = ''
      throw new Error(y)
    })
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && h.push(y)
    }
    function m(y) {
      ;(f[y] = !0), v(y)
    }
  }
  function e(a) {
    var o = {},
      s = []
    return (
      R(a, function (l) {
        var u = n(o, l),
          c = (u.originalDeps = t(l)),
          h = i(c, a)
        ;(u.entryCount = h.length),
          u.entryCount === 0 && s.push(l),
          R(h, function (f) {
            re(u.predecessor, f) < 0 && u.predecessor.push(f)
            var d = n(o, f)
            re(d.successor, f) < 0 && d.successor.push(l)
          })
      }),
      {
        graph: o,
        noEntryList: s,
      }
    )
  }
  function n(a, o) {
    return (
      a[o] ||
        (a[o] = {
          predecessor: [],
          successor: [],
        }),
      a[o]
    )
  }
  function i(a, o) {
    var s = []
    return (
      R(a, function (l) {
        re(o, l) >= 0 && s.push(l)
      }),
      s
    )
  }
}
function gl(r, t) {
  return te(te({}, r, !0), t, !0)
}
const Wnt = {
    time: {
      month: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ],
      monthAbbr: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
      ],
      dayOfWeek: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
      ],
      dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    },
    legend: {
      selector: {
        all: 'All',
        inverse: 'Inv',
      },
    },
    toolbox: {
      brush: {
        title: {
          rect: 'Box Select',
          polygon: 'Lasso Select',
          lineX: 'Horizontally Select',
          lineY: 'Vertically Select',
          keep: 'Keep Selections',
          clear: 'Clear Selections',
        },
      },
      dataView: {
        title: 'Data View',
        lang: ['Data View', 'Close', 'Refresh'],
      },
      dataZoom: {
        title: {
          zoom: 'Zoom',
          back: 'Zoom Reset',
        },
      },
      magicType: {
        title: {
          line: 'Switch to Line Chart',
          bar: 'Switch to Bar Chart',
          stack: 'Stack',
          tiled: 'Tile',
        },
      },
      restore: {
        title: 'Restore',
      },
      saveAsImage: {
        title: 'Save as Image',
        lang: ['Right Click to Save Image'],
      },
    },
    series: {
      typeNames: {
        pie: 'Pie chart',
        bar: 'Bar chart',
        line: 'Line chart',
        scatter: 'Scatter plot',
        effectScatter: 'Ripple scatter plot',
        radar: 'Radar chart',
        tree: 'Tree',
        treemap: 'Treemap',
        boxplot: 'Boxplot',
        candlestick: 'Candlestick',
        k: 'K line chart',
        heatmap: 'Heat map',
        map: 'Map',
        parallel: 'Parallel coordinate map',
        lines: 'Line graph',
        graph: 'Relationship graph',
        sankey: 'Sankey diagram',
        funnel: 'Funnel chart',
        gauge: 'Gauge',
        pictorialBar: 'Pictorial bar',
        themeRiver: 'Theme River Map',
        sunburst: 'Sunburst',
        custom: 'Custom chart',
        chart: 'Chart',
      },
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: 'This is a chart',
      },
      series: {
        single: {
          prefix: '',
          withName: ' with type {seriesType} named {seriesName}.',
          withoutName: ' with type {seriesType}.',
        },
        multiple: {
          prefix: '. It consists of {seriesCount} series count.',
          withName:
            ' The {seriesId} series is a {seriesType} representing {seriesName}.',
          withoutName: ' The {seriesId} series is a {seriesType}.',
          separator: {
            middle: '',
            end: '',
          },
        },
      },
      data: {
        allData: 'The data is as follows: ',
        partialData: 'The first {displayCnt} items are: ',
        withName: 'the data for {name} is {value}',
        withoutName: '{value}',
        separator: {
          middle: ', ',
          end: '. ',
        },
      },
    },
  },
  Xnt = {
    time: {
      month: [
        '一月',
        '二月',
        '三月',
        '四月',
        '五月',
        '六月',
        '七月',
        '八月',
        '九月',
        '十月',
        '十一月',
        '十二月',
      ],
      monthAbbr: [
        '1月',
        '2月',
        '3月',
        '4月',
        '5月',
        '6月',
        '7月',
        '8月',
        '9月',
        '10月',
        '11月',
        '12月',
      ],
      dayOfWeek: [
        '星期日',
        '星期一',
        '星期二',
        '星期三',
        '星期四',
        '星期五',
        '星期六',
      ],
      dayOfWeekAbbr: ['日', '一', '二', '三', '四', '五', '六'],
    },
    legend: {
      selector: {
        all: '全选',
        inverse: '反选',
      },
    },
    toolbox: {
      brush: {
        title: {
          rect: '矩形选择',
          polygon: '圈选',
          lineX: '横向选择',
          lineY: '纵向选择',
          keep: '保持选择',
          clear: '清除选择',
        },
      },
      dataView: {
        title: '数据视图',
        lang: ['数据视图', '关闭', '刷新'],
      },
      dataZoom: {
        title: {
          zoom: '区域缩放',
          back: '区域缩放还原',
        },
      },
      magicType: {
        title: {
          line: '切换为折线图',
          bar: '切换为柱状图',
          stack: '切换为堆叠',
          tiled: '切换为平铺',
        },
      },
      restore: {
        title: '还原',
      },
      saveAsImage: {
        title: '保存为图片',
        lang: ['右键另存为图片'],
      },
    },
    series: {
      typeNames: {
        pie: '饼图',
        bar: '柱状图',
        line: '折线图',
        scatter: '散点图',
        effectScatter: '涟漪散点图',
        radar: '雷达图',
        tree: '树图',
        treemap: '矩形树图',
        boxplot: '箱型图',
        candlestick: 'K线图',
        k: 'K线图',
        heatmap: '热力图',
        map: '地图',
        parallel: '平行坐标图',
        lines: '线图',
        graph: '关系图',
        sankey: '桑基图',
        funnel: '漏斗图',
        gauge: '仪表盘图',
        pictorialBar: '象形柱图',
        themeRiver: '主题河流图',
        sunburst: '旭日图',
        custom: '自定义图表',
        chart: '图表',
      },
    },
    aria: {
      general: {
        withTitle: '这是一个关于“{title}”的图表。',
        withoutTitle: '这是一个图表，',
      },
      series: {
        single: {
          prefix: '',
          withName: '图表类型是{seriesType}，表示{seriesName}。',
          withoutName: '图表类型是{seriesType}。',
        },
        multiple: {
          prefix: '它由{seriesCount}个图表系列组成。',
          withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
          withoutName: '第{seriesId}个系列是一个{seriesType}，',
          separator: {
            middle: '；',
            end: '。',
          },
        },
      },
      data: {
        allData: '其数据是——',
        partialData: '其中，前{displayCnt}项是——',
        withName: '{name}的数据是{value}',
        withoutName: '{value}',
        separator: {
          middle: '，',
          end: '',
        },
      },
    },
  }
var Ky = 'ZH',
  nC = 'EN',
  Ih = nC,
  ny = {},
  rC = {},
  YU = Se.domSupported
    ? (function () {
        var r = (
          document.documentElement.lang ||
          navigator.language ||
          navigator.browserLanguage ||
          Ih
        ).toUpperCase()
        return r.indexOf(Ky) > -1 ? Ky : Ih
      })()
    : Ih
function $U(r, t) {
  ;(r = r.toUpperCase()), (rC[r] = new qe(t)), (ny[r] = t)
}
function Ynt(r) {
  if (bt(r)) {
    var t = ny[r.toUpperCase()] || {}
    return r === Ky || r === nC ? Vt(t) : te(Vt(t), Vt(ny[Ih]), !1)
  } else return te(Vt(r), Vt(ny[Ih]), !1)
}
function uw(r) {
  return rC[r]
}
function $nt() {
  return rC[Ih]
}
$U(nC, Wnt)
$U(Ky, Xnt)
var iC = 1e3,
  aC = iC * 60,
  lp = aC * 60,
  Xi = lp * 24,
  WP = Xi * 365,
  zd = {
    year: '{yyyy}',
    month: '{MMM}',
    day: '{d}',
    hour: '{HH}:{mm}',
    minute: '{HH}:{mm}',
    second: '{HH}:{mm}:{ss}',
    millisecond: '{HH}:{mm}:{ss} {SSS}',
    none: '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}',
  },
  Yg = '{yyyy}-{MM}-{dd}',
  XP = {
    year: '{yyyy}',
    month: '{yyyy}-{MM}',
    day: Yg,
    hour: Yg + ' ' + zd.hour,
    minute: Yg + ' ' + zd.minute,
    second: Yg + ' ' + zd.second,
    millisecond: zd.none,
  },
  T1 = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'],
  qU = [
    'year',
    'half-year',
    'quarter',
    'month',
    'week',
    'half-week',
    'day',
    'half-day',
    'quarter-day',
    'hour',
    'minute',
    'second',
    'millisecond',
  ]
function ys(r, t) {
  return (r += ''), '0000'.substr(0, t - r.length) + r
}
function Oh(r) {
  switch (r) {
    case 'half-year':
    case 'quarter':
      return 'month'
    case 'week':
    case 'half-week':
      return 'day'
    case 'half-day':
    case 'quarter-day':
      return 'hour'
    default:
      return r
  }
}
function qnt(r) {
  return r === Oh(r)
}
function Znt(r) {
  switch (r) {
    case 'year':
    case 'month':
      return 'day'
    case 'millisecond':
      return 'millisecond'
    default:
      return 'second'
  }
}
function u_(r, t, e, n) {
  var i = po(r),
    a = i[oC(e)](),
    o = i[Nh(e)]() + 1,
    s = Math.floor((o - 1) / 3) + 1,
    l = i[c_(e)](),
    u = i['get' + (e ? 'UTC' : '') + 'Day'](),
    c = i[Yp(e)](),
    h = ((c - 1) % 12) + 1,
    f = i[h_(e)](),
    d = i[f_(e)](),
    p = i[d_(e)](),
    g = c >= 12 ? 'pm' : 'am',
    v = g.toUpperCase(),
    m = n instanceof qe ? n : uw(n || YU) || $nt(),
    y = m.getModel('time'),
    _ = y.get('month'),
    x = y.get('monthAbbr'),
    A = y.get('dayOfWeek'),
    S = y.get('dayOfWeekAbbr')
  return (t || '')
    .replace(/{a}/g, g + '')
    .replace(/{A}/g, v + '')
    .replace(/{yyyy}/g, a + '')
    .replace(/{yy}/g, ys((a % 100) + '', 2))
    .replace(/{Q}/g, s + '')
    .replace(/{MMMM}/g, _[o - 1])
    .replace(/{MMM}/g, x[o - 1])
    .replace(/{MM}/g, ys(o, 2))
    .replace(/{M}/g, o + '')
    .replace(/{dd}/g, ys(l, 2))
    .replace(/{d}/g, l + '')
    .replace(/{eeee}/g, A[u])
    .replace(/{ee}/g, S[u])
    .replace(/{e}/g, u + '')
    .replace(/{HH}/g, ys(c, 2))
    .replace(/{H}/g, c + '')
    .replace(/{hh}/g, ys(h + '', 2))
    .replace(/{h}/g, h + '')
    .replace(/{mm}/g, ys(f, 2))
    .replace(/{m}/g, f + '')
    .replace(/{ss}/g, ys(d, 2))
    .replace(/{s}/g, d + '')
    .replace(/{SSS}/g, ys(p, 3))
    .replace(/{S}/g, p + '')
}
function Knt(r, t, e, n, i) {
  var a = null
  if (bt(e)) a = e
  else if (Nt(e))
    a = e(r.value, t, {
      level: r.level,
    })
  else {
    var o = Q({}, zd)
    if (r.level > 0)
      for (var s = 0; s < T1.length; ++s)
        o[T1[s]] = '{primary|' + o[T1[s]] + '}'
    var l = e ? (e.inherit === !1 ? e : zt(e, o)) : o,
      u = ZU(r.value, i)
    if (l[u]) a = l[u]
    else if (l.inherit) {
      for (var c = qU.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          a = l[u]
          break
        }
      a = a || o.none
    }
    if (at(a)) {
      var h = r.level == null ? 0 : r.level >= 0 ? r.level : a.length + r.level
      ;(h = Math.min(h, a.length - 1)), (a = a[h])
    }
  }
  return u_(new Date(r.value), a, i, n)
}
function ZU(r, t) {
  var e = po(r),
    n = e[Nh(t)]() + 1,
    i = e[c_(t)](),
    a = e[Yp(t)](),
    o = e[h_(t)](),
    s = e[f_(t)](),
    l = e[d_(t)](),
    u = l === 0,
    c = u && s === 0,
    h = c && o === 0,
    f = h && a === 0,
    d = f && i === 1,
    p = d && n === 1
  return p
    ? 'year'
    : d
    ? 'month'
    : f
    ? 'day'
    : h
    ? 'hour'
    : c
    ? 'minute'
    : u
    ? 'second'
    : 'millisecond'
}
function YP(r, t, e) {
  var n = be(r) ? po(r) : r
  switch (((t = t || ZU(r, e)), t)) {
    case 'year':
      return n[oC(e)]()
    case 'half-year':
      return n[Nh(e)]() >= 6 ? 1 : 0
    case 'quarter':
      return Math.floor((n[Nh(e)]() + 1) / 4)
    case 'month':
      return n[Nh(e)]()
    case 'day':
      return n[c_(e)]()
    case 'half-day':
      return n[Yp(e)]() / 24
    case 'hour':
      return n[Yp(e)]()
    case 'minute':
      return n[h_(e)]()
    case 'second':
      return n[f_(e)]()
    case 'millisecond':
      return n[d_(e)]()
  }
}
function oC(r) {
  return r ? 'getUTCFullYear' : 'getFullYear'
}
function Nh(r) {
  return r ? 'getUTCMonth' : 'getMonth'
}
function c_(r) {
  return r ? 'getUTCDate' : 'getDate'
}
function Yp(r) {
  return r ? 'getUTCHours' : 'getHours'
}
function h_(r) {
  return r ? 'getUTCMinutes' : 'getMinutes'
}
function f_(r) {
  return r ? 'getUTCSeconds' : 'getSeconds'
}
function d_(r) {
  return r ? 'getUTCMilliseconds' : 'getMilliseconds'
}
function jnt(r) {
  return r ? 'setUTCFullYear' : 'setFullYear'
}
function KU(r) {
  return r ? 'setUTCMonth' : 'setMonth'
}
function jU(r) {
  return r ? 'setUTCDate' : 'setDate'
}
function JU(r) {
  return r ? 'setUTCHours' : 'setHours'
}
function QU(r) {
  return r ? 'setUTCMinutes' : 'setMinutes'
}
function t5(r) {
  return r ? 'setUTCSeconds' : 'setSeconds'
}
function e5(r) {
  return r ? 'setUTCMilliseconds' : 'setMilliseconds'
}
function n5(r) {
  if (!Fz(r)) return bt(r) ? r : '-'
  var t = (r + '').split('.')
  return (
    t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') +
    (t.length > 1 ? '.' + t[1] : '')
  )
}
function r5(r, t) {
  return (
    (r = (r || '').toLowerCase().replace(/-(.)/g, function (e, n) {
      return n.toUpperCase()
    })),
    t && r && (r = r.charAt(0).toUpperCase() + r.slice(1)),
    r
  )
}
var wf = LT
function cw(r, t, e) {
  var n = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}'
  function i(c) {
    return c && xa(c) ? c : '-'
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c))
  }
  var o = t === 'time',
    s = r instanceof Date
  if (o || s) {
    var l = o ? po(r) : r
    if (isNaN(+l)) {
      if (s) return '-'
    } else return u_(l, n, e)
  }
  if (t === 'ordinal') return Cb(r) ? i(r) : be(r) && a(r) ? r + '' : '-'
  var u = Jo(r)
  return a(u) ? n5(u) : Cb(r) ? i(r) : typeof r == 'boolean' ? r + '' : '-'
}
var $P = ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
  C1 = function (r, t) {
    return '{' + r + (t ?? '') + '}'
  }
function i5(r, t, e) {
  at(t) || (t = [t])
  var n = t.length
  if (!n) return ''
  for (var i = t[0].$vars || [], a = 0; a < i.length; a++) {
    var o = $P[a]
    r = r.replace(C1(o), C1(o, 0))
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = t[s][i[l]]
      r = r.replace(C1($P[l], s), e ? Fr(u) : u)
    }
  return r
}
function Jnt(r, t, e) {
  return (
    R(t, function (n, i) {
      r = r.replace('{' + i + '}', e ? Fr(n) : n)
    }),
    r
  )
}
function Qnt(r, t) {
  var e = bt(r)
      ? {
          color: r,
          extraCssText: t,
        }
      : r || {},
    n = e.color,
    i = e.type
  t = e.extraCssText
  var a = e.renderMode || 'html'
  if (!n) return ''
  if (a === 'html')
    return i === 'subItem'
      ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' +
          Fr(n) +
          ';' +
          (t || '') +
          '"></span>'
      : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' +
          Fr(n) +
          ';' +
          (t || '') +
          '"></span>'
  var o = e.markerId || 'markerX'
  return {
    renderMode: a,
    content: '{' + o + '|}  ',
    style:
      i === 'subItem'
        ? {
            width: 4,
            height: 4,
            borderRadius: 2,
            backgroundColor: n,
          }
        : {
            width: 10,
            height: 10,
            borderRadius: 5,
            backgroundColor: n,
          },
  }
}
function Zu(r, t) {
  return (
    (t = t || 'transparent'),
    bt(r) ? r : (Ut(r) && r.colorStops && (r.colorStops[0] || {}).color) || t
  )
}
function jy(r, t) {
  if (t === '_blank' || t === 'blank') {
    var e = window.open()
    ;(e.opener = null), (e.location.href = r)
  } else window.open(r, t)
}
var ry = R,
  a5 = ['left', 'right', 'top', 'bottom', 'width', 'height'],
  _u = [
    ['width', 'left', 'right'],
    ['height', 'top', 'bottom'],
  ]
function sC(r, t, e, n, i) {
  var a = 0,
    o = 0
  n == null && (n = 1 / 0), i == null && (i = 1 / 0)
  var s = 0
  t.eachChild(function (l, u) {
    var c = l.getBoundingRect(),
      h = t.childAt(u + 1),
      f = h && h.getBoundingRect(),
      d,
      p
    if (r === 'horizontal') {
      var g = c.width + (f ? -f.x + c.x : 0)
      ;(d = a + g),
        d > n || l.newline
          ? ((a = 0), (d = g), (o += s + e), (s = c.height))
          : (s = Math.max(s, c.height))
    } else {
      var v = c.height + (f ? -f.y + c.y : 0)
      ;(p = o + v),
        p > i || l.newline
          ? ((a += s + e), (o = 0), (p = v), (s = c.width))
          : (s = Math.max(s, c.width))
    }
    l.newline ||
      ((l.x = a),
      (l.y = o),
      l.markRedraw(),
      r === 'horizontal' ? (a = d + e) : (o = p + e))
  })
}
var ku = sC
Zt(sC, 'vertical')
Zt(sC, 'horizontal')
function trt(r, t, e) {
  var n = t.width,
    i = t.height,
    a = _t(r.left, n),
    o = _t(r.top, i),
    s = _t(r.right, n),
    l = _t(r.bottom, i)
  return (
    (isNaN(a) || isNaN(parseFloat(r.left))) && (a = 0),
    (isNaN(s) || isNaN(parseFloat(r.right))) && (s = n),
    (isNaN(o) || isNaN(parseFloat(r.top))) && (o = 0),
    (isNaN(l) || isNaN(parseFloat(r.bottom))) && (l = i),
    (e = wf(e || 0)),
    {
      width: Math.max(s - a - e[1] - e[3], 0),
      height: Math.max(l - o - e[0] - e[2], 0),
    }
  )
}
function Vn(r, t, e) {
  e = wf(e || 0)
  var n = t.width,
    i = t.height,
    a = _t(r.left, n),
    o = _t(r.top, i),
    s = _t(r.right, n),
    l = _t(r.bottom, i),
    u = _t(r.width, n),
    c = _t(r.height, i),
    h = e[2] + e[0],
    f = e[1] + e[3],
    d = r.aspect
  switch (
    (isNaN(u) && (u = n - s - f - a),
    isNaN(c) && (c = i - l - h - o),
    d != null &&
      (isNaN(u) && isNaN(c) && (d > n / i ? (u = n * 0.8) : (c = i * 0.8)),
      isNaN(u) && (u = d * c),
      isNaN(c) && (c = u / d)),
    isNaN(a) && (a = n - s - u - f),
    isNaN(o) && (o = i - l - c - h),
    r.left || r.right)
  ) {
    case 'center':
      a = n / 2 - u / 2 - e[3]
      break
    case 'right':
      a = n - u - f
      break
  }
  switch (r.top || r.bottom) {
    case 'middle':
    case 'center':
      o = i / 2 - c / 2 - e[0]
      break
    case 'bottom':
      o = i - c - h
      break
  }
  ;(a = a || 0),
    (o = o || 0),
    isNaN(u) && (u = n - f - a - (s || 0)),
    isNaN(c) && (c = i - h - o - (l || 0))
  var p = new ee(a + e[3], o + e[0], u, c)
  return (p.margin = e), p
}
function p_(r, t, e, n, i, a) {
  var o = !i || !i.hv || i.hv[0],
    s = !i || !i.hv || i.hv[1],
    l = (i && i.boundingMode) || 'all'
  if (((a = a || r), (a.x = r.x), (a.y = r.y), !o && !s)) return !1
  var u
  if (l === 'raw')
    u =
      r.type === 'group'
        ? new ee(0, 0, +t.width || 0, +t.height || 0)
        : r.getBoundingRect()
  else if (((u = r.getBoundingRect()), r.needLocalTransform())) {
    var c = r.getLocalTransform()
    ;(u = u.clone()), u.applyTransform(c)
  }
  var h = Vn(
      zt(
        {
          width: u.width,
          height: u.height,
        },
        t,
      ),
      e,
      n,
    ),
    f = o ? h.x - u.x : 0,
    d = s ? h.y - u.y : 0
  return (
    l === 'raw' ? ((a.x = f), (a.y = d)) : ((a.x += f), (a.y += d)),
    a === r && r.markRedraw(),
    !0
  )
}
function ert(r, t) {
  return r[_u[t][0]] != null || (r[_u[t][1]] != null && r[_u[t][2]] != null)
}
function $p(r) {
  var t = r.layoutMode || r.constructor.layoutMode
  return Ut(t)
    ? t
    : t
    ? {
        type: t,
      }
    : null
}
function ol(r, t, e) {
  var n = e && e.ignoreSize
  !at(n) && (n = [n, n])
  var i = o(_u[0], 0),
    a = o(_u[1], 1)
  u(_u[0], r, i), u(_u[1], r, a)
  function o(c, h) {
    var f = {},
      d = 0,
      p = {},
      g = 0,
      v = 2
    if (
      (ry(c, function (_) {
        p[_] = r[_]
      }),
      ry(c, function (_) {
        s(t, _) && (f[_] = p[_] = t[_]), l(f, _) && d++, l(p, _) && g++
      }),
      n[h])
    )
      return l(t, c[1]) ? (p[c[2]] = null) : l(t, c[2]) && (p[c[1]] = null), p
    if (g === v || !d) return p
    if (d >= v) return f
    for (var m = 0; m < c.length; m++) {
      var y = c[m]
      if (!s(f, y) && s(r, y)) {
        f[y] = r[y]
        break
      }
    }
    return f
  }
  function s(c, h) {
    return c.hasOwnProperty(h)
  }
  function l(c, h) {
    return c[h] != null && c[h] !== 'auto'
  }
  function u(c, h, f) {
    ry(c, function (d) {
      h[d] = f[d]
    })
  }
}
function Mf(r) {
  return o5({}, r)
}
function o5(r, t) {
  return (
    t &&
      r &&
      ry(a5, function (e) {
        t.hasOwnProperty(e) && (r[e] = t[e])
      }),
    r
  )
}
var nrt = ve(),
  Tf = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this, e, n, i) || this
      return (a.uid = bf('ec_cpt_model')), a
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i)
      }),
      (t.prototype.mergeDefaultAndTheme = function (e, n) {
        var i = $p(this),
          a = i ? Mf(e) : {},
          o = n.getTheme()
        te(e, o.get(this.mainType)),
          te(e, this.getDefaultOption()),
          i && ol(e, a, i)
      }),
      (t.prototype.mergeOption = function (e, n) {
        te(this.option, e, !0)
        var i = $p(this)
        i && ol(this.option, e, i)
      }),
      (t.prototype.optionUpdated = function (e, n) {}),
      (t.prototype.getDefaultOption = function () {
        var e = this.constructor
        if (!Ntt(e)) return e.defaultOption
        var n = nrt(this)
        if (!n.defaultOption) {
          for (var i = [], a = e; a; ) {
            var o = a.prototype.defaultOption
            o && i.push(o), (a = a.superClass)
          }
          for (var s = {}, l = i.length - 1; l >= 0; l--) s = te(s, i[l], !0)
          n.defaultOption = s
        }
        return n.defaultOption
      }),
      (t.prototype.getReferringComponents = function (e, n) {
        var i = e + 'Index',
          a = e + 'Id'
        return yv(
          this.ecModel,
          e,
          {
            index: this.get(i, !0),
            id: this.get(a, !0),
          },
          n,
        )
      }),
      (t.prototype.getBoxLayoutParams = function () {
        var e = this
        return {
          left: e.get('left'),
          top: e.get('top'),
          right: e.get('right'),
          bottom: e.get('bottom'),
          width: e.get('width'),
          height: e.get('height'),
        }
      }),
      (t.prototype.getZLevelKey = function () {
        return ''
      }),
      (t.prototype.setZLevel = function (e) {
        this.option.zlevel = e
      }),
      (t.protoInitialize = (function () {
        var e = t.prototype
        ;(e.type = 'component'),
          (e.id = ''),
          (e.name = ''),
          (e.mainType = ''),
          (e.subType = ''),
          (e.componentIndex = 0)
      })()),
      t
    )
  })(qe)
qz(Tf, qe)
J0(Tf)
Gnt(Tf)
Hnt(Tf, rrt)
function rrt(r) {
  var t = []
  return (
    R(Tf.getClassesByMainType(r), function (e) {
      t = t.concat(e.dependencies || e.prototype.dependencies || [])
    }),
    (t = st(t, function (e) {
      return to(e).main
    })),
    r !== 'dataset' && re(t, 'dataset') <= 0 && t.unshift('dataset'),
    t
  )
}
const xe = Tf
var s5 = ''
typeof navigator < 'u' && (s5 = navigator.platform || '')
var Xc = 'rgba(0, 0, 0, 0.2)'
const irt = {
  darkMode: 'auto',
  colorBy: 'series',
  color: [
    '#5470c6',
    '#91cc75',
    '#fac858',
    '#ee6666',
    '#73c0de',
    '#3ba272',
    '#fc8452',
    '#9a60b4',
    '#ea7ccc',
  ],
  gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
  aria: {
    decal: {
      decals: [
        {
          color: Xc,
          dashArrayX: [1, 0],
          dashArrayY: [2, 5],
          symbolSize: 1,
          rotation: Math.PI / 6,
        },
        {
          color: Xc,
          symbol: 'circle',
          dashArrayX: [
            [8, 8],
            [0, 8, 8, 0],
          ],
          dashArrayY: [6, 0],
          symbolSize: 0.8,
        },
        {
          color: Xc,
          dashArrayX: [1, 0],
          dashArrayY: [4, 3],
          rotation: -Math.PI / 4,
        },
        {
          color: Xc,
          dashArrayX: [
            [6, 6],
            [0, 6, 6, 0],
          ],
          dashArrayY: [6, 0],
        },
        {
          color: Xc,
          dashArrayX: [
            [1, 0],
            [1, 6],
          ],
          dashArrayY: [1, 0, 6, 0],
          rotation: Math.PI / 4,
        },
        {
          color: Xc,
          symbol: 'triangle',
          dashArrayX: [
            [9, 9],
            [0, 9, 9, 0],
          ],
          dashArrayY: [7, 2],
          symbolSize: 0.75,
        },
      ],
    },
  },
  textStyle: {
    fontFamily: s5.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
    fontSize: 12,
    fontStyle: 'normal',
    fontWeight: 'normal',
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: 'cubicOut',
  },
  animation: 'auto',
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: 'cubicInOut',
  animationEasingUpdate: 'cubicInOut',
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: !1,
}
var l5 = Pt([
    'tooltip',
    'label',
    'itemName',
    'itemId',
    'itemGroupId',
    'itemChildGroupId',
    'seriesName',
  ]),
  ia = 'original',
  Dr = 'arrayRows',
  aa = 'objectRows',
  _o = 'keyedColumns',
  js = 'typedArray',
  u5 = 'unknown',
  oo = 'column',
  Cf = 'row',
  fr = {
    Must: 1,
    Might: 2,
    Not: 3,
  },
  c5 = ve()
function art(r) {
  c5(r).datasetMap = Pt()
}
function h5(r, t, e) {
  var n = {},
    i = uC(t)
  if (!i || !r) return n
  var a = [],
    o = [],
    s = t.ecModel,
    l = c5(s).datasetMap,
    u = i.uid + '_' + e.seriesLayoutBy,
    c,
    h
  ;(r = r.slice()),
    R(r, function (g, v) {
      var m = Ut(g)
        ? g
        : (r[v] = {
            name: g,
          })
      m.type === 'ordinal' && c == null && ((c = v), (h = p(m))),
        (n[m.name] = [])
    })
  var f =
    l.get(u) ||
    l.set(u, {
      categoryWayDim: h,
      valueWayDim: 0,
    })
  R(r, function (g, v) {
    var m = g.name,
      y = p(g)
    if (c == null) {
      var _ = f.valueWayDim
      d(n[m], _, y), d(o, _, y), (f.valueWayDim += y)
    } else if (c === v) d(n[m], 0, y), d(a, 0, y)
    else {
      var _ = f.categoryWayDim
      d(n[m], _, y), d(o, _, y), (f.categoryWayDim += y)
    }
  })
  function d(g, v, m) {
    for (var y = 0; y < m; y++) g.push(v + y)
  }
  function p(g) {
    var v = g.dimsDef
    return v ? v.length : 1
  }
  return a.length && (n.itemName = a), o.length && (n.seriesName = o), n
}
function lC(r, t, e) {
  var n = {},
    i = uC(r)
  if (!i) return n
  var a = t.sourceFormat,
    o = t.dimensionsDefine,
    s
  ;(a === aa || a === _o) &&
    R(o, function (c, h) {
      ;(Ut(c) ? c.name : c) === 'name' && (s = h)
    })
  var l = (function () {
    for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, e); d < p; d++) {
      var g = d5(t.data, a, t.seriesLayoutBy, o, t.startIndex, d)
      f.push(g)
      var v = g === fr.Not
      if (
        (v && c.v == null && d !== s && (c.v = d),
        (c.n == null || c.n === c.v || (!v && f[c.n] === fr.Not)) && (c.n = d),
        m(c) && f[c.n] !== fr.Not)
      )
        return c
      v ||
        (g === fr.Might && h.v == null && d !== s && (h.v = d),
        (h.n == null || h.n === h.v) && (h.n = d))
    }
    function m(y) {
      return y.v != null && y.n != null
    }
    return m(c) ? c : m(h) ? h : null
  })()
  if (l) {
    n.value = [l.v]
    var u = s ?? l.n
    ;(n.itemName = [u]), (n.seriesName = [u])
  }
  return n
}
function uC(r) {
  var t = r.get('data', !0)
  if (!t)
    return yv(
      r.ecModel,
      'dataset',
      {
        index: r.get('datasetIndex', !0),
        id: r.get('datasetId', !0),
      },
      Pn,
    ).models[0]
}
function ort(r) {
  return !r.get('transform', !0) && !r.get('fromTransformResult', !0)
    ? []
    : yv(
        r.ecModel,
        'dataset',
        {
          index: r.get('fromDatasetIndex', !0),
          id: r.get('fromDatasetId', !0),
        },
        Pn,
      ).models
}
function f5(r, t) {
  return d5(
    r.data,
    r.sourceFormat,
    r.seriesLayoutBy,
    r.dimensionsDefine,
    r.startIndex,
    t,
  )
}
function d5(r, t, e, n, i, a) {
  var o,
    s = 5
  if (ai(r)) return fr.Not
  var l, u
  if (n) {
    var c = n[a]
    Ut(c) ? ((l = c.name), (u = c.type)) : bt(c) && (l = c)
  }
  if (u != null) return u === 'ordinal' ? fr.Must : fr.Not
  if (t === Dr) {
    var h = r
    if (e === Cf) {
      for (var f = h[a], d = 0; d < (f || []).length && d < s; d++)
        if ((o = x(f[i + d])) != null) return o
    } else
      for (var d = 0; d < h.length && d < s; d++) {
        var p = h[i + d]
        if (p && (o = x(p[a])) != null) return o
      }
  } else if (t === aa) {
    var g = r
    if (!l) return fr.Not
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d]
      if (v && (o = x(v[l])) != null) return o
    }
  } else if (t === _o) {
    var m = r
    if (!l) return fr.Not
    var f = m[l]
    if (!f || ai(f)) return fr.Not
    for (var d = 0; d < f.length && d < s; d++)
      if ((o = x(f[d])) != null) return o
  } else if (t === ia)
    for (var y = r, d = 0; d < y.length && d < s; d++) {
      var v = y[d],
        _ = yf(v)
      if (!at(_)) return fr.Not
      if ((o = x(_[a])) != null) return o
    }
  function x(A) {
    var S = bt(A)
    if (A != null && Number.isFinite(Number(A)) && A !== '')
      return S ? fr.Might : fr.Not
    if (S && A !== '-') return fr.Must
  }
  return fr.Not
}
var hw = Pt()
function srt(r, t) {
  Gr(hw.get(r) == null && t), hw.set(r, t)
}
function lrt(r, t, e) {
  var n = hw.get(t)
  if (!n) return e
  var i = n(r)
  return i ? e.concat(i) : e
}
var qP = ve(),
  urt = ve(),
  cC = (function () {
    function r() {}
    return (
      (r.prototype.getColorFromPalette = function (t, e, n) {
        var i = ke(this.get('color', !0)),
          a = this.get('colorLayer', !0)
        return p5(this, qP, i, a, t, e, n)
      }),
      (r.prototype.clearColorPalette = function () {
        hrt(this, qP)
      }),
      r
    )
  })()
function fw(r, t, e, n) {
  var i = ke(r.get(['aria', 'decal', 'decals']))
  return p5(r, urt, i, null, t, e, n)
}
function crt(r, t) {
  for (var e = r.length, n = 0; n < e; n++) if (r[n].length > t) return r[n]
  return r[e - 1]
}
function p5(r, t, e, n, i, a, o) {
  a = a || r
  var s = t(a),
    l = s.paletteIdx || 0,
    u = (s.paletteNameMap = s.paletteNameMap || {})
  if (u.hasOwnProperty(i)) return u[i]
  var c = o == null || !n ? e : crt(n, o)
  if (((c = c || e), !(!c || !c.length))) {
    var h = c[l]
    return i && (u[i] = h), (s.paletteIdx = (l + 1) % c.length), h
  }
}
function hrt(r, t) {
  ;(t(r).paletteIdx = 0), (t(r).paletteNameMap = {})
}
var $g,
  rd,
  ZP,
  KP = '\0_ec_inner',
  frt = 1,
  v5 = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.init = function (e, n, i, a, o, s) {
        ;(a = a || {}),
          (this.option = null),
          (this._theme = new qe(a)),
          (this._locale = new qe(o)),
          (this._optionManager = s)
      }),
      (t.prototype.setOption = function (e, n, i) {
        var a = QP(n)
        this._optionManager.setOption(e, i, a), this._resetOption(null, a)
      }),
      (t.prototype.resetOption = function (e, n) {
        return this._resetOption(e, QP(n))
      }),
      (t.prototype._resetOption = function (e, n) {
        var i = !1,
          a = this._optionManager
        if (!e || e === 'recreate') {
          var o = a.mountOption(e === 'recreate')
          !this.option || e === 'recreate'
            ? ZP(this, o)
            : (this.restoreData(), this._mergeOption(o, n)),
            (i = !0)
        }
        if (
          ((e === 'timeline' || e === 'media') && this.restoreData(),
          !e || e === 'recreate' || e === 'timeline')
        ) {
          var s = a.getTimelineOption(this)
          s && ((i = !0), this._mergeOption(s, n))
        }
        if (!e || e === 'recreate' || e === 'media') {
          var l = a.getMediaOption(this)
          l.length &&
            R(
              l,
              function (u) {
                ;(i = !0), this._mergeOption(u, n)
              },
              this,
            )
        }
        return i
      }),
      (t.prototype.mergeOption = function (e) {
        this._mergeOption(e, null)
      }),
      (t.prototype._mergeOption = function (e, n) {
        var i = this.option,
          a = this._componentsMap,
          o = this._componentsCount,
          s = [],
          l = Pt(),
          u = n && n.replaceMergeMainTypeMap
        art(this),
          R(e, function (h, f) {
            h != null &&
              (xe.hasClass(f)
                ? f && (s.push(f), l.set(f, !0))
                : (i[f] = i[f] == null ? Vt(h) : te(i[f], h, !0)))
          }),
          u &&
            u.each(function (h, f) {
              xe.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0))
            }),
          xe.topologicalTravel(s, xe.getAllClassMainTypes(), c, this)
        function c(h) {
          var f = lrt(this, h, ke(e[h])),
            d = a.get(h),
            p = d
              ? u && u.get(h)
                ? 'replaceMerge'
                : 'normalMerge'
              : 'replaceAll',
            g = Hz(d, f, p)
          Ttt(g, h, xe), (i[h] = null), a.set(h, null), o.set(h, 0)
          var v = [],
            m = [],
            y = 0,
            _
          R(
            g,
            function (x, A) {
              var S = x.existing,
                b = x.newOption
              if (!b) S && (S.mergeOption({}, this), S.optionUpdated({}, !1))
              else {
                var T = h === 'series',
                  w = xe.getClass(h, x.keyInfo.subType, !T)
                if (!w) return
                if (h === 'tooltip') {
                  if (_) return
                  _ = !0
                }
                if (S && S.constructor === w)
                  (S.name = x.keyInfo.name),
                    S.mergeOption(b, this),
                    S.optionUpdated(b, !1)
                else {
                  var M = Q(
                    {
                      componentIndex: A,
                    },
                    x.keyInfo,
                  )
                  ;(S = new w(b, this, this, M)),
                    Q(S, M),
                    x.brandNew && (S.__requireNewView = !0),
                    S.init(b, this, this),
                    S.optionUpdated(null, !0)
                }
              }
              S
                ? (v.push(S.option), m.push(S), y++)
                : (v.push(void 0), m.push(void 0))
            },
            this,
          ),
            (i[h] = v),
            a.set(h, m),
            o.set(h, y),
            h === 'series' && $g(this)
        }
        this._seriesIndices || $g(this)
      }),
      (t.prototype.getOption = function () {
        var e = Vt(this.option)
        return (
          R(e, function (n, i) {
            if (xe.hasClass(i)) {
              for (var a = ke(n), o = a.length, s = !1, l = o - 1; l >= 0; l--)
                a[l] && !Vp(a[l]) ? (s = !0) : ((a[l] = null), !s && o--)
              ;(a.length = o), (e[i] = a)
            }
          }),
          delete e[KP],
          e
        )
      }),
      (t.prototype.getTheme = function () {
        return this._theme
      }),
      (t.prototype.getLocaleModel = function () {
        return this._locale
      }),
      (t.prototype.setUpdatePayload = function (e) {
        this._payload = e
      }),
      (t.prototype.getUpdatePayload = function () {
        return this._payload
      }),
      (t.prototype.getComponent = function (e, n) {
        var i = this._componentsMap.get(e)
        if (i) {
          var a = i[n || 0]
          if (a) return a
          if (n == null) {
            for (var o = 0; o < i.length; o++) if (i[o]) return i[o]
          }
        }
      }),
      (t.prototype.queryComponents = function (e) {
        var n = e.mainType
        if (!n) return []
        var i = e.index,
          a = e.id,
          o = e.name,
          s = this._componentsMap.get(n)
        if (!s || !s.length) return []
        var l
        return (
          i != null
            ? ((l = []),
              R(ke(i), function (u) {
                s[u] && l.push(s[u])
              }))
            : a != null
            ? (l = jP('id', a, s))
            : o != null
            ? (l = jP('name', o, s))
            : (l = Ne(s, function (u) {
                return !!u
              })),
          JP(l, e)
        )
      }),
      (t.prototype.findComponents = function (e) {
        var n = e.query,
          i = e.mainType,
          a = s(n),
          o = a
            ? this.queryComponents(a)
            : Ne(this._componentsMap.get(i), function (u) {
                return !!u
              })
        return l(JP(o, e))
        function s(u) {
          var c = i + 'Index',
            h = i + 'Id',
            f = i + 'Name'
          return u && (u[c] != null || u[h] != null || u[f] != null)
            ? {
                mainType: i,
                index: u[c],
                id: u[h],
                name: u[f],
              }
            : null
        }
        function l(u) {
          return e.filter ? Ne(u, e.filter) : u
        }
      }),
      (t.prototype.eachComponent = function (e, n, i) {
        var a = this._componentsMap
        if (Nt(e)) {
          var o = n,
            s = e
          a.each(function (h, f) {
            for (var d = 0; h && d < h.length; d++) {
              var p = h[d]
              p && s.call(o, f, p, p.componentIndex)
            }
          })
        } else
          for (
            var l = bt(e) ? a.get(e) : Ut(e) ? this.findComponents(e) : null,
              u = 0;
            l && u < l.length;
            u++
          ) {
            var c = l[u]
            c && n.call(i, c, c.componentIndex)
          }
      }),
      (t.prototype.getSeriesByName = function (e) {
        var n = Un(e, null)
        return Ne(this._componentsMap.get('series'), function (i) {
          return !!i && n != null && i.name === n
        })
      }),
      (t.prototype.getSeriesByIndex = function (e) {
        return this._componentsMap.get('series')[e]
      }),
      (t.prototype.getSeriesByType = function (e) {
        return Ne(this._componentsMap.get('series'), function (n) {
          return !!n && n.subType === e
        })
      }),
      (t.prototype.getSeries = function () {
        return Ne(this._componentsMap.get('series'), function (e) {
          return !!e
        })
      }),
      (t.prototype.getSeriesCount = function () {
        return this._componentsCount.get('series')
      }),
      (t.prototype.eachSeries = function (e, n) {
        rd(this),
          R(
            this._seriesIndices,
            function (i) {
              var a = this._componentsMap.get('series')[i]
              e.call(n, a, i)
            },
            this,
          )
      }),
      (t.prototype.eachRawSeries = function (e, n) {
        R(this._componentsMap.get('series'), function (i) {
          i && e.call(n, i, i.componentIndex)
        })
      }),
      (t.prototype.eachSeriesByType = function (e, n, i) {
        rd(this),
          R(
            this._seriesIndices,
            function (a) {
              var o = this._componentsMap.get('series')[a]
              o.subType === e && n.call(i, o, a)
            },
            this,
          )
      }),
      (t.prototype.eachRawSeriesByType = function (e, n, i) {
        return R(this.getSeriesByType(e), n, i)
      }),
      (t.prototype.isSeriesFiltered = function (e) {
        return rd(this), this._seriesIndicesMap.get(e.componentIndex) == null
      }),
      (t.prototype.getCurrentSeriesIndices = function () {
        return (this._seriesIndices || []).slice()
      }),
      (t.prototype.filterSeries = function (e, n) {
        rd(this)
        var i = []
        R(
          this._seriesIndices,
          function (a) {
            var o = this._componentsMap.get('series')[a]
            e.call(n, o, a) && i.push(a)
          },
          this,
        ),
          (this._seriesIndices = i),
          (this._seriesIndicesMap = Pt(i))
      }),
      (t.prototype.restoreData = function (e) {
        $g(this)
        var n = this._componentsMap,
          i = []
        n.each(function (a, o) {
          xe.hasClass(o) && i.push(o)
        }),
          xe.topologicalTravel(i, xe.getAllClassMainTypes(), function (a) {
            R(n.get(a), function (o) {
              o && (a !== 'series' || !drt(o, e)) && o.restoreData()
            })
          })
      }),
      (t.internalField = (function () {
        ;($g = function (e) {
          var n = (e._seriesIndices = [])
          R(e._componentsMap.get('series'), function (i) {
            i && n.push(i.componentIndex)
          }),
            (e._seriesIndicesMap = Pt(n))
        }),
          (rd = function (e) {}),
          (ZP = function (e, n) {
            ;(e.option = {}),
              (e.option[KP] = frt),
              (e._componentsMap = Pt({
                series: [],
              })),
              (e._componentsCount = Pt())
            var i = n.aria
            Ut(i) && i.enabled == null && (i.enabled = !0),
              prt(n, e._theme.option),
              te(n, irt, !1),
              e._mergeOption(n, null)
          })
      })()),
      t
    )
  })(qe)
function drt(r, t) {
  if (t) {
    var e = t.seriesIndex,
      n = t.seriesId,
      i = t.seriesName
    return (
      (e != null && r.componentIndex !== e) ||
      (n != null && r.id !== n) ||
      (i != null && r.name !== i)
    )
  }
}
function prt(r, t) {
  var e = r.color && !r.colorLayer
  R(t, function (n, i) {
    ;(i === 'colorLayer' && e) ||
      xe.hasClass(i) ||
      (typeof n == 'object'
        ? (r[i] = r[i] ? te(r[i], n, !1) : Vt(n))
        : r[i] == null && (r[i] = n))
  })
}
function jP(r, t, e) {
  if (at(t)) {
    var n = Pt()
    return (
      R(t, function (a) {
        if (a != null) {
          var o = Un(a, null)
          o != null && n.set(a, !0)
        }
      }),
      Ne(e, function (a) {
        return a && n.get(a[r])
      })
    )
  } else {
    var i = Un(t, null)
    return Ne(e, function (a) {
      return a && i != null && a[r] === i
    })
  }
}
function JP(r, t) {
  return t.hasOwnProperty('subType')
    ? Ne(r, function (e) {
        return e && e.subType === t.subType
      })
    : r
}
function QP(r) {
  var t = Pt()
  return (
    r &&
      R(ke(r.replaceMerge), function (e) {
        t.set(e, !0)
      }),
    {
      replaceMergeMainTypeMap: t,
    }
  )
}
In(v5, cC)
const g5 = v5
var vrt = [
    'getDom',
    'getZr',
    'getWidth',
    'getHeight',
    'getDevicePixelRatio',
    'dispatchAction',
    'isSSR',
    'isDisposed',
    'on',
    'off',
    'getDataURL',
    'getConnectedDataURL',
    'getOption',
    'getId',
    'updateLabelLayout',
  ],
  grt = (function () {
    function r(t) {
      R(
        vrt,
        function (e) {
          this[e] = Tt(t[e], t)
        },
        this,
      )
    }
    return r
  })()
const m5 = grt
var E1 = {},
  mrt = (function () {
    function r() {
      this._coordinateSystems = []
    }
    return (
      (r.prototype.create = function (t, e) {
        var n = []
        R(E1, function (i, a) {
          var o = i.create(t, e)
          n = n.concat(o || [])
        }),
          (this._coordinateSystems = n)
      }),
      (r.prototype.update = function (t, e) {
        R(this._coordinateSystems, function (n) {
          n.update && n.update(t, e)
        })
      }),
      (r.prototype.getCoordinateSystems = function () {
        return this._coordinateSystems.slice()
      }),
      (r.register = function (t, e) {
        E1[t] = e
      }),
      (r.get = function (t) {
        return E1[t]
      }),
      r
    )
  })()
const Av = mrt
var yrt = /^(min|max)?(.+)$/,
  _rt = (function () {
    function r(t) {
      ;(this._timelineOptions = []),
        (this._mediaList = []),
        (this._currentMediaIndices = []),
        (this._api = t)
    }
    return (
      (r.prototype.setOption = function (t, e, n) {
        t &&
          (R(ke(t.series), function (o) {
            o && o.data && ai(o.data) && Ny(o.data)
          }),
          R(ke(t.dataset), function (o) {
            o && o.source && ai(o.source) && Ny(o.source)
          })),
          (t = Vt(t))
        var i = this._optionBackup,
          a = xrt(t, e, !i)
        ;(this._newBaseOption = a.baseOption),
          i
            ? (a.timelineOptions.length &&
                (i.timelineOptions = a.timelineOptions),
              a.mediaList.length && (i.mediaList = a.mediaList),
              a.mediaDefault && (i.mediaDefault = a.mediaDefault))
            : (this._optionBackup = a)
      }),
      (r.prototype.mountOption = function (t) {
        var e = this._optionBackup
        return (
          (this._timelineOptions = e.timelineOptions),
          (this._mediaList = e.mediaList),
          (this._mediaDefault = e.mediaDefault),
          (this._currentMediaIndices = []),
          Vt(t ? e.baseOption : this._newBaseOption)
        )
      }),
      (r.prototype.getTimelineOption = function (t) {
        var e,
          n = this._timelineOptions
        if (n.length) {
          var i = t.getComponent('timeline')
          i && (e = Vt(n[i.getCurrentIndex()]))
        }
        return e
      }),
      (r.prototype.getMediaOption = function (t) {
        var e = this._api.getWidth(),
          n = this._api.getHeight(),
          i = this._mediaList,
          a = this._mediaDefault,
          o = [],
          s = []
        if (!i.length && !a) return s
        for (var l = 0, u = i.length; l < u; l++)
          Srt(i[l].query, e, n) && o.push(l)
        return (
          !o.length && a && (o = [-1]),
          o.length &&
            !brt(o, this._currentMediaIndices) &&
            (s = st(o, function (c) {
              return Vt(c === -1 ? a.option : i[c].option)
            })),
          (this._currentMediaIndices = o),
          s
        )
      }),
      r
    )
  })()
function xrt(r, t, e) {
  var n = [],
    i,
    a,
    o = r.baseOption,
    s = r.timeline,
    l = r.options,
    u = r.media,
    c = !!r.media,
    h = !!(l || s || (o && o.timeline))
  o
    ? ((a = o), a.timeline || (a.timeline = s))
    : ((h || c) && (r.options = r.media = null), (a = r)),
    c &&
      at(u) &&
      R(u, function (d) {
        d && d.option && (d.query ? n.push(d) : i || (i = d))
      }),
    f(a),
    R(l, function (d) {
      return f(d)
    }),
    R(n, function (d) {
      return f(d.option)
    })
  function f(d) {
    R(t, function (p) {
      p(d, e)
    })
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n,
  }
}
function Srt(r, t, e) {
  var n = {
      width: t,
      height: e,
      aspectratio: t / e,
    },
    i = !0
  return (
    R(r, function (a, o) {
      var s = o.match(yrt)
      if (!(!s || !s[1] || !s[2])) {
        var l = s[1],
          u = s[2].toLowerCase()
        Art(n[u], a, l) || (i = !1)
      }
    }),
    i
  )
}
function Art(r, t, e) {
  return e === 'min' ? r >= t : e === 'max' ? r <= t : r === t
}
function brt(r, t) {
  return r.join(',') === t.join(',')
}
const wrt = _rt
var ca = R,
  qp = Ut,
  tR = [
    'areaStyle',
    'lineStyle',
    'nodeStyle',
    'linkStyle',
    'chordStyle',
    'label',
    'labelLine',
  ]
function D1(r) {
  var t = r && r.itemStyle
  if (t)
    for (var e = 0, n = tR.length; e < n; e++) {
      var i = tR[e],
        a = t.normal,
        o = t.emphasis
      a &&
        a[i] &&
        ((r[i] = r[i] || {}),
        r[i].normal ? te(r[i].normal, a[i]) : (r[i].normal = a[i]),
        (a[i] = null)),
        o &&
          o[i] &&
          ((r[i] = r[i] || {}),
          r[i].emphasis ? te(r[i].emphasis, o[i]) : (r[i].emphasis = o[i]),
          (o[i] = null))
    }
}
function br(r, t, e) {
  if (r && r[t] && (r[t].normal || r[t].emphasis)) {
    var n = r[t].normal,
      i = r[t].emphasis
    n && (e ? ((r[t].normal = r[t].emphasis = null), zt(r[t], n)) : (r[t] = n)),
      i &&
        ((r.emphasis = r.emphasis || {}),
        (r.emphasis[t] = i),
        i.focus && (r.emphasis.focus = i.focus),
        i.blurScope && (r.emphasis.blurScope = i.blurScope))
  }
}
function Ud(r) {
  br(r, 'itemStyle'),
    br(r, 'lineStyle'),
    br(r, 'areaStyle'),
    br(r, 'label'),
    br(r, 'labelLine'),
    br(r, 'upperLabel'),
    br(r, 'edgeLabel')
}
function Cn(r, t) {
  var e = qp(r) && r[t],
    n = qp(e) && e.textStyle
  if (n)
    for (var i = 0, a = oP.length; i < a; i++) {
      var o = oP[i]
      n.hasOwnProperty(o) && (e[o] = n[o])
    }
}
function zi(r) {
  r && (Ud(r), Cn(r, 'label'), r.emphasis && Cn(r.emphasis, 'label'))
}
function Mrt(r) {
  if (qp(r)) {
    D1(r),
      Ud(r),
      Cn(r, 'label'),
      Cn(r, 'upperLabel'),
      Cn(r, 'edgeLabel'),
      r.emphasis &&
        (Cn(r.emphasis, 'label'),
        Cn(r.emphasis, 'upperLabel'),
        Cn(r.emphasis, 'edgeLabel'))
    var t = r.markPoint
    t && (D1(t), zi(t))
    var e = r.markLine
    e && (D1(e), zi(e))
    var n = r.markArea
    n && zi(n)
    var i = r.data
    if (r.type === 'graph') {
      i = i || r.nodes
      var a = r.links || r.edges
      if (a && !ai(a)) for (var o = 0; o < a.length; o++) zi(a[o])
      R(r.categories, function (u) {
        Ud(u)
      })
    }
    if (i && !ai(i)) for (var o = 0; o < i.length; o++) zi(i[o])
    if (((t = r.markPoint), t && t.data))
      for (var s = t.data, o = 0; o < s.length; o++) zi(s[o])
    if (((e = r.markLine), e && e.data))
      for (var l = e.data, o = 0; o < l.length; o++)
        at(l[o]) ? (zi(l[o][0]), zi(l[o][1])) : zi(l[o])
    r.type === 'gauge'
      ? (Cn(r, 'axisLabel'), Cn(r, 'title'), Cn(r, 'detail'))
      : r.type === 'treemap'
      ? (br(r.breadcrumb, 'itemStyle'),
        R(r.levels, function (u) {
          Ud(u)
        }))
      : r.type === 'tree' && Ud(r.leaves)
  }
}
function Do(r) {
  return at(r) ? r : r ? [r] : []
}
function eR(r) {
  return (at(r) ? r[0] : r) || {}
}
function Trt(r, t) {
  ca(Do(r.series), function (n) {
    qp(n) && Mrt(n)
  })
  var e = [
    'xAxis',
    'yAxis',
    'radiusAxis',
    'angleAxis',
    'singleAxis',
    'parallelAxis',
    'radar',
  ]
  t && e.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis'),
    ca(e, function (n) {
      ca(Do(r[n]), function (i) {
        i && (Cn(i, 'axisLabel'), Cn(i.axisPointer, 'label'))
      })
    }),
    ca(Do(r.parallel), function (n) {
      var i = n && n.parallelAxisDefault
      Cn(i, 'axisLabel'), Cn(i && i.axisPointer, 'label')
    }),
    ca(Do(r.calendar), function (n) {
      br(n, 'itemStyle'),
        Cn(n, 'dayLabel'),
        Cn(n, 'monthLabel'),
        Cn(n, 'yearLabel')
    }),
    ca(Do(r.radar), function (n) {
      Cn(n, 'name'),
        n.name && n.axisName == null && ((n.axisName = n.name), delete n.name),
        n.nameGap != null &&
          n.axisNameGap == null &&
          ((n.axisNameGap = n.nameGap), delete n.nameGap)
    }),
    ca(Do(r.geo), function (n) {
      qp(n) &&
        (zi(n),
        ca(Do(n.regions), function (i) {
          zi(i)
        }))
    }),
    ca(Do(r.timeline), function (n) {
      zi(n), br(n, 'label'), br(n, 'itemStyle'), br(n, 'controlStyle', !0)
      var i = n.data
      at(i) &&
        R(i, function (a) {
          Ut(a) && (br(a, 'label'), br(a, 'itemStyle'))
        })
    }),
    ca(Do(r.toolbox), function (n) {
      br(n, 'iconStyle'),
        ca(n.feature, function (i) {
          br(i, 'iconStyle')
        })
    }),
    Cn(eR(r.axisPointer), 'label'),
    Cn(eR(r.tooltip).axisPointer, 'label')
}
function Crt(r, t) {
  for (
    var e = t.split(','), n = r, i = 0;
    i < e.length && ((n = n && n[e[i]]), n != null);
    i++
  );
  return n
}
function Ert(r, t, e, n) {
  for (var i = t.split(','), a = r, o, s = 0; s < i.length - 1; s++)
    (o = i[s]), a[o] == null && (a[o] = {}), (a = a[o])
  ;(n || a[i[s]] == null) && (a[i[s]] = e)
}
function nR(r) {
  r &&
    R(Drt, function (t) {
      t[0] in r && !(t[1] in r) && (r[t[1]] = r[t[0]])
    })
}
var Drt = [
    ['x', 'left'],
    ['y', 'top'],
    ['x2', 'right'],
    ['y2', 'bottom'],
  ],
  Lrt = [
    'grid',
    'geo',
    'parallel',
    'legend',
    'toolbox',
    'title',
    'visualMap',
    'dataZoom',
    'timeline',
  ],
  L1 = [
    ['borderRadius', 'barBorderRadius'],
    ['borderColor', 'barBorderColor'],
    ['borderWidth', 'barBorderWidth'],
  ]
function id(r) {
  var t = r && r.itemStyle
  if (t)
    for (var e = 0; e < L1.length; e++) {
      var n = L1[e][1],
        i = L1[e][0]
      t[n] != null && (t[i] = t[n])
    }
}
function rR(r) {
  r &&
    r.alignTo === 'edge' &&
    r.margin != null &&
    r.edgeDistance == null &&
    (r.edgeDistance = r.margin)
}
function iR(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay)
}
function Prt(r) {
  r &&
    r.focusNodeAdjacency != null &&
    ((r.emphasis = r.emphasis || {}),
    r.emphasis.focus == null && (r.emphasis.focus = 'adjacency'))
}
function y5(r, t) {
  if (r)
    for (var e = 0; e < r.length; e++) t(r[e]), r[e] && y5(r[e].children, t)
}
function _5(r, t) {
  Trt(r, t),
    (r.series = ke(r.series)),
    R(r.series, function (e) {
      if (Ut(e)) {
        var n = e.type
        if (n === 'line') e.clipOverflow != null && (e.clip = e.clipOverflow)
        else if (n === 'pie' || n === 'gauge') {
          e.clockWise != null && (e.clockwise = e.clockWise), rR(e.label)
          var i = e.data
          if (i && !ai(i)) for (var a = 0; a < i.length; a++) rR(i[a])
          e.hoverOffset != null &&
            ((e.emphasis = e.emphasis || {}),
            (e.emphasis.scaleSize = null) &&
              (e.emphasis.scaleSize = e.hoverOffset))
        } else if (n === 'gauge') {
          var o = Crt(e, 'pointer.color')
          o != null && Ert(e, 'itemStyle.color', o)
        } else if (n === 'bar') {
          id(e), id(e.backgroundStyle), id(e.emphasis)
          var i = e.data
          if (i && !ai(i))
            for (var a = 0; a < i.length; a++)
              typeof i[a] == 'object' && (id(i[a]), id(i[a] && i[a].emphasis))
        } else if (n === 'sunburst') {
          var s = e.highlightPolicy
          s &&
            ((e.emphasis = e.emphasis || {}),
            e.emphasis.focus || (e.emphasis.focus = s)),
            iR(e),
            y5(e.data, iR)
        } else
          n === 'graph' || n === 'sankey'
            ? Prt(e)
            : n === 'map' &&
              (e.mapType && !e.map && (e.map = e.mapType),
              e.mapLocation && zt(e, e.mapLocation))
        e.hoverAnimation != null &&
          ((e.emphasis = e.emphasis || {}),
          e.emphasis &&
            e.emphasis.scale == null &&
            (e.emphasis.scale = e.hoverAnimation)),
          nR(e)
      }
    }),
    r.dataRange && (r.visualMap = r.dataRange),
    R(Lrt, function (e) {
      var n = r[e]
      n &&
        (at(n) || (n = [n]),
        R(n, function (i) {
          nR(i)
        }))
    })
}
function Rrt(r) {
  var t = Pt()
  r.eachSeries(function (e) {
    var n = e.get('stack')
    if (n) {
      var i = t.get(n) || t.set(n, []),
        a = e.getData(),
        o = {
          stackResultDimension: a.getCalculationInfo('stackResultDimension'),
          stackedOverDimension: a.getCalculationInfo('stackedOverDimension'),
          stackedDimension: a.getCalculationInfo('stackedDimension'),
          stackedByDimension: a.getCalculationInfo('stackedByDimension'),
          isStackedByIndex: a.getCalculationInfo('isStackedByIndex'),
          data: a,
          seriesModel: e,
        }
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return
      i.length &&
        a.setCalculationInfo('stackedOnSeries', i[i.length - 1].seriesModel),
        i.push(o)
    }
  }),
    t.each(Irt)
}
function Irt(r) {
  R(r, function (t, e) {
    var n = [],
      i = [NaN, NaN],
      a = [t.stackResultDimension, t.stackedOverDimension],
      o = t.data,
      s = t.isStackedByIndex,
      l = t.seriesModel.get('stackStrategy') || 'samesign'
    o.modify(a, function (u, c, h) {
      var f = o.get(t.stackedDimension, h)
      if (isNaN(f)) return i
      var d, p
      s ? (p = o.getRawIndex(h)) : (d = o.get(t.stackedByDimension, h))
      for (var g = NaN, v = e - 1; v >= 0; v--) {
        var m = r[v]
        if ((s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0)) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p)
          if (
            l === 'all' ||
            (l === 'positive' && y > 0) ||
            (l === 'negative' && y < 0) ||
            (l === 'samesign' && f >= 0 && y > 0) ||
            (l === 'samesign' && f <= 0 && y < 0)
          ) {
            ;(f = vtt(f, y)), (g = y)
            break
          }
        }
      }
      return (n[0] = f), (n[1] = g), n
    })
  })
}
var v_ = (function () {
  function r(t) {
    ;(this.data = t.data || (t.sourceFormat === _o ? {} : [])),
      (this.sourceFormat = t.sourceFormat || u5),
      (this.seriesLayoutBy = t.seriesLayoutBy || oo),
      (this.startIndex = t.startIndex || 0),
      (this.dimensionsDetectedCount = t.dimensionsDetectedCount),
      (this.metaRawOption = t.metaRawOption)
    var e = (this.dimensionsDefine = t.dimensionsDefine)
    if (e)
      for (var n = 0; n < e.length; n++) {
        var i = e[n]
        i.type == null && f5(this, n) === fr.Must && (i.type = 'ordinal')
      }
  }
  return r
})()
function hC(r) {
  return r instanceof v_
}
function dw(r, t, e) {
  e = e || x5(r)
  var n = t.seriesLayoutBy,
    i = Nrt(r, e, n, t.sourceHeader, t.dimensions),
    a = new v_({
      data: r,
      sourceFormat: e,
      seriesLayoutBy: n,
      dimensionsDefine: i.dimensionsDefine,
      startIndex: i.startIndex,
      dimensionsDetectedCount: i.dimensionsDetectedCount,
      metaRawOption: Vt(t),
    })
  return a
}
function fC(r) {
  return new v_({
    data: r,
    sourceFormat: ai(r) ? js : ia,
  })
}
function Ort(r) {
  return new v_({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: Vt(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
  })
}
function x5(r) {
  var t = u5
  if (ai(r)) t = js
  else if (at(r)) {
    r.length === 0 && (t = Dr)
    for (var e = 0, n = r.length; e < n; e++) {
      var i = r[e]
      if (i != null) {
        if (at(i) || ai(i)) {
          t = Dr
          break
        } else if (Ut(i)) {
          t = aa
          break
        }
      }
    }
  } else if (Ut(r)) {
    for (var a in r)
      if (Et(r, a) && Er(r[a])) {
        t = _o
        break
      }
  }
  return t
}
function Nrt(r, t, e, n, i) {
  var a, o
  if (!r)
    return {
      dimensionsDefine: aR(i),
      startIndex: o,
      dimensionsDetectedCount: a,
    }
  if (t === Dr) {
    var s = r
    n === 'auto' || n == null
      ? oR(
          function (u) {
            u != null && u !== '-' && (bt(u) ? o == null && (o = 1) : (o = 0))
          },
          e,
          s,
          10,
        )
      : (o = be(n) ? n : n ? 1 : 0),
      !i &&
        o === 1 &&
        ((i = []),
        oR(
          function (u, c) {
            i[c] = u != null ? u + '' : ''
          },
          e,
          s,
          1 / 0,
        )),
      (a = i ? i.length : e === Cf ? s.length : s[0] ? s[0].length : null)
  } else if (t === aa) i || (i = krt(r))
  else if (t === _o)
    i ||
      ((i = []),
      R(r, function (u, c) {
        i.push(c)
      }))
  else if (t === ia) {
    var l = yf(r[0])
    a = (at(l) && l.length) || 1
  }
  return {
    startIndex: o,
    dimensionsDefine: aR(i),
    dimensionsDetectedCount: a,
  }
}
function krt(r) {
  for (var t = 0, e; t < r.length && !(e = r[t++]); );
  if (e) return pe(e)
}
function aR(r) {
  if (r) {
    var t = Pt()
    return st(r, function (e, n) {
      e = Ut(e)
        ? e
        : {
            name: e,
          }
      var i = {
        name: e.name,
        displayName: e.displayName,
        type: e.type,
      }
      if (i.name == null) return i
      ;(i.name += ''), i.displayName == null && (i.displayName = i.name)
      var a = t.get(i.name)
      return (
        a
          ? (i.name += '-' + a.count++)
          : t.set(i.name, {
              count: 1,
            }),
        i
      )
    })
  }
}
function oR(r, t, e, n) {
  if (t === Cf)
    for (var i = 0; i < e.length && i < n; i++) r(e[i] ? e[i][0] : null, i)
  else for (var a = e[0] || [], i = 0; i < a.length && i < n; i++) r(a[i], i)
}
function S5(r) {
  var t = r.sourceFormat
  return t === aa || t === _o
}
var Xl,
  Yl,
  $l,
  sR,
  lR,
  A5 = (function () {
    function r(t, e) {
      var n = hC(t) ? t : fC(t)
      this._source = n
      var i = (this._data = n.data)
      n.sourceFormat === js &&
        ((this._offset = 0), (this._dimSize = e), (this._data = i)),
        lR(this, i, n)
    }
    return (
      (r.prototype.getSource = function () {
        return this._source
      }),
      (r.prototype.count = function () {
        return 0
      }),
      (r.prototype.getItem = function (t, e) {}),
      (r.prototype.appendData = function (t) {}),
      (r.prototype.clean = function () {}),
      (r.protoInitialize = (function () {
        var t = r.prototype
        ;(t.pure = !1), (t.persistent = !0)
      })()),
      (r.internalField = (function () {
        var t
        lR = function (o, s, l) {
          var u = l.sourceFormat,
            c = l.seriesLayoutBy,
            h = l.startIndex,
            f = l.dimensionsDefine,
            d = sR[dC(u, c)]
          if ((Q(o, d), u === js))
            (o.getItem = e), (o.count = i), (o.fillStorage = n)
          else {
            var p = b5(u, c)
            o.getItem = Tt(p, null, s, h, f)
            var g = w5(u, c)
            o.count = Tt(g, null, s, h, f)
          }
        }
        var e = function (o, s) {
            ;(o = o - this._offset), (s = s || [])
            for (
              var l = this._data, u = this._dimSize, c = u * o, h = 0;
              h < u;
              h++
            )
              s[h] = l[c + h]
            return s
          },
          n = function (o, s, l, u) {
            for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
              for (
                var d = u[f],
                  p = d[0] == null ? 1 / 0 : d[0],
                  g = d[1] == null ? -1 / 0 : d[1],
                  v = s - o,
                  m = l[f],
                  y = 0;
                y < v;
                y++
              ) {
                var _ = c[y * h + f]
                ;(m[o + y] = _), _ < p && (p = _), _ > g && (g = _)
              }
              ;(d[0] = p), (d[1] = g)
            }
          },
          i = function () {
            return this._data ? this._data.length / this._dimSize : 0
          }
        sR =
          ((t = {}),
          (t[Dr + '_' + oo] = {
            pure: !0,
            appendData: a,
          }),
          (t[Dr + '_' + Cf] = {
            pure: !0,
            appendData: function () {
              throw new Error(
                'Do not support appendData when set seriesLayoutBy: "row".',
              )
            },
          }),
          (t[aa] = {
            pure: !0,
            appendData: a,
          }),
          (t[_o] = {
            pure: !0,
            appendData: function (o) {
              var s = this._data
              R(o, function (l, u) {
                for (
                  var c = s[u] || (s[u] = []), h = 0;
                  h < (l || []).length;
                  h++
                )
                  c.push(l[h])
              })
            },
          }),
          (t[ia] = {
            appendData: a,
          }),
          (t[js] = {
            persistent: !1,
            pure: !0,
            appendData: function (o) {
              this._data = o
            },
            clean: function () {
              ;(this._offset += this.count()), (this._data = null)
            },
          }),
          t)
        function a(o) {
          for (var s = 0; s < o.length; s++) this._data.push(o[s])
        }
      })()),
      r
    )
  })(),
  uR = function (r, t, e, n) {
    return r[n]
  },
  Brt =
    ((Xl = {}),
    (Xl[Dr + '_' + oo] = function (r, t, e, n) {
      return r[n + t]
    }),
    (Xl[Dr + '_' + Cf] = function (r, t, e, n, i) {
      n += t
      for (var a = i || [], o = r, s = 0; s < o.length; s++) {
        var l = o[s]
        a[s] = l ? l[n] : null
      }
      return a
    }),
    (Xl[aa] = uR),
    (Xl[_o] = function (r, t, e, n, i) {
      for (var a = i || [], o = 0; o < e.length; o++) {
        var s = e[o].name,
          l = r[s]
        a[o] = l ? l[n] : null
      }
      return a
    }),
    (Xl[ia] = uR),
    Xl)
function b5(r, t) {
  var e = Brt[dC(r, t)]
  return e
}
var cR = function (r, t, e) {
    return r.length
  },
  Frt =
    ((Yl = {}),
    (Yl[Dr + '_' + oo] = function (r, t, e) {
      return Math.max(0, r.length - t)
    }),
    (Yl[Dr + '_' + Cf] = function (r, t, e) {
      var n = r[0]
      return n ? Math.max(0, n.length - t) : 0
    }),
    (Yl[aa] = cR),
    (Yl[_o] = function (r, t, e) {
      var n = e[0].name,
        i = r[n]
      return i ? i.length : 0
    }),
    (Yl[ia] = cR),
    Yl)
function w5(r, t) {
  var e = Frt[dC(r, t)]
  return e
}
var P1 = function (r, t, e) {
    return r[t]
  },
  zrt =
    (($l = {}),
    ($l[Dr] = P1),
    ($l[aa] = function (r, t, e) {
      return r[e]
    }),
    ($l[_o] = P1),
    ($l[ia] = function (r, t, e) {
      var n = yf(r)
      return n instanceof Array ? n[t] : n
    }),
    ($l[js] = P1),
    $l)
function M5(r) {
  var t = zrt[r]
  return t
}
function dC(r, t) {
  return r === Dr ? r + '_' + t : r
}
function nf(r, t, e) {
  if (r) {
    var n = r.getRawDataItem(t)
    if (n != null) {
      var i = r.getStore(),
        a = i.getSource().sourceFormat
      if (e != null) {
        var o = r.getDimensionIndex(e),
          s = i.getDimensionProperty(o)
        return M5(a)(n, o, s)
      } else {
        var l = n
        return a === ia && (l = yf(n)), l
      }
    }
  }
}
var Urt = /\{@(.+?)\}/g,
  g_ = (function () {
    function r() {}
    return (
      (r.prototype.getDataParams = function (t, e) {
        var n = this.getData(e),
          i = this.getRawValue(t, e),
          a = n.getRawIndex(t),
          o = n.getName(t),
          s = n.getRawDataItem(t),
          l = n.getItemVisual(t, 'style'),
          u = l && l[n.getItemVisual(t, 'drawType') || 'fill'],
          c = l && l.stroke,
          h = this.mainType,
          f = h === 'series',
          d = n.userOutput && n.userOutput.get()
        return {
          componentType: h,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: f ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: f ? this.id : null,
          seriesName: f ? this.name : null,
          name: o,
          dataIndex: a,
          data: s,
          dataType: e,
          value: i,
          color: u,
          borderColor: c,
          dimensionNames: d ? d.fullDimensions : null,
          encode: d ? d.encode : null,
          $vars: ['seriesName', 'name', 'value'],
        }
      }),
      (r.prototype.getFormattedLabel = function (t, e, n, i, a, o) {
        e = e || 'normal'
        var s = this.getData(n),
          l = this.getDataParams(t, n)
        if (
          (o && (l.value = o.interpolatedValue),
          i != null && at(l.value) && (l.value = l.value[i]),
          !a)
        ) {
          var u = s.getItemModel(t)
          a = u.get(
            e === 'normal' ? ['label', 'formatter'] : [e, 'label', 'formatter'],
          )
        }
        if (Nt(a)) return (l.status = e), (l.dimensionIndex = i), a(l)
        if (bt(a)) {
          var c = i5(a, l)
          return c.replace(Urt, function (h, f) {
            var d = f.length,
              p = f
            p.charAt(0) === '[' &&
              p.charAt(d - 1) === ']' &&
              (p = +p.slice(1, d - 1))
            var g = nf(s, t, p)
            if (o && at(o.interpolatedValue)) {
              var v = s.getDimensionIndex(p)
              v >= 0 && (g = o.interpolatedValue[v])
            }
            return g != null ? g + '' : ''
          })
        }
      }),
      (r.prototype.getRawValue = function (t, e) {
        return nf(this.getData(e), t)
      }),
      (r.prototype.formatTooltip = function (t, e, n) {}),
      r
    )
  })()
function hR(r) {
  var t, e
  return (
    Ut(r) ? r.type && (e = r) : (t = r),
    {
      text: t,
      frag: e,
    }
  )
}
function up(r) {
  return new Vrt(r)
}
var Vrt = (function () {
    function r(t) {
      ;(t = t || {}),
        (this._reset = t.reset),
        (this._plan = t.plan),
        (this._count = t.count),
        (this._onDirty = t.onDirty),
        (this._dirty = !0)
    }
    return (
      (r.prototype.perform = function (t) {
        var e = this._upstream,
          n = t && t.skip
        if (this._dirty && e) {
          var i = this.context
          i.data = i.outputData = e.context.outputData
        }
        this.__pipeline && (this.__pipeline.currentTask = this)
        var a
        this._plan && !n && (a = this._plan(this.context))
        var o = c(this._modBy),
          s = this._modDataCount || 0,
          l = c(t && t.modBy),
          u = (t && t.modDataCount) || 0
        ;(o !== l || s !== u) && (a = 'reset')
        function c(y) {
          return !(y >= 1) && (y = 1), y
        }
        var h
        ;(this._dirty || a === 'reset') &&
          ((this._dirty = !1), (h = this._doReset(n))),
          (this._modBy = l),
          (this._modDataCount = u)
        var f = t && t.step
        if (
          (e
            ? (this._dueEnd = e._outputDueEnd)
            : (this._dueEnd = this._count ? this._count(this.context) : 1 / 0),
          this._progress)
        ) {
          var d = this._dueIndex,
            p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd)
          if (!n && (h || d < p)) {
            var g = this._progress
            if (at(g))
              for (var v = 0; v < g.length; v++)
                this._doProgress(g[v], d, p, l, u)
            else this._doProgress(g, d, p, l, u)
          }
          this._dueIndex = p
          var m = this._settedOutputEnd != null ? this._settedOutputEnd : p
          this._outputDueEnd = m
        } else
          this._dueIndex = this._outputDueEnd =
            this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd
        return this.unfinished()
      }),
      (r.prototype.dirty = function () {
        ;(this._dirty = !0), this._onDirty && this._onDirty(this.context)
      }),
      (r.prototype._doProgress = function (t, e, n, i, a) {
        fR.reset(e, n, i, a),
          (this._callingProgress = t),
          this._callingProgress(
            {
              start: e,
              end: n,
              count: n - e,
              next: fR.next,
            },
            this.context,
          )
      }),
      (r.prototype._doReset = function (t) {
        ;(this._dueIndex = this._outputDueEnd = this._dueEnd = 0),
          (this._settedOutputEnd = null)
        var e, n
        !t &&
          this._reset &&
          ((e = this._reset(this.context)),
          e && e.progress && ((n = e.forceFirstProgress), (e = e.progress)),
          at(e) && !e.length && (e = null)),
          (this._progress = e),
          (this._modBy = this._modDataCount = null)
        var i = this._downstream
        return i && i.dirty(), n
      }),
      (r.prototype.unfinished = function () {
        return this._progress && this._dueIndex < this._dueEnd
      }),
      (r.prototype.pipe = function (t) {
        ;(this._downstream !== t || this._dirty) &&
          ((this._downstream = t), (t._upstream = this), t.dirty())
      }),
      (r.prototype.dispose = function () {
        this._disposed ||
          (this._upstream && (this._upstream._downstream = null),
          this._downstream && (this._downstream._upstream = null),
          (this._dirty = !1),
          (this._disposed = !0))
      }),
      (r.prototype.getUpstream = function () {
        return this._upstream
      }),
      (r.prototype.getDownstream = function () {
        return this._downstream
      }),
      (r.prototype.setOutputEnd = function (t) {
        this._outputDueEnd = this._settedOutputEnd = t
      }),
      r
    )
  })(),
  fR = (function () {
    var r,
      t,
      e,
      n,
      i,
      a = {
        reset: function (l, u, c, h) {
          ;(t = l),
            (r = u),
            (e = c),
            (n = h),
            (i = Math.ceil(n / e)),
            (a.next = e > 1 && n > 0 ? s : o)
        },
      }
    return a
    function o() {
      return t < r ? t++ : null
    }
    function s() {
      var l = (t % i) * e + Math.ceil(t / i),
        u = t >= r ? null : l < n ? l : t
      return t++, u
    }
  })()
function Js(r, t) {
  var e = t && t.type
  return e === 'ordinal'
    ? r
    : (e === 'time' && !be(r) && r != null && r !== '-' && (r = +po(r)),
      r == null || r === '' ? NaN : Number(r))
}
var Grt = Pt({
  number: function (r) {
    return parseFloat(r)
  },
  time: function (r) {
    return +po(r)
  },
  trim: function (r) {
    return bt(r) ? xa(r) : r
  },
})
function T5(r) {
  return Grt.get(r)
}
var C5 = {
    lt: function (r, t) {
      return r < t
    },
    lte: function (r, t) {
      return r <= t
    },
    gt: function (r, t) {
      return r > t
    },
    gte: function (r, t) {
      return r >= t
    },
  },
  Hrt = (function () {
    function r(t, e) {
      if (!be(e)) {
        var n = ''
        Ce(n)
      }
      ;(this._opFn = C5[t]), (this._rvalFloat = Jo(e))
    }
    return (
      (r.prototype.evaluate = function (t) {
        return be(t)
          ? this._opFn(t, this._rvalFloat)
          : this._opFn(Jo(t), this._rvalFloat)
      }),
      r
    )
  })(),
  E5 = (function () {
    function r(t, e) {
      var n = t === 'desc'
      ;(this._resultLT = n ? 1 : -1),
        e == null && (e = n ? 'min' : 'max'),
        (this._incomparable = e === 'min' ? -1 / 0 : 1 / 0)
    }
    return (
      (r.prototype.evaluate = function (t, e) {
        var n = be(t) ? t : Jo(t),
          i = be(e) ? e : Jo(e),
          a = isNaN(n),
          o = isNaN(i)
        if (
          (a && (n = this._incomparable), o && (i = this._incomparable), a && o)
        ) {
          var s = bt(t),
            l = bt(e)
          s && (n = l ? t : 0), l && (i = s ? e : 0)
        }
        return n < i ? this._resultLT : n > i ? -this._resultLT : 0
      }),
      r
    )
  })(),
  Wrt = (function () {
    function r(t, e) {
      ;(this._rval = e),
        (this._isEQ = t),
        (this._rvalTypeof = typeof e),
        (this._rvalFloat = Jo(e))
    }
    return (
      (r.prototype.evaluate = function (t) {
        var e = t === this._rval
        if (!e) {
          var n = typeof t
          n !== this._rvalTypeof &&
            (n === 'number' || this._rvalTypeof === 'number') &&
            (e = Jo(t) === this._rvalFloat)
        }
        return this._isEQ ? e : !e
      }),
      r
    )
  })()
function Xrt(r, t) {
  return r === 'eq' || r === 'ne'
    ? new Wrt(r === 'eq', t)
    : Et(C5, r)
    ? new Hrt(r, t)
    : null
}
var Yrt = (function () {
  function r() {}
  return (
    (r.prototype.getRawData = function () {
      throw new Error('not supported')
    }),
    (r.prototype.getRawDataItem = function (t) {
      throw new Error('not supported')
    }),
    (r.prototype.cloneRawData = function () {}),
    (r.prototype.getDimensionInfo = function (t) {}),
    (r.prototype.cloneAllDimensionInfo = function () {}),
    (r.prototype.count = function () {}),
    (r.prototype.retrieveValue = function (t, e) {}),
    (r.prototype.retrieveValueFromItem = function (t, e) {}),
    (r.prototype.convertValue = function (t, e) {
      return Js(t, e)
    }),
    r
  )
})()
function $rt(r, t) {
  var e = new Yrt(),
    n = r.data,
    i = (e.sourceFormat = r.sourceFormat),
    a = r.startIndex,
    o = ''
  r.seriesLayoutBy !== oo && Ce(o)
  var s = [],
    l = {},
    u = r.dimensionsDefine
  if (u)
    R(u, function (g, v) {
      var m = g.name,
        y = {
          index: v,
          name: m,
          displayName: g.displayName,
        }
      if ((s.push(y), m != null)) {
        var _ = ''
        Et(l, m) && Ce(_), (l[m] = y)
      }
    })
  else
    for (var c = 0; c < r.dimensionsDetectedCount; c++)
      s.push({
        index: c,
      })
  var h = b5(i, oo)
  t.__isBuiltIn &&
    ((e.getRawDataItem = function (g) {
      return h(n, a, s, g)
    }),
    (e.getRawData = Tt(qrt, null, r))),
    (e.cloneRawData = Tt(Zrt, null, r))
  var f = w5(i, oo)
  e.count = Tt(f, null, n, a, s)
  var d = M5(i)
  e.retrieveValue = function (g, v) {
    var m = h(n, a, s, g)
    return p(m, v)
  }
  var p = (e.retrieveValueFromItem = function (g, v) {
    if (g != null) {
      var m = s[v]
      if (m) return d(g, v, m.name)
    }
  })
  return (
    (e.getDimensionInfo = Tt(Krt, null, s, l)),
    (e.cloneAllDimensionInfo = Tt(jrt, null, s)),
    e
  )
}
function qrt(r) {
  var t = r.sourceFormat
  if (!pC(t)) {
    var e = ''
    Ce(e)
  }
  return r.data
}
function Zrt(r) {
  var t = r.sourceFormat,
    e = r.data
  if (!pC(t)) {
    var n = ''
    Ce(n)
  }
  if (t === Dr) {
    for (var i = [], a = 0, o = e.length; a < o; a++) i.push(e[a].slice())
    return i
  } else if (t === aa) {
    for (var i = [], a = 0, o = e.length; a < o; a++) i.push(Q({}, e[a]))
    return i
  }
}
function Krt(r, t, e) {
  if (e != null) {
    if (be(e) || (!isNaN(e) && !Et(t, e))) return r[e]
    if (Et(t, e)) return t[e]
  }
}
function jrt(r) {
  return Vt(r)
}
var D5 = Pt()
function Jrt(r) {
  r = Vt(r)
  var t = r.type,
    e = ''
  t || Ce(e)
  var n = t.split(':')
  n.length !== 2 && Ce(e)
  var i = !1
  n[0] === 'echarts' && ((t = n[1]), (i = !0)),
    (r.__isBuiltIn = i),
    D5.set(t, r)
}
function Qrt(r, t, e) {
  var n = ke(r),
    i = n.length,
    a = ''
  i || Ce(a)
  for (var o = 0, s = i; o < s; o++) {
    var l = n[o]
    ;(t = tit(l, t)), o !== s - 1 && (t.length = Math.max(t.length, 1))
  }
  return t
}
function tit(r, t, e, n) {
  var i = ''
  t.length || Ce(i), Ut(r) || Ce(i)
  var a = r.type,
    o = D5.get(a)
  o || Ce(i)
  var s = st(t, function (u) {
      return $rt(u, o)
    }),
    l = ke(
      o.transform({
        upstream: s[0],
        upstreamList: s,
        config: Vt(r.config),
      }),
    )
  return st(l, function (u, c) {
    var h = ''
    Ut(u) || Ce(h), u.data || Ce(h)
    var f = x5(u.data)
    pC(f) || Ce(h)
    var d,
      p = t[0]
    if (p && c === 0 && !u.dimensions) {
      var g = p.startIndex
      g && (u.data = p.data.slice(0, g).concat(u.data)),
        (d = {
          seriesLayoutBy: oo,
          sourceHeader: g,
          dimensions: p.metaRawOption.dimensions,
        })
    } else
      d = {
        seriesLayoutBy: oo,
        sourceHeader: 0,
        dimensions: u.dimensions,
      }
    return dw(u.data, d, null)
  })
}
function pC(r) {
  return r === Dr || r === aa
}
var m_ = 'undefined',
  eit = typeof Uint32Array === m_ ? Array : Uint32Array,
  nit = typeof Uint16Array === m_ ? Array : Uint16Array,
  L5 = typeof Int32Array === m_ ? Array : Int32Array,
  dR = typeof Float64Array === m_ ? Array : Float64Array,
  P5 = {
    float: dR,
    int: L5,
    ordinal: Array,
    number: Array,
    time: dR,
  },
  R1
function ad(r) {
  return r > 65535 ? eit : nit
}
function Yc() {
  return [1 / 0, -1 / 0]
}
function rit(r) {
  var t = r.constructor
  return t === Array ? r.slice() : new t(r)
}
function pR(r, t, e, n, i) {
  var a = P5[e || 'float']
  if (i) {
    var o = r[t],
      s = o && o.length
    if (s !== n) {
      for (var l = new a(n), u = 0; u < s; u++) l[u] = o[u]
      r[t] = l
    }
  } else r[t] = new a(n)
}
var pw = (function () {
    function r() {
      ;(this._chunks = []),
        (this._rawExtent = []),
        (this._extent = []),
        (this._count = 0),
        (this._rawCount = 0),
        (this._calcDimNameToIdx = Pt())
    }
    return (
      (r.prototype.initData = function (t, e, n) {
        ;(this._provider = t),
          (this._chunks = []),
          (this._indices = null),
          (this.getRawIndex = this._getRawIdxIdentity)
        var i = t.getSource(),
          a = (this.defaultDimValueGetter = R1[i.sourceFormat])
        ;(this._dimValueGetter = n || a),
          (this._rawExtent = []),
          S5(i),
          (this._dimensions = st(e, function (o) {
            return {
              type: o.type,
              property: o.property,
            }
          })),
          this._initDataFromProvider(0, t.count())
      }),
      (r.prototype.getProvider = function () {
        return this._provider
      }),
      (r.prototype.getSource = function () {
        return this._provider.getSource()
      }),
      (r.prototype.ensureCalculationDimension = function (t, e) {
        var n = this._calcDimNameToIdx,
          i = this._dimensions,
          a = n.get(t)
        if (a != null) {
          if (i[a].type === e) return a
        } else a = i.length
        return (
          (i[a] = {
            type: e,
          }),
          n.set(t, a),
          (this._chunks[a] = new P5[e || 'float'](this._rawCount)),
          (this._rawExtent[a] = Yc()),
          a
        )
      }),
      (r.prototype.collectOrdinalMeta = function (t, e) {
        var n = this._chunks[t],
          i = this._dimensions[t],
          a = this._rawExtent,
          o = i.ordinalOffset || 0,
          s = n.length
        o === 0 && (a[t] = Yc())
        for (var l = a[t], u = o; u < s; u++) {
          var c = (n[u] = e.parseAndCollect(n[u]))
          isNaN(c) || ((l[0] = Math.min(c, l[0])), (l[1] = Math.max(c, l[1])))
        }
        ;(i.ordinalMeta = e), (i.ordinalOffset = s), (i.type = 'ordinal')
      }),
      (r.prototype.getOrdinalMeta = function (t) {
        var e = this._dimensions[t],
          n = e.ordinalMeta
        return n
      }),
      (r.prototype.getDimensionProperty = function (t) {
        var e = this._dimensions[t]
        return e && e.property
      }),
      (r.prototype.appendData = function (t) {
        var e = this._provider,
          n = this.count()
        e.appendData(t)
        var i = e.count()
        return (
          e.persistent || (i += n),
          n < i && this._initDataFromProvider(n, i, !0),
          [n, i]
        )
      }),
      (r.prototype.appendValues = function (t, e) {
        for (
          var n = this._chunks,
            i = this._dimensions,
            a = i.length,
            o = this._rawExtent,
            s = this.count(),
            l = s + Math.max(t.length, e || 0),
            u = 0;
          u < a;
          u++
        ) {
          var c = i[u]
          pR(n, u, c.type, l, !0)
        }
        for (var h = [], f = s; f < l; f++)
          for (var d = f - s, p = 0; p < a; p++) {
            var c = i[p],
              g = R1.arrayRows.call(this, t[d] || h, c.property, d, p)
            n[p][f] = g
            var v = o[p]
            g < v[0] && (v[0] = g), g > v[1] && (v[1] = g)
          }
        return (
          (this._rawCount = this._count = l),
          {
            start: s,
            end: l,
          }
        )
      }),
      (r.prototype._initDataFromProvider = function (t, e, n) {
        for (
          var i = this._provider,
            a = this._chunks,
            o = this._dimensions,
            s = o.length,
            l = this._rawExtent,
            u = st(o, function (y) {
              return y.property
            }),
            c = 0;
          c < s;
          c++
        ) {
          var h = o[c]
          l[c] || (l[c] = Yc()), pR(a, c, h.type, e, n)
        }
        if (i.fillStorage) i.fillStorage(t, e, a, l)
        else
          for (var f = [], d = t; d < e; d++) {
            f = i.getItem(d, f)
            for (var p = 0; p < s; p++) {
              var g = a[p],
                v = this._dimValueGetter(f, u[p], d, p)
              g[d] = v
              var m = l[p]
              v < m[0] && (m[0] = v), v > m[1] && (m[1] = v)
            }
          }
        !i.persistent && i.clean && i.clean(),
          (this._rawCount = this._count = e),
          (this._extent = [])
      }),
      (r.prototype.count = function () {
        return this._count
      }),
      (r.prototype.get = function (t, e) {
        if (!(e >= 0 && e < this._count)) return NaN
        var n = this._chunks[t]
        return n ? n[this.getRawIndex(e)] : NaN
      }),
      (r.prototype.getValues = function (t, e) {
        var n = [],
          i = []
        if (e == null) {
          ;(e = t), (t = [])
          for (var a = 0; a < this._dimensions.length; a++) i.push(a)
        } else i = t
        for (var a = 0, o = i.length; a < o; a++) n.push(this.get(i[a], e))
        return n
      }),
      (r.prototype.getByRawIndex = function (t, e) {
        if (!(e >= 0 && e < this._rawCount)) return NaN
        var n = this._chunks[t]
        return n ? n[e] : NaN
      }),
      (r.prototype.getSum = function (t) {
        var e = this._chunks[t],
          n = 0
        if (e)
          for (var i = 0, a = this.count(); i < a; i++) {
            var o = this.get(t, i)
            isNaN(o) || (n += o)
          }
        return n
      }),
      (r.prototype.getMedian = function (t) {
        var e = []
        this.each([t], function (a) {
          isNaN(a) || e.push(a)
        })
        var n = e.sort(function (a, o) {
            return a - o
          }),
          i = this.count()
        return i === 0
          ? 0
          : i % 2 === 1
          ? n[(i - 1) / 2]
          : (n[i / 2] + n[i / 2 - 1]) / 2
      }),
      (r.prototype.indexOfRawIndex = function (t) {
        if (t >= this._rawCount || t < 0) return -1
        if (!this._indices) return t
        var e = this._indices,
          n = e[t]
        if (n != null && n < this._count && n === t) return t
        for (var i = 0, a = this._count - 1; i <= a; ) {
          var o = ((i + a) / 2) | 0
          if (e[o] < t) i = o + 1
          else if (e[o] > t) a = o - 1
          else return o
        }
        return -1
      }),
      (r.prototype.indicesOfNearest = function (t, e, n) {
        var i = this._chunks,
          a = i[t],
          o = []
        if (!a) return o
        n == null && (n = 1 / 0)
        for (
          var s = 1 / 0, l = -1, u = 0, c = 0, h = this.count();
          c < h;
          c++
        ) {
          var f = this.getRawIndex(c),
            d = e - a[f],
            p = Math.abs(d)
          p <= n &&
            ((p < s || (p === s && d >= 0 && l < 0)) &&
              ((s = p), (l = d), (u = 0)),
            d === l && (o[u++] = c))
        }
        return (o.length = u), o
      }),
      (r.prototype.getIndices = function () {
        var t,
          e = this._indices
        if (e) {
          var n = e.constructor,
            i = this._count
          if (n === Array) {
            t = new n(i)
            for (var a = 0; a < i; a++) t[a] = e[a]
          } else t = new n(e.buffer, 0, i)
        } else {
          var n = ad(this._rawCount)
          t = new n(this.count())
          for (var a = 0; a < t.length; a++) t[a] = a
        }
        return t
      }),
      (r.prototype.filter = function (t, e) {
        if (!this._count) return this
        for (
          var n = this.clone(),
            i = n.count(),
            a = ad(n._rawCount),
            o = new a(i),
            s = [],
            l = t.length,
            u = 0,
            c = t[0],
            h = n._chunks,
            f = 0;
          f < i;
          f++
        ) {
          var d = void 0,
            p = n.getRawIndex(f)
          if (l === 0) d = e(f)
          else if (l === 1) {
            var g = h[c][p]
            d = e(g, f)
          } else {
            for (var v = 0; v < l; v++) s[v] = h[t[v]][p]
            ;(s[v] = f), (d = e.apply(null, s))
          }
          d && (o[u++] = p)
        }
        return (
          u < i && (n._indices = o),
          (n._count = u),
          (n._extent = []),
          n._updateGetRawIdx(),
          n
        )
      }),
      (r.prototype.selectRange = function (t) {
        var e = this.clone(),
          n = e._count
        if (!n) return this
        var i = pe(t),
          a = i.length
        if (!a) return this
        var o = e.count(),
          s = ad(e._rawCount),
          l = new s(o),
          u = 0,
          c = i[0],
          h = t[c][0],
          f = t[c][1],
          d = e._chunks,
          p = !1
        if (!e._indices) {
          var g = 0
          if (a === 1) {
            for (var v = d[i[0]], m = 0; m < n; m++) {
              var y = v[m]
              ;((y >= h && y <= f) || isNaN(y)) && (l[u++] = g), g++
            }
            p = !0
          } else if (a === 2) {
            for (
              var v = d[i[0]],
                _ = d[i[1]],
                x = t[i[1]][0],
                A = t[i[1]][1],
                m = 0;
              m < n;
              m++
            ) {
              var y = v[m],
                S = _[m]
              ;((y >= h && y <= f) || isNaN(y)) &&
                ((S >= x && S <= A) || isNaN(S)) &&
                (l[u++] = g),
                g++
            }
            p = !0
          }
        }
        if (!p)
          if (a === 1)
            for (var m = 0; m < o; m++) {
              var b = e.getRawIndex(m),
                y = d[i[0]][b]
              ;((y >= h && y <= f) || isNaN(y)) && (l[u++] = b)
            }
          else
            for (var m = 0; m < o; m++) {
              for (var T = !0, b = e.getRawIndex(m), w = 0; w < a; w++) {
                var M = i[w],
                  y = d[M][b]
                ;(y < t[M][0] || y > t[M][1]) && (T = !1)
              }
              T && (l[u++] = e.getRawIndex(m))
            }
        return (
          u < o && (e._indices = l),
          (e._count = u),
          (e._extent = []),
          e._updateGetRawIdx(),
          e
        )
      }),
      (r.prototype.map = function (t, e) {
        var n = this.clone(t)
        return this._updateDims(n, t, e), n
      }),
      (r.prototype.modify = function (t, e) {
        this._updateDims(this, t, e)
      }),
      (r.prototype._updateDims = function (t, e, n) {
        for (
          var i = t._chunks,
            a = [],
            o = e.length,
            s = t.count(),
            l = [],
            u = t._rawExtent,
            c = 0;
          c < e.length;
          c++
        )
          u[e[c]] = Yc()
        for (var h = 0; h < s; h++) {
          for (var f = t.getRawIndex(h), d = 0; d < o; d++) l[d] = i[e[d]][f]
          l[o] = h
          var p = n && n.apply(null, l)
          if (p != null) {
            typeof p != 'object' && ((a[0] = p), (p = a))
            for (var c = 0; c < p.length; c++) {
              var g = e[c],
                v = p[c],
                m = u[g],
                y = i[g]
              y && (y[f] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v)
            }
          }
        }
      }),
      (r.prototype.lttbDownSample = function (t, e) {
        var n = this.clone([t], !0),
          i = n._chunks,
          a = i[t],
          o = this.count(),
          s = 0,
          l = Math.floor(1 / e),
          u = this.getRawIndex(0),
          c,
          h,
          f,
          d = new (ad(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o))
        d[s++] = u
        for (var p = 1; p < o - 1; p += l) {
          for (
            var g = Math.min(p + l, o - 1),
              v = Math.min(p + l * 2, o),
              m = (v + g) / 2,
              y = 0,
              _ = g;
            _ < v;
            _++
          ) {
            var x = this.getRawIndex(_),
              A = a[x]
            isNaN(A) || (y += A)
          }
          y /= v - g
          var S = p,
            b = Math.min(p + l, o),
            T = p - 1,
            w = a[u]
          ;(c = -1), (f = S)
          for (var M = -1, C = 0, _ = S; _ < b; _++) {
            var x = this.getRawIndex(_),
              A = a[x]
            if (isNaN(A)) {
              C++, M < 0 && (M = x)
              continue
            }
            ;(h = Math.abs((T - m) * (A - w) - (T - _) * (y - w))),
              h > c && ((c = h), (f = x))
          }
          C > 0 &&
            C < b - S &&
            ((d[s++] = Math.min(M, f)), (f = Math.max(M, f))),
            (d[s++] = f),
            (u = f)
        }
        return (
          (d[s++] = this.getRawIndex(o - 1)),
          (n._count = s),
          (n._indices = d),
          (n.getRawIndex = this._getRawIdx),
          n
        )
      }),
      (r.prototype.downSample = function (t, e, n, i) {
        for (
          var a = this.clone([t], !0),
            o = a._chunks,
            s = [],
            l = Math.floor(1 / e),
            u = o[t],
            c = this.count(),
            h = (a._rawExtent[t] = Yc()),
            f = new (ad(this._rawCount))(Math.ceil(c / l)),
            d = 0,
            p = 0;
          p < c;
          p += l
        ) {
          l > c - p && ((l = c - p), (s.length = l))
          for (var g = 0; g < l; g++) {
            var v = this.getRawIndex(p + g)
            s[g] = u[v]
          }
          var m = n(s),
            y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1))
          ;(u[y] = m),
            m < h[0] && (h[0] = m),
            m > h[1] && (h[1] = m),
            (f[d++] = y)
        }
        return (a._count = d), (a._indices = f), a._updateGetRawIdx(), a
      }),
      (r.prototype.each = function (t, e) {
        if (this._count)
          for (
            var n = t.length, i = this._chunks, a = 0, o = this.count();
            a < o;
            a++
          ) {
            var s = this.getRawIndex(a)
            switch (n) {
              case 0:
                e(a)
                break
              case 1:
                e(i[t[0]][s], a)
                break
              case 2:
                e(i[t[0]][s], i[t[1]][s], a)
                break
              default:
                for (var l = 0, u = []; l < n; l++) u[l] = i[t[l]][s]
                ;(u[l] = a), e.apply(null, u)
            }
          }
      }),
      (r.prototype.getDataExtent = function (t) {
        var e = this._chunks[t],
          n = Yc()
        if (!e) return n
        var i = this.count(),
          a = !this._indices,
          o
        if (a) return this._rawExtent[t].slice()
        if (((o = this._extent[t]), o)) return o.slice()
        o = n
        for (var s = o[0], l = o[1], u = 0; u < i; u++) {
          var c = this.getRawIndex(u),
            h = e[c]
          h < s && (s = h), h > l && (l = h)
        }
        return (o = [s, l]), (this._extent[t] = o), o
      }),
      (r.prototype.getRawDataItem = function (t) {
        var e = this.getRawIndex(t)
        if (this._provider.persistent) return this._provider.getItem(e)
        for (var n = [], i = this._chunks, a = 0; a < i.length; a++)
          n.push(i[a][e])
        return n
      }),
      (r.prototype.clone = function (t, e) {
        var n = new r(),
          i = this._chunks,
          a =
            t &&
            co(
              t,
              function (s, l) {
                return (s[l] = !0), s
              },
              {},
            )
        if (a)
          for (var o = 0; o < i.length; o++)
            n._chunks[o] = a[o] ? rit(i[o]) : i[o]
        else n._chunks = i
        return (
          this._copyCommonProps(n),
          e || (n._indices = this._cloneIndices()),
          n._updateGetRawIdx(),
          n
        )
      }),
      (r.prototype._copyCommonProps = function (t) {
        ;(t._count = this._count),
          (t._rawCount = this._rawCount),
          (t._provider = this._provider),
          (t._dimensions = this._dimensions),
          (t._extent = Vt(this._extent)),
          (t._rawExtent = Vt(this._rawExtent))
      }),
      (r.prototype._cloneIndices = function () {
        if (this._indices) {
          var t = this._indices.constructor,
            e = void 0
          if (t === Array) {
            var n = this._indices.length
            e = new t(n)
            for (var i = 0; i < n; i++) e[i] = this._indices[i]
          } else e = new t(this._indices)
          return e
        }
        return null
      }),
      (r.prototype._getRawIdxIdentity = function (t) {
        return t
      }),
      (r.prototype._getRawIdx = function (t) {
        return t < this._count && t >= 0 ? this._indices[t] : -1
      }),
      (r.prototype._updateGetRawIdx = function () {
        this.getRawIndex = this._indices
          ? this._getRawIdx
          : this._getRawIdxIdentity
      }),
      (r.internalField = (function () {
        function t(e, n, i, a) {
          return Js(e[a], this._dimensions[a])
        }
        R1 = {
          arrayRows: t,
          objectRows: function (e, n, i, a) {
            return Js(e[n], this._dimensions[a])
          },
          keyedColumns: t,
          original: function (e, n, i, a) {
            var o = e && (e.value == null ? e : e.value)
            return Js(o instanceof Array ? o[a] : o, this._dimensions[a])
          },
          typedArray: function (e, n, i, a) {
            return e[a]
          },
        }
      })()),
      r
    )
  })(),
  R5 = (function () {
    function r(t) {
      ;(this._sourceList = []),
        (this._storeList = []),
        (this._upstreamSignList = []),
        (this._versionSignBase = 0),
        (this._dirty = !0),
        (this._sourceHost = t)
    }
    return (
      (r.prototype.dirty = function () {
        this._setLocalSource([], []), (this._storeList = []), (this._dirty = !0)
      }),
      (r.prototype._setLocalSource = function (t, e) {
        ;(this._sourceList = t),
          (this._upstreamSignList = e),
          this._versionSignBase++,
          this._versionSignBase > 9e10 && (this._versionSignBase = 0)
      }),
      (r.prototype._getVersionSign = function () {
        return this._sourceHost.uid + '_' + this._versionSignBase
      }),
      (r.prototype.prepareSource = function () {
        this._isDirty() && (this._createSource(), (this._dirty = !1))
      }),
      (r.prototype._createSource = function () {
        this._setLocalSource([], [])
        var t = this._sourceHost,
          e = this._getUpstreamSourceManagers(),
          n = !!e.length,
          i,
          a
        if (qg(t)) {
          var o = t,
            s = void 0,
            l = void 0,
            u = void 0
          if (n) {
            var c = e[0]
            c.prepareSource(),
              (u = c.getSource()),
              (s = u.data),
              (l = u.sourceFormat),
              (a = [c._getVersionSign()])
          } else (s = o.get('data', !0)), (l = ai(s) ? js : ia), (a = [])
          var h = this._getSourceMetaRawOption() || {},
            f = (u && u.metaRawOption) || {},
            d = $t(h.seriesLayoutBy, f.seriesLayoutBy) || null,
            p = $t(h.sourceHeader, f.sourceHeader),
            g = $t(h.dimensions, f.dimensions),
            v = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || g
          i = v
            ? [
                dw(
                  s,
                  {
                    seriesLayoutBy: d,
                    sourceHeader: p,
                    dimensions: g,
                  },
                  l,
                ),
              ]
            : []
        } else {
          var m = t
          if (n) {
            var y = this._applyTransform(e)
            ;(i = y.sourceList), (a = y.upstreamSignList)
          } else {
            var _ = m.get('source', !0)
            ;(i = [dw(_, this._getSourceMetaRawOption(), null)]), (a = [])
          }
        }
        this._setLocalSource(i, a)
      }),
      (r.prototype._applyTransform = function (t) {
        var e = this._sourceHost,
          n = e.get('transform', !0),
          i = e.get('fromTransformResult', !0)
        if (i != null) {
          var a = ''
          t.length !== 1 && gR(a)
        }
        var o,
          s = [],
          l = []
        return (
          R(t, function (u) {
            u.prepareSource()
            var c = u.getSource(i || 0),
              h = ''
            i != null && !c && gR(h), s.push(c), l.push(u._getVersionSign())
          }),
          n
            ? (o = Qrt(n, s, {
                datasetIndex: e.componentIndex,
              }))
            : i != null && (o = [Ort(s[0])]),
          {
            sourceList: o,
            upstreamSignList: l,
          }
        )
      }),
      (r.prototype._isDirty = function () {
        if (this._dirty) return !0
        for (
          var t = this._getUpstreamSourceManagers(), e = 0;
          e < t.length;
          e++
        ) {
          var n = t[e]
          if (n._isDirty() || this._upstreamSignList[e] !== n._getVersionSign())
            return !0
        }
      }),
      (r.prototype.getSource = function (t) {
        t = t || 0
        var e = this._sourceList[t]
        if (!e) {
          var n = this._getUpstreamSourceManagers()
          return n[0] && n[0].getSource(t)
        }
        return e
      }),
      (r.prototype.getSharedDataStore = function (t) {
        var e = t.makeStoreSchema()
        return this._innerGetDataStore(e.dimensions, t.source, e.hash)
      }),
      (r.prototype._innerGetDataStore = function (t, e, n) {
        var i = 0,
          a = this._storeList,
          o = a[i]
        o || (o = a[i] = {})
        var s = o[n]
        if (!s) {
          var l = this._getUpstreamSourceManagers()[0]
          qg(this._sourceHost) && l
            ? (s = l._innerGetDataStore(t, e, n))
            : ((s = new pw()), s.initData(new A5(e, t.length), t)),
            (o[n] = s)
        }
        return s
      }),
      (r.prototype._getUpstreamSourceManagers = function () {
        var t = this._sourceHost
        if (qg(t)) {
          var e = uC(t)
          return e ? [e.getSourceManager()] : []
        } else
          return st(ort(t), function (n) {
            return n.getSourceManager()
          })
      }),
      (r.prototype._getSourceMetaRawOption = function () {
        var t = this._sourceHost,
          e,
          n,
          i
        if (qg(t))
          (e = t.get('seriesLayoutBy', !0)),
            (n = t.get('sourceHeader', !0)),
            (i = t.get('dimensions', !0))
        else if (!this._getUpstreamSourceManagers().length) {
          var a = t
          ;(e = a.get('seriesLayoutBy', !0)),
            (n = a.get('sourceHeader', !0)),
            (i = a.get('dimensions', !0))
        }
        return {
          seriesLayoutBy: e,
          sourceHeader: n,
          dimensions: i,
        }
      }),
      r
    )
  })()
function vR(r) {
  var t = r.option.transform
  t && Ny(r.option.transform)
}
function qg(r) {
  return r.mainType === 'series'
}
function gR(r) {
  throw new Error(r)
}
var I5 = 'line-height:1'
function O5(r, t) {
  var e = r.color || '#6e7079',
    n = r.fontSize || 12,
    i = r.fontWeight || '400',
    a = r.color || '#464646',
    o = r.fontSize || 14,
    s = r.fontWeight || '900'
  return t === 'html'
    ? {
        nameStyle:
          'font-size:' +
          Fr(n + '') +
          'px;color:' +
          Fr(e) +
          ';font-weight:' +
          Fr(i + ''),
        valueStyle:
          'font-size:' +
          Fr(o + '') +
          'px;color:' +
          Fr(a) +
          ';font-weight:' +
          Fr(s + ''),
      }
    : {
        nameStyle: {
          fontSize: n,
          fill: e,
          fontWeight: i,
        },
        valueStyle: {
          fontSize: o,
          fill: a,
          fontWeight: s,
        },
      }
}
var iit = [0, 10, 20, 30],
  ait = [
    '',
    `
`,
    `

`,
    `


`,
  ]
function Kn(r, t) {
  return (t.type = r), t
}
function vw(r) {
  return r.type === 'section'
}
function N5(r) {
  return vw(r) ? oit : sit
}
function k5(r) {
  if (vw(r)) {
    var t = 0,
      e = r.blocks.length,
      n = e > 1 || (e > 0 && !r.noHeader)
    return (
      R(r.blocks, function (i) {
        var a = k5(i)
        a >= t && (t = a + +(n && (!a || (vw(i) && !i.noHeader))))
      }),
      t
    )
  }
  return 0
}
function oit(r, t, e, n) {
  var i = t.noHeader,
    a = lit(k5(t)),
    o = [],
    s = t.blocks || []
  Gr(!s || at(s)), (s = s || [])
  var l = r.orderMode
  if (t.sortBlocks && l) {
    s = s.slice()
    var u = {
      valueAsc: 'asc',
      valueDesc: 'desc',
    }
    if (Et(u, l)) {
      var c = new E5(u[l], null)
      s.sort(function (p, g) {
        return c.evaluate(p.sortParam, g.sortParam)
      })
    } else l === 'seriesDesc' && s.reverse()
  }
  R(s, function (p, g) {
    var v = t.valueFormatter,
      m = N5(p)(
        v
          ? Q(Q({}, r), {
              valueFormatter: v,
            })
          : r,
        p,
        g > 0 ? a.html : 0,
        n,
      )
    m != null && o.push(m)
  })
  var h =
    r.renderMode === 'richText'
      ? o.join(a.richText)
      : gw(o.join(''), i ? e : a.html)
  if (i) return h
  var f = cw(t.header, 'ordinal', r.useUTC),
    d = O5(n, r.renderMode).nameStyle
  return r.renderMode === 'richText'
    ? B5(r, f, d) + a.richText + h
    : gw('<div style="' + d + ';' + I5 + ';">' + Fr(f) + '</div>' + h, e)
}
function sit(r, t, e, n) {
  var i = r.renderMode,
    a = t.noName,
    o = t.noValue,
    s = !t.markerType,
    l = t.name,
    u = r.useUTC,
    c =
      t.valueFormatter ||
      r.valueFormatter ||
      function (x) {
        return (
          (x = at(x) ? x : [x]),
          st(x, function (A, S) {
            return cw(A, at(d) ? d[S] : d, u)
          })
        )
      }
  if (!(a && o)) {
    var h = s
        ? ''
        : r.markupStyleCreator.makeTooltipMarker(
            t.markerType,
            t.markerColor || '#333',
            i,
          ),
      f = a ? '' : cw(l, 'ordinal', u),
      d = t.valueType,
      p = o ? [] : c(t.value, t.dataIndex),
      g = !s || !a,
      v = !s && a,
      m = O5(n, i),
      y = m.nameStyle,
      _ = m.valueStyle
    return i === 'richText'
      ? (s ? '' : h) + (a ? '' : B5(r, f, y)) + (o ? '' : hit(r, p, g, v, _))
      : gw(
          (s ? '' : h) + (a ? '' : uit(f, !s, y)) + (o ? '' : cit(p, g, v, _)),
          e,
        )
  }
}
function mR(r, t, e, n, i, a) {
  if (r) {
    var o = N5(r),
      s = {
        useUTC: i,
        renderMode: e,
        orderMode: n,
        markupStyleCreator: t,
        valueFormatter: r.valueFormatter,
      }
    return o(s, r, 0, a)
  }
}
function lit(r) {
  return {
    html: iit[r],
    richText: ait[r],
  }
}
function gw(r, t) {
  var e = '<div style="clear:both"></div>',
    n = 'margin: ' + t + 'px 0 0'
  return '<div style="' + n + ';' + I5 + ';">' + r + e + '</div>'
}
function uit(r, t, e) {
  var n = t ? 'margin-left:2px' : ''
  return '<span style="' + e + ';' + n + '">' + Fr(r) + '</span>'
}
function cit(r, t, e, n) {
  var i = e ? '10px' : '20px',
    a = t ? 'float:right;margin-left:' + i : ''
  return (
    (r = at(r) ? r : [r]),
    '<span style="' +
      a +
      ';' +
      n +
      '">' +
      st(r, function (o) {
        return Fr(o)
      }).join('&nbsp;&nbsp;') +
      '</span>'
  )
}
function B5(r, t, e) {
  return r.markupStyleCreator.wrapRichTextStyle(t, e)
}
function hit(r, t, e, n, i) {
  var a = [i],
    o = n ? 10 : 20
  return (
    e &&
      a.push({
        padding: [0, 0, 0, o],
        align: 'right',
      }),
    r.markupStyleCreator.wrapRichTextStyle(at(t) ? t.join('  ') : t, a)
  )
}
function F5(r, t) {
  var e = r.getData().getItemVisual(t, 'style'),
    n = e[r.visualDrawType]
  return Zu(n)
}
function z5(r, t) {
  var e = r.get('padding')
  return e ?? (t === 'richText' ? [8, 10] : 10)
}
var I1 = (function () {
  function r() {
    ;(this.richTextStyles = {}), (this._nextStyleNameId = zz())
  }
  return (
    (r.prototype._generateStyleName = function () {
      return '__EC_aUTo_' + this._nextStyleNameId++
    }),
    (r.prototype.makeTooltipMarker = function (t, e, n) {
      var i = n === 'richText' ? this._generateStyleName() : null,
        a = Qnt({
          color: e,
          type: t,
          renderMode: n,
          markerId: i,
        })
      return bt(a) ? a : ((this.richTextStyles[i] = a.style), a.content)
    }),
    (r.prototype.wrapRichTextStyle = function (t, e) {
      var n = {}
      at(e)
        ? R(e, function (a) {
            return Q(n, a)
          })
        : Q(n, e)
      var i = this._generateStyleName()
      return (this.richTextStyles[i] = n), '{' + i + '|' + t + '}'
    }),
    r
  )
})()
function U5(r) {
  var t = r.series,
    e = r.dataIndex,
    n = r.multipleSeries,
    i = t.getData(),
    a = i.mapDimensionsAll('defaultedTooltip'),
    o = a.length,
    s = t.getRawValue(e),
    l = at(s),
    u = F5(t, e),
    c,
    h,
    f,
    d
  if (o > 1 || (l && !o)) {
    var p = fit(s, t, e, a, u)
    ;(c = p.inlineValues),
      (h = p.inlineValueTypes),
      (f = p.blocks),
      (d = p.inlineValues[0])
  } else if (o) {
    var g = i.getDimensionInfo(a[0])
    ;(d = c = nf(i, e, a[0])), (h = g.type)
  } else d = c = l ? s[0] : s
  var v = zT(t),
    m = (v && t.name) || '',
    y = i.getName(e),
    _ = n ? m : y
  return Kn('section', {
    header: m,
    noHeader: n || !v,
    sortParam: d,
    blocks: [
      Kn('nameValue', {
        markerType: 'item',
        markerColor: u,
        name: _,
        noName: !xa(_),
        value: c,
        valueType: h,
        dataIndex: e,
      }),
    ].concat(f || []),
  })
}
function fit(r, t, e, n, i) {
  var a = t.getData(),
    o = co(
      r,
      function (h, f, d) {
        var p = a.getDimensionInfo(d)
        return (h = h || (p && p.tooltip !== !1 && p.displayName != null))
      },
      !1,
    ),
    s = [],
    l = [],
    u = []
  n.length
    ? R(n, function (h) {
        c(nf(a, e, h), h)
      })
    : R(r, c)
  function c(h, f) {
    var d = a.getDimensionInfo(f)
    !d ||
      d.otherDims.tooltip === !1 ||
      (o
        ? u.push(
            Kn('nameValue', {
              markerType: 'subItem',
              markerColor: i,
              name: d.displayName,
              value: h,
              valueType: d.type,
            }),
          )
        : (s.push(h), l.push(d.type)))
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u,
  }
}
var _s = ve()
function Zg(r, t) {
  return r.getName(t) || r.getId(t)
}
var iy = '__universalTransitionEnabled',
  y_ = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e._selectedDataIndicesMap = {}), e
    }
    return (
      (t.prototype.init = function (e, n, i) {
        ;(this.seriesIndex = this.componentIndex),
          (this.dataTask = up({
            count: pit,
            reset: vit,
          })),
          (this.dataTask.context = {
            model: this,
          }),
          this.mergeDefaultAndTheme(e, i)
        var a = (_s(this).sourceManager = new R5(this))
        a.prepareSource()
        var o = this.getInitialData(e, i)
        _R(o, this),
          (this.dataTask.context.data = o),
          (_s(this).dataBeforeProcessed = o),
          yR(this),
          this._initSelectedMapFromData(o)
      }),
      (t.prototype.mergeDefaultAndTheme = function (e, n) {
        var i = $p(this),
          a = i ? Mf(e) : {},
          o = this.subType
        xe.hasClass(o) && (o += 'Series'),
          te(e, n.getTheme().get(this.subType)),
          te(e, this.getDefaultOption()),
          Xu(e, 'label', ['show']),
          this.fillDataTextStyle(e.data),
          i && ol(e, a, i)
      }),
      (t.prototype.mergeOption = function (e, n) {
        ;(e = te(this.option, e, !0)), this.fillDataTextStyle(e.data)
        var i = $p(this)
        i && ol(this.option, e, i)
        var a = _s(this).sourceManager
        a.dirty(), a.prepareSource()
        var o = this.getInitialData(e, n)
        _R(o, this),
          this.dataTask.dirty(),
          (this.dataTask.context.data = o),
          (_s(this).dataBeforeProcessed = o),
          yR(this),
          this._initSelectedMapFromData(o)
      }),
      (t.prototype.fillDataTextStyle = function (e) {
        if (e && !ai(e))
          for (var n = ['show'], i = 0; i < e.length; i++)
            e[i] && e[i].label && Xu(e[i], 'label', n)
      }),
      (t.prototype.getInitialData = function (e, n) {}),
      (t.prototype.appendData = function (e) {
        var n = this.getRawData()
        n.appendData(e.data)
      }),
      (t.prototype.getData = function (e) {
        var n = mw(this)
        if (n) {
          var i = n.context.data
          return e == null || !i.getLinkedData ? i : i.getLinkedData(e)
        } else return _s(this).data
      }),
      (t.prototype.getAllData = function () {
        var e = this.getData()
        return e && e.getLinkedDataAll
          ? e.getLinkedDataAll()
          : [
              {
                data: e,
              },
            ]
      }),
      (t.prototype.setData = function (e) {
        var n = mw(this)
        if (n) {
          var i = n.context
          ;(i.outputData = e), n !== this.dataTask && (i.data = e)
        }
        _s(this).data = e
      }),
      (t.prototype.getEncode = function () {
        var e = this.get('encode', !0)
        if (e) return Pt(e)
      }),
      (t.prototype.getSourceManager = function () {
        return _s(this).sourceManager
      }),
      (t.prototype.getSource = function () {
        return this.getSourceManager().getSource()
      }),
      (t.prototype.getRawData = function () {
        return _s(this).dataBeforeProcessed
      }),
      (t.prototype.getColorBy = function () {
        var e = this.get('colorBy')
        return e || 'series'
      }),
      (t.prototype.isColorBySeries = function () {
        return this.getColorBy() === 'series'
      }),
      (t.prototype.getBaseAxis = function () {
        var e = this.coordinateSystem
        return e && e.getBaseAxis && e.getBaseAxis()
      }),
      (t.prototype.formatTooltip = function (e, n, i) {
        return U5({
          series: this,
          dataIndex: e,
          multipleSeries: n,
        })
      }),
      (t.prototype.isAnimationEnabled = function () {
        var e = this.ecModel
        if (Se.node && !(e && e.ssr)) return !1
        var n = this.getShallow('animation')
        return (
          n &&
            this.getData().count() > this.getShallow('animationThreshold') &&
            (n = !1),
          !!n
        )
      }),
      (t.prototype.restoreData = function () {
        this.dataTask.dirty()
      }),
      (t.prototype.getColorFromPalette = function (e, n, i) {
        var a = this.ecModel,
          o = cC.prototype.getColorFromPalette.call(this, e, n, i)
        return o || (o = a.getColorFromPalette(e, n, i)), o
      }),
      (t.prototype.coordDimToDataDim = function (e) {
        return this.getRawData().mapDimensionsAll(e)
      }),
      (t.prototype.getProgressive = function () {
        return this.get('progressive')
      }),
      (t.prototype.getProgressiveThreshold = function () {
        return this.get('progressiveThreshold')
      }),
      (t.prototype.select = function (e, n) {
        this._innerSelect(this.getData(n), e)
      }),
      (t.prototype.unselect = function (e, n) {
        var i = this.option.selectedMap
        if (i) {
          var a = this.option.selectedMode,
            o = this.getData(n)
          if (a === 'series' || i === 'all') {
            ;(this.option.selectedMap = {}), (this._selectedDataIndicesMap = {})
            return
          }
          for (var s = 0; s < e.length; s++) {
            var l = e[s],
              u = Zg(o, l)
            ;(i[u] = !1), (this._selectedDataIndicesMap[u] = -1)
          }
        }
      }),
      (t.prototype.toggleSelect = function (e, n) {
        for (var i = [], a = 0; a < e.length; a++)
          (i[0] = e[a]),
            this.isSelected(e[a], n) ? this.unselect(i, n) : this.select(i, n)
      }),
      (t.prototype.getSelectedDataIndices = function () {
        if (this.option.selectedMap === 'all')
          return [].slice.call(this.getData().getIndices())
        for (
          var e = this._selectedDataIndicesMap, n = pe(e), i = [], a = 0;
          a < n.length;
          a++
        ) {
          var o = e[n[a]]
          o >= 0 && i.push(o)
        }
        return i
      }),
      (t.prototype.isSelected = function (e, n) {
        var i = this.option.selectedMap
        if (!i) return !1
        var a = this.getData(n)
        return (
          (i === 'all' || i[Zg(a, e)]) &&
          !a.getItemModel(e).get(['select', 'disabled'])
        )
      }),
      (t.prototype.isUniversalTransitionEnabled = function () {
        if (this[iy]) return !0
        var e = this.option.universalTransition
        return e ? (e === !0 ? !0 : e && e.enabled) : !1
      }),
      (t.prototype._innerSelect = function (e, n) {
        var i,
          a,
          o = this.option,
          s = o.selectedMode,
          l = n.length
        if (!(!s || !l)) {
          if (s === 'series') o.selectedMap = 'all'
          else if (s === 'multiple') {
            Ut(o.selectedMap) || (o.selectedMap = {})
            for (var u = o.selectedMap, c = 0; c < l; c++) {
              var h = n[c],
                f = Zg(e, h)
              ;(u[f] = !0), (this._selectedDataIndicesMap[f] = e.getRawIndex(h))
            }
          } else if (s === 'single' || s === !0) {
            var d = n[l - 1],
              f = Zg(e, d)
            ;(o.selectedMap = ((i = {}), (i[f] = !0), i)),
              (this._selectedDataIndicesMap =
                ((a = {}), (a[f] = e.getRawIndex(d)), a))
          }
        }
      }),
      (t.prototype._initSelectedMapFromData = function (e) {
        if (!this.option.selectedMap) {
          var n = []
          e.hasItemOption &&
            e.each(function (i) {
              var a = e.getRawDataItem(i)
              a && a.selected && n.push(i)
            }),
            n.length > 0 && this._innerSelect(e, n)
        }
      }),
      (t.registerClass = function (e) {
        return xe.registerClass(e)
      }),
      (t.protoInitialize = (function () {
        var e = t.prototype
        ;(e.type = 'series.__base__'),
          (e.seriesIndex = 0),
          (e.ignoreStyleOnData = !1),
          (e.hasSymbolVisual = !1),
          (e.defaultSymbol = 'circle'),
          (e.visualStyleAccessPath = 'itemStyle'),
          (e.visualDrawType = 'fill')
      })()),
      t
    )
  })(xe)
In(y_, g_)
In(y_, cC)
qz(y_, xe)
function yR(r) {
  var t = r.name
  zT(r) || (r.name = dit(r) || t)
}
function dit(r) {
  var t = r.getRawData(),
    e = t.mapDimensionsAll('seriesName'),
    n = []
  return (
    R(e, function (i) {
      var a = t.getDimensionInfo(i)
      a.displayName && n.push(a.displayName)
    }),
    n.join(' ')
  )
}
function pit(r) {
  return r.model.getRawData().count()
}
function vit(r) {
  var t = r.model
  return t.setData(t.getRawData().cloneShallow()), git
}
function git(r, t) {
  t.outputData &&
    r.end > t.outputData.count() &&
    t.model.getRawData().cloneShallow(t.outputData)
}
function _R(r, t) {
  R(ky(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function (e) {
    r.wrapMethod(e, Zt(mit, t))
  })
}
function mit(r, t) {
  var e = mw(r)
  return e && e.setOutputEnd((t || this).count()), t
}
function mw(r) {
  var t = (r.ecModel || {}).scheduler,
    e = t && t.getPipeline(r.uid)
  if (e) {
    var n = e.currentTask
    if (n) {
      var i = n.agentStubMap
      i && (n = i.get(r.uid))
    }
    return n
  }
}
const rn = y_
var vC = (function () {
  function r() {
    ;(this.group = new Ht()), (this.uid = bf('viewComponent'))
  }
  return (
    (r.prototype.init = function (t, e) {}),
    (r.prototype.render = function (t, e, n, i) {}),
    (r.prototype.dispose = function (t, e) {}),
    (r.prototype.updateView = function (t, e, n, i) {}),
    (r.prototype.updateLayout = function (t, e, n, i) {}),
    (r.prototype.updateVisual = function (t, e, n, i) {}),
    (r.prototype.toggleBlurSeries = function (t, e, n) {}),
    (r.prototype.eachRendered = function (t) {
      var e = this.group
      e && e.traverse(t)
    }),
    r
  )
})()
VT(vC)
J0(vC)
const dn = vC
function Ef() {
  var r = ve()
  return function (t) {
    var e = r(t),
      n = t.pipelineContext,
      i = !!e.large,
      a = !!e.progressiveRender,
      o = (e.large = !!(n && n.large)),
      s = (e.progressiveRender = !!(n && n.progressiveRender))
    return (i !== o || a !== s) && 'reset'
  }
}
var V5 = ve(),
  yit = Ef(),
  gC = (function () {
    function r() {
      ;(this.group = new Ht()),
        (this.uid = bf('viewChart')),
        (this.renderTask = up({
          plan: _it,
          reset: xit,
        })),
        (this.renderTask.context = {
          view: this,
        })
    }
    return (
      (r.prototype.init = function (t, e) {}),
      (r.prototype.render = function (t, e, n, i) {}),
      (r.prototype.highlight = function (t, e, n, i) {
        var a = t.getData(i && i.dataType)
        a && SR(a, i, 'emphasis')
      }),
      (r.prototype.downplay = function (t, e, n, i) {
        var a = t.getData(i && i.dataType)
        a && SR(a, i, 'normal')
      }),
      (r.prototype.remove = function (t, e) {
        this.group.removeAll()
      }),
      (r.prototype.dispose = function (t, e) {}),
      (r.prototype.updateView = function (t, e, n, i) {
        this.render(t, e, n, i)
      }),
      (r.prototype.updateLayout = function (t, e, n, i) {
        this.render(t, e, n, i)
      }),
      (r.prototype.updateVisual = function (t, e, n, i) {
        this.render(t, e, n, i)
      }),
      (r.prototype.eachRendered = function (t) {
        vl(this.group, t)
      }),
      (r.markUpdateMethod = function (t, e) {
        V5(t).updateMethod = e
      }),
      (r.protoInitialize = (function () {
        var t = r.prototype
        t.type = 'chart'
      })()),
      r
    )
  })()
function xR(r, t, e) {
  r && Wp(r) && (t === 'emphasis' ? Qo : ts)(r, e)
}
function SR(r, t, e) {
  var n = Yu(r, t),
    i = t && t.highlightKey != null ? Yet(t.highlightKey) : null
  n != null
    ? R(ke(n), function (a) {
        xR(r.getItemGraphicEl(a), e, i)
      })
    : r.eachItemGraphicEl(function (a) {
        xR(a, e, i)
      })
}
VT(gC)
J0(gC)
function _it(r) {
  return yit(r.model)
}
function xit(r) {
  var t = r.model,
    e = r.ecModel,
    n = r.api,
    i = r.payload,
    a = t.pipelineContext.progressiveRender,
    o = r.view,
    s = i && V5(i).updateMethod,
    l = a ? 'incrementalPrepareRender' : s && o[s] ? s : 'render'
  return l !== 'render' && o[l](t, e, n, i), Sit[l]
}
var Sit = {
  incrementalPrepareRender: {
    progress: function (r, t) {
      t.view.incrementalRender(r, t.model, t.ecModel, t.api, t.payload)
    },
  },
  render: {
    forceFirstProgress: !0,
    progress: function (r, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload)
    },
  },
}
const Ze = gC
var Jy = '\0__throttleOriginMethod',
  AR = '\0__throttleRate',
  bR = '\0__throttleType'
function __(r, t, e) {
  var n,
    i = 0,
    a = 0,
    o = null,
    s,
    l,
    u,
    c
  t = t || 0
  function h() {
    ;(a = new Date().getTime()), (o = null), r.apply(l, u || [])
  }
  var f = function () {
    for (var d = [], p = 0; p < arguments.length; p++) d[p] = arguments[p]
    ;(n = new Date().getTime()), (l = this), (u = d)
    var g = c || t,
      v = c || e
    ;(c = null),
      (s = n - (v ? i : a) - g),
      clearTimeout(o),
      v ? (o = setTimeout(h, g)) : s >= 0 ? h() : (o = setTimeout(h, -s)),
      (i = n)
  }
  return (
    (f.clear = function () {
      o && (clearTimeout(o), (o = null))
    }),
    (f.debounceNextCall = function (d) {
      c = d
    }),
    f
  )
}
function Df(r, t, e, n) {
  var i = r[t]
  if (i) {
    var a = i[Jy] || i,
      o = i[bR],
      s = i[AR]
    if (s !== e || o !== n) {
      if (e == null || !n) return (r[t] = a)
      ;(i = r[t] = __(a, e, n === 'debounce')),
        (i[Jy] = a),
        (i[bR] = n),
        (i[AR] = e)
    }
    return i
  }
}
function Zp(r, t) {
  var e = r[t]
  e && e[Jy] && (e.clear && e.clear(), (r[t] = e[Jy]))
}
var wR = ve(),
  MR = {
    itemStyle: $u(XU, !0),
    lineStyle: $u(WU, !0),
  },
  Ait = {
    lineStyle: 'stroke',
    itemStyle: 'fill',
  }
function G5(r, t) {
  var e = r.visualStyleMapper || MR[t]
  return e || (console.warn("Unknown style type '" + t + "'."), MR.itemStyle)
}
function H5(r, t) {
  var e = r.visualDrawType || Ait[t]
  return e || (console.warn("Unknown style type '" + t + "'."), 'fill')
}
var bit = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (r, t) {
      var e = r.getData(),
        n = r.visualStyleAccessPath || 'itemStyle',
        i = r.getModel(n),
        a = G5(r, n),
        o = a(i),
        s = i.getShallow('decal')
      s && (e.setVisual('decal', s), (s.dirty = !0))
      var l = H5(r, n),
        u = o[l],
        c = Nt(u) ? u : null,
        h = o.fill === 'auto' || o.stroke === 'auto'
      if (!o[l] || c || h) {
        var f = r.getColorFromPalette(r.name, null, t.getSeriesCount())
        o[l] || ((o[l] = f), e.setVisual('colorFromPalette', !0)),
          (o.fill = o.fill === 'auto' || Nt(o.fill) ? f : o.fill),
          (o.stroke = o.stroke === 'auto' || Nt(o.stroke) ? f : o.stroke)
      }
      if (
        (e.setVisual('style', o),
        e.setVisual('drawType', l),
        !t.isSeriesFiltered(r) && c)
      )
        return (
          e.setVisual('colorFromPalette', !1),
          {
            dataEach: function (d, p) {
              var g = r.getDataParams(p),
                v = Q({}, o)
              ;(v[l] = c(g)), d.setItemVisual(p, 'style', v)
            },
          }
        )
    },
  },
  od = new qe(),
  wit = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (r, t) {
      if (!(r.ignoreStyleOnData || t.isSeriesFiltered(r))) {
        var e = r.getData(),
          n = r.visualStyleAccessPath || 'itemStyle',
          i = G5(r, n),
          a = e.getVisual('drawType')
        return {
          dataEach: e.hasItemOption
            ? function (o, s) {
                var l = o.getRawDataItem(s)
                if (l && l[n]) {
                  od.option = l[n]
                  var u = i(od),
                    c = o.ensureUniqueItemVisual(s, 'style')
                  Q(c, u),
                    od.option.decal &&
                      (o.setItemVisual(s, 'decal', od.option.decal),
                      (od.option.decal.dirty = !0)),
                    a in u && o.setItemVisual(s, 'colorFromPalette', !1)
                }
              }
            : null,
        }
      }
    },
  },
  Mit = {
    performRawSeries: !0,
    overallReset: function (r) {
      var t = Pt()
      r.eachSeries(function (e) {
        var n = e.getColorBy()
        if (!e.isColorBySeries()) {
          var i = e.type + '-' + n,
            a = t.get(i)
          a || ((a = {}), t.set(i, a)), (wR(e).scope = a)
        }
      }),
        r.eachSeries(function (e) {
          if (!(e.isColorBySeries() || r.isSeriesFiltered(e))) {
            var n = e.getRawData(),
              i = {},
              a = e.getData(),
              o = wR(e).scope,
              s = e.visualStyleAccessPath || 'itemStyle',
              l = H5(e, s)
            a.each(function (u) {
              var c = a.getRawIndex(u)
              i[c] = u
            }),
              n.each(function (u) {
                var c = i[u],
                  h = a.getItemVisual(c, 'colorFromPalette')
                if (h) {
                  var f = a.ensureUniqueItemVisual(c, 'style'),
                    d = n.getName(u) || u + '',
                    p = n.count()
                  f[l] = e.getColorFromPalette(d, o, p)
                }
              })
          }
        })
    },
  },
  Kg = Math.PI
function Tit(r, t) {
  ;(t = t || {}),
    zt(t, {
      text: 'loading',
      textColor: '#000',
      fontSize: 12,
      fontWeight: 'normal',
      fontStyle: 'normal',
      fontFamily: 'sans-serif',
      maskColor: 'rgba(255, 255, 255, 0.8)',
      showSpinner: !0,
      color: '#5470c6',
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0,
    })
  var e = new Ht(),
    n = new ge({
      style: {
        fill: t.maskColor,
      },
      zlevel: t.zlevel,
      z: 1e4,
    })
  e.add(n)
  var i = new Ae({
      style: {
        text: t.text,
        fill: t.textColor,
        fontSize: t.fontSize,
        fontWeight: t.fontWeight,
        fontStyle: t.fontStyle,
        fontFamily: t.fontFamily,
      },
      zlevel: t.zlevel,
      z: 10001,
    }),
    a = new ge({
      style: {
        fill: 'none',
      },
      textContent: i,
      textConfig: {
        position: 'right',
        distance: 10,
      },
      zlevel: t.zlevel,
      z: 10001,
    })
  e.add(a)
  var o
  return (
    t.showSpinner &&
      ((o = new jT({
        shape: {
          startAngle: -Kg / 2,
          endAngle: -Kg / 2 + 0.1,
          r: t.spinnerRadius,
        },
        style: {
          stroke: t.color,
          lineCap: 'round',
          lineWidth: t.lineWidth,
        },
        zlevel: t.zlevel,
        z: 10001,
      })),
      o
        .animateShape(!0)
        .when(1e3, {
          endAngle: (Kg * 3) / 2,
        })
        .start('circularInOut'),
      o
        .animateShape(!0)
        .when(1e3, {
          startAngle: (Kg * 3) / 2,
        })
        .delay(300)
        .start('circularInOut'),
      e.add(o)),
    (e.resize = function () {
      var s = i.getBoundingRect().width,
        l = t.showSpinner ? t.spinnerRadius : 0,
        u =
          (r.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 -
          (t.showSpinner && s ? 0 : 5 + s / 2) +
          (t.showSpinner ? 0 : s / 2) +
          (s ? 0 : l),
        c = r.getHeight() / 2
      t.showSpinner &&
        o.setShape({
          cx: u,
          cy: c,
        }),
        a.setShape({
          x: u - l,
          y: c - l,
          width: l * 2,
          height: l * 2,
        }),
        n.setShape({
          x: 0,
          y: 0,
          width: r.getWidth(),
          height: r.getHeight(),
        })
    }),
    e.resize(),
    e
  )
}
var Cit = (function () {
  function r(t, e, n, i) {
    ;(this._stageTaskMap = Pt()),
      (this.ecInstance = t),
      (this.api = e),
      (n = this._dataProcessorHandlers = n.slice()),
      (i = this._visualHandlers = i.slice()),
      (this._allHandlers = n.concat(i))
  }
  return (
    (r.prototype.restoreData = function (t, e) {
      t.restoreData(e),
        this._stageTaskMap.each(function (n) {
          var i = n.overallTask
          i && i.dirty()
        })
    }),
    (r.prototype.getPerformArgs = function (t, e) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id),
          i = n.context,
          a =
            !e &&
            n.progressiveEnabled &&
            (!i || i.progressiveRender) &&
            t.__idxInPipeline > n.blockIndex,
          o = a ? n.step : null,
          s = i && i.modDataCount,
          l = s != null ? Math.ceil(s / o) : null
        return {
          step: o,
          modBy: l,
          modDataCount: s,
        }
      }
    }),
    (r.prototype.getPipeline = function (t) {
      return this._pipelineMap.get(t)
    }),
    (r.prototype.updateStreamModes = function (t, e) {
      var n = this._pipelineMap.get(t.uid),
        i = t.getData(),
        a = i.count(),
        o =
          n.progressiveEnabled &&
          e.incrementalPrepareRender &&
          a >= n.threshold,
        s = t.get('large') && a >= t.get('largeThreshold'),
        l = t.get('progressiveChunkMode') === 'mod' ? a : null
      t.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s,
      }
    }),
    (r.prototype.restorePipelines = function (t) {
      var e = this,
        n = (e._pipelineMap = Pt())
      t.eachSeries(function (i) {
        var a = i.getProgressive(),
          o = i.uid
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled:
            a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0,
        }),
          e._pipe(i, i.dataTask)
      })
    }),
    (r.prototype.prepareStageTasks = function () {
      var t = this._stageTaskMap,
        e = this.api.getModel(),
        n = this.api
      R(
        this._allHandlers,
        function (i) {
          var a = t.get(i.uid) || t.set(i.uid, {}),
            o = ''
          Gr(!(i.reset && i.overallReset), o),
            i.reset && this._createSeriesStageTask(i, a, e, n),
            i.overallReset && this._createOverallStageTask(i, a, e, n)
        },
        this,
      )
    }),
    (r.prototype.prepareView = function (t, e, n, i) {
      var a = t.renderTask,
        o = a.context
      ;(o.model = e),
        (o.ecModel = n),
        (o.api = i),
        (a.__block = !t.incrementalPrepareRender),
        this._pipe(e, a)
    }),
    (r.prototype.performDataProcessorTasks = function (t, e) {
      this._performStageTasks(this._dataProcessorHandlers, t, e, {
        block: !0,
      })
    }),
    (r.prototype.performVisualTasks = function (t, e, n) {
      this._performStageTasks(this._visualHandlers, t, e, n)
    }),
    (r.prototype._performStageTasks = function (t, e, n, i) {
      i = i || {}
      var a = !1,
        o = this
      R(t, function (l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid),
            h = c.seriesTaskMap,
            f = c.overallTask
          if (f) {
            var d,
              p = f.agentStubMap
            p.each(function (v) {
              s(i, v) && (v.dirty(), (d = !0))
            }),
              d && f.dirty(),
              o.updatePayload(f, n)
            var g = o.getPerformArgs(f, i.block)
            p.each(function (v) {
              v.perform(g)
            }),
              f.perform(g) && (a = !0)
          } else
            h &&
              h.each(function (v, m) {
                s(i, v) && v.dirty()
                var y = o.getPerformArgs(v, i.block)
                ;(y.skip =
                  !l.performRawSeries && e.isSeriesFiltered(v.context.model)),
                  o.updatePayload(v, n),
                  v.perform(y) && (a = !0)
              })
        }
      })
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id))
      }
      this.unfinished = a || this.unfinished
    }),
    (r.prototype.performSeriesTasks = function (t) {
      var e
      t.eachSeries(function (n) {
        e = n.dataTask.perform() || e
      }),
        (this.unfinished = e || this.unfinished)
    }),
    (r.prototype.plan = function () {
      this._pipelineMap.each(function (t) {
        var e = t.tail
        do {
          if (e.__block) {
            t.blockIndex = e.__idxInPipeline
            break
          }
          e = e.getUpstream()
        } while (e)
      })
    }),
    (r.prototype.updatePayload = function (t, e) {
      e !== 'remain' && (t.context.payload = e)
    }),
    (r.prototype._createSeriesStageTask = function (t, e, n, i) {
      var a = this,
        o = e.seriesTaskMap,
        s = (e.seriesTaskMap = Pt()),
        l = t.seriesType,
        u = t.getTargetSeries
      t.createOnAllSeries
        ? n.eachRawSeries(c)
        : l
        ? n.eachRawSeriesByType(l, c)
        : u && u(n, i).each(c)
      function c(h) {
        var f = h.uid,
          d = s.set(
            f,
            (o && o.get(f)) ||
              up({
                plan: Rit,
                reset: Iit,
                count: Nit,
              }),
          )
        ;(d.context = {
          model: h,
          ecModel: n,
          api: i,
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a,
        }),
          a._pipe(h, d)
      }
    }),
    (r.prototype._createOverallStageTask = function (t, e, n, i) {
      var a = this,
        o = (e.overallTask =
          e.overallTask ||
          up({
            reset: Eit,
          }))
      o.context = {
        ecModel: n,
        api: i,
        overallReset: t.overallReset,
        scheduler: a,
      }
      var s = o.agentStubMap,
        l = (o.agentStubMap = Pt()),
        u = t.seriesType,
        c = t.getTargetSeries,
        h = !0,
        f = !1,
        d = ''
      Gr(!t.createOnAllSeries, d),
        u
          ? n.eachRawSeriesByType(u, p)
          : c
          ? c(n, i).each(p)
          : ((h = !1), R(n.getSeries(), p))
      function p(g) {
        var v = g.uid,
          m = l.set(
            v,
            (s && s.get(v)) ||
              ((f = !0),
              up({
                reset: Dit,
                onDirty: Pit,
              })),
          )
        ;(m.context = {
          model: g,
          overallProgress: h,
        }),
          (m.agent = o),
          (m.__block = h),
          a._pipe(g, m)
      }
      f && o.dirty()
    }),
    (r.prototype._pipe = function (t, e) {
      var n = t.uid,
        i = this._pipelineMap.get(n)
      !i.head && (i.head = e),
        i.tail && i.tail.pipe(e),
        (i.tail = e),
        (e.__idxInPipeline = i.count++),
        (e.__pipeline = i)
    }),
    (r.wrapStageHandler = function (t, e) {
      return (
        Nt(t) &&
          (t = {
            overallReset: t,
            seriesType: kit(t),
          }),
        (t.uid = bf('stageHandler')),
        e && (t.visualType = e),
        t
      )
    }),
    r
  )
})()
function Eit(r) {
  r.overallReset(r.ecModel, r.api, r.payload)
}
function Dit(r) {
  return r.overallProgress && Lit
}
function Lit() {
  this.agent.dirty(), this.getDownstream().dirty()
}
function Pit() {
  this.agent && this.agent.dirty()
}
function Rit(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null
}
function Iit(r) {
  r.useClearVisual && r.data.clearAllVisual()
  var t = (r.resetDefines = ke(r.reset(r.model, r.ecModel, r.api, r.payload)))
  return t.length > 1
    ? st(t, function (e, n) {
        return W5(n)
      })
    : Oit
}
var Oit = W5(0)
function W5(r) {
  return function (t, e) {
    var n = e.data,
      i = e.resetDefines[r]
    if (i && i.dataEach) for (var a = t.start; a < t.end; a++) i.dataEach(n, a)
    else i && i.progress && i.progress(t, n)
  }
}
function Nit(r) {
  return r.data.count()
}
function kit(r) {
  Qy = null
  try {
    r(Kp, X5)
  } catch {}
  return Qy
}
var Kp = {},
  X5 = {},
  Qy
Y5(Kp, g5)
Y5(X5, m5)
Kp.eachSeriesByType = Kp.eachRawSeriesByType = function (r) {
  Qy = r
}
Kp.eachComponent = function (r) {
  r.mainType === 'series' && r.subType && (Qy = r.subType)
}
function Y5(r, t) {
  for (var e in t.prototype) r[e] = wn
}
const $5 = Cit
var TR = [
  '#37A2DA',
  '#32C5E9',
  '#67E0E3',
  '#9FE6B8',
  '#FFDB5C',
  '#ff9f7f',
  '#fb7293',
  '#E062AE',
  '#E690D1',
  '#e7bcf3',
  '#9d96f5',
  '#8378EA',
  '#96BFFF',
]
const Bit = {
  color: TR,
  colorLayer: [
    ['#37A2DA', '#ffd85c', '#fd7b5f'],
    ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'],
    [
      '#37A2DA',
      '#32C5E9',
      '#9FE6B8',
      '#FFDB5C',
      '#ff9f7f',
      '#fb7293',
      '#e7bcf3',
      '#8378EA',
      '#96BFFF',
    ],
    TR,
  ],
}
var Rr = '#B9B8CE',
  CR = '#100C2A',
  jg = function () {
    return {
      axisLine: {
        lineStyle: {
          color: Rr,
        },
      },
      splitLine: {
        lineStyle: {
          color: '#484753',
        },
      },
      splitArea: {
        areaStyle: {
          color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)'],
        },
      },
      minorSplitLine: {
        lineStyle: {
          color: '#20203B',
        },
      },
    }
  },
  ER = [
    '#4992ff',
    '#7cffb2',
    '#fddd60',
    '#ff6e76',
    '#58d9f9',
    '#05c091',
    '#ff8a45',
    '#8d48e3',
    '#dd79ff',
  ],
  q5 = {
    darkMode: !0,
    color: ER,
    backgroundColor: CR,
    axisPointer: {
      lineStyle: {
        color: '#817f91',
      },
      crossStyle: {
        color: '#817f91',
      },
      label: {
        color: '#fff',
      },
    },
    legend: {
      textStyle: {
        color: Rr,
      },
    },
    textStyle: {
      color: Rr,
    },
    title: {
      textStyle: {
        color: '#EEF1FA',
      },
      subtextStyle: {
        color: '#B9B8CE',
      },
    },
    toolbox: {
      iconStyle: {
        borderColor: Rr,
      },
    },
    dataZoom: {
      borderColor: '#71708A',
      textStyle: {
        color: Rr,
      },
      brushStyle: {
        color: 'rgba(135,163,206,0.3)',
      },
      handleStyle: {
        color: '#353450',
        borderColor: '#C5CBE3',
      },
      moveHandleStyle: {
        color: '#B0B6C3',
        opacity: 0.3,
      },
      fillerColor: 'rgba(135,163,206,0.2)',
      emphasis: {
        handleStyle: {
          borderColor: '#91B7F2',
          color: '#4D587D',
        },
        moveHandleStyle: {
          color: '#636D9A',
          opacity: 0.7,
        },
      },
      dataBackground: {
        lineStyle: {
          color: '#71708A',
          width: 1,
        },
        areaStyle: {
          color: '#71708A',
        },
      },
      selectedDataBackground: {
        lineStyle: {
          color: '#87A3CE',
        },
        areaStyle: {
          color: '#87A3CE',
        },
      },
    },
    visualMap: {
      textStyle: {
        color: Rr,
      },
    },
    timeline: {
      lineStyle: {
        color: Rr,
      },
      label: {
        color: Rr,
      },
      controlStyle: {
        color: Rr,
        borderColor: Rr,
      },
    },
    calendar: {
      itemStyle: {
        color: CR,
      },
      dayLabel: {
        color: Rr,
      },
      monthLabel: {
        color: Rr,
      },
      yearLabel: {
        color: Rr,
      },
    },
    timeAxis: jg(),
    logAxis: jg(),
    valueAxis: jg(),
    categoryAxis: jg(),
    line: {
      symbol: 'circle',
    },
    graph: {
      color: ER,
    },
    gauge: {
      title: {
        color: Rr,
      },
      axisLine: {
        lineStyle: {
          color: [[1, 'rgba(207,212,219,0.2)']],
        },
      },
      axisLabel: {
        color: Rr,
      },
      detail: {
        color: '#EEF1FA',
      },
    },
    candlestick: {
      itemStyle: {
        color: '#f64e56',
        color0: '#54ea92',
        borderColor: '#f64e56',
        borderColor0: '#54ea92',
      },
    },
  }
q5.categoryAxis.splitLine.show = !1
const Fit = q5
var zit = (function () {
    function r() {}
    return (
      (r.prototype.normalizeQuery = function (t) {
        var e = {},
          n = {},
          i = {}
        if (bt(t)) {
          var a = to(t)
          ;(e.mainType = a.main || null), (e.subType = a.sub || null)
        } else {
          var o = ['Index', 'Name', 'Id'],
            s = {
              name: 1,
              dataIndex: 1,
              dataType: 1,
            }
          R(t, function (l, u) {
            for (var c = !1, h = 0; h < o.length; h++) {
              var f = o[h],
                d = u.lastIndexOf(f)
              if (d > 0 && d === u.length - f.length) {
                var p = u.slice(0, d)
                p !== 'data' &&
                  ((e.mainType = p), (e[f.toLowerCase()] = l), (c = !0))
              }
            }
            s.hasOwnProperty(u) && ((n[u] = l), (c = !0)), c || (i[u] = l)
          })
        }
        return {
          cptQuery: e,
          dataQuery: n,
          otherQuery: i,
        }
      }),
      (r.prototype.filter = function (t, e) {
        var n = this.eventInfo
        if (!n) return !0
        var i = n.targetEl,
          a = n.packedEvent,
          o = n.model,
          s = n.view
        if (!o || !s) return !0
        var l = e.cptQuery,
          u = e.dataQuery
        return (
          c(l, o, 'mainType') &&
          c(l, o, 'subType') &&
          c(l, o, 'index', 'componentIndex') &&
          c(l, o, 'name') &&
          c(l, o, 'id') &&
          c(u, a, 'name') &&
          c(u, a, 'dataIndex') &&
          c(u, a, 'dataType') &&
          (!s.filterForExposedEvent ||
            s.filterForExposedEvent(t, e.otherQuery, i, a))
        )
        function c(h, f, d, p) {
          return h[d] == null || f[p || d] === h[d]
        }
      }),
      (r.prototype.afterTrigger = function () {
        this.eventInfo = null
      }),
      r
    )
  })(),
  yw = ['symbol', 'symbolSize', 'symbolRotate', 'symbolOffset'],
  DR = yw.concat(['symbolKeepAspect']),
  Uit = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (r, t) {
      var e = r.getData()
      if (
        (r.legendIcon && e.setVisual('legendIcon', r.legendIcon),
        !r.hasSymbolVisual)
      )
        return
      for (var n = {}, i = {}, a = !1, o = 0; o < yw.length; o++) {
        var s = yw[o],
          l = r.get(s)
        Nt(l) ? ((a = !0), (i[s] = l)) : (n[s] = l)
      }
      if (
        ((n.symbol = n.symbol || r.defaultSymbol),
        e.setVisual(
          Q(
            {
              legendIcon: r.legendIcon || n.symbol,
              symbolKeepAspect: r.get('symbolKeepAspect'),
            },
            n,
          ),
        ),
        t.isSeriesFiltered(r))
      )
        return
      var u = pe(i)
      function c(h, f) {
        for (
          var d = r.getRawValue(f), p = r.getDataParams(f), g = 0;
          g < u.length;
          g++
        ) {
          var v = u[g]
          h.setItemVisual(f, v, i[v](d, p))
        }
      }
      return {
        dataEach: a ? c : null,
      }
    },
  },
  Vit = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (r, t) {
      if (!r.hasSymbolVisual || t.isSeriesFiltered(r)) return
      var e = r.getData()
      function n(i, a) {
        for (var o = i.getItemModel(a), s = 0; s < DR.length; s++) {
          var l = DR[s],
            u = o.getShallow(l, !0)
          u != null && i.setItemVisual(a, l, u)
        }
      }
      return {
        dataEach: e.hasItemOption ? n : null,
      }
    },
  }
function mC(r, t, e) {
  switch (e) {
    case 'color':
      var n = r.getItemVisual(t, 'style')
      return n[r.getVisual('drawType')]
    case 'opacity':
      return r.getItemVisual(t, 'style').opacity
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return r.getItemVisual(t, e)
  }
}
function bv(r, t) {
  switch (t) {
    case 'color':
      var e = r.getVisual('style')
      return e[r.getVisual('drawType')]
    case 'opacity':
      return r.getVisual('style').opacity
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return r.getVisual(t)
  }
}
function Z5(r, t, e, n) {
  switch (e) {
    case 'color':
      var i = r.ensureUniqueItemVisual(t, 'style')
      ;(i[r.getVisual('drawType')] = n),
        r.setItemVisual(t, 'colorFromPalette', !1)
      break
    case 'opacity':
      r.ensureUniqueItemVisual(t, 'style').opacity = n
      break
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      r.setItemVisual(t, e, n)
      break
  }
}
function K5(r, t) {
  function e(n, i) {
    var a = []
    return (
      n.eachComponent(
        {
          mainType: 'series',
          subType: r,
          query: i,
        },
        function (o) {
          a.push(o.seriesIndex)
        },
      ),
      a
    )
  }
  R(
    [
      [r + 'ToggleSelect', 'toggleSelect'],
      [r + 'Select', 'select'],
      [r + 'UnSelect', 'unselect'],
    ],
    function (n) {
      t(n[0], function (i, a, o) {
        ;(i = Q({}, i)),
          o.dispatchAction(
            Q(i, {
              type: n[1],
              seriesIndex: e(a, i),
            }),
          )
      })
    },
  )
}
function $c(r, t, e, n, i) {
  var a = r + t
  e.isSilent(a) ||
    n.eachComponent(
      {
        mainType: 'series',
        subType: 'pie',
      },
      function (o) {
        for (
          var s = o.seriesIndex,
            l = o.option.selectedMap,
            u = i.selected,
            c = 0;
          c < u.length;
          c++
        )
          if (u[c].seriesIndex === s) {
            var h = o.getData(),
              f = Yu(h, i.fromActionPayload)
            e.trigger(a, {
              type: a,
              seriesId: o.id,
              name: at(f) ? h.getName(f[0]) : h.getName(f),
              selected: bt(l) ? l : Q({}, l),
            })
          }
      },
    )
}
function Git(r, t, e) {
  r.on('selectchanged', function (n) {
    var i = e.getModel()
    n.isFromClick
      ? ($c('map', 'selectchanged', t, i, n),
        $c('pie', 'selectchanged', t, i, n))
      : n.fromAction === 'select'
      ? ($c('map', 'selected', t, i, n), $c('pie', 'selected', t, i, n))
      : n.fromAction === 'unselect' &&
        ($c('map', 'unselected', t, i, n), $c('pie', 'unselected', t, i, n))
  })
}
function xu(r, t, e) {
  for (var n; r && !(t(r) && ((n = r), e)); ) r = r.__hostTarget || r.parent
  return n
}
var Hit = Math.round(Math.random() * 9),
  Wit = typeof Object.defineProperty == 'function',
  Xit = (function () {
    function r() {
      this._id = '__ec_inner_' + Hit++
    }
    return (
      (r.prototype.get = function (t) {
        return this._guard(t)[this._id]
      }),
      (r.prototype.set = function (t, e) {
        var n = this._guard(t)
        return (
          Wit
            ? Object.defineProperty(n, this._id, {
                value: e,
                enumerable: !1,
                configurable: !0,
              })
            : (n[this._id] = e),
          this
        )
      }),
      (r.prototype.delete = function (t) {
        return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1
      }),
      (r.prototype.has = function (t) {
        return !!this._guard(t)[this._id]
      }),
      (r.prototype._guard = function (t) {
        if (t !== Object(t))
          throw TypeError('Value of WeakMap is not a non-null object.')
        return t
      }),
      r
    )
  })()
const Yit = Xit
var $it = oe.extend({
    type: 'triangle',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0,
    },
    buildPath: function (r, t) {
      var e = t.cx,
        n = t.cy,
        i = t.width / 2,
        a = t.height / 2
      r.moveTo(e, n - a),
        r.lineTo(e + i, n + a),
        r.lineTo(e - i, n + a),
        r.closePath()
    },
  }),
  qit = oe.extend({
    type: 'diamond',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0,
    },
    buildPath: function (r, t) {
      var e = t.cx,
        n = t.cy,
        i = t.width / 2,
        a = t.height / 2
      r.moveTo(e, n - a),
        r.lineTo(e + i, n),
        r.lineTo(e, n + a),
        r.lineTo(e - i, n),
        r.closePath()
    },
  }),
  Zit = oe.extend({
    type: 'pin',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
    },
    buildPath: function (r, t) {
      var e = t.x,
        n = t.y,
        i = (t.width / 5) * 3,
        a = Math.max(i, t.height),
        o = i / 2,
        s = (o * o) / (a - o),
        l = n - a + o + s,
        u = Math.asin(s / o),
        c = Math.cos(u) * o,
        h = Math.sin(u),
        f = Math.cos(u),
        d = o * 0.6,
        p = o * 0.7
      r.moveTo(e - c, l + s),
        r.arc(e, l, o, Math.PI - u, Math.PI * 2 + u),
        r.bezierCurveTo(e + c - h * d, l + s + f * d, e, n - p, e, n),
        r.bezierCurveTo(e, n - p, e - c + h * d, l + s + f * d, e - c, l + s),
        r.closePath()
    },
  }),
  Kit = oe.extend({
    type: 'arrow',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
    },
    buildPath: function (r, t) {
      var e = t.height,
        n = t.width,
        i = t.x,
        a = t.y,
        o = (n / 3) * 2
      r.moveTo(i, a),
        r.lineTo(i + o, a + e),
        r.lineTo(i, a + (e / 4) * 3),
        r.lineTo(i - o, a + e),
        r.lineTo(i, a),
        r.closePath()
    },
  }),
  jit = {
    line: rr,
    rect: ge,
    roundRect: ge,
    square: ge,
    circle: pl,
    diamond: qit,
    pin: Zit,
    arrow: Kit,
    triangle: $it,
  },
  Jit = {
    line: function (r, t, e, n, i) {
      ;(i.x1 = r), (i.y1 = t + n / 2), (i.x2 = r + e), (i.y2 = t + n / 2)
    },
    rect: function (r, t, e, n, i) {
      ;(i.x = r), (i.y = t), (i.width = e), (i.height = n)
    },
    roundRect: function (r, t, e, n, i) {
      ;(i.x = r),
        (i.y = t),
        (i.width = e),
        (i.height = n),
        (i.r = Math.min(e, n) / 4)
    },
    square: function (r, t, e, n, i) {
      var a = Math.min(e, n)
      ;(i.x = r), (i.y = t), (i.width = a), (i.height = a)
    },
    circle: function (r, t, e, n, i) {
      ;(i.cx = r + e / 2), (i.cy = t + n / 2), (i.r = Math.min(e, n) / 2)
    },
    diamond: function (r, t, e, n, i) {
      ;(i.cx = r + e / 2), (i.cy = t + n / 2), (i.width = e), (i.height = n)
    },
    pin: function (r, t, e, n, i) {
      ;(i.x = r + e / 2), (i.y = t + n / 2), (i.width = e), (i.height = n)
    },
    arrow: function (r, t, e, n, i) {
      ;(i.x = r + e / 2), (i.y = t + n / 2), (i.width = e), (i.height = n)
    },
    triangle: function (r, t, e, n, i) {
      ;(i.cx = r + e / 2), (i.cy = t + n / 2), (i.width = e), (i.height = n)
    },
  },
  t0 = {}
R(jit, function (r, t) {
  t0[t] = new r()
})
var Qit = oe.extend({
  type: 'symbol',
  shape: {
    symbolType: '',
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  },
  calculateTextPosition: function (r, t, e) {
    var n = Hy(r, t, e),
      i = this.shape
    return (
      i &&
        i.symbolType === 'pin' &&
        t.position === 'inside' &&
        (n.y = e.y + e.height * 0.4),
      n
    )
  },
  buildPath: function (r, t, e) {
    var n = t.symbolType
    if (n !== 'none') {
      var i = t0[n]
      i || ((n = 'rect'), (i = t0[n])),
        Jit[n](t.x, t.y, t.width, t.height, i.shape),
        i.buildPath(r, i.shape, e)
    }
  },
})
function tat(r, t) {
  if (this.type !== 'image') {
    var e = this.style
    this.__isEmptyBrush
      ? ((e.stroke = r), (e.fill = t || '#fff'), (e.lineWidth = 2))
      : this.shape.symbolType === 'line'
      ? (e.stroke = r)
      : (e.fill = r),
      this.markRedraw()
  }
}
function Rn(r, t, e, n, i, a, o) {
  var s = r.indexOf('empty') === 0
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6))
  var l
  return (
    r.indexOf('image://') === 0
      ? (l = kU(r.slice(8), new ee(t, e, n, i), o ? 'center' : 'cover'))
      : r.indexOf('path://') === 0
      ? (l = o_(r.slice(7), {}, new ee(t, e, n, i), o ? 'center' : 'cover'))
      : (l = new Qit({
          shape: {
            symbolType: r,
            x: t,
            y: e,
            width: n,
            height: i,
          },
        })),
    (l.__isEmptyBrush = s),
    (l.setColor = tat),
    a && l.setColor(a),
    l
  )
}
function Lf(r) {
  return at(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0]
}
function ic(r, t) {
  if (r != null)
    return (
      at(r) || (r = [r, r]),
      [_t(r[0], t[0]) || 0, _t($t(r[1], r[0]), t[1]) || 0]
    )
}
function Su(r) {
  return isFinite(r)
}
function eat(r, t, e) {
  var n = t.x == null ? 0 : t.x,
    i = t.x2 == null ? 1 : t.x2,
    a = t.y == null ? 0 : t.y,
    o = t.y2 == null ? 0 : t.y2
  t.global ||
    ((n = n * e.width + e.x),
    (i = i * e.width + e.x),
    (a = a * e.height + e.y),
    (o = o * e.height + e.y)),
    (n = Su(n) ? n : 0),
    (i = Su(i) ? i : 1),
    (a = Su(a) ? a : 0),
    (o = Su(o) ? o : 0)
  var s = r.createLinearGradient(n, a, i, o)
  return s
}
function nat(r, t, e) {
  var n = e.width,
    i = e.height,
    a = Math.min(n, i),
    o = t.x == null ? 0.5 : t.x,
    s = t.y == null ? 0.5 : t.y,
    l = t.r == null ? 0.5 : t.r
  t.global || ((o = o * n + e.x), (s = s * i + e.y), (l = l * a)),
    (o = Su(o) ? o : 0.5),
    (s = Su(s) ? s : 0.5),
    (l = l >= 0 && Su(l) ? l : 0.5)
  var u = r.createRadialGradient(o, s, 0, o, s, l)
  return u
}
function _w(r, t, e) {
  for (
    var n = t.type === 'radial' ? nat(r, t, e) : eat(r, t, e),
      i = t.colorStops,
      a = 0;
    a < i.length;
    a++
  )
    n.addColorStop(i[a].offset, i[a].color)
  return n
}
function rat(r, t) {
  if (r === t || (!r && !t)) return !1
  if (!r || !t || r.length !== t.length) return !0
  for (var e = 0; e < r.length; e++) if (r[e] !== t[e]) return !0
  return !1
}
function Jg(r) {
  return parseInt(r, 10)
}
function xh(r, t, e) {
  var n = ['width', 'height'][t],
    i = ['clientWidth', 'clientHeight'][t],
    a = ['paddingLeft', 'paddingTop'][t],
    o = ['paddingRight', 'paddingBottom'][t]
  if (e[n] != null && e[n] !== 'auto') return parseFloat(e[n])
  var s = document.defaultView.getComputedStyle(r)
  return (
    ((r[i] || Jg(s[n]) || Jg(r.style[n])) - (Jg(s[a]) || 0) - (Jg(s[o]) || 0)) |
    0
  )
}
function iat(r, t) {
  return !r || r === 'solid' || !(t > 0)
    ? null
    : r === 'dashed'
    ? [4 * t, 2 * t]
    : r === 'dotted'
    ? [t]
    : be(r)
    ? [r]
    : at(r)
    ? r
    : null
}
function yC(r) {
  var t = r.style,
    e = t.lineDash && t.lineWidth > 0 && iat(t.lineDash, t.lineWidth),
    n = t.lineDashOffset
  if (e) {
    var i = t.strokeNoScale && r.getLineScale ? r.getLineScale() : 1
    i &&
      i !== 1 &&
      ((e = st(e, function (a) {
        return a / i
      })),
      (n /= i))
  }
  return [e, n]
}
var aat = new vo(!0)
function e0(r) {
  var t = r.stroke
  return !(t == null || t === 'none' || !(r.lineWidth > 0))
}
function LR(r) {
  return typeof r == 'string' && r !== 'none'
}
function n0(r) {
  var t = r.fill
  return t != null && t !== 'none'
}
function PR(r, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var e = r.globalAlpha
    ;(r.globalAlpha = t.fillOpacity * t.opacity), r.fill(), (r.globalAlpha = e)
  } else r.fill()
}
function RR(r, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var e = r.globalAlpha
    ;(r.globalAlpha = t.strokeOpacity * t.opacity),
      r.stroke(),
      (r.globalAlpha = e)
  } else r.stroke()
}
function xw(r, t, e) {
  var n = GT(t.image, t.__image, e)
  if (Q0(n)) {
    var i = r.createPattern(n, t.repeat || 'repeat')
    if (typeof DOMMatrix == 'function' && i && i.setTransform) {
      var a = new DOMMatrix()
      a.translateSelf(t.x || 0, t.y || 0),
        a.rotateSelf(0, 0, (t.rotation || 0) * Wm),
        a.scaleSelf(t.scaleX || 1, t.scaleY || 1),
        i.setTransform(a)
    }
    return i
  }
}
function oat(r, t, e, n) {
  var i,
    a = e0(e),
    o = n0(e),
    s = e.strokePercent,
    l = s < 1,
    u = !t.path
  ;(!t.silent || l) && u && t.createPathProxy()
  var c = t.path || aat,
    h = t.__dirty
  if (!n) {
    var f = e.fill,
      d = e.stroke,
      p = o && !!f.colorStops,
      g = a && !!d.colorStops,
      v = o && !!f.image,
      m = a && !!d.image,
      y = void 0,
      _ = void 0,
      x = void 0,
      A = void 0,
      S = void 0
    ;(p || g) && (S = t.getBoundingRect()),
      p &&
        ((y = h ? _w(r, f, S) : t.__canvasFillGradient),
        (t.__canvasFillGradient = y)),
      g &&
        ((_ = h ? _w(r, d, S) : t.__canvasStrokeGradient),
        (t.__canvasStrokeGradient = _)),
      v &&
        ((x =
          h || !t.__canvasFillPattern ? xw(r, f, t) : t.__canvasFillPattern),
        (t.__canvasFillPattern = x)),
      m &&
        ((A =
          h || !t.__canvasStrokePattern
            ? xw(r, d, t)
            : t.__canvasStrokePattern),
        (t.__canvasStrokePattern = x)),
      p ? (r.fillStyle = y) : v && (x ? (r.fillStyle = x) : (o = !1)),
      g ? (r.strokeStyle = _) : m && (A ? (r.strokeStyle = A) : (a = !1))
  }
  var b = t.getGlobalScale()
  c.setScale(b[0], b[1], t.segmentIgnoreThreshold)
  var T, w
  r.setLineDash && e.lineDash && ((i = yC(t)), (T = i[0]), (w = i[1]))
  var M = !0
  ;(u || h & oh) &&
    (c.setDPR(r.dpr),
    l ? c.setContext(null) : (c.setContext(r), (M = !1)),
    c.reset(),
    t.buildPath(c, t.shape, n),
    c.toStatic(),
    t.pathUpdated()),
    M && c.rebuildPath(r, l ? s : 1),
    T && (r.setLineDash(T), (r.lineDashOffset = w)),
    n ||
      (e.strokeFirst
        ? (a && RR(r, e), o && PR(r, e))
        : (o && PR(r, e), a && RR(r, e))),
    T && r.setLineDash([])
}
function sat(r, t, e) {
  var n = (t.__image = GT(e.image, t.__image, t, t.onload))
  if (!(!n || !Q0(n))) {
    var i = e.x || 0,
      a = e.y || 0,
      o = t.getWidth(),
      s = t.getHeight(),
      l = n.width / n.height
    if (
      (o == null && s != null
        ? (o = s * l)
        : s == null && o != null
        ? (s = o / l)
        : o == null && s == null && ((o = n.width), (s = n.height)),
      e.sWidth && e.sHeight)
    ) {
      var u = e.sx || 0,
        c = e.sy || 0
      r.drawImage(n, u, c, e.sWidth, e.sHeight, i, a, o, s)
    } else if (e.sx && e.sy) {
      var u = e.sx,
        c = e.sy,
        h = o - u,
        f = s - c
      r.drawImage(n, u, c, h, f, i, a, o, s)
    } else r.drawImage(n, i, a, o, s)
  }
}
function lat(r, t, e) {
  var n,
    i = e.text
  if ((i != null && (i += ''), i)) {
    ;(r.font = e.font || nl),
      (r.textAlign = e.textAlign),
      (r.textBaseline = e.textBaseline)
    var a = void 0,
      o = void 0
    r.setLineDash && e.lineDash && ((n = yC(t)), (a = n[0]), (o = n[1])),
      a && (r.setLineDash(a), (r.lineDashOffset = o)),
      e.strokeFirst
        ? (e0(e) && r.strokeText(i, e.x, e.y), n0(e) && r.fillText(i, e.x, e.y))
        : (n0(e) && r.fillText(i, e.x, e.y),
          e0(e) && r.strokeText(i, e.x, e.y)),
      a && r.setLineDash([])
  }
}
var IR = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'],
  OR = [
    ['lineCap', 'butt'],
    ['lineJoin', 'miter'],
    ['miterLimit', 10],
  ]
function j5(r, t, e, n, i) {
  var a = !1
  if (!n && ((e = e || {}), t === e)) return !1
  if (n || t.opacity !== e.opacity) {
    jr(r, i), (a = !0)
    var o = Math.max(Math.min(t.opacity, 1), 0)
    r.globalAlpha = isNaN(o) ? Ru.opacity : o
  }
  ;(n || t.blend !== e.blend) &&
    (a || (jr(r, i), (a = !0)),
    (r.globalCompositeOperation = t.blend || Ru.blend))
  for (var s = 0; s < IR.length; s++) {
    var l = IR[s]
    ;(n || t[l] !== e[l]) &&
      (a || (jr(r, i), (a = !0)), (r[l] = r.dpr * (t[l] || 0)))
  }
  return (
    (n || t.shadowColor !== e.shadowColor) &&
      (a || (jr(r, i), (a = !0)),
      (r.shadowColor = t.shadowColor || Ru.shadowColor)),
    a
  )
}
function NR(r, t, e, n, i) {
  var a = jp(t, i.inHover),
    o = n ? null : (e && jp(e, i.inHover)) || {}
  if (a === o) return !1
  var s = j5(r, a, o, n, i)
  if (
    ((n || a.fill !== o.fill) &&
      (s || (jr(r, i), (s = !0)), LR(a.fill) && (r.fillStyle = a.fill)),
    (n || a.stroke !== o.stroke) &&
      (s || (jr(r, i), (s = !0)), LR(a.stroke) && (r.strokeStyle = a.stroke)),
    (n || a.opacity !== o.opacity) &&
      (s || (jr(r, i), (s = !0)),
      (r.globalAlpha = a.opacity == null ? 1 : a.opacity)),
    t.hasStroke())
  ) {
    var l = a.lineWidth,
      u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1)
    r.lineWidth !== u && (s || (jr(r, i), (s = !0)), (r.lineWidth = u))
  }
  for (var c = 0; c < OR.length; c++) {
    var h = OR[c],
      f = h[0]
    ;(n || a[f] !== o[f]) && (s || (jr(r, i), (s = !0)), (r[f] = a[f] || h[1]))
  }
  return s
}
function uat(r, t, e, n, i) {
  return j5(r, jp(t, i.inHover), e && jp(e, i.inHover), n, i)
}
function J5(r, t) {
  var e = t.transform,
    n = r.dpr || 1
  e
    ? r.setTransform(n * e[0], n * e[1], n * e[2], n * e[3], n * e[4], n * e[5])
    : r.setTransform(n, 0, 0, n, 0, 0)
}
function cat(r, t, e) {
  for (var n = !1, i = 0; i < r.length; i++) {
    var a = r[i]
    ;(n = n || a.isZeroArea()),
      J5(t, a),
      t.beginPath(),
      a.buildPath(t, a.shape),
      t.clip()
  }
  e.allClipped = n
}
function hat(r, t) {
  return r && t
    ? r[0] !== t[0] ||
        r[1] !== t[1] ||
        r[2] !== t[2] ||
        r[3] !== t[3] ||
        r[4] !== t[4] ||
        r[5] !== t[5]
    : !(!r && !t)
}
var kR = 1,
  BR = 2,
  FR = 3,
  zR = 4
function fat(r) {
  var t = n0(r),
    e = e0(r)
  return !(
    r.lineDash ||
    !(+t ^ +e) ||
    (t && typeof r.fill != 'string') ||
    (e && typeof r.stroke != 'string') ||
    r.strokePercent < 1 ||
    r.strokeOpacity < 1 ||
    r.fillOpacity < 1
  )
}
function jr(r, t) {
  t.batchFill && r.fill(),
    t.batchStroke && r.stroke(),
    (t.batchFill = ''),
    (t.batchStroke = '')
}
function jp(r, t) {
  return (t && r.__hoverStyle) || r.style
}
function Q5(r, t) {
  Au(
    r,
    t,
    {
      inHover: !1,
      viewWidth: 0,
      viewHeight: 0,
    },
    !0,
  )
}
function Au(r, t, e, n) {
  var i = t.transform
  if (!t.shouldBePainted(e.viewWidth, e.viewHeight, !1, !1)) {
    ;(t.__dirty &= ~yi), (t.__isRendered = !1)
    return
  }
  var a = t.__clipPaths,
    o = e.prevElClipPaths,
    s = !1,
    l = !1
  if (
    ((!o || rat(a, o)) &&
      (o &&
        o.length &&
        (jr(r, e),
        r.restore(),
        (l = s = !0),
        (e.prevElClipPaths = null),
        (e.allClipped = !1),
        (e.prevEl = null)),
      a && a.length && (jr(r, e), r.save(), cat(a, r, e), (s = !0)),
      (e.prevElClipPaths = a)),
    e.allClipped)
  ) {
    t.__isRendered = !1
    return
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush()
  var u = e.prevEl
  u || (l = s = !0)
  var c = t instanceof oe && t.autoBatch && fat(t.style)
  s || hat(i, u.transform) ? (jr(r, e), J5(r, t)) : c || jr(r, e)
  var h = jp(t, e.inHover)
  t instanceof oe
    ? (e.lastDrawType !== kR && ((l = !0), (e.lastDrawType = kR)),
      NR(r, t, u, l, e),
      (!c || (!e.batchFill && !e.batchStroke)) && r.beginPath(),
      oat(r, t, h, c),
      c && ((e.batchFill = h.fill || ''), (e.batchStroke = h.stroke || '')))
    : t instanceof Gp
    ? (e.lastDrawType !== FR && ((l = !0), (e.lastDrawType = FR)),
      NR(r, t, u, l, e),
      lat(r, t, h))
    : t instanceof yr
    ? (e.lastDrawType !== BR && ((l = !0), (e.lastDrawType = BR)),
      uat(r, t, u, l, e),
      sat(r, t, h))
    : t.getTemporalDisplayables &&
      (e.lastDrawType !== zR && ((l = !0), (e.lastDrawType = zR)),
      dat(r, t, e)),
    c && n && jr(r, e),
    t.innerAfterBrush(),
    t.afterBrush && t.afterBrush(),
    (e.prevEl = t),
    (t.__dirty = 0),
    (t.__isRendered = !0)
}
function dat(r, t, e) {
  var n = t.getDisplayables(),
    i = t.getTemporalDisplayables()
  r.save()
  var a = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: !1,
      viewWidth: e.viewWidth,
      viewHeight: e.viewHeight,
      inHover: e.inHover,
    },
    o,
    s
  for (o = t.getCursor(), s = n.length; o < s; o++) {
    var l = n[o]
    l.beforeBrush && l.beforeBrush(),
      l.innerBeforeBrush(),
      Au(r, l, a, o === s - 1),
      l.innerAfterBrush(),
      l.afterBrush && l.afterBrush(),
      (a.prevEl = l)
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u]
    l.beforeBrush && l.beforeBrush(),
      l.innerBeforeBrush(),
      Au(r, l, a, u === c - 1),
      l.innerAfterBrush(),
      l.afterBrush && l.afterBrush(),
      (a.prevEl = l)
  }
  t.clearTemporalDisplayables(), (t.notClear = !0), r.restore()
}
var O1 = new Yit(),
  UR = new gv(100),
  VR = [
    'symbol',
    'symbolSize',
    'symbolKeepAspect',
    'color',
    'backgroundColor',
    'dashArrayX',
    'dashArrayY',
    'maxTileWidth',
    'maxTileHeight',
  ]
function rf(r, t) {
  if (r === 'none') return null
  var e = t.getDevicePixelRatio(),
    n = t.getZr(),
    i = n.painter.type === 'svg'
  r.dirty && O1.delete(r)
  var a = O1.get(r)
  if (a) return a
  var o = zt(r, {
    symbol: 'rect',
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: 'rgba(0, 0, 0, 0.2)',
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512,
  })
  o.backgroundColor === 'none' && (o.backgroundColor = null)
  var s = {
    repeat: 'repeat',
  }
  return (
    l(s),
    (s.rotation = o.rotation),
    (s.scaleX = s.scaleY = i ? 1 : 1 / e),
    O1.set(r, s),
    (r.dirty = !1),
    s
  )
  function l(u) {
    for (var c = [e], h = !0, f = 0; f < VR.length; ++f) {
      var d = o[VR[f]]
      if (d != null && !at(d) && !bt(d) && !be(d) && typeof d != 'boolean') {
        h = !1
        break
      }
      c.push(d)
    }
    var p
    if (h) {
      p = c.join(',') + (i ? '-svg' : '')
      var g = UR.get(p)
      g && (i ? (u.svgElement = g) : (u.image = g))
    }
    var v = eV(o.dashArrayX),
      m = pat(o.dashArrayY),
      y = tV(o.symbol),
      _ = vat(v),
      x = nV(m),
      A = !i && rl.createCanvas(),
      S = i && {
        tag: 'g',
        attrs: {},
        key: 'dcl',
        children: [],
      },
      b = w(),
      T
    A &&
      ((A.width = b.width * e),
      (A.height = b.height * e),
      (T = A.getContext('2d'))),
      M(),
      h && UR.put(p, A || S),
      (u.image = A),
      (u.svgElement = S),
      (u.svgWidth = b.width),
      (u.svgHeight = b.height)
    function w() {
      for (var C = 1, E = 0, D = _.length; E < D; ++E) C = iP(C, _[E])
      for (var P = 1, E = 0, D = y.length; E < D; ++E) P = iP(P, y[E].length)
      C *= P
      var L = x * _.length * y.length
      return {
        width: Math.max(1, Math.min(C, o.maxTileWidth)),
        height: Math.max(1, Math.min(L, o.maxTileHeight)),
      }
    }
    function M() {
      T &&
        (T.clearRect(0, 0, A.width, A.height),
        o.backgroundColor &&
          ((T.fillStyle = o.backgroundColor),
          T.fillRect(0, 0, A.width, A.height)))
      for (var C = 0, E = 0; E < m.length; ++E) C += m[E]
      if (C <= 0) return
      for (var D = -x, P = 0, L = 0, I = 0; D < b.height; ) {
        if (P % 2 === 0) {
          for (
            var F = (L / 2) % y.length, k = 0, V = 0, H = 0;
            k < b.width * 2;

          ) {
            for (var Y = 0, E = 0; E < v[I].length; ++E) Y += v[I][E]
            if (Y <= 0) break
            if (V % 2 === 0) {
              var K = (1 - o.symbolSize) * 0.5,
                ut = k + v[I][V] * K,
                W = D + m[P] * K,
                Z = v[I][V] * o.symbolSize,
                ft = m[P] * o.symbolSize,
                lt = (H / 2) % y[F].length
              ct(ut, W, Z, ft, y[F][lt])
            }
            ;(k += v[I][V]), ++H, ++V, V === v[I].length && (V = 0)
          }
          ++I, I === v.length && (I = 0)
        }
        ;(D += m[P]), ++L, ++P, P === m.length && (P = 0)
      }
      function ct(At, gt, dt, B, ht) {
        var it = i ? 1 : e,
          xt = Rn(
            ht,
            At * it,
            gt * it,
            dt * it,
            B * it,
            o.color,
            o.symbolKeepAspect,
          )
        if (i) {
          var rt = n.painter.renderOneToVNode(xt)
          rt && S.children.push(rt)
        } else Q5(T, xt)
      }
    }
  }
}
function tV(r) {
  if (!r || r.length === 0) return [['rect']]
  if (bt(r)) return [[r]]
  for (var t = !0, e = 0; e < r.length; ++e)
    if (!bt(r[e])) {
      t = !1
      break
    }
  if (t) return tV([r])
  for (var n = [], e = 0; e < r.length; ++e)
    bt(r[e]) ? n.push([r[e]]) : n.push(r[e])
  return n
}
function eV(r) {
  if (!r || r.length === 0) return [[0, 0]]
  if (be(r)) {
    var t = Math.ceil(r)
    return [[t, t]]
  }
  for (var e = !0, n = 0; n < r.length; ++n)
    if (!be(r[n])) {
      e = !1
      break
    }
  if (e) return eV([r])
  for (var i = [], n = 0; n < r.length; ++n)
    if (be(r[n])) {
      var t = Math.ceil(r[n])
      i.push([t, t])
    } else {
      var t = st(r[n], function (s) {
        return Math.ceil(s)
      })
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t)
    }
  return i
}
function pat(r) {
  if (!r || (typeof r == 'object' && r.length === 0)) return [0, 0]
  if (be(r)) {
    var t = Math.ceil(r)
    return [t, t]
  }
  var e = st(r, function (n) {
    return Math.ceil(n)
  })
  return r.length % 2 ? e.concat(e) : e
}
function vat(r) {
  return st(r, function (t) {
    return nV(t)
  })
}
function nV(r) {
  for (var t = 0, e = 0; e < r.length; ++e) t += r[e]
  return r.length % 2 === 1 ? t * 2 : t
}
function gat(r, t) {
  r.eachRawSeries(function (e) {
    if (!r.isSeriesFiltered(e)) {
      var n = e.getData()
      n.hasItemVisual() &&
        n.each(function (o) {
          var s = n.getItemVisual(o, 'decal')
          if (s) {
            var l = n.ensureUniqueItemVisual(o, 'style')
            l.decal = rf(s, t)
          }
        })
      var i = n.getVisual('decal')
      if (i) {
        var a = n.getVisual('style')
        a.decal = rf(i, t)
      }
    }
  })
}
var mat = new ra()
const pa = mat
var rV = {}
function yat(r, t) {
  rV[r] = t
}
function _at(r) {
  return rV[r]
}
var xat = 1,
  Sat = 800,
  Aat = 900,
  bat = 1e3,
  wat = 2e3,
  Mat = 5e3,
  iV = 1e3,
  Tat = 1100,
  _C = 2e3,
  aV = 3e3,
  Cat = 4e3,
  x_ = 4500,
  Eat = 4600,
  Dat = 5e3,
  Lat = 6e3,
  oV = 7e3,
  Pat = {
    PROCESSOR: {
      FILTER: bat,
      SERIES_FILTER: Sat,
      STATISTIC: Mat,
    },
    VISUAL: {
      LAYOUT: iV,
      PROGRESSIVE_LAYOUT: Tat,
      GLOBAL: _C,
      CHART: aV,
      POST_CHART_LAYOUT: Eat,
      COMPONENT: Cat,
      BRUSH: Dat,
      CHART_ITEM: x_,
      ARIA: Lat,
      DECAL: oV,
    },
  },
  Ar = '__flagInMainProcess',
  Yr = '__pendingUpdate',
  N1 = '__needsUpdateStatus',
  GR = /^[a-zA-Z0-9_]+$/,
  k1 = '__connectUpdateStatus',
  HR = 0,
  Rat = 1,
  Iat = 2
function sV(r) {
  return function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
    if (this.isDisposed()) {
      this.id
      return
    }
    return uV(this, r, t)
  }
}
function lV(r) {
  return function () {
    for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]
    return uV(this, r, t)
  }
}
function uV(r, t, e) {
  return (e[0] = e[0] && e[0].toLowerCase()), ra.prototype[t].apply(r, e)
}
var cV = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return t
  })(ra),
  hV = cV.prototype
hV.on = lV('on')
hV.off = lV('off')
var qc,
  B1,
  Qg,
  xs,
  F1,
  z1,
  U1,
  sd,
  ld,
  WR,
  XR,
  V1,
  YR,
  tm,
  $R,
  fV,
  Pi,
  qR,
  dV = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this, new zit()) || this
      ;(a._chartsViews = []),
        (a._chartsMap = {}),
        (a._componentsViews = []),
        (a._componentsMap = {}),
        (a._pendingActions = []),
        (i = i || {}),
        bt(n) && (n = pV[n]),
        (a._dom = e)
      var o = 'canvas',
        s = 'auto',
        l = !1
      i.ssr &&
        htt(function (f) {
          var d = Wt(f),
            p = d.dataIndex
          if (p != null) {
            var g = Pt()
            return (
              g.set('series_index', d.seriesIndex),
              g.set('data_index', p),
              d.ssrType && g.set('ssr_type', d.ssrType),
              g
            )
          }
        })
      var u = (a._zr = tP(e, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: $t(i.useDirtyRect, l),
        useCoarsePointer: $t(i.useCoarsePointer, s),
        pointerSize: i.pointerSize,
      }))
      ;(a._ssr = i.ssr),
        (a._throttledZrFlush = __(Tt(u.flush, u), 17)),
        (n = Vt(n)),
        n && _5(n, !0),
        (a._theme = n),
        (a._locale = Ynt(i.locale || YU)),
        (a._coordSysMgr = new Av())
      var c = (a._api = $R(a))
      function h(f, d) {
        return f.__prio - d.__prio
      }
      return (
        $m(i0, h),
        $m(Sw, h),
        (a._scheduler = new $5(a, c, Sw, i0)),
        (a._messageCenter = new cV()),
        a._initEvents(),
        (a.resize = Tt(a.resize, a)),
        u.animation.on('frame', a._onframe, a),
        WR(u, a),
        XR(u, a),
        Ny(a),
        a
      )
    }
    return (
      (t.prototype._onframe = function () {
        if (!this._disposed) {
          qR(this)
          var e = this._scheduler
          if (this[Yr]) {
            var n = this[Yr].silent
            this[Ar] = !0
            try {
              qc(this), xs.update.call(this, null, this[Yr].updateParams)
            } catch (l) {
              throw ((this[Ar] = !1), (this[Yr] = null), l)
            }
            this._zr.flush(),
              (this[Ar] = !1),
              (this[Yr] = null),
              sd.call(this, n),
              ld.call(this, n)
          } else if (e.unfinished) {
            var i = xat,
              a = this._model,
              o = this._api
            e.unfinished = !1
            do {
              var s = +new Date()
              e.performSeriesTasks(a),
                e.performDataProcessorTasks(a),
                z1(this, a),
                e.performVisualTasks(a),
                tm(this, this._model, o, 'remain', {}),
                (i -= +new Date() - s)
            } while (i > 0 && e.unfinished)
            e.unfinished || this._zr.flush()
          }
        }
      }),
      (t.prototype.getDom = function () {
        return this._dom
      }),
      (t.prototype.getId = function () {
        return this.id
      }),
      (t.prototype.getZr = function () {
        return this._zr
      }),
      (t.prototype.isSSR = function () {
        return this._ssr
      }),
      (t.prototype.setOption = function (e, n, i) {
        if (!this[Ar]) {
          if (this._disposed) {
            this.id
            return
          }
          var a, o, s
          if (
            (Ut(n) &&
              ((i = n.lazyUpdate),
              (a = n.silent),
              (o = n.replaceMerge),
              (s = n.transition),
              (n = n.notMerge)),
            (this[Ar] = !0),
            !this._model || n)
          ) {
            var l = new wrt(this._api),
              u = this._theme,
              c = (this._model = new g5())
            ;(c.scheduler = this._scheduler),
              (c.ssr = this._ssr),
              c.init(null, null, null, u, this._locale, l)
          }
          this._model.setOption(
            e,
            {
              replaceMerge: o,
            },
            Aw,
          )
          var h = {
            seriesTransition: s,
            optionChanged: !0,
          }
          if (i)
            (this[Yr] = {
              silent: a,
              updateParams: h,
            }),
              (this[Ar] = !1),
              this.getZr().wakeUp()
          else {
            try {
              qc(this), xs.update.call(this, null, h)
            } catch (f) {
              throw ((this[Yr] = null), (this[Ar] = !1), f)
            }
            this._ssr || this._zr.flush(),
              (this[Yr] = null),
              (this[Ar] = !1),
              sd.call(this, a),
              ld.call(this, a)
          }
        }
      }),
      (t.prototype.setTheme = function () {}),
      (t.prototype.getModel = function () {
        return this._model
      }),
      (t.prototype.getOption = function () {
        return this._model && this._model.getOption()
      }),
      (t.prototype.getWidth = function () {
        return this._zr.getWidth()
      }),
      (t.prototype.getHeight = function () {
        return this._zr.getHeight()
      }),
      (t.prototype.getDevicePixelRatio = function () {
        return (
          this._zr.painter.dpr ||
          (Se.hasGlobalWindow && window.devicePixelRatio) ||
          1
        )
      }),
      (t.prototype.getRenderedCanvas = function (e) {
        return this.renderToCanvas(e)
      }),
      (t.prototype.renderToCanvas = function (e) {
        e = e || {}
        var n = this._zr.painter
        return n.getRenderedCanvas({
          backgroundColor:
            e.backgroundColor || this._model.get('backgroundColor'),
          pixelRatio: e.pixelRatio || this.getDevicePixelRatio(),
        })
      }),
      (t.prototype.renderToSVGString = function (e) {
        e = e || {}
        var n = this._zr.painter
        return n.renderToString({
          useViewBox: e.useViewBox,
        })
      }),
      (t.prototype.getSvgDataURL = function () {
        if (Se.svgSupported) {
          var e = this._zr,
            n = e.storage.getDisplayList()
          return (
            R(n, function (i) {
              i.stopAnimation(null, !0)
            }),
            e.painter.toDataURL()
          )
        }
      }),
      (t.prototype.getDataURL = function (e) {
        if (this._disposed) {
          this.id
          return
        }
        e = e || {}
        var n = e.excludeComponents,
          i = this._model,
          a = [],
          o = this
        R(n, function (l) {
          i.eachComponent(
            {
              mainType: l,
            },
            function (u) {
              var c = o._componentsMap[u.__viewId]
              c.group.ignore || (a.push(c), (c.group.ignore = !0))
            },
          )
        })
        var s =
          this._zr.painter.getType() === 'svg'
            ? this.getSvgDataURL()
            : this.renderToCanvas(e).toDataURL(
                'image/' + ((e && e.type) || 'png'),
              )
        return (
          R(a, function (l) {
            l.group.ignore = !1
          }),
          s
        )
      }),
      (t.prototype.getConnectedDataURL = function (e) {
        if (this._disposed) {
          this.id
          return
        }
        var n = e.type === 'svg',
          i = this.group,
          a = Math.min,
          o = Math.max,
          s = 1 / 0
        if (ZR[i]) {
          var l = s,
            u = s,
            c = -s,
            h = -s,
            f = [],
            d = (e && e.pixelRatio) || this.getDevicePixelRatio()
          R(hp, function (_, x) {
            if (_.group === i) {
              var A = n
                  ? _.getZr().painter.getSvgDom().innerHTML
                  : _.renderToCanvas(Vt(e)),
                S = _.getDom().getBoundingClientRect()
              ;(l = a(S.left, l)),
                (u = a(S.top, u)),
                (c = o(S.right, c)),
                (h = o(S.bottom, h)),
                f.push({
                  dom: A,
                  left: S.left,
                  top: S.top,
                })
            }
          }),
            (l *= d),
            (u *= d),
            (c *= d),
            (h *= d)
          var p = c - l,
            g = h - u,
            v = rl.createCanvas(),
            m = tP(v, {
              renderer: n ? 'svg' : 'canvas',
            })
          if (
            (m.resize({
              width: p,
              height: g,
            }),
            n)
          ) {
            var y = ''
            return (
              R(f, function (_) {
                var x = _.left - l,
                  A = _.top - u
                y +=
                  '<g transform="translate(' +
                  x +
                  ',' +
                  A +
                  ')">' +
                  _.dom +
                  '</g>'
              }),
              (m.painter.getSvgRoot().innerHTML = y),
              e.connectedBackgroundColor &&
                m.painter.setBackgroundColor(e.connectedBackgroundColor),
              m.refreshImmediately(),
              m.painter.toDataURL()
            )
          } else
            return (
              e.connectedBackgroundColor &&
                m.add(
                  new ge({
                    shape: {
                      x: 0,
                      y: 0,
                      width: p,
                      height: g,
                    },
                    style: {
                      fill: e.connectedBackgroundColor,
                    },
                  }),
                ),
              R(f, function (_) {
                var x = new yr({
                  style: {
                    x: _.left * d - l,
                    y: _.top * d - u,
                    image: _.dom,
                  },
                })
                m.add(x)
              }),
              m.refreshImmediately(),
              v.toDataURL('image/' + ((e && e.type) || 'png'))
            )
        } else return this.getDataURL(e)
      }),
      (t.prototype.convertToPixel = function (e, n) {
        return F1(this, 'convertToPixel', e, n)
      }),
      (t.prototype.convertFromPixel = function (e, n) {
        return F1(this, 'convertFromPixel', e, n)
      }),
      (t.prototype.containPixel = function (e, n) {
        if (this._disposed) {
          this.id
          return
        }
        var i = this._model,
          a,
          o = ip(i, e)
        return (
          R(
            o,
            function (s, l) {
              l.indexOf('Models') >= 0 &&
                R(
                  s,
                  function (u) {
                    var c = u.coordinateSystem
                    if (c && c.containPoint) a = a || !!c.containPoint(n)
                    else if (l === 'seriesModels') {
                      var h = this._chartsMap[u.__viewId]
                      h && h.containPoint && (a = a || h.containPoint(n, u))
                    }
                  },
                  this,
                )
            },
            this,
          ),
          !!a
        )
      }),
      (t.prototype.getVisual = function (e, n) {
        var i = this._model,
          a = ip(i, e, {
            defaultMainType: 'series',
          }),
          o = a.seriesModel,
          s = o.getData(),
          l = a.hasOwnProperty('dataIndexInside')
            ? a.dataIndexInside
            : a.hasOwnProperty('dataIndex')
            ? s.indexOfRawIndex(a.dataIndex)
            : null
        return l != null ? mC(s, l, n) : bv(s, n)
      }),
      (t.prototype.getViewOfComponentModel = function (e) {
        return this._componentsMap[e.__viewId]
      }),
      (t.prototype.getViewOfSeriesModel = function (e) {
        return this._chartsMap[e.__viewId]
      }),
      (t.prototype._initEvents = function () {
        var e = this
        R(Oat, function (n) {
          var i = function (a) {
            var o = e.getModel(),
              s = a.target,
              l,
              u = n === 'globalout'
            if (
              (u
                ? (l = {})
                : s &&
                  xu(
                    s,
                    function (p) {
                      var g = Wt(p)
                      if (g && g.dataIndex != null) {
                        var v = g.dataModel || o.getSeriesByIndex(g.seriesIndex)
                        return (
                          (l =
                            (v &&
                              v.getDataParams(g.dataIndex, g.dataType, s)) ||
                            {}),
                          !0
                        )
                      } else if (g.eventData)
                        return (l = Q({}, g.eventData)), !0
                    },
                    !0,
                  ),
              l)
            ) {
              var c = l.componentType,
                h = l.componentIndex
              ;(c === 'markLine' || c === 'markPoint' || c === 'markArea') &&
                ((c = 'series'), (h = l.seriesIndex))
              var f = c && h != null && o.getComponent(c, h),
                d =
                  f &&
                  e[f.mainType === 'series' ? '_chartsMap' : '_componentsMap'][
                    f.__viewId
                  ]
              ;(l.event = a),
                (l.type = n),
                (e._$eventProcessor.eventInfo = {
                  targetEl: s,
                  packedEvent: l,
                  model: f,
                  view: d,
                }),
                e.trigger(n, l)
            }
          }
          ;(i.zrEventfulCallAtLast = !0), e._zr.on(n, i, e)
        }),
          R(cp, function (n, i) {
            e._messageCenter.on(
              i,
              function (a) {
                this.trigger(i, a)
              },
              e,
            )
          }),
          R(['selectchanged'], function (n) {
            e._messageCenter.on(
              n,
              function (i) {
                this.trigger(n, i)
              },
              e,
            )
          }),
          Git(this._messageCenter, this, this._api)
      }),
      (t.prototype.isDisposed = function () {
        return this._disposed
      }),
      (t.prototype.clear = function () {
        if (this._disposed) {
          this.id
          return
        }
        this.setOption(
          {
            series: [],
          },
          !0,
        )
      }),
      (t.prototype.dispose = function () {
        if (this._disposed) {
          this.id
          return
        }
        this._disposed = !0
        var e = this.getDom()
        e && Xz(this.getDom(), SC, '')
        var n = this,
          i = n._api,
          a = n._model
        R(n._componentsViews, function (o) {
          o.dispose(a, i)
        }),
          R(n._chartsViews, function (o) {
            o.dispose(a, i)
          }),
          n._zr.dispose(),
          (n._dom =
            n._model =
            n._chartsMap =
            n._componentsMap =
            n._chartsViews =
            n._componentsViews =
            n._scheduler =
            n._api =
            n._zr =
            n._throttledZrFlush =
            n._theme =
            n._coordSysMgr =
            n._messageCenter =
              null),
          delete hp[n.id]
      }),
      (t.prototype.resize = function (e) {
        if (!this[Ar]) {
          if (this._disposed) {
            this.id
            return
          }
          this._zr.resize(e)
          var n = this._model
          if ((this._loadingFX && this._loadingFX.resize(), !!n)) {
            var i = n.resetOption('media'),
              a = e && e.silent
            this[Yr] &&
              (a == null && (a = this[Yr].silent), (i = !0), (this[Yr] = null)),
              (this[Ar] = !0)
            try {
              i && qc(this),
                xs.update.call(this, {
                  type: 'resize',
                  animation: Q(
                    {
                      duration: 0,
                    },
                    e && e.animation,
                  ),
                })
            } catch (o) {
              throw ((this[Ar] = !1), o)
            }
            ;(this[Ar] = !1), sd.call(this, a), ld.call(this, a)
          }
        }
      }),
      (t.prototype.showLoading = function (e, n) {
        if (this._disposed) {
          this.id
          return
        }
        if (
          (Ut(e) && ((n = e), (e = '')),
          (e = e || 'default'),
          this.hideLoading(),
          !!bw[e])
        ) {
          var i = bw[e](this._api, n),
            a = this._zr
          ;(this._loadingFX = i), a.add(i)
        }
      }),
      (t.prototype.hideLoading = function () {
        if (this._disposed) {
          this.id
          return
        }
        this._loadingFX && this._zr.remove(this._loadingFX),
          (this._loadingFX = null)
      }),
      (t.prototype.makeActionFromEvent = function (e) {
        var n = Q({}, e)
        return (n.type = cp[e.type]), n
      }),
      (t.prototype.dispatchAction = function (e, n) {
        if (this._disposed) {
          this.id
          return
        }
        if (
          (Ut(n) ||
            (n = {
              silent: !!n,
            }),
          !!r0[e.type] && this._model)
        ) {
          if (this[Ar]) {
            this._pendingActions.push(e)
            return
          }
          var i = n.silent
          U1.call(this, e, i)
          var a = n.flush
          a
            ? this._zr.flush()
            : a !== !1 && Se.browser.weChat && this._throttledZrFlush(),
            sd.call(this, i),
            ld.call(this, i)
        }
      }),
      (t.prototype.updateLabelLayout = function () {
        pa.trigger('series:layoutlabels', this._model, this._api, {
          updatedSeries: [],
        })
      }),
      (t.prototype.appendData = function (e) {
        if (this._disposed) {
          this.id
          return
        }
        var n = e.seriesIndex,
          i = this.getModel(),
          a = i.getSeriesByIndex(n)
        a.appendData(e),
          (this._scheduler.unfinished = !0),
          this.getZr().wakeUp()
      }),
      (t.internalField = (function () {
        ;(qc = function (h) {
          var f = h._scheduler
          f.restorePipelines(h._model),
            f.prepareStageTasks(),
            B1(h, !0),
            B1(h, !1),
            f.plan()
        }),
          (B1 = function (h, f) {
            for (
              var d = h._model,
                p = h._scheduler,
                g = f ? h._componentsViews : h._chartsViews,
                v = f ? h._componentsMap : h._chartsMap,
                m = h._zr,
                y = h._api,
                _ = 0;
              _ < g.length;
              _++
            )
              g[_].__alive = !1
            f
              ? d.eachComponent(function (S, b) {
                  S !== 'series' && x(b)
                })
              : d.eachSeries(x)
            function x(S) {
              var b = S.__requireNewView
              S.__requireNewView = !1
              var T = '_ec_' + S.id + '_' + S.type,
                w = !b && v[T]
              if (!w) {
                var M = to(S.type),
                  C = f ? dn.getClass(M.main, M.sub) : Ze.getClass(M.sub)
                ;(w = new C()),
                  w.init(d, y),
                  (v[T] = w),
                  g.push(w),
                  m.add(w.group)
              }
              ;(S.__viewId = w.__id = T),
                (w.__alive = !0),
                (w.__model = S),
                (w.group.__ecComponentInfo = {
                  mainType: S.mainType,
                  index: S.componentIndex,
                }),
                !f && p.prepareView(w, S, d, y)
            }
            for (var _ = 0; _ < g.length; ) {
              var A = g[_]
              A.__alive
                ? _++
                : (!f && A.renderTask.dispose(),
                  m.remove(A.group),
                  A.dispose(d, y),
                  g.splice(_, 1),
                  v[A.__id] === A && delete v[A.__id],
                  (A.__id = A.group.__ecComponentInfo = null))
            }
          }),
          (Qg = function (h, f, d, p, g) {
            var v = h._model
            if ((v.setUpdatePayload(d), !p)) {
              R([].concat(h._componentsViews).concat(h._chartsViews), A)
              return
            }
            var m = {}
            ;(m[p + 'Id'] = d[p + 'Id']),
              (m[p + 'Index'] = d[p + 'Index']),
              (m[p + 'Name'] = d[p + 'Name'])
            var y = {
              mainType: p,
              query: m,
            }
            g && (y.subType = g)
            var _ = d.excludeSeriesId,
              x
            _ != null &&
              ((x = Pt()),
              R(ke(_), function (S) {
                var b = Un(S, null)
                b != null && x.set(b, !0)
              })),
              v &&
                v.eachComponent(
                  y,
                  function (S) {
                    var b = x && x.get(S.id) != null
                    if (!b)
                      if (LP(d))
                        if (S instanceof rn)
                          d.type === Iu &&
                            !d.notBlur &&
                            !S.get(['emphasis', 'disabled']) &&
                            Fet(S, d, h._api)
                        else {
                          var T = qT(
                              S.mainType,
                              S.componentIndex,
                              d.name,
                              h._api,
                            ),
                            w = T.focusSelf,
                            M = T.dispatchers
                          d.type === Iu &&
                            w &&
                            !d.notBlur &&
                            rw(S.mainType, S.componentIndex, h._api),
                            M &&
                              R(M, function (C) {
                                d.type === Iu ? Qo(C) : ts(C)
                              })
                        }
                      else
                        aw(d) &&
                          S instanceof rn &&
                          (Vet(S, d, h._api), EP(S), Pi(h))
                  },
                  h,
                ),
              v &&
                v.eachComponent(
                  y,
                  function (S) {
                    var b = x && x.get(S.id) != null
                    b ||
                      A(
                        h[p === 'series' ? '_chartsMap' : '_componentsMap'][
                          S.__viewId
                        ],
                      )
                  },
                  h,
                )
            function A(S) {
              S && S.__alive && S[f] && S[f](S.__model, v, h._api, d)
            }
          }),
          (xs = {
            prepareAndUpdate: function (h) {
              qc(this),
                xs.update.call(this, h, {
                  optionChanged: h.newOption != null,
                })
            },
            update: function (h, f) {
              var d = this._model,
                p = this._api,
                g = this._zr,
                v = this._coordSysMgr,
                m = this._scheduler
              if (d) {
                d.setUpdatePayload(h),
                  m.restoreData(d, h),
                  m.performSeriesTasks(d),
                  v.create(d, p),
                  m.performDataProcessorTasks(d, h),
                  z1(this, d),
                  v.update(d, p),
                  e(d),
                  m.performVisualTasks(d, h),
                  V1(this, d, p, h, f)
                var y = d.get('backgroundColor') || 'transparent',
                  _ = d.get('darkMode')
                g.setBackgroundColor(y),
                  _ != null && _ !== 'auto' && g.setDarkMode(_),
                  pa.trigger('afterupdate', d, p)
              }
            },
            updateTransform: function (h) {
              var f = this,
                d = this._model,
                p = this._api
              if (d) {
                d.setUpdatePayload(h)
                var g = []
                d.eachComponent(function (m, y) {
                  if (m !== 'series') {
                    var _ = f.getViewOfComponentModel(y)
                    if (_ && _.__alive)
                      if (_.updateTransform) {
                        var x = _.updateTransform(y, d, p, h)
                        x && x.update && g.push(_)
                      } else g.push(_)
                  }
                })
                var v = Pt()
                d.eachSeries(function (m) {
                  var y = f._chartsMap[m.__viewId]
                  if (y.updateTransform) {
                    var _ = y.updateTransform(m, d, p, h)
                    _ && _.update && v.set(m.uid, 1)
                  } else v.set(m.uid, 1)
                }),
                  e(d),
                  this._scheduler.performVisualTasks(d, h, {
                    setDirty: !0,
                    dirtyMap: v,
                  }),
                  tm(this, d, p, h, {}, v),
                  pa.trigger('afterupdate', d, p)
              }
            },
            updateView: function (h) {
              var f = this._model
              f &&
                (f.setUpdatePayload(h),
                Ze.markUpdateMethod(h, 'updateView'),
                e(f),
                this._scheduler.performVisualTasks(f, h, {
                  setDirty: !0,
                }),
                V1(this, f, this._api, h, {}),
                pa.trigger('afterupdate', f, this._api))
            },
            updateVisual: function (h) {
              var f = this,
                d = this._model
              d &&
                (d.setUpdatePayload(h),
                d.eachSeries(function (p) {
                  p.getData().clearAllVisual()
                }),
                Ze.markUpdateMethod(h, 'updateVisual'),
                e(d),
                this._scheduler.performVisualTasks(d, h, {
                  visualType: 'visual',
                  setDirty: !0,
                }),
                d.eachComponent(function (p, g) {
                  if (p !== 'series') {
                    var v = f.getViewOfComponentModel(g)
                    v && v.__alive && v.updateVisual(g, d, f._api, h)
                  }
                }),
                d.eachSeries(function (p) {
                  var g = f._chartsMap[p.__viewId]
                  g.updateVisual(p, d, f._api, h)
                }),
                pa.trigger('afterupdate', d, this._api))
            },
            updateLayout: function (h) {
              xs.update.call(this, h)
            },
          }),
          (F1 = function (h, f, d, p) {
            if (h._disposed) {
              h.id
              return
            }
            for (
              var g = h._model,
                v = h._coordSysMgr.getCoordinateSystems(),
                m,
                y = ip(g, d),
                _ = 0;
              _ < v.length;
              _++
            ) {
              var x = v[_]
              if (x[f] && (m = x[f](g, y, p)) != null) return m
            }
          }),
          (z1 = function (h, f) {
            var d = h._chartsMap,
              p = h._scheduler
            f.eachSeries(function (g) {
              p.updateStreamModes(g, d[g.__viewId])
            })
          }),
          (U1 = function (h, f) {
            var d = this,
              p = this.getModel(),
              g = h.type,
              v = h.escapeConnect,
              m = r0[g],
              y = m.actionInfo,
              _ = (y.update || 'update').split(':'),
              x = _.pop(),
              A = _[0] != null && to(_[0])
            this[Ar] = !0
            var S = [h],
              b = !1
            h.batch &&
              ((b = !0),
              (S = st(h.batch, function (P) {
                return (P = zt(Q({}, P), h)), (P.batch = null), P
              })))
            var T = [],
              w,
              M = aw(h),
              C = LP(h)
            if (
              (C && gU(this._api),
              R(S, function (P) {
                if (
                  ((w = m.action(P, d._model, d._api)),
                  (w = w || Q({}, P)),
                  (w.type = y.event || w.type),
                  T.push(w),
                  C)
                ) {
                  var L = UT(h),
                    I = L.queryOptionMap,
                    F = L.mainTypeSpecified,
                    k = F ? I.keys()[0] : 'series'
                  Qg(d, x, P, k), Pi(d)
                } else M ? (Qg(d, x, P, 'series'), Pi(d)) : A && Qg(d, x, P, A.main, A.sub)
              }),
              x !== 'none' && !C && !M && !A)
            )
              try {
                this[Yr]
                  ? (qc(this), xs.update.call(this, h), (this[Yr] = null))
                  : xs[x].call(this, h)
              } catch (P) {
                throw ((this[Ar] = !1), P)
              }
            if (
              (b
                ? (w = {
                    type: y.event || g,
                    escapeConnect: v,
                    batch: T,
                  })
                : (w = T[0]),
              (this[Ar] = !1),
              !f)
            ) {
              var E = this._messageCenter
              if ((E.trigger(w.type, w), M)) {
                var D = {
                  type: 'selectchanged',
                  escapeConnect: v,
                  selected: Get(p),
                  isFromClick: h.isFromClick || !1,
                  fromAction: h.type,
                  fromActionPayload: h,
                }
                E.trigger(D.type, D)
              }
            }
          }),
          (sd = function (h) {
            for (var f = this._pendingActions; f.length; ) {
              var d = f.shift()
              U1.call(this, d, h)
            }
          }),
          (ld = function (h) {
            !h && this.trigger('updated')
          }),
          (WR = function (h, f) {
            h.on('rendered', function (d) {
              f.trigger('rendered', d),
                h.animation.isFinished() &&
                  !f[Yr] &&
                  !f._scheduler.unfinished &&
                  !f._pendingActions.length &&
                  f.trigger('finished')
            })
          }),
          (XR = function (h, f) {
            h.on('mouseover', function (d) {
              var p = d.target,
                g = xu(p, Wp)
              g && (zet(g, d, f._api), Pi(f))
            })
              .on('mouseout', function (d) {
                var p = d.target,
                  g = xu(p, Wp)
                g && (Uet(g, d, f._api), Pi(f))
              })
              .on('click', function (d) {
                var p = d.target,
                  g = xu(
                    p,
                    function (y) {
                      return Wt(y).dataIndex != null
                    },
                    !0,
                  )
                if (g) {
                  var v = g.selected ? 'unselect' : 'select',
                    m = Wt(g)
                  f._api.dispatchAction({
                    type: v,
                    dataType: m.dataType,
                    dataIndexInside: m.dataIndex,
                    seriesIndex: m.seriesIndex,
                    isFromClick: !0,
                  })
                }
              })
          })
        function e(h) {
          h.clearColorPalette(),
            h.eachSeries(function (f) {
              f.clearColorPalette()
            })
        }
        function n(h) {
          var f = [],
            d = [],
            p = !1
          if (
            (h.eachComponent(function (y, _) {
              var x = _.get('zlevel') || 0,
                A = _.get('z') || 0,
                S = _.getZLevelKey()
              ;(p = p || !!S),
                (y === 'series' ? d : f).push({
                  zlevel: x,
                  z: A,
                  idx: _.componentIndex,
                  type: y,
                  key: S,
                })
            }),
            p)
          ) {
            var g = f.concat(d),
              v,
              m
            $m(g, function (y, _) {
              return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel
            }),
              R(g, function (y) {
                var _ = h.getComponent(y.type, y.idx),
                  x = y.zlevel,
                  A = y.key
                v != null && (x = Math.max(v, x)),
                  A
                    ? (x === v && A !== m && x++, (m = A))
                    : m && (x === v && x++, (m = '')),
                  (v = x),
                  _.setZLevel(x)
              })
          }
        }
        ;(V1 = function (h, f, d, p, g) {
          n(f),
            YR(h, f, d, p, g),
            R(h._chartsViews, function (v) {
              v.__alive = !1
            }),
            tm(h, f, d, p, g),
            R(h._chartsViews, function (v) {
              v.__alive || v.remove(f, d)
            })
        }),
          (YR = function (h, f, d, p, g, v) {
            R(v || h._componentsViews, function (m) {
              var y = m.__model
              u(y, m), m.render(y, f, d, p), s(y, m), c(y, m)
            })
          }),
          (tm = function (h, f, d, p, g, v) {
            var m = h._scheduler
            ;(g = Q(g || {}, {
              updatedSeries: f.getSeries(),
            })),
              pa.trigger('series:beforeupdate', f, d, g)
            var y = !1
            f.eachSeries(function (_) {
              var x = h._chartsMap[_.__viewId]
              x.__alive = !0
              var A = x.renderTask
              m.updatePayload(A, p),
                u(_, x),
                v && v.get(_.uid) && A.dirty(),
                A.perform(m.getPerformArgs(A)) && (y = !0),
                (x.group.silent = !!_.get('silent')),
                o(_, x),
                EP(_)
            }),
              (m.unfinished = y || m.unfinished),
              pa.trigger('series:layoutlabels', f, d, g),
              pa.trigger('series:transition', f, d, g),
              f.eachSeries(function (_) {
                var x = h._chartsMap[_.__viewId]
                s(_, x), c(_, x)
              }),
              a(h, f),
              pa.trigger('series:afterupdate', f, d, g)
          }),
          (Pi = function (h) {
            ;(h[N1] = !0), h.getZr().wakeUp()
          }),
          (qR = function (h) {
            h[N1] &&
              (h.getZr().storage.traverse(function (f) {
                Rh(f) || i(f)
              }),
              (h[N1] = !1))
          })
        function i(h) {
          for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
            var g = d[p]
            g === 'emphasis' || g === 'blur' || g === 'select' || f.push(g)
          }
          h.selected && h.states.select && f.push('select'),
            h.hoverState === n_ && h.states.emphasis
              ? f.push('emphasis')
              : h.hoverState === _v && h.states.blur && f.push('blur'),
            h.useStates(f)
        }
        function a(h, f) {
          var d = h._zr,
            p = d.storage,
            g = 0
          p.traverse(function (v) {
            v.isGroup || g++
          }),
            g > f.get('hoverLayerThreshold') &&
              !Se.node &&
              !Se.worker &&
              f.eachSeries(function (v) {
                if (!v.preventUsingHoverLayer) {
                  var m = h._chartsMap[v.__viewId]
                  m.__alive &&
                    m.eachRendered(function (y) {
                      y.states.emphasis && (y.states.emphasis.hoverLayer = !0)
                    })
                }
              })
        }
        function o(h, f) {
          var d = h.get('blendMode') || null
          f.eachRendered(function (p) {
            p.isGroup || (p.style.blend = d)
          })
        }
        function s(h, f) {
          if (!h.preventAutoZ) {
            var d = h.get('z') || 0,
              p = h.get('zlevel') || 0
            f.eachRendered(function (g) {
              return l(g, d, p, -1 / 0), !0
            })
          }
        }
        function l(h, f, d, p) {
          var g = h.getTextContent(),
            v = h.getTextGuideLine(),
            m = h.isGroup
          if (m)
            for (var y = h.childrenRef(), _ = 0; _ < y.length; _++)
              p = Math.max(l(y[_], f, d, p), p)
          else (h.z = f), (h.zlevel = d), (p = Math.max(h.z2, p))
          if (
            (g && ((g.z = f), (g.zlevel = d), isFinite(p) && (g.z2 = p + 2)), v)
          ) {
            var x = h.textGuideLineConfig
            ;(v.z = f),
              (v.zlevel = d),
              isFinite(p) && (v.z2 = p + (x && x.showAbove ? 1 : -1))
          }
          return p
        }
        function u(h, f) {
          f.eachRendered(function (d) {
            if (!Rh(d)) {
              var p = d.getTextContent(),
                g = d.getTextGuideLine()
              d.stateTransition && (d.stateTransition = null),
                p && p.stateTransition && (p.stateTransition = null),
                g && g.stateTransition && (g.stateTransition = null),
                d.hasState()
                  ? ((d.prevStates = d.currentStates), d.clearStates())
                  : d.prevStates && (d.prevStates = null)
            }
          })
        }
        function c(h, f) {
          var d = h.getModel('stateAnimation'),
            p = h.isAnimationEnabled(),
            g = d.get('duration'),
            v =
              g > 0
                ? {
                    duration: g,
                    delay: d.get('delay'),
                    easing: d.get('easing'),
                  }
                : null
          f.eachRendered(function (m) {
            if (m.states && m.states.emphasis) {
              if (Rh(m)) return
              if ((m instanceof oe && $et(m), m.__dirty)) {
                var y = m.prevStates
                y && m.useStates(y)
              }
              if (p) {
                m.stateTransition = v
                var _ = m.getTextContent(),
                  x = m.getTextGuideLine()
                _ && (_.stateTransition = v), x && (x.stateTransition = v)
              }
              m.__dirty && i(m)
            }
          })
        }
        ;($R = function (h) {
          return new ((function (f) {
            X(d, f)
            function d() {
              return (f !== null && f.apply(this, arguments)) || this
            }
            return (
              (d.prototype.getCoordinateSystems = function () {
                return h._coordSysMgr.getCoordinateSystems()
              }),
              (d.prototype.getComponentByElement = function (p) {
                for (; p; ) {
                  var g = p.__ecComponentInfo
                  if (g != null)
                    return h._model.getComponent(g.mainType, g.index)
                  p = p.parent
                }
              }),
              (d.prototype.enterEmphasis = function (p, g) {
                Qo(p, g), Pi(h)
              }),
              (d.prototype.leaveEmphasis = function (p, g) {
                ts(p, g), Pi(h)
              }),
              (d.prototype.enterBlur = function (p) {
                fU(p), Pi(h)
              }),
              (d.prototype.leaveBlur = function (p) {
                $T(p), Pi(h)
              }),
              (d.prototype.enterSelect = function (p) {
                dU(p), Pi(h)
              }),
              (d.prototype.leaveSelect = function (p) {
                pU(p), Pi(h)
              }),
              (d.prototype.getModel = function () {
                return h.getModel()
              }),
              (d.prototype.getViewOfComponentModel = function (p) {
                return h.getViewOfComponentModel(p)
              }),
              (d.prototype.getViewOfSeriesModel = function (p) {
                return h.getViewOfSeriesModel(p)
              }),
              d
            )
          })(m5))(h)
        }),
          (fV = function (h) {
            function f(d, p) {
              for (var g = 0; g < d.length; g++) {
                var v = d[g]
                v[k1] = p
              }
            }
            R(cp, function (d, p) {
              h._messageCenter.on(p, function (g) {
                if (ZR[h.group] && h[k1] !== HR) {
                  if (g && g.escapeConnect) return
                  var v = h.makeActionFromEvent(g),
                    m = []
                  R(hp, function (y) {
                    y !== h && y.group === h.group && m.push(y)
                  }),
                    f(m, HR),
                    R(m, function (y) {
                      y[k1] !== Rat && y.dispatchAction(v)
                    }),
                    f(m, Iat)
                }
              })
            })
          })
      })()),
      t
    )
  })(ra),
  xC = dV.prototype
xC.on = sV('on')
xC.off = sV('off')
xC.one = function (r, t, e) {
  var n = this
  function i() {
    for (var a = [], o = 0; o < arguments.length; o++) a[o] = arguments[o]
    t && t.apply && t.apply(this, a), n.off(r, i)
  }
  this.on.call(this, r, i, e)
}
var Oat = [
  'click',
  'dblclick',
  'mouseover',
  'mouseout',
  'mousemove',
  'mousedown',
  'mouseup',
  'globalout',
  'contextmenu',
]
var r0 = {},
  cp = {},
  Sw = [],
  Aw = [],
  i0 = [],
  pV = {},
  bw = {},
  hp = {},
  ZR = {},
  Nat = +new Date() - 0,
  SC = '_echarts_instance_'
function kat(r, t, e) {
  var n = !(e && e.ssr)
  if (n) {
    var i = Bat(r)
    if (i) return i
  }
  var a = new dV(r, t, e)
  return (
    (a.id = 'ec_' + Nat++),
    (hp[a.id] = a),
    n && Xz(r, SC, a.id),
    fV(a),
    pa.trigger('afterinit', a),
    a
  )
}
function Bat(r) {
  return hp[Ptt(r, SC)]
}
function vV(r, t) {
  pV[r] = t
}
function gV(r) {
  re(Aw, r) < 0 && Aw.push(r)
}
function mV(r, t) {
  bC(Sw, r, t, wat)
}
function Fat(r) {
  AC('afterinit', r)
}
function zat(r) {
  AC('afterupdate', r)
}
function AC(r, t) {
  pa.on(r, t)
}
function xo(r, t, e) {
  Nt(t) && ((e = t), (t = ''))
  var n = Ut(r)
    ? r.type
    : [
        r,
        (r = {
          event: t,
        }),
      ][0]
  ;(r.event = (r.event || n).toLowerCase()),
    (t = r.event),
    !cp[t] &&
      (Gr(GR.test(n) && GR.test(t)),
      r0[n] ||
        (r0[n] = {
          action: e,
          actionInfo: r,
        }),
      (cp[t] = n))
}
function Uat(r, t) {
  Av.register(r, t)
}
function Vat(r, t) {
  bC(i0, r, t, iV, 'layout')
}
function ac(r, t) {
  bC(i0, r, t, aV, 'visual')
}
var KR = []
function bC(r, t, e, n, i) {
  if (((Nt(t) || Ut(t)) && ((e = t), (t = n)), !(re(KR, e) >= 0))) {
    KR.push(e)
    var a = $5.wrapStageHandler(e, i)
    ;(a.__prio = t), (a.__raw = e), r.push(a)
  }
}
function yV(r, t) {
  bw[r] = t
}
function Gat(r, t, e) {
  var n = _at('registerMap')
  n && n(r, t, e)
}
var Hat = Jrt
ac(_C, bit)
ac(x_, wit)
ac(x_, Mit)
ac(_C, Uit)
ac(x_, Vit)
ac(oV, gat)
gV(_5)
mV(Aat, Rrt)
yV('default', Tit)
xo(
  {
    type: Iu,
    event: Iu,
    update: Iu,
  },
  wn,
)
xo(
  {
    type: Qm,
    event: Qm,
    update: Qm,
  },
  wn,
)
xo(
  {
    type: ap,
    event: ap,
    update: ap,
  },
  wn,
)
xo(
  {
    type: ty,
    event: ty,
    update: ty,
  },
  wn,
)
xo(
  {
    type: op,
    event: op,
    update: op,
  },
  wn,
)
vV('light', Bit)
vV('dark', Fit)
var jR = [],
  Wat = {
    registerPreprocessor: gV,
    registerProcessor: mV,
    registerPostInit: Fat,
    registerPostUpdate: zat,
    registerUpdateLifecycle: AC,
    registerAction: xo,
    registerCoordinateSystem: Uat,
    registerLayout: Vat,
    registerVisual: ac,
    registerTransform: Hat,
    registerLoading: yV,
    registerMap: Gat,
    registerImpl: yat,
    PRIORITY: Pat,
    ComponentModel: xe,
    ComponentView: dn,
    SeriesModel: rn,
    ChartView: Ze,
    registerComponentModel: function (r) {
      xe.registerClass(r)
    },
    registerComponentView: function (r) {
      dn.registerClass(r)
    },
    registerSeriesModel: function (r) {
      rn.registerClass(r)
    },
    registerChartView: function (r) {
      Ze.registerClass(r)
    },
    registerSubTypeDefaulter: function (r, t) {
      xe.registerSubTypeDefaulter(r, t)
    },
    registerPainter: function (r, t) {
      utt(r, t)
    },
  }
function ie(r) {
  if (at(r)) {
    R(r, function (t) {
      ie(t)
    })
    return
  }
  re(jR, r) >= 0 ||
    (jR.push(r),
    Nt(r) &&
      (r = {
        install: r,
      }),
    r.install(Wat))
}
function ud(r) {
  return r == null ? 0 : r.length || 1
}
function JR(r) {
  return r
}
var Xat = (function () {
  function r(t, e, n, i, a, o) {
    ;(this._old = t),
      (this._new = e),
      (this._oldKeyGetter = n || JR),
      (this._newKeyGetter = i || JR),
      (this.context = a),
      (this._diffModeMultiple = o === 'multiple')
  }
  return (
    (r.prototype.add = function (t) {
      return (this._add = t), this
    }),
    (r.prototype.update = function (t) {
      return (this._update = t), this
    }),
    (r.prototype.updateManyToOne = function (t) {
      return (this._updateManyToOne = t), this
    }),
    (r.prototype.updateOneToMany = function (t) {
      return (this._updateOneToMany = t), this
    }),
    (r.prototype.updateManyToMany = function (t) {
      return (this._updateManyToMany = t), this
    }),
    (r.prototype.remove = function (t) {
      return (this._remove = t), this
    }),
    (r.prototype.execute = function () {
      this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']()
    }),
    (r.prototype._executeOneToOne = function () {
      var t = this._old,
        e = this._new,
        n = {},
        i = new Array(t.length),
        a = new Array(e.length)
      this._initIndexMap(t, null, i, '_oldKeyGetter'),
        this._initIndexMap(e, n, a, '_newKeyGetter')
      for (var o = 0; o < t.length; o++) {
        var s = i[o],
          l = n[s],
          u = ud(l)
        if (u > 1) {
          var c = l.shift()
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o)
        } else
          u === 1
            ? ((n[s] = null), this._update && this._update(l, o))
            : this._remove && this._remove(o)
      }
      this._performRestAdd(a, n)
    }),
    (r.prototype._executeMultiple = function () {
      var t = this._old,
        e = this._new,
        n = {},
        i = {},
        a = [],
        o = []
      this._initIndexMap(t, n, a, '_oldKeyGetter'),
        this._initIndexMap(e, i, o, '_newKeyGetter')
      for (var s = 0; s < a.length; s++) {
        var l = a[s],
          u = n[l],
          c = i[l],
          h = ud(u),
          f = ud(c)
        if (h > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), (i[l] = null)
        else if (h === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), (i[l] = null)
        else if (h === 1 && f === 1)
          this._update && this._update(c, u), (i[l] = null)
        else if (h > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), (i[l] = null)
        else if (h > 1)
          for (var d = 0; d < h; d++) this._remove && this._remove(u[d])
        else this._remove && this._remove(u)
      }
      this._performRestAdd(o, i)
    }),
    (r.prototype._performRestAdd = function (t, e) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n],
          a = e[i],
          o = ud(a)
        if (o > 1) for (var s = 0; s < o; s++) this._add && this._add(a[s])
        else o === 1 && this._add && this._add(a)
        e[i] = null
      }
    }),
    (r.prototype._initIndexMap = function (t, e, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
        var s = '_ec_' + this[i](t[o], o)
        if ((a || (n[o] = s), !!e)) {
          var l = e[s],
            u = ud(l)
          u === 0
            ? ((e[s] = o), a && n.push(s))
            : u === 1
            ? (e[s] = [l, o])
            : l.push(o)
        }
      }
    }),
    r
  )
})()
const es = Xat
var Yat = (function () {
  function r(t, e) {
    ;(this._encode = t), (this._schema = e)
  }
  return (
    (r.prototype.get = function () {
      return {
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode,
      }
    }),
    (r.prototype._getFullDimensionNames = function () {
      return (
        this._cachedDimNames ||
          (this._cachedDimNames = this._schema
            ? this._schema.makeOutputDimensionNames()
            : []),
        this._cachedDimNames
      )
    }),
    r
  )
})()
function $at(r, t) {
  var e = {},
    n = (e.encode = {}),
    i = Pt(),
    a = [],
    o = [],
    s = {}
  R(r.dimensions, function (f) {
    var d = r.getDimensionInfo(f),
      p = d.coordDim
    if (p) {
      var g = d.coordDimIndex
      ;(G1(n, p)[g] = f),
        d.isExtraCoord ||
          (i.set(p, 1),
          qat(d.type) && (a[0] = f),
          (G1(s, p)[g] = r.getDimensionIndex(d.name))),
        d.defaultTooltip && o.push(f)
    }
    l5.each(function (v, m) {
      var y = G1(n, m),
        _ = d.otherDims[m]
      _ != null && _ !== !1 && (y[_] = d.name)
    })
  })
  var l = [],
    u = {}
  i.each(function (f, d) {
    var p = n[d]
    ;(u[d] = p[0]), (l = l.concat(p))
  }),
    (e.dataDimsOnCoord = l),
    (e.dataDimIndicesOnCoord = st(l, function (f) {
      return r.getDimensionInfo(f).storeDimIndex
    })),
    (e.encodeFirstDimNotExtra = u)
  var c = n.label
  c && c.length && (a = c.slice())
  var h = n.tooltip
  return (
    h && h.length ? (o = h.slice()) : o.length || (o = a.slice()),
    (n.defaultedLabel = a),
    (n.defaultedTooltip = o),
    (e.userOutput = new Yat(s, t)),
    e
  )
}
function G1(r, t) {
  return r.hasOwnProperty(t) || (r[t] = []), r[t]
}
function a0(r) {
  return r === 'category' ? 'ordinal' : r === 'time' ? 'time' : 'float'
}
function qat(r) {
  return !(r === 'ordinal' || r === 'time')
}
var Zat = (function () {
  function r(t) {
    ;(this.otherDims = {}), t != null && Q(this, t)
  }
  return r
})()
const ay = Zat
var Kat = ve(),
  jat = {
    float: 'f',
    int: 'i',
    ordinal: 'o',
    number: 'n',
    time: 't',
  },
  _V = (function () {
    function r(t) {
      ;(this.dimensions = t.dimensions),
        (this._dimOmitted = t.dimensionOmitted),
        (this.source = t.source),
        (this._fullDimCount = t.fullDimensionCount),
        this._updateDimOmitted(t.dimensionOmitted)
    }
    return (
      (r.prototype.isDimensionOmitted = function () {
        return this._dimOmitted
      }),
      (r.prototype._updateDimOmitted = function (t) {
        ;(this._dimOmitted = t),
          t && (this._dimNameMap || (this._dimNameMap = AV(this.source)))
      }),
      (r.prototype.getSourceDimensionIndex = function (t) {
        return $t(this._dimNameMap.get(t), -1)
      }),
      (r.prototype.getSourceDimension = function (t) {
        var e = this.source.dimensionsDefine
        if (e) return e[t]
      }),
      (r.prototype.makeStoreSchema = function () {
        for (
          var t = this._fullDimCount,
            e = S5(this.source),
            n = !bV(t),
            i = '',
            a = [],
            o = 0,
            s = 0;
          o < t;
          o++
        ) {
          var l = void 0,
            u = void 0,
            c = void 0,
            h = this.dimensions[s]
          if (h && h.storeDimIndex === o)
            (l = e ? h.name : null), (u = h.type), (c = h.ordinalMeta), s++
          else {
            var f = this.getSourceDimension(o)
            f && ((l = e ? f.name : null), (u = f.type))
          }
          a.push({
            property: l,
            type: u,
            ordinalMeta: c,
          }),
            e &&
              l != null &&
              (!h || !h.isCalculationCoord) &&
              (i += n ? l.replace(/\`/g, '`1').replace(/\$/g, '`2') : l),
            (i += '$'),
            (i += jat[u] || 'f'),
            c && (i += c.uid),
            (i += '$')
        }
        var d = this.source,
          p = [d.seriesLayoutBy, d.startIndex, i].join('$$')
        return {
          dimensions: a,
          hash: p,
        }
      }),
      (r.prototype.makeOutputDimensionNames = function () {
        for (var t = [], e = 0, n = 0; e < this._fullDimCount; e++) {
          var i = void 0,
            a = this.dimensions[n]
          if (a && a.storeDimIndex === e)
            a.isCalculationCoord || (i = a.name), n++
          else {
            var o = this.getSourceDimension(e)
            o && (i = o.name)
          }
          t.push(i)
        }
        return t
      }),
      (r.prototype.appendCalculationDimension = function (t) {
        this.dimensions.push(t),
          (t.isCalculationCoord = !0),
          this._fullDimCount++,
          this._updateDimOmitted(!0)
      }),
      r
    )
  })()
function xV(r) {
  return r instanceof _V
}
function SV(r) {
  for (var t = Pt(), e = 0; e < (r || []).length; e++) {
    var n = r[e],
      i = Ut(n) ? n.name : n
    i != null && t.get(i) == null && t.set(i, e)
  }
  return t
}
function AV(r) {
  var t = Kat(r)
  return t.dimNameMap || (t.dimNameMap = SV(r.dimensionsDefine))
}
function bV(r) {
  return r > 30
}
var cd = Ut,
  Ss = st,
  Jat = typeof Int32Array > 'u' ? Array : Int32Array,
  Qat = 'e\0\0',
  QR = -1,
  tot = [
    'hasItemOption',
    '_nameList',
    '_idList',
    '_invertedIndicesMap',
    '_dimSummary',
    'userOutput',
    '_rawData',
    '_dimValueGetter',
    '_nameDimIdx',
    '_idDimIdx',
    '_nameRepeatCount',
  ],
  eot = ['_approximateExtent'],
  tI,
  em,
  hd,
  fd,
  H1,
  nm,
  W1,
  not = (function () {
    function r(t, e) {
      ;(this.type = 'list'),
        (this._dimOmitted = !1),
        (this._nameList = []),
        (this._idList = []),
        (this._visual = {}),
        (this._layout = {}),
        (this._itemVisuals = []),
        (this._itemLayouts = []),
        (this._graphicEls = []),
        (this._approximateExtent = {}),
        (this._calculationInfo = {}),
        (this.hasItemOption = !1),
        (this.TRANSFERABLE_METHODS = [
          'cloneShallow',
          'downSample',
          'lttbDownSample',
          'map',
        ]),
        (this.CHANGABLE_METHODS = ['filterSelf', 'selectRange']),
        (this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'])
      var n,
        i = !1
      xV(t)
        ? ((n = t.dimensions),
          (this._dimOmitted = t.isDimensionOmitted()),
          (this._schema = t))
        : ((i = !0), (n = t)),
        (n = n || ['x', 'y'])
      for (
        var a = {}, o = [], s = {}, l = !1, u = {}, c = 0;
        c < n.length;
        c++
      ) {
        var h = n[c],
          f = bt(h)
            ? new ay({
                name: h,
              })
            : h instanceof ay
            ? h
            : new ay(h),
          d = f.name
        ;(f.type = f.type || 'float'),
          f.coordDim || ((f.coordDim = d), (f.coordDimIndex = 0))
        var p = (f.otherDims = f.otherDims || {})
        o.push(d),
          (a[d] = f),
          u[d] != null && (l = !0),
          f.createInvertedIndices && (s[d] = []),
          p.itemName === 0 && (this._nameDimIdx = c),
          p.itemId === 0 && (this._idDimIdx = c),
          i && (f.storeDimIndex = c)
      }
      if (
        ((this.dimensions = o),
        (this._dimInfos = a),
        this._initGetDimensionInfo(l),
        (this.hostModel = e),
        (this._invertedIndicesMap = s),
        this._dimOmitted)
      ) {
        var g = (this._dimIdxToName = Pt())
        R(o, function (v) {
          g.set(a[v].storeDimIndex, v)
        })
      }
    }
    return (
      (r.prototype.getDimension = function (t) {
        var e = this._recognizeDimIndex(t)
        if (e == null) return t
        if (((e = t), !this._dimOmitted)) return this.dimensions[e]
        var n = this._dimIdxToName.get(e)
        if (n != null) return n
        var i = this._schema.getSourceDimension(e)
        if (i) return i.name
      }),
      (r.prototype.getDimensionIndex = function (t) {
        var e = this._recognizeDimIndex(t)
        if (e != null) return e
        if (t == null) return -1
        var n = this._getDimInfo(t)
        return n
          ? n.storeDimIndex
          : this._dimOmitted
          ? this._schema.getSourceDimensionIndex(t)
          : -1
      }),
      (r.prototype._recognizeDimIndex = function (t) {
        if (
          be(t) ||
          (t != null &&
            !isNaN(t) &&
            !this._getDimInfo(t) &&
            (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        )
          return +t
      }),
      (r.prototype._getStoreDimIndex = function (t) {
        var e = this.getDimensionIndex(t)
        return e
      }),
      (r.prototype.getDimensionInfo = function (t) {
        return this._getDimInfo(this.getDimension(t))
      }),
      (r.prototype._initGetDimensionInfo = function (t) {
        var e = this._dimInfos
        this._getDimInfo = t
          ? function (n) {
              return e.hasOwnProperty(n) ? e[n] : void 0
            }
          : function (n) {
              return e[n]
            }
      }),
      (r.prototype.getDimensionsOnCoord = function () {
        return this._dimSummary.dataDimsOnCoord.slice()
      }),
      (r.prototype.mapDimension = function (t, e) {
        var n = this._dimSummary
        if (e == null) return n.encodeFirstDimNotExtra[t]
        var i = n.encode[t]
        return i ? i[e] : null
      }),
      (r.prototype.mapDimensionsAll = function (t) {
        var e = this._dimSummary,
          n = e.encode[t]
        return (n || []).slice()
      }),
      (r.prototype.getStore = function () {
        return this._store
      }),
      (r.prototype.initData = function (t, e, n) {
        var i = this,
          a
        if ((t instanceof pw && (a = t), !a)) {
          var o = this.dimensions,
            s = hC(t) || Er(t) ? new A5(t, o.length) : t
          a = new pw()
          var l = Ss(o, function (u) {
            return {
              type: i._dimInfos[u].type,
              property: u,
            }
          })
          a.initData(s, l, n)
        }
        ;(this._store = a),
          (this._nameList = (e || []).slice()),
          (this._idList = []),
          (this._nameRepeatCount = {}),
          this._doInit(0, a.count()),
          (this._dimSummary = $at(this, this._schema)),
          (this.userOutput = this._dimSummary.userOutput)
      }),
      (r.prototype.appendData = function (t) {
        var e = this._store.appendData(t)
        this._doInit(e[0], e[1])
      }),
      (r.prototype.appendValues = function (t, e) {
        var n = this._store.appendValues(t, e.length),
          i = n.start,
          a = n.end,
          o = this._shouldMakeIdFromName()
        if ((this._updateOrdinalMeta(), e))
          for (var s = i; s < a; s++) {
            var l = s - i
            ;(this._nameList[s] = e[l]), o && W1(this, s)
          }
      }),
      (r.prototype._updateOrdinalMeta = function () {
        for (
          var t = this._store, e = this.dimensions, n = 0;
          n < e.length;
          n++
        ) {
          var i = this._dimInfos[e[n]]
          i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta)
        }
      }),
      (r.prototype._shouldMakeIdFromName = function () {
        var t = this._store.getProvider()
        return (
          this._idDimIdx == null &&
          t.getSource().sourceFormat !== js &&
          !t.fillStorage
        )
      }),
      (r.prototype._doInit = function (t, e) {
        if (!(t >= e)) {
          var n = this._store,
            i = n.getProvider()
          this._updateOrdinalMeta()
          var a = this._nameList,
            o = this._idList,
            s = i.getSource().sourceFormat,
            l = s === ia
          if (l && !i.pure)
            for (var u = [], c = t; c < e; c++) {
              var h = i.getItem(c, u)
              if (
                (!this.hasItemOption && ytt(h) && (this.hasItemOption = !0), h)
              ) {
                var f = h.name
                a[c] == null && f != null && (a[c] = Un(f, null))
                var d = h.id
                o[c] == null && d != null && (o[c] = Un(d, null))
              }
            }
          if (this._shouldMakeIdFromName())
            for (var c = t; c < e; c++) W1(this, c)
          tI(this)
        }
      }),
      (r.prototype.getApproximateExtent = function (t) {
        return (
          this._approximateExtent[t] ||
          this._store.getDataExtent(this._getStoreDimIndex(t))
        )
      }),
      (r.prototype.setApproximateExtent = function (t, e) {
        ;(e = this.getDimension(e)), (this._approximateExtent[e] = t.slice())
      }),
      (r.prototype.getCalculationInfo = function (t) {
        return this._calculationInfo[t]
      }),
      (r.prototype.setCalculationInfo = function (t, e) {
        cd(t) ? Q(this._calculationInfo, t) : (this._calculationInfo[t] = e)
      }),
      (r.prototype.getName = function (t) {
        var e = this.getRawIndex(t),
          n = this._nameList[e]
        return (
          n == null &&
            this._nameDimIdx != null &&
            (n = hd(this, this._nameDimIdx, e)),
          n == null && (n = ''),
          n
        )
      }),
      (r.prototype._getCategory = function (t, e) {
        var n = this._store.get(t, e),
          i = this._store.getOrdinalMeta(t)
        return i ? i.categories[n] : n
      }),
      (r.prototype.getId = function (t) {
        return em(this, this.getRawIndex(t))
      }),
      (r.prototype.count = function () {
        return this._store.count()
      }),
      (r.prototype.get = function (t, e) {
        var n = this._store,
          i = this._dimInfos[t]
        if (i) return n.get(i.storeDimIndex, e)
      }),
      (r.prototype.getByRawIndex = function (t, e) {
        var n = this._store,
          i = this._dimInfos[t]
        if (i) return n.getByRawIndex(i.storeDimIndex, e)
      }),
      (r.prototype.getIndices = function () {
        return this._store.getIndices()
      }),
      (r.prototype.getDataExtent = function (t) {
        return this._store.getDataExtent(this._getStoreDimIndex(t))
      }),
      (r.prototype.getSum = function (t) {
        return this._store.getSum(this._getStoreDimIndex(t))
      }),
      (r.prototype.getMedian = function (t) {
        return this._store.getMedian(this._getStoreDimIndex(t))
      }),
      (r.prototype.getValues = function (t, e) {
        var n = this,
          i = this._store
        return at(t)
          ? i.getValues(
              Ss(t, function (a) {
                return n._getStoreDimIndex(a)
              }),
              e,
            )
          : i.getValues(t)
      }),
      (r.prototype.hasValue = function (t) {
        for (
          var e = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = e.length;
          n < i;
          n++
        )
          if (isNaN(this._store.get(e[n], t))) return !1
        return !0
      }),
      (r.prototype.indexOfName = function (t) {
        for (var e = 0, n = this._store.count(); e < n; e++)
          if (this.getName(e) === t) return e
        return -1
      }),
      (r.prototype.getRawIndex = function (t) {
        return this._store.getRawIndex(t)
      }),
      (r.prototype.indexOfRawIndex = function (t) {
        return this._store.indexOfRawIndex(t)
      }),
      (r.prototype.rawIndexOf = function (t, e) {
        var n = t && this._invertedIndicesMap[t],
          i = n[e]
        return i == null || isNaN(i) ? QR : i
      }),
      (r.prototype.indicesOfNearest = function (t, e, n) {
        return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, n)
      }),
      (r.prototype.each = function (t, e, n) {
        Nt(t) && ((n = e), (e = t), (t = []))
        var i = n || this,
          a = Ss(fd(t), this._getStoreDimIndex, this)
        this._store.each(a, i ? Tt(e, i) : e)
      }),
      (r.prototype.filterSelf = function (t, e, n) {
        Nt(t) && ((n = e), (e = t), (t = []))
        var i = n || this,
          a = Ss(fd(t), this._getStoreDimIndex, this)
        return (this._store = this._store.filter(a, i ? Tt(e, i) : e)), this
      }),
      (r.prototype.selectRange = function (t) {
        var e = this,
          n = {},
          i = pe(t)
        return (
          R(i, function (a) {
            var o = e._getStoreDimIndex(a)
            n[o] = t[a]
          }),
          (this._store = this._store.selectRange(n)),
          this
        )
      }),
      (r.prototype.mapArray = function (t, e, n) {
        Nt(t) && ((n = e), (e = t), (t = [])), (n = n || this)
        var i = []
        return (
          this.each(
            t,
            function () {
              i.push(e && e.apply(this, arguments))
            },
            n,
          ),
          i
        )
      }),
      (r.prototype.map = function (t, e, n, i) {
        var a = n || i || this,
          o = Ss(fd(t), this._getStoreDimIndex, this),
          s = nm(this)
        return (s._store = this._store.map(o, a ? Tt(e, a) : e)), s
      }),
      (r.prototype.modify = function (t, e, n, i) {
        var a = n || i || this,
          o = Ss(fd(t), this._getStoreDimIndex, this)
        this._store.modify(o, a ? Tt(e, a) : e)
      }),
      (r.prototype.downSample = function (t, e, n, i) {
        var a = nm(this)
        return (
          (a._store = this._store.downSample(
            this._getStoreDimIndex(t),
            e,
            n,
            i,
          )),
          a
        )
      }),
      (r.prototype.lttbDownSample = function (t, e) {
        var n = nm(this)
        return (
          (n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e)),
          n
        )
      }),
      (r.prototype.getRawDataItem = function (t) {
        return this._store.getRawDataItem(t)
      }),
      (r.prototype.getItemModel = function (t) {
        var e = this.hostModel,
          n = this.getRawDataItem(t)
        return new qe(n, e, e && e.ecModel)
      }),
      (r.prototype.diff = function (t) {
        var e = this
        return new es(
          t ? t.getStore().getIndices() : [],
          this.getStore().getIndices(),
          function (n) {
            return em(t, n)
          },
          function (n) {
            return em(e, n)
          },
        )
      }),
      (r.prototype.getVisual = function (t) {
        var e = this._visual
        return e && e[t]
      }),
      (r.prototype.setVisual = function (t, e) {
        ;(this._visual = this._visual || {}),
          cd(t) ? Q(this._visual, t) : (this._visual[t] = e)
      }),
      (r.prototype.getItemVisual = function (t, e) {
        var n = this._itemVisuals[t],
          i = n && n[e]
        return i ?? this.getVisual(e)
      }),
      (r.prototype.hasItemVisual = function () {
        return this._itemVisuals.length > 0
      }),
      (r.prototype.ensureUniqueItemVisual = function (t, e) {
        var n = this._itemVisuals,
          i = n[t]
        i || (i = n[t] = {})
        var a = i[e]
        return (
          a == null &&
            ((a = this.getVisual(e)),
            at(a) ? (a = a.slice()) : cd(a) && (a = Q({}, a)),
            (i[e] = a)),
          a
        )
      }),
      (r.prototype.setItemVisual = function (t, e, n) {
        var i = this._itemVisuals[t] || {}
        ;(this._itemVisuals[t] = i), cd(e) ? Q(i, e) : (i[e] = n)
      }),
      (r.prototype.clearAllVisual = function () {
        ;(this._visual = {}), (this._itemVisuals = [])
      }),
      (r.prototype.setLayout = function (t, e) {
        cd(t) ? Q(this._layout, t) : (this._layout[t] = e)
      }),
      (r.prototype.getLayout = function (t) {
        return this._layout[t]
      }),
      (r.prototype.getItemLayout = function (t) {
        return this._itemLayouts[t]
      }),
      (r.prototype.setItemLayout = function (t, e, n) {
        this._itemLayouts[t] = n ? Q(this._itemLayouts[t] || {}, e) : e
      }),
      (r.prototype.clearItemLayouts = function () {
        this._itemLayouts.length = 0
      }),
      (r.prototype.setItemGraphicEl = function (t, e) {
        var n = this.hostModel && this.hostModel.seriesIndex
        ew(n, this.dataType, t, e), (this._graphicEls[t] = e)
      }),
      (r.prototype.getItemGraphicEl = function (t) {
        return this._graphicEls[t]
      }),
      (r.prototype.eachItemGraphicEl = function (t, e) {
        R(this._graphicEls, function (n, i) {
          n && t && t.call(e, n, i)
        })
      }),
      (r.prototype.cloneShallow = function (t) {
        return (
          t ||
            (t = new r(
              this._schema
                ? this._schema
                : Ss(this.dimensions, this._getDimInfo, this),
              this.hostModel,
            )),
          H1(t, this),
          (t._store = this._store),
          t
        )
      }),
      (r.prototype.wrapMethod = function (t, e) {
        var n = this[t]
        Nt(n) &&
          ((this.__wrappedMethods = this.__wrappedMethods || []),
          this.__wrappedMethods.push(t),
          (this[t] = function () {
            var i = n.apply(this, arguments)
            return e.apply(this, [i].concat(DT(arguments)))
          }))
      }),
      (r.internalField = (function () {
        ;(tI = function (t) {
          var e = t._invertedIndicesMap
          R(e, function (n, i) {
            var a = t._dimInfos[i],
              o = a.ordinalMeta,
              s = t._store
            if (o) {
              n = e[i] = new Jat(o.categories.length)
              for (var l = 0; l < n.length; l++) n[l] = QR
              for (var l = 0; l < s.count(); l++)
                n[s.get(a.storeDimIndex, l)] = l
            }
          })
        }),
          (hd = function (t, e, n) {
            return Un(t._getCategory(e, n), null)
          }),
          (em = function (t, e) {
            var n = t._idList[e]
            return (
              n == null && t._idDimIdx != null && (n = hd(t, t._idDimIdx, e)),
              n == null && (n = Qat + e),
              n
            )
          }),
          (fd = function (t) {
            return at(t) || (t = t != null ? [t] : []), t
          }),
          (nm = function (t) {
            var e = new r(
              t._schema ? t._schema : Ss(t.dimensions, t._getDimInfo, t),
              t.hostModel,
            )
            return H1(e, t), e
          }),
          (H1 = function (t, e) {
            R(tot.concat(e.__wrappedMethods || []), function (n) {
              e.hasOwnProperty(n) && (t[n] = e[n])
            }),
              (t.__wrappedMethods = e.__wrappedMethods),
              R(eot, function (n) {
                t[n] = Vt(e[n])
              }),
              (t._calculationInfo = Q({}, e._calculationInfo))
          }),
          (W1 = function (t, e) {
            var n = t._nameList,
              i = t._idList,
              a = t._nameDimIdx,
              o = t._idDimIdx,
              s = n[e],
              l = i[e]
            if (
              (s == null && a != null && (n[e] = s = hd(t, a, e)),
              l == null && o != null && (i[e] = l = hd(t, o, e)),
              l == null && s != null)
            ) {
              var u = t._nameRepeatCount,
                c = (u[s] = (u[s] || 0) + 1)
              ;(l = s), c > 1 && (l += '__ec__' + c), (i[e] = l)
            }
          })
      })()),
      r
    )
  })()
const Vr = not
function wv(r, t) {
  hC(r) || (r = fC(r)), (t = t || {})
  var e = t.coordDimensions || [],
    n = t.dimensionsDefine || r.dimensionsDefine || [],
    i = Pt(),
    a = [],
    o = iot(r, e, n, t.dimensionsCount),
    s = t.canOmitUnusedDimensions && bV(o),
    l = n === r.dimensionsDefine,
    u = l ? AV(r) : SV(n),
    c = t.encodeDefine
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(r, o))
  for (var h = Pt(c), f = new L5(o), d = 0; d < f.length; d++) f[d] = -1
  function p(w) {
    var M = f[w]
    if (M < 0) {
      var C = n[w],
        E = Ut(C)
          ? C
          : {
              name: C,
            },
        D = new ay(),
        P = E.name
      P != null && u.get(P) != null && (D.name = D.displayName = P),
        E.type != null && (D.type = E.type),
        E.displayName != null && (D.displayName = E.displayName)
      var L = a.length
      return (f[w] = L), (D.storeDimIndex = w), a.push(D), D
    }
    return a[M]
  }
  if (!s) for (var d = 0; d < o; d++) p(d)
  h.each(function (w, M) {
    var C = ke(w).slice()
    if (C.length === 1 && !bt(C[0]) && C[0] < 0) {
      h.set(M, !1)
      return
    }
    var E = h.set(M, [])
    R(C, function (D, P) {
      var L = bt(D) ? u.get(D) : D
      L != null && L < o && ((E[P] = L), v(p(L), M, P))
    })
  })
  var g = 0
  R(e, function (w) {
    var M, C, E, D
    if (bt(w)) (M = w), (D = {})
    else {
      ;(D = w), (M = D.name)
      var P = D.ordinalMeta
      ;(D.ordinalMeta = null),
        (D = Q({}, D)),
        (D.ordinalMeta = P),
        (C = D.dimsDef),
        (E = D.otherDims),
        (D.name = D.coordDim = D.coordDimIndex = D.dimsDef = D.otherDims = null)
    }
    var L = h.get(M)
    if (L !== !1) {
      if (((L = ke(L)), !L.length))
        for (var I = 0; I < ((C && C.length) || 1); I++) {
          for (; g < o && p(g).coordDim != null; ) g++
          g < o && L.push(g++)
        }
      R(L, function (F, k) {
        var V = p(F)
        if (
          (l && D.type != null && (V.type = D.type),
          v(zt(V, D), M, k),
          V.name == null && C)
        ) {
          var H = C[k]
          !Ut(H) &&
            (H = {
              name: H,
            }),
            (V.name = V.displayName = H.name),
            (V.defaultTooltip = H.defaultTooltip)
        }
        E && zt(V.otherDims, E)
      })
    }
  })
  function v(w, M, C) {
    l5.get(M) != null
      ? (w.otherDims[M] = C)
      : ((w.coordDim = M), (w.coordDimIndex = C), i.set(M, !0))
  }
  var m = t.generateCoord,
    y = t.generateCoordCount,
    _ = y != null
  y = m ? y || 1 : 0
  var x = m || 'value'
  function A(w) {
    w.name == null && (w.name = w.coordDim)
  }
  if (s)
    R(a, function (w) {
      A(w)
    }),
      a.sort(function (w, M) {
        return w.storeDimIndex - M.storeDimIndex
      })
  else
    for (var S = 0; S < o; S++) {
      var b = p(S),
        T = b.coordDim
      T == null &&
        ((b.coordDim = aot(x, i, _)),
        (b.coordDimIndex = 0),
        (!m || y <= 0) && (b.isExtraCoord = !0),
        y--),
        A(b),
        b.type == null &&
          (f5(r, S) === fr.Must ||
            (b.isExtraCoord &&
              (b.otherDims.itemName != null ||
                b.otherDims.seriesName != null))) &&
          (b.type = 'ordinal')
    }
  return (
    rot(a),
    new _V({
      source: r,
      dimensions: a,
      fullDimensionCount: o,
      dimensionOmitted: s,
    })
  )
}
function rot(r) {
  for (var t = Pt(), e = 0; e < r.length; e++) {
    var n = r[e],
      i = n.name,
      a = t.get(i) || 0
    a > 0 && (n.name = i + (a - 1)), a++, t.set(i, a)
  }
}
function iot(r, t, e, n) {
  var i = Math.max(r.dimensionsDetectedCount || 1, t.length, e.length, n || 0)
  return (
    R(t, function (a) {
      var o
      Ut(a) && (o = a.dimsDef) && (i = Math.max(i, o.length))
    }),
    i
  )
}
function aot(r, t, e) {
  if (e || t.hasKey(r)) {
    for (var n = 0; t.hasKey(r + n); ) n++
    r += n
  }
  return t.set(r, !0), r
}
var oot = (function () {
  function r(t) {
    ;(this.coordSysDims = []),
      (this.axisMap = Pt()),
      (this.categoryAxisMap = Pt()),
      (this.coordSysName = t)
  }
  return r
})()
function sot(r) {
  var t = r.get('coordinateSystem'),
    e = new oot(t),
    n = lot[t]
  if (n) return n(r, e, e.axisMap, e.categoryAxisMap), e
}
var lot = {
  cartesian2d: function (r, t, e, n) {
    var i = r.getReferringComponents('xAxis', Pn).models[0],
      a = r.getReferringComponents('yAxis', Pn).models[0]
    ;(t.coordSysDims = ['x', 'y']),
      e.set('x', i),
      e.set('y', a),
      Zc(i) && (n.set('x', i), (t.firstCategoryDimIndex = 0)),
      Zc(a) &&
        (n.set('y', a),
        t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1))
  },
  singleAxis: function (r, t, e, n) {
    var i = r.getReferringComponents('singleAxis', Pn).models[0]
    ;(t.coordSysDims = ['single']),
      e.set('single', i),
      Zc(i) && (n.set('single', i), (t.firstCategoryDimIndex = 0))
  },
  polar: function (r, t, e, n) {
    var i = r.getReferringComponents('polar', Pn).models[0],
      a = i.findAxisModel('radiusAxis'),
      o = i.findAxisModel('angleAxis')
    ;(t.coordSysDims = ['radius', 'angle']),
      e.set('radius', a),
      e.set('angle', o),
      Zc(a) && (n.set('radius', a), (t.firstCategoryDimIndex = 0)),
      Zc(o) &&
        (n.set('angle', o),
        t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1))
  },
  geo: function (r, t, e, n) {
    t.coordSysDims = ['lng', 'lat']
  },
  parallel: function (r, t, e, n) {
    var i = r.ecModel,
      a = i.getComponent('parallel', r.get('parallelIndex')),
      o = (t.coordSysDims = a.dimensions.slice())
    R(a.parallelAxisIndex, function (s, l) {
      var u = i.getComponent('parallelAxis', s),
        c = o[l]
      e.set(c, u),
        Zc(u) &&
          (n.set(c, u),
          t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l))
    })
  },
}
function Zc(r) {
  return r.get('type') === 'category'
}
function uot(r, t, e) {
  e = e || {}
  var n = e.byIndex,
    i = e.stackedCoordDimension,
    a,
    o,
    s
  cot(t) ? (a = t) : ((o = t.schema), (a = o.dimensions), (s = t.store))
  var l = !!(r && r.get('stack')),
    u,
    c,
    h,
    f
  if (
    (R(a, function (y, _) {
      bt(y) &&
        (a[_] = y =
          {
            name: y,
          }),
        l &&
          !y.isExtraCoord &&
          (!n && !u && y.ordinalMeta && (u = y),
          !c &&
            y.type !== 'ordinal' &&
            y.type !== 'time' &&
            (!i || i === y.coordDim) &&
            (c = y))
    }),
    c && !n && !u && (n = !0),
    c)
  ) {
    ;(h = '__\0ecstackresult_' + r.id),
      (f = '__\0ecstackedover_' + r.id),
      u && (u.createInvertedIndices = !0)
    var d = c.coordDim,
      p = c.type,
      g = 0
    R(a, function (y) {
      y.coordDim === d && g++
    })
    var v = {
        name: h,
        coordDim: d,
        coordDimIndex: g,
        type: p,
        isExtraCoord: !0,
        isCalculationCoord: !0,
        storeDimIndex: a.length,
      },
      m = {
        name: f,
        coordDim: f,
        coordDimIndex: g + 1,
        type: p,
        isExtraCoord: !0,
        isCalculationCoord: !0,
        storeDimIndex: a.length + 1,
      }
    o
      ? (s &&
          ((v.storeDimIndex = s.ensureCalculationDimension(f, p)),
          (m.storeDimIndex = s.ensureCalculationDimension(h, p))),
        o.appendCalculationDimension(v),
        o.appendCalculationDimension(m))
      : (a.push(v), a.push(m))
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: f,
    stackResultDimension: h,
  }
}
function cot(r) {
  return !xV(r.schema)
}
function sl(r, t) {
  return !!t && t === r.getCalculationInfo('stackedDimension')
}
function wV(r, t) {
  return sl(r, t) ? r.getCalculationInfo('stackResultDimension') : t
}
function hot(r, t) {
  var e = r.get('coordinateSystem'),
    n = Av.get(e),
    i
  return (
    t &&
      t.coordSysDims &&
      (i = st(t.coordSysDims, function (a) {
        var o = {
            name: a,
          },
          s = t.axisMap.get(a)
        if (s) {
          var l = s.get('type')
          o.type = a0(l)
        }
        return o
      })),
    i ||
      (i = (n &&
        (n.getDimensionsInfo
          ? n.getDimensionsInfo()
          : n.dimensions.slice())) || ['x', 'y']),
    i
  )
}
function fot(r, t, e) {
  var n, i
  return (
    e &&
      R(r, function (a, o) {
        var s = a.coordDim,
          l = e.categoryAxisMap.get(s)
        l &&
          (n == null && (n = o),
          (a.ordinalMeta = l.getOrdinalMeta()),
          t && (a.createInvertedIndices = !0)),
          a.otherDims.itemName != null && (i = !0)
      }),
    !i && n != null && (r[n].otherDims.itemName = 0),
    n
  )
}
function as(r, t, e) {
  e = e || {}
  var n = t.getSourceManager(),
    i,
    a = !1
  r
    ? ((a = !0), (i = fC(r)))
    : ((i = n.getSource()), (a = i.sourceFormat === ia))
  var o = sot(t),
    s = hot(t, o),
    l = e.useEncodeDefaulter,
    u = Nt(l) ? l : l ? Zt(h5, s, t) : null,
    c = {
      coordDimensions: s,
      generateCoord: e.generateCoord,
      encodeDefine: t.getEncode(),
      encodeDefaulter: u,
      canOmitUnusedDimensions: !a,
    },
    h = wv(i, c),
    f = fot(h.dimensions, e.createInvertedIndices, o),
    d = a ? null : n.getSharedDataStore(h),
    p = uot(t, {
      schema: h,
      store: d,
    }),
    g = new Vr(h, t)
  g.setCalculationInfo(p)
  var v =
    f != null && dot(i)
      ? function (m, y, _, x) {
          return x === f ? _ : this.defaultDimValueGetter(m, y, _, x)
        }
      : null
  return (g.hasItemOption = !1), g.initData(a ? i : d, null, v), g
}
function dot(r) {
  if (r.sourceFormat === ia) {
    var t = pot(r.data || [])
    return !at(yf(t))
  }
}
function pot(r) {
  for (var t = 0; t < r.length && r[t] == null; ) t++
  return r[t]
}
var MV = (function () {
  function r(t) {
    ;(this._setting = t || {}), (this._extent = [1 / 0, -1 / 0])
  }
  return (
    (r.prototype.getSetting = function (t) {
      return this._setting[t]
    }),
    (r.prototype.unionExtent = function (t) {
      var e = this._extent
      t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1])
    }),
    (r.prototype.unionExtentFromData = function (t, e) {
      this.unionExtent(t.getApproximateExtent(e))
    }),
    (r.prototype.getExtent = function () {
      return this._extent.slice()
    }),
    (r.prototype.setExtent = function (t, e) {
      var n = this._extent
      isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e)
    }),
    (r.prototype.isInExtentRange = function (t) {
      return this._extent[0] <= t && this._extent[1] >= t
    }),
    (r.prototype.isBlank = function () {
      return this._isBlank
    }),
    (r.prototype.setBlank = function (t) {
      this._isBlank = t
    }),
    r
  )
})()
J0(MV)
const os = MV
var vot = 0,
  got = (function () {
    function r(t) {
      ;(this.categories = t.categories || []),
        (this._needCollect = t.needCollect),
        (this._deduplication = t.deduplication),
        (this.uid = ++vot)
    }
    return (
      (r.createByAxisModel = function (t) {
        var e = t.option,
          n = e.data,
          i = n && st(n, mot)
        return new r({
          categories: i,
          needCollect: !i,
          deduplication: e.dedplication !== !1,
        })
      }),
      (r.prototype.getOrdinal = function (t) {
        return this._getOrCreateMap().get(t)
      }),
      (r.prototype.parseAndCollect = function (t) {
        var e,
          n = this._needCollect
        if (!bt(t) && !n) return t
        if (n && !this._deduplication)
          return (e = this.categories.length), (this.categories[e] = t), e
        var i = this._getOrCreateMap()
        return (
          (e = i.get(t)),
          e == null &&
            (n
              ? ((e = this.categories.length),
                (this.categories[e] = t),
                i.set(t, e))
              : (e = NaN)),
          e
        )
      }),
      (r.prototype._getOrCreateMap = function () {
        return this._map || (this._map = Pt(this.categories))
      }),
      r
    )
  })()
function mot(r) {
  return Ut(r) && r.value != null ? r.value : r + ''
}
const ww = got
function Mw(r) {
  return r.type === 'interval' || r.type === 'log'
}
function yot(r, t, e, n) {
  var i = {},
    a = r[1] - r[0],
    o = (i.interval = Bz(a / t, !0))
  e != null && o < e && (o = i.interval = e),
    n != null && o > n && (o = i.interval = n)
  var s = (i.intervalPrecision = TV(o)),
    l = (i.niceTickExtent = [
      mn(Math.ceil(r[0] / o) * o, s),
      mn(Math.floor(r[1] / o) * o, s),
    ])
  return _ot(l, r), i
}
function X1(r) {
  var t = Math.pow(10, FT(r)),
    e = r / t
  return (
    e ? (e === 2 ? (e = 3) : e === 3 ? (e = 5) : (e *= 2)) : (e = 1), mn(e * t)
  )
}
function TV(r) {
  return Qa(r) + 2
}
function eI(r, t, e) {
  r[t] = Math.max(Math.min(r[t], e[1]), e[0])
}
function _ot(r, t) {
  !isFinite(r[0]) && (r[0] = t[0]),
    !isFinite(r[1]) && (r[1] = t[1]),
    eI(r, 0, t),
    eI(r, 1, t),
    r[0] > r[1] && (r[0] = r[1])
}
function S_(r, t) {
  return r >= t[0] && r <= t[1]
}
function A_(r, t) {
  return t[1] === t[0] ? 0.5 : (r - t[0]) / (t[1] - t[0])
}
function b_(r, t) {
  return r * (t[1] - t[0]) + t[0]
}
var CV = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this, e) || this
    n.type = 'ordinal'
    var i = n.getSetting('ordinalMeta')
    return (
      i || (i = new ww({})),
      at(i) &&
        (i = new ww({
          categories: st(i, function (a) {
            return Ut(a) ? a.value : a
          }),
        })),
      (n._ordinalMeta = i),
      (n._extent = n.getSetting('extent') || [0, i.categories.length - 1]),
      n
    )
  }
  return (
    (t.prototype.parse = function (e) {
      return e == null
        ? NaN
        : bt(e)
        ? this._ordinalMeta.getOrdinal(e)
        : Math.round(e)
    }),
    (t.prototype.contain = function (e) {
      return (
        (e = this.parse(e)),
        S_(e, this._extent) && this._ordinalMeta.categories[e] != null
      )
    }),
    (t.prototype.normalize = function (e) {
      return (e = this._getTickNumber(this.parse(e))), A_(e, this._extent)
    }),
    (t.prototype.scale = function (e) {
      return (e = Math.round(b_(e, this._extent))), this.getRawOrdinalNumber(e)
    }),
    (t.prototype.getTicks = function () {
      for (var e = [], n = this._extent, i = n[0]; i <= n[1]; )
        e.push({
          value: i,
        }),
          i++
      return e
    }),
    (t.prototype.getMinorTicks = function (e) {}),
    (t.prototype.setSortInfo = function (e) {
      if (e == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null
        return
      }
      for (
        var n = e.ordinalNumbers,
          i = (this._ordinalNumbersByTick = []),
          a = (this._ticksByOrdinalNumber = []),
          o = 0,
          s = this._ordinalMeta.categories.length,
          l = Math.min(s, n.length);
        o < l;
        ++o
      ) {
        var u = n[o]
        ;(i[o] = u), (a[u] = o)
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; ) c++
        i.push(c), (a[c] = o)
      }
    }),
    (t.prototype._getTickNumber = function (e) {
      var n = this._ticksByOrdinalNumber
      return n && e >= 0 && e < n.length ? n[e] : e
    }),
    (t.prototype.getRawOrdinalNumber = function (e) {
      var n = this._ordinalNumbersByTick
      return n && e >= 0 && e < n.length ? n[e] : e
    }),
    (t.prototype.getLabel = function (e) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(e.value),
          i = this._ordinalMeta.categories[n]
        return i == null ? '' : i + ''
      }
    }),
    (t.prototype.count = function () {
      return this._extent[1] - this._extent[0] + 1
    }),
    (t.prototype.unionExtentFromData = function (e, n) {
      this.unionExtent(e.getApproximateExtent(n))
    }),
    (t.prototype.isInExtentRange = function (e) {
      return (
        (e = this._getTickNumber(e)),
        this._extent[0] <= e && this._extent[1] >= e
      )
    }),
    (t.prototype.getOrdinalMeta = function () {
      return this._ordinalMeta
    }),
    (t.prototype.calcNiceTicks = function () {}),
    (t.prototype.calcNiceExtent = function () {}),
    (t.type = 'ordinal'),
    t
  )
})(os)
os.registerClass(CV)
const wC = CV
var ql = mn,
  EV = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = 'interval'), (e._interval = 0), (e._intervalPrecision = 2), e
      )
    }
    return (
      (t.prototype.parse = function (e) {
        return e
      }),
      (t.prototype.contain = function (e) {
        return S_(e, this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return A_(e, this._extent)
      }),
      (t.prototype.scale = function (e) {
        return b_(e, this._extent)
      }),
      (t.prototype.setExtent = function (e, n) {
        var i = this._extent
        isNaN(e) || (i[0] = parseFloat(e)), isNaN(n) || (i[1] = parseFloat(n))
      }),
      (t.prototype.unionExtent = function (e) {
        var n = this._extent
        e[0] < n[0] && (n[0] = e[0]),
          e[1] > n[1] && (n[1] = e[1]),
          this.setExtent(n[0], n[1])
      }),
      (t.prototype.getInterval = function () {
        return this._interval
      }),
      (t.prototype.setInterval = function (e) {
        ;(this._interval = e),
          (this._niceExtent = this._extent.slice()),
          (this._intervalPrecision = TV(e))
      }),
      (t.prototype.getTicks = function (e) {
        var n = this._interval,
          i = this._extent,
          a = this._niceExtent,
          o = this._intervalPrecision,
          s = []
        if (!n) return s
        var l = 1e4
        i[0] < a[0] &&
          (e
            ? s.push({
                value: ql(a[0] - n, o),
              })
            : s.push({
                value: i[0],
              }))
        for (
          var u = a[0];
          u <= a[1] &&
          (s.push({
            value: u,
          }),
          (u = ql(u + n, o)),
          u !== s[s.length - 1].value);

        )
          if (s.length > l) return []
        var c = s.length ? s[s.length - 1].value : a[1]
        return (
          i[1] > c &&
            (e
              ? s.push({
                  value: ql(c + n, o),
                })
              : s.push({
                  value: i[1],
                })),
          s
        )
      }),
      (t.prototype.getMinorTicks = function (e) {
        for (
          var n = this.getTicks(!0), i = [], a = this.getExtent(), o = 1;
          o < n.length;
          o++
        ) {
          for (
            var s = n[o],
              l = n[o - 1],
              u = 0,
              c = [],
              h = s.value - l.value,
              f = h / e;
            u < e - 1;

          ) {
            var d = ql(l.value + (u + 1) * f)
            d > a[0] && d < a[1] && c.push(d), u++
          }
          i.push(c)
        }
        return i
      }),
      (t.prototype.getLabel = function (e, n) {
        if (e == null) return ''
        var i = n && n.precision
        i == null
          ? (i = Qa(e.value) || 0)
          : i === 'auto' && (i = this._intervalPrecision)
        var a = ql(e.value, i, !0)
        return n5(a)
      }),
      (t.prototype.calcNiceTicks = function (e, n, i) {
        e = e || 5
        var a = this._extent,
          o = a[1] - a[0]
        if (isFinite(o)) {
          o < 0 && ((o = -o), a.reverse())
          var s = yot(a, e, n, i)
          ;(this._intervalPrecision = s.intervalPrecision),
            (this._interval = s.interval),
            (this._niceExtent = s.niceTickExtent)
        }
      }),
      (t.prototype.calcNiceExtent = function (e) {
        var n = this._extent
        if (n[0] === n[1])
          if (n[0] !== 0) {
            var i = Math.abs(n[0])
            e.fixMax || (n[1] += i / 2), (n[0] -= i / 2)
          } else n[1] = 1
        var a = n[1] - n[0]
        isFinite(a) || ((n[0] = 0), (n[1] = 1)),
          this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval)
        var o = this._interval
        e.fixMin || (n[0] = ql(Math.floor(n[0] / o) * o)),
          e.fixMax || (n[1] = ql(Math.ceil(n[1] / o) * o))
      }),
      (t.prototype.setNiceExtent = function (e, n) {
        this._niceExtent = [e, n]
      }),
      (t.type = 'interval'),
      t
    )
  })(os)
os.registerClass(EV)
const ll = EV
var DV = typeof Float32Array < 'u',
  xot = DV ? Float32Array : Array
function eo(r) {
  return at(r) ? (DV ? new Float32Array(r) : r) : new xot(r)
}
var Tw = '__ec_stack_'
function MC(r) {
  return r.get('stack') || Tw + r.seriesIndex
}
function TC(r) {
  return r.dim + r.index
}
function Sot(r) {
  var t = [],
    e = r.axis,
    n = 'axis0'
  if (e.type === 'category') {
    for (var i = e.getBandWidth(), a = 0; a < r.count; a++)
      t.push(
        zt(
          {
            bandWidth: i,
            axisKey: n,
            stackId: Tw + a,
          },
          r,
        ),
      )
    for (var o = RV(t), s = [], a = 0; a < r.count; a++) {
      var l = o[n][Tw + a]
      ;(l.offsetCenter = l.offset + l.width / 2), s.push(l)
    }
    return s
  }
}
function LV(r, t) {
  var e = []
  return (
    t.eachSeriesByType(r, function (n) {
      NV(n) && e.push(n)
    }),
    e
  )
}
function Aot(r) {
  var t = {}
  R(r, function (l) {
    var u = l.coordinateSystem,
      c = u.getBaseAxis()
    if (!(c.type !== 'time' && c.type !== 'value'))
      for (
        var h = l.getData(),
          f = c.dim + '_' + c.index,
          d = h.getDimensionIndex(h.mapDimension(c.dim)),
          p = h.getStore(),
          g = 0,
          v = p.count();
        g < v;
        ++g
      ) {
        var m = p.get(d, g)
        t[f] ? t[f].push(m) : (t[f] = [m])
      }
  })
  var e = {}
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var i = t[n]
      if (i) {
        i.sort(function (l, u) {
          return l - u
        })
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1]
          s > 0 && (a = a === null ? s : Math.min(a, s))
        }
        e[n] = a
      }
    }
  return e
}
function PV(r) {
  var t = Aot(r),
    e = []
  return (
    R(r, function (n) {
      var i = n.coordinateSystem,
        a = i.getBaseAxis(),
        o = a.getExtent(),
        s
      if (a.type === 'category') s = a.getBandWidth()
      else if (a.type === 'value' || a.type === 'time') {
        var l = a.dim + '_' + a.index,
          u = t[l],
          c = Math.abs(o[1] - o[0]),
          h = a.scale.getExtent(),
          f = Math.abs(h[1] - h[0])
        s = u ? (c / f) * u : c
      } else {
        var d = n.getData()
        s = Math.abs(o[1] - o[0]) / d.count()
      }
      var p = _t(n.get('barWidth'), s),
        g = _t(n.get('barMaxWidth'), s),
        v = _t(n.get('barMinWidth') || (kV(n) ? 0.5 : 1), s),
        m = n.get('barGap'),
        y = n.get('barCategoryGap')
      e.push({
        bandWidth: s,
        barWidth: p,
        barMaxWidth: g,
        barMinWidth: v,
        barGap: m,
        barCategoryGap: y,
        axisKey: TC(a),
        stackId: MC(n),
      })
    }),
    RV(e)
  )
}
function RV(r) {
  var t = {}
  R(r, function (n, i) {
    var a = n.axisKey,
      o = n.bandWidth,
      s = t[a] || {
        bandWidth: o,
        remainedWidth: o,
        autoWidthCount: 0,
        categoryGap: null,
        gap: '20%',
        stacks: {},
      },
      l = s.stacks
    t[a] = s
    var u = n.stackId
    l[u] || s.autoWidthCount++,
      (l[u] = l[u] || {
        width: 0,
        maxWidth: 0,
      })
    var c = n.barWidth
    c &&
      !l[u].width &&
      ((l[u].width = c),
      (c = Math.min(s.remainedWidth, c)),
      (s.remainedWidth -= c))
    var h = n.barMaxWidth
    h && (l[u].maxWidth = h)
    var f = n.barMinWidth
    f && (l[u].minWidth = f)
    var d = n.barGap
    d != null && (s.gap = d)
    var p = n.barCategoryGap
    p != null && (s.categoryGap = p)
  })
  var e = {}
  return (
    R(t, function (n, i) {
      e[i] = {}
      var a = n.stacks,
        o = n.bandWidth,
        s = n.categoryGap
      if (s == null) {
        var l = pe(a).length
        s = Math.max(35 - l * 4, 15) + '%'
      }
      var u = _t(s, o),
        c = _t(n.gap, 1),
        h = n.remainedWidth,
        f = n.autoWidthCount,
        d = (h - u) / (f + (f - 1) * c)
      ;(d = Math.max(d, 0)),
        R(a, function (m) {
          var y = m.maxWidth,
            _ = m.minWidth
          if (m.width) {
            var x = m.width
            y && (x = Math.min(x, y)),
              _ && (x = Math.max(x, _)),
              (m.width = x),
              (h -= x + c * x),
              f--
          } else {
            var x = d
            y && y < x && (x = Math.min(y, h)),
              _ && _ > x && (x = _),
              x !== d && ((m.width = x), (h -= x + c * x), f--)
          }
        }),
        (d = (h - u) / (f + (f - 1) * c)),
        (d = Math.max(d, 0))
      var p = 0,
        g
      R(a, function (m, y) {
        m.width || (m.width = d), (g = m), (p += m.width * (1 + c))
      }),
        g && (p -= g.width * c)
      var v = -p / 2
      R(a, function (m, y) {
        ;(e[i][y] = e[i][y] || {
          bandWidth: o,
          offset: v,
          width: m.width,
        }),
          (v += m.width * (1 + c))
      })
    }),
    e
  )
}
function bot(r, t, e) {
  if (r && t) {
    var n = r[TC(t)]
    return n != null && e != null ? n[MC(e)] : n
  }
}
function IV(r, t) {
  var e = LV(r, t),
    n = PV(e)
  R(e, function (i) {
    var a = i.getData(),
      o = i.coordinateSystem,
      s = o.getBaseAxis(),
      l = MC(i),
      u = n[TC(s)][l],
      c = u.offset,
      h = u.width
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: h,
    })
  })
}
function OV(r) {
  return {
    seriesType: r,
    plan: Ef(),
    reset: function (t) {
      if (NV(t)) {
        var e = t.getData(),
          n = t.coordinateSystem,
          i = n.getBaseAxis(),
          a = n.getOtherAxis(i),
          o = e.getDimensionIndex(e.mapDimension(a.dim)),
          s = e.getDimensionIndex(e.mapDimension(i.dim)),
          l = t.get('showBackground', !0),
          u = e.mapDimension(a.dim),
          c = e.getCalculationInfo('stackResultDimension'),
          h = sl(e, u) && !!e.getCalculationInfo('stackedOnSeries'),
          f = a.isHorizontal(),
          d = wot(i, a),
          p = kV(t),
          g = t.get('barMinHeight') || 0,
          v = c && e.getDimensionIndex(c),
          m = e.getLayout('size'),
          y = e.getLayout('offset')
        return {
          progress: function (_, x) {
            for (
              var A = _.count,
                S = p && eo(A * 3),
                b = p && l && eo(A * 3),
                T = p && eo(A),
                w = n.master.getRect(),
                M = f ? w.width : w.height,
                C,
                E = x.getStore(),
                D = 0;
              (C = _.next()) != null;

            ) {
              var P = E.get(h ? v : o, C),
                L = E.get(s, C),
                I = d,
                F = void 0
              h && (F = +P - E.get(o, C))
              var k = void 0,
                V = void 0,
                H = void 0,
                Y = void 0
              if (f) {
                var K = n.dataToPoint([P, L])
                if (h) {
                  var ut = n.dataToPoint([F, L])
                  I = ut[0]
                }
                ;(k = I),
                  (V = K[1] + y),
                  (H = K[0] - I),
                  (Y = m),
                  Math.abs(H) < g && (H = (H < 0 ? -1 : 1) * g)
              } else {
                var K = n.dataToPoint([L, P])
                if (h) {
                  var ut = n.dataToPoint([L, F])
                  I = ut[1]
                }
                ;(k = K[0] + y),
                  (V = I),
                  (H = m),
                  (Y = K[1] - I),
                  Math.abs(Y) < g && (Y = (Y <= 0 ? -1 : 1) * g)
              }
              p
                ? ((S[D] = k),
                  (S[D + 1] = V),
                  (S[D + 2] = f ? H : Y),
                  b &&
                    ((b[D] = f ? w.x : k),
                    (b[D + 1] = f ? V : w.y),
                    (b[D + 2] = M)),
                  (T[C] = C))
                : x.setItemLayout(C, {
                    x: k,
                    y: V,
                    width: H,
                    height: Y,
                  }),
                (D += 3)
            }
            p &&
              x.setLayout({
                largePoints: S,
                largeDataIndices: T,
                largeBackgroundPoints: b,
                valueAxisHorizontal: f,
              })
          },
        }
      }
    },
  }
}
function NV(r) {
  return r.coordinateSystem && r.coordinateSystem.type === 'cartesian2d'
}
function kV(r) {
  return r.pipelineContext && r.pipelineContext.large
}
function wot(r, t) {
  var e = t.model.get('startValue')
  return (
    e || (e = 0),
    t.toGlobalCoord(t.dataToCoord(t.type === 'log' ? (e > 0 ? e : 1) : e))
  )
}
var Mot = function (r, t, e, n) {
    for (; e < n; ) {
      var i = (e + n) >>> 1
      r[i][1] < t ? (e = i + 1) : (n = i)
    }
    return e
  },
  BV = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'time'), n
    }
    return (
      (t.prototype.getLabel = function (e) {
        var n = this.getSetting('useUTC')
        return u_(
          e.value,
          XP[Znt(Oh(this._minLevelUnit))] || XP.second,
          n,
          this.getSetting('locale'),
        )
      }),
      (t.prototype.getFormattedLabel = function (e, n, i) {
        var a = this.getSetting('useUTC'),
          o = this.getSetting('locale')
        return Knt(e, n, i, o, a)
      }),
      (t.prototype.getTicks = function () {
        var e = this._interval,
          n = this._extent,
          i = []
        if (!e) return i
        i.push({
          value: n[0],
          level: 0,
        })
        var a = this.getSetting('useUTC'),
          o = Rot(this._minLevelUnit, this._approxInterval, a, n)
        return (
          (i = i.concat(o)),
          i.push({
            value: n[1],
            level: 0,
          }),
          i
        )
      }),
      (t.prototype.calcNiceExtent = function (e) {
        var n = this._extent
        if (
          (n[0] === n[1] && ((n[0] -= Xi), (n[1] += Xi)),
          n[1] === -1 / 0 && n[0] === 1 / 0)
        ) {
          var i = new Date()
          ;(n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate())),
            (n[0] = n[1] - Xi)
        }
        this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval)
      }),
      (t.prototype.calcNiceTicks = function (e, n, i) {
        e = e || 10
        var a = this._extent,
          o = a[1] - a[0]
        ;(this._approxInterval = o / e),
          n != null && this._approxInterval < n && (this._approxInterval = n),
          i != null && this._approxInterval > i && (this._approxInterval = i)
        var s = rm.length,
          l = Math.min(Mot(rm, this._approxInterval, 0, s), s - 1)
        ;(this._interval = rm[l][1]),
          (this._minLevelUnit = rm[Math.max(l - 1, 0)][0])
      }),
      (t.prototype.parse = function (e) {
        return be(e) ? e : +po(e)
      }),
      (t.prototype.contain = function (e) {
        return S_(this.parse(e), this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return A_(this.parse(e), this._extent)
      }),
      (t.prototype.scale = function (e) {
        return b_(e, this._extent)
      }),
      (t.type = 'time'),
      t
    )
  })(ll),
  rm = [
    ['second', iC],
    ['minute', aC],
    ['hour', lp],
    ['quarter-day', lp * 6],
    ['half-day', lp * 12],
    ['day', Xi * 1.2],
    ['half-week', Xi * 3.5],
    ['week', Xi * 7],
    ['month', Xi * 31],
    ['quarter', Xi * 95],
    ['half-year', WP / 2],
    ['year', WP],
  ]
function Tot(r, t, e, n) {
  var i = po(t),
    a = po(e),
    o = function (p) {
      return YP(i, p, n) === YP(a, p, n)
    },
    s = function () {
      return o('year')
    },
    l = function () {
      return s() && o('month')
    },
    u = function () {
      return l() && o('day')
    },
    c = function () {
      return u() && o('hour')
    },
    h = function () {
      return c() && o('minute')
    },
    f = function () {
      return h() && o('second')
    },
    d = function () {
      return f() && o('millisecond')
    }
  switch (r) {
    case 'year':
      return s()
    case 'month':
      return l()
    case 'day':
      return u()
    case 'hour':
      return c()
    case 'minute':
      return h()
    case 'second':
      return f()
    case 'millisecond':
      return d()
  }
}
function Cot(r, t) {
  return (r /= Xi), r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1
}
function Eot(r) {
  var t = 30 * Xi
  return (r /= t), r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1
}
function Dot(r) {
  return (r /= lp), r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1
}
function nI(r, t) {
  return (
    (r /= t ? aC : iC),
    r > 30
      ? 30
      : r > 20
      ? 20
      : r > 15
      ? 15
      : r > 10
      ? 10
      : r > 5
      ? 5
      : r > 2
      ? 2
      : 1
  )
}
function Lot(r) {
  return Bz(r, !0)
}
function Pot(r, t, e) {
  var n = new Date(r)
  switch (Oh(t)) {
    case 'year':
    case 'month':
      n[KU(e)](0)
    case 'day':
      n[jU(e)](1)
    case 'hour':
      n[JU(e)](0)
    case 'minute':
      n[QU(e)](0)
    case 'second':
      n[t5(e)](0), n[e5(e)](0)
  }
  return n.getTime()
}
function Rot(r, t, e, n) {
  var i = 1e4,
    a = qU,
    o = 0
  function s(M, C, E, D, P, L, I) {
    for (var F = new Date(C), k = C, V = F[D](); k < E && k <= n[1]; )
      I.push({
        value: k,
      }),
        (V += M),
        F[P](V),
        (k = F.getTime())
    I.push({
      value: k,
      notAdd: !0,
    })
  }
  function l(M, C, E) {
    var D = [],
      P = !C.length
    if (!Tot(Oh(M), n[0], n[1], e)) {
      P &&
        (C = [
          {
            value: Pot(new Date(n[0]), M, e),
          },
          {
            value: n[1],
          },
        ])
      for (var L = 0; L < C.length - 1; L++) {
        var I = C[L].value,
          F = C[L + 1].value
        if (I !== F) {
          var k = void 0,
            V = void 0,
            H = void 0,
            Y = !1
          switch (M) {
            case 'year':
              ;(k = Math.max(1, Math.round(t / Xi / 365))),
                (V = oC(e)),
                (H = jnt(e))
              break
            case 'half-year':
            case 'quarter':
            case 'month':
              ;(k = Eot(t)), (V = Nh(e)), (H = KU(e))
              break
            case 'week':
            case 'half-week':
            case 'day':
              ;(k = Cot(t)), (V = c_(e)), (H = jU(e)), (Y = !0)
              break
            case 'half-day':
            case 'quarter-day':
            case 'hour':
              ;(k = Dot(t)), (V = Yp(e)), (H = JU(e))
              break
            case 'minute':
              ;(k = nI(t, !0)), (V = h_(e)), (H = QU(e))
              break
            case 'second':
              ;(k = nI(t, !1)), (V = f_(e)), (H = t5(e))
              break
            case 'millisecond':
              ;(k = Lot(t)), (V = d_(e)), (H = e5(e))
              break
          }
          s(k, I, F, V, H, Y, D),
            M === 'year' &&
              E.length > 1 &&
              L === 0 &&
              E.unshift({
                value: E[0].value - k,
              })
        }
      }
      for (var L = 0; L < D.length; L++) E.push(D[L])
      return D
    }
  }
  for (var u = [], c = [], h = 0, f = 0, d = 0; d < a.length && o++ < i; ++d) {
    var p = Oh(a[d])
    if (qnt(a[d])) {
      l(a[d], u[u.length - 1] || [], c)
      var g = a[d + 1] ? Oh(a[d + 1]) : null
      if (p !== g) {
        if (c.length) {
          ;(f = h),
            c.sort(function (M, C) {
              return M.value - C.value
            })
          for (var v = [], m = 0; m < c.length; ++m) {
            var y = c[m].value
            ;(m === 0 || c[m - 1].value !== y) &&
              (v.push(c[m]), y >= n[0] && y <= n[1] && h++)
          }
          var _ = (n[1] - n[0]) / t
          if ((h > _ * 1.5 && f > _ / 1.5) || (u.push(v), h > _ || r === a[d]))
            break
        }
        c = []
      }
    }
  }
  for (
    var x = Ne(
        st(u, function (M) {
          return Ne(M, function (C) {
            return C.value >= n[0] && C.value <= n[1] && !C.notAdd
          })
        }),
        function (M) {
          return M.length > 0
        },
      ),
      A = [],
      S = x.length - 1,
      d = 0;
    d < x.length;
    ++d
  )
    for (var b = x[d], T = 0; T < b.length; ++T)
      A.push({
        value: b[T].value,
        level: S - d,
      })
  A.sort(function (M, C) {
    return M.value - C.value
  })
  for (var w = [], d = 0; d < A.length; ++d)
    (d === 0 || A[d].value !== A[d - 1].value) && w.push(A[d])
  return w
}
os.registerClass(BV)
const FV = BV
var rI = os.prototype,
  fp = ll.prototype,
  Iot = mn,
  Oot = Math.floor,
  Not = Math.ceil,
  im = Math.pow,
  ha = Math.log,
  CC = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = 'log'),
        (e.base = 10),
        (e._originalScale = new ll()),
        (e._interval = 0),
        e
      )
    }
    return (
      (t.prototype.getTicks = function (e) {
        var n = this._originalScale,
          i = this._extent,
          a = n.getExtent(),
          o = fp.getTicks.call(this, e)
        return st(
          o,
          function (s) {
            var l = s.value,
              u = mn(im(this.base, l))
            return (
              (u = l === i[0] && this._fixMin ? am(u, a[0]) : u),
              (u = l === i[1] && this._fixMax ? am(u, a[1]) : u),
              {
                value: u,
              }
            )
          },
          this,
        )
      }),
      (t.prototype.setExtent = function (e, n) {
        var i = ha(this.base)
        ;(e = ha(Math.max(0, e)) / i),
          (n = ha(Math.max(0, n)) / i),
          fp.setExtent.call(this, e, n)
      }),
      (t.prototype.getExtent = function () {
        var e = this.base,
          n = rI.getExtent.call(this)
        ;(n[0] = im(e, n[0])), (n[1] = im(e, n[1]))
        var i = this._originalScale,
          a = i.getExtent()
        return (
          this._fixMin && (n[0] = am(n[0], a[0])),
          this._fixMax && (n[1] = am(n[1], a[1])),
          n
        )
      }),
      (t.prototype.unionExtent = function (e) {
        this._originalScale.unionExtent(e)
        var n = this.base
        ;(e[0] = ha(e[0]) / ha(n)),
          (e[1] = ha(e[1]) / ha(n)),
          rI.unionExtent.call(this, e)
      }),
      (t.prototype.unionExtentFromData = function (e, n) {
        this.unionExtent(e.getApproximateExtent(n))
      }),
      (t.prototype.calcNiceTicks = function (e) {
        e = e || 10
        var n = this._extent,
          i = n[1] - n[0]
        if (!(i === 1 / 0 || i <= 0)) {
          var a = mtt(i),
            o = (e / i) * a
          for (
            o <= 0.5 && (a *= 10);
            !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0;

          )
            a *= 10
          var s = [mn(Not(n[0] / a) * a), mn(Oot(n[1] / a) * a)]
          ;(this._interval = a), (this._niceExtent = s)
        }
      }),
      (t.prototype.calcNiceExtent = function (e) {
        fp.calcNiceExtent.call(this, e),
          (this._fixMin = e.fixMin),
          (this._fixMax = e.fixMax)
      }),
      (t.prototype.parse = function (e) {
        return e
      }),
      (t.prototype.contain = function (e) {
        return (e = ha(e) / ha(this.base)), S_(e, this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return (e = ha(e) / ha(this.base)), A_(e, this._extent)
      }),
      (t.prototype.scale = function (e) {
        return (e = b_(e, this._extent)), im(this.base, e)
      }),
      (t.type = 'log'),
      t
    )
  })(os),
  zV = CC.prototype
zV.getMinorTicks = fp.getMinorTicks
zV.getLabel = fp.getLabel
function am(r, t) {
  return Iot(r, Qa(t))
}
os.registerClass(CC)
const kot = CC
var Bot = (function () {
    function r(t, e, n) {
      this._prepareParams(t, e, n)
    }
    return (
      (r.prototype._prepareParams = function (t, e, n) {
        n[1] < n[0] && (n = [NaN, NaN]),
          (this._dataMin = n[0]),
          (this._dataMax = n[1])
        var i = (this._isOrdinal = t.type === 'ordinal')
        this._needCrossZero =
          t.type === 'interval' && e.getNeedCrossZero && e.getNeedCrossZero()
        var a = e.get('min', !0)
        a == null && (a = e.get('startValue', !0))
        var o = (this._modelMinRaw = a)
        Nt(o)
          ? (this._modelMinNum = om(
              t,
              o({
                min: n[0],
                max: n[1],
              }),
            ))
          : o !== 'dataMin' && (this._modelMinNum = om(t, o))
        var s = (this._modelMaxRaw = e.get('max', !0))
        if (
          (Nt(s)
            ? (this._modelMaxNum = om(
                t,
                s({
                  min: n[0],
                  max: n[1],
                }),
              ))
            : s !== 'dataMax' && (this._modelMaxNum = om(t, s)),
          i)
        )
          this._axisDataLen = e.getCategories().length
        else {
          var l = e.get('boundaryGap'),
            u = at(l) ? l : [l || 0, l || 0]
          typeof u[0] == 'boolean' || typeof u[1] == 'boolean'
            ? (this._boundaryGapInner = [0, 0])
            : (this._boundaryGapInner = [Ta(u[0], 1), Ta(u[1], 1)])
        }
      }),
      (r.prototype.calculate = function () {
        var t = this._isOrdinal,
          e = this._dataMin,
          n = this._dataMax,
          i = this._axisDataLen,
          a = this._boundaryGapInner,
          o = t ? null : n - e || Math.abs(e),
          s = this._modelMinRaw === 'dataMin' ? e : this._modelMinNum,
          l = this._modelMaxRaw === 'dataMax' ? n : this._modelMaxNum,
          u = s != null,
          c = l != null
        s == null && (s = t ? (i ? 0 : NaN) : e - a[0] * o),
          l == null && (l = t ? (i ? i - 1 : NaN) : n + a[1] * o),
          (s == null || !isFinite(s)) && (s = NaN),
          (l == null || !isFinite(l)) && (l = NaN)
        var h = kp(s) || kp(l) || (t && !i)
        this._needCrossZero &&
          (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0))
        var f = this._determinedMin,
          d = this._determinedMax
        return (
          f != null && ((s = f), (u = !0)),
          d != null && ((l = d), (c = !0)),
          {
            min: s,
            max: l,
            minFixed: u,
            maxFixed: c,
            isBlank: h,
          }
        )
      }),
      (r.prototype.modifyDataMinMax = function (t, e) {
        this[zot[t]] = e
      }),
      (r.prototype.setDeterminedMinMax = function (t, e) {
        var n = Fot[t]
        this[n] = e
      }),
      (r.prototype.freeze = function () {
        this.frozen = !0
      }),
      r
    )
  })(),
  Fot = {
    min: '_determinedMin',
    max: '_determinedMax',
  },
  zot = {
    min: '_dataMin',
    max: '_dataMax',
  }
function UV(r, t, e) {
  var n = r.rawExtentInfo
  return n || ((n = new Bot(r, t, e)), (r.rawExtentInfo = n), n)
}
function om(r, t) {
  return t == null ? null : kp(t) ? NaN : r.parse(t)
}
function VV(r, t) {
  var e = r.type,
    n = UV(r, t, r.getExtent()).calculate()
  r.setBlank(n.isBlank)
  var i = n.min,
    a = n.max,
    o = t.ecModel
  if (o && e === 'time') {
    var s = LV('bar', o),
      l = !1
    if (
      (R(s, function (h) {
        l = l || h.getBaseAxis() === t.axis
      }),
      l)
    ) {
      var u = PV(s),
        c = Uot(i, a, t, u)
      ;(i = c.min), (a = c.max)
    }
  }
  return {
    extent: [i, a],
    fixMin: n.minFixed,
    fixMax: n.maxFixed,
  }
}
function Uot(r, t, e, n) {
  var i = e.axis.getExtent(),
    a = i[1] - i[0],
    o = bot(n, e.axis)
  if (o === void 0)
    return {
      min: r,
      max: t,
    }
  var s = 1 / 0
  R(o, function (d) {
    s = Math.min(d.offset, s)
  })
  var l = -1 / 0
  R(o, function (d) {
    l = Math.max(d.offset + d.width, l)
  }),
    (s = Math.abs(s)),
    (l = Math.abs(l))
  var u = s + l,
    c = t - r,
    h = 1 - (s + l) / a,
    f = c / h - c
  return (
    (t += f * (l / u)),
    (r -= f * (s / u)),
    {
      min: r,
      max: t,
    }
  )
}
function af(r, t) {
  var e = t,
    n = VV(r, e),
    i = n.extent,
    a = e.get('splitNumber')
  r instanceof kot && (r.base = e.get('logBase'))
  var o = r.type,
    s = e.get('interval'),
    l = o === 'interval' || o === 'time'
  r.setExtent(i[0], i[1]),
    r.calcNiceExtent({
      splitNumber: a,
      fixMin: n.fixMin,
      fixMax: n.fixMax,
      minInterval: l ? e.get('minInterval') : null,
      maxInterval: l ? e.get('maxInterval') : null,
    }),
    s != null && r.setInterval && r.setInterval(s)
}
function w_(r, t) {
  if (((t = t || r.get('type')), t))
    switch (t) {
      case 'category':
        return new wC({
          ordinalMeta: r.getOrdinalMeta
            ? r.getOrdinalMeta()
            : r.getCategories(),
          extent: [1 / 0, -1 / 0],
        })
      case 'time':
        return new FV({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get('useUTC'),
        })
      default:
        return new (os.getClass(t) || ll)()
    }
}
function Vot(r) {
  var t = r.scale.getExtent(),
    e = t[0],
    n = t[1]
  return !((e > 0 && n > 0) || (e < 0 && n < 0))
}
function Pf(r) {
  var t = r.getLabelModel().get('formatter'),
    e = r.type === 'category' ? r.scale.getExtent()[0] : null
  return r.scale.type === 'time'
    ? (function (n) {
        return function (i, a) {
          return r.scale.getFormattedLabel(i, a, n)
        }
      })(t)
    : bt(t)
    ? (function (n) {
        return function (i) {
          var a = r.scale.getLabel(i),
            o = n.replace('{value}', a ?? '')
          return o
        }
      })(t)
    : Nt(t)
    ? (function (n) {
        return function (i, a) {
          return (
            e != null && (a = i.value - e),
            n(
              EC(r, i),
              a,
              i.level != null
                ? {
                    level: i.level,
                  }
                : null,
            )
          )
        }
      })(t)
    : function (n) {
        return r.scale.getLabel(n)
      }
}
function EC(r, t) {
  return r.type === 'category' ? r.scale.getLabel(t) : t.value
}
function Got(r) {
  var t = r.model,
    e = r.scale
  if (!(!t.get(['axisLabel', 'show']) || e.isBlank())) {
    var n,
      i,
      a = e.getExtent()
    e instanceof wC ? (i = e.count()) : ((n = e.getTicks()), (i = n.length))
    var o = r.getLabelModel(),
      s = Pf(r),
      l,
      u = 1
    i > 40 && (u = Math.ceil(i / 40))
    for (var c = 0; c < i; c += u) {
      var h = n
          ? n[c]
          : {
              value: a[0] + c,
            },
        f = s(h, c),
        d = o.getTextRect(f),
        p = Hot(d, o.get('rotate') || 0)
      l ? l.union(p) : (l = p)
    }
    return l
  }
}
function Hot(r, t) {
  var e = (t * Math.PI) / 180,
    n = r.width,
    i = r.height,
    a = n * Math.abs(Math.cos(e)) + Math.abs(i * Math.sin(e)),
    o = n * Math.abs(Math.sin(e)) + Math.abs(i * Math.cos(e)),
    s = new ee(r.x, r.y, a, o)
  return s
}
function DC(r) {
  var t = r.get('interval')
  return t ?? 'auto'
}
function GV(r) {
  return r.type === 'category' && DC(r.getLabelModel()) === 0
}
function o0(r, t) {
  var e = {}
  return (
    R(r.mapDimensionsAll(t), function (n) {
      e[wV(r, n)] = !0
    }),
    pe(e)
  )
}
function Wot(r, t, e) {
  t &&
    R(o0(t, e), function (n) {
      var i = t.getApproximateExtent(n)
      i[0] < r[0] && (r[0] = i[0]), i[1] > r[1] && (r[1] = i[1])
    })
}
var Mv = (function () {
    function r() {}
    return (
      (r.prototype.getNeedCrossZero = function () {
        var t = this.option
        return !t.scale
      }),
      (r.prototype.getCoordSysModel = function () {}),
      r
    )
  })(),
  Xot = 1e-8
function iI(r, t) {
  return Math.abs(r - t) < Xot
}
function hu(r, t, e) {
  var n = 0,
    i = r[0]
  if (!i) return !1
  for (var a = 1; a < r.length; a++) {
    var o = r[a]
    ;(n += No(i[0], i[1], o[0], o[1], t, e)), (i = o)
  }
  var s = r[0]
  return (
    (!iI(i[0], s[0]) || !iI(i[1], s[1])) &&
      (n += No(i[0], i[1], s[0], s[1], t, e)),
    n !== 0
  )
}
var Yot = []
function Y1(r, t) {
  for (var e = 0; e < r.length; e++) pr(r[e], r[e], t)
}
function aI(r, t, e, n) {
  for (var i = 0; i < r.length; i++) {
    var a = r[i]
    n && (a = n.project(a)),
      a && isFinite(a[0]) && isFinite(a[1]) && (Bs(t, t, a), Fs(e, e, a))
  }
}
function $ot(r) {
  for (
    var t = 0,
      e = 0,
      n = 0,
      i = r.length,
      a = r[i - 1][0],
      o = r[i - 1][1],
      s = 0;
    s < i;
    s++
  ) {
    var l = r[s][0],
      u = r[s][1],
      c = a * u - l * o
    ;(t += c), (e += (a + l) * c), (n += (o + u) * c), (a = l), (o = u)
  }
  return t ? [e / t / 3, n / t / 3, t] : [r[0][0] || 0, r[0][1] || 0]
}
var HV = (function () {
    function r(t) {
      this.name = t
    }
    return (
      (r.prototype.setCenter = function (t) {
        this._center = t
      }),
      (r.prototype.getCenter = function () {
        var t = this._center
        return t || (t = this._center = this.calcCenter()), t
      }),
      r
    )
  })(),
  oI = (function () {
    function r(t, e) {
      ;(this.type = 'polygon'), (this.exterior = t), (this.interiors = e)
    }
    return r
  })(),
  sI = (function () {
    function r(t) {
      ;(this.type = 'linestring'), (this.points = t)
    }
    return r
  })(),
  WV = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this, e) || this
      return (
        (a.type = 'geoJSON'),
        (a.geometries = n),
        (a._center = i && [i[0], i[1]]),
        a
      )
    }
    return (
      (t.prototype.calcCenter = function () {
        for (var e = this.geometries, n, i = 0, a = 0; a < e.length; a++) {
          var o = e[a],
            s = o.exterior,
            l = s && s.length
          l > i && ((n = o), (i = l))
        }
        if (n) return $ot(n.exterior)
        var u = this.getBoundingRect()
        return [u.x + u.width / 2, u.y + u.height / 2]
      }),
      (t.prototype.getBoundingRect = function (e) {
        var n = this._rect
        if (n && !e) return n
        var i = [1 / 0, 1 / 0],
          a = [-1 / 0, -1 / 0],
          o = this.geometries
        return (
          R(o, function (s) {
            s.type === 'polygon'
              ? aI(s.exterior, i, a, e)
              : R(s.points, function (l) {
                  aI(l, i, a, e)
                })
          }),
          (isFinite(i[0]) &&
            isFinite(i[1]) &&
            isFinite(a[0]) &&
            isFinite(a[1])) ||
            (i[0] = i[1] = a[0] = a[1] = 0),
          (n = new ee(i[0], i[1], a[0] - i[0], a[1] - i[1])),
          e || (this._rect = n),
          n
        )
      }),
      (t.prototype.contain = function (e) {
        var n = this.getBoundingRect(),
          i = this.geometries
        if (!n.contain(e[0], e[1])) return !1
        t: for (var a = 0, o = i.length; a < o; a++) {
          var s = i[a]
          if (s.type === 'polygon') {
            var l = s.exterior,
              u = s.interiors
            if (hu(l, e[0], e[1])) {
              for (var c = 0; c < (u ? u.length : 0); c++)
                if (hu(u[c], e[0], e[1])) continue t
              return !0
            }
          }
        }
        return !1
      }),
      (t.prototype.transformTo = function (e, n, i, a) {
        var o = this.getBoundingRect(),
          s = o.width / o.height
        i ? a || (a = i / s) : (i = s * a)
        for (
          var l = new ee(e, n, i, a),
            u = o.calculateTransform(l),
            c = this.geometries,
            h = 0;
          h < c.length;
          h++
        ) {
          var f = c[h]
          f.type === 'polygon'
            ? (Y1(f.exterior, u),
              R(f.interiors, function (d) {
                Y1(d, u)
              }))
            : R(f.points, function (d) {
                Y1(d, u)
              })
        }
        ;(o = this._rect),
          o.copy(l),
          (this._center = [o.x + o.width / 2, o.y + o.height / 2])
      }),
      (t.prototype.cloneShallow = function (e) {
        e == null && (e = this.name)
        var n = new t(e, this.geometries, this._center)
        return (n._rect = this._rect), (n.transformTo = null), n
      }),
      t
    )
  })(HV),
  qot = (function (r) {
    X(t, r)
    function t(e, n) {
      var i = r.call(this, e) || this
      return (i.type = 'geoSVG'), (i._elOnlyForCalculate = n), i
    }
    return (
      (t.prototype.calcCenter = function () {
        for (
          var e = this._elOnlyForCalculate,
            n = e.getBoundingRect(),
            i = [n.x + n.width / 2, n.y + n.height / 2],
            a = Z0(Yot),
            o = e;
          o && !o.isGeoSVGGraphicRoot;

        )
          Ho(a, o.getLocalTransform(), a), (o = o.parent)
        return mf(a, a), pr(i, i, a), i
      }),
      t
    )
  })(HV)
function Zot(r) {
  if (!r.UTF8Encoding) return r
  var t = r,
    e = t.UTF8Scale
  e == null && (e = 1024)
  var n = t.features
  return (
    R(n, function (i) {
      var a = i.geometry,
        o = a.encodeOffsets,
        s = a.coordinates
      if (o)
        switch (a.type) {
          case 'LineString':
            a.coordinates = XV(s, o, e)
            break
          case 'Polygon':
            $1(s, o, e)
            break
          case 'MultiLineString':
            $1(s, o, e)
            break
          case 'MultiPolygon':
            R(s, function (l, u) {
              return $1(l, o[u], e)
            })
        }
    }),
    (t.UTF8Encoding = !1),
    t
  )
}
function $1(r, t, e) {
  for (var n = 0; n < r.length; n++) r[n] = XV(r[n], t[n], e)
}
function XV(r, t, e) {
  for (var n = [], i = t[0], a = t[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64,
      l = r.charCodeAt(o + 1) - 64
    ;(s = (s >> 1) ^ -(s & 1)),
      (l = (l >> 1) ^ -(l & 1)),
      (s += i),
      (l += a),
      (i = s),
      (a = l),
      n.push([s / e, l / e])
  }
  return n
}
function Kot(r, t) {
  return (
    (r = Zot(r)),
    st(
      Ne(r.features, function (e) {
        return e.geometry && e.properties && e.geometry.coordinates.length > 0
      }),
      function (e) {
        var n = e.properties,
          i = e.geometry,
          a = []
        switch (i.type) {
          case 'Polygon':
            var o = i.coordinates
            a.push(new oI(o[0], o.slice(1)))
            break
          case 'MultiPolygon':
            R(i.coordinates, function (l) {
              l[0] && a.push(new oI(l[0], l.slice(1)))
            })
            break
          case 'LineString':
            a.push(new sI([i.coordinates]))
            break
          case 'MultiLineString':
            a.push(new sI(i.coordinates))
        }
        var s = new WV(n[t || 'name'], a, n.cp)
        return (s.properties = n), s
      },
    )
  )
}
var Jp = ve()
function YV(r, t) {
  var e = st(t, function (n) {
    return r.scale.parse(n)
  })
  return (
    r.type === 'time' &&
      e.length > 0 &&
      (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])),
    e
  )
}
function jot(r) {
  var t = r.getLabelModel().get('customValues')
  if (t) {
    var e = Pf(r)
    return {
      labels: YV(r, t).map(function (n) {
        var i = {
          value: n,
        }
        return {
          formattedLabel: e(i),
          rawLabel: r.scale.getLabel(i),
          tickValue: n,
        }
      }),
    }
  }
  return r.type === 'category' ? Qot(r) : est(r)
}
function Jot(r, t) {
  var e = r.getTickModel().get('customValues')
  return e
    ? {
        ticks: YV(r, e),
      }
    : r.type === 'category'
    ? tst(r, t)
    : {
        ticks: st(r.scale.getTicks(), function (n) {
          return n.value
        }),
      }
}
function Qot(r) {
  var t = r.getLabelModel(),
    e = $V(r, t)
  return !t.get('show') || r.scale.isBlank()
    ? {
        labels: [],
        labelCategoryInterval: e.labelCategoryInterval,
      }
    : e
}
function $V(r, t) {
  var e = qV(r, 'labels'),
    n = DC(t),
    i = ZV(e, n)
  if (i) return i
  var a, o
  return (
    Nt(n) ? (a = JV(r, n)) : ((o = n === 'auto' ? nst(r) : n), (a = jV(r, o))),
    KV(e, n, {
      labels: a,
      labelCategoryInterval: o,
    })
  )
}
function tst(r, t) {
  var e = qV(r, 'ticks'),
    n = DC(t),
    i = ZV(e, n)
  if (i) return i
  var a, o
  if (((!t.get('show') || r.scale.isBlank()) && (a = []), Nt(n)))
    a = JV(r, n, !0)
  else if (n === 'auto') {
    var s = $V(r, r.getLabelModel())
    ;(o = s.labelCategoryInterval),
      (a = st(s.labels, function (l) {
        return l.tickValue
      }))
  } else (o = n), (a = jV(r, o, !0))
  return KV(e, n, {
    ticks: a,
    tickCategoryInterval: o,
  })
}
function est(r) {
  var t = r.scale.getTicks(),
    e = Pf(r)
  return {
    labels: st(t, function (n, i) {
      return {
        level: n.level,
        formattedLabel: e(n, i),
        rawLabel: r.scale.getLabel(n),
        tickValue: n.value,
      }
    }),
  }
}
function qV(r, t) {
  return Jp(r)[t] || (Jp(r)[t] = [])
}
function ZV(r, t) {
  for (var e = 0; e < r.length; e++) if (r[e].key === t) return r[e].value
}
function KV(r, t, e) {
  return (
    r.push({
      key: t,
      value: e,
    }),
    e
  )
}
function nst(r) {
  var t = Jp(r).autoInterval
  return t ?? (Jp(r).autoInterval = r.calculateCategoryInterval())
}
function rst(r) {
  var t = ist(r),
    e = Pf(r),
    n = ((t.axisRotate - t.labelRotate) / 180) * Math.PI,
    i = r.scale,
    a = i.getExtent(),
    o = i.count()
  if (a[1] - a[0] < 1) return 0
  var s = 1
  o > 40 && (s = Math.max(1, Math.floor(o / 40)))
  for (
    var l = a[0],
      u = r.dataToCoord(l + 1) - r.dataToCoord(l),
      c = Math.abs(u * Math.cos(n)),
      h = Math.abs(u * Math.sin(n)),
      f = 0,
      d = 0;
    l <= a[1];
    l += s
  ) {
    var p = 0,
      g = 0,
      v = mv(
        e({
          value: l,
        }),
        t.font,
        'center',
        'top',
      )
    ;(p = v.width * 1.3),
      (g = v.height * 1.3),
      (f = Math.max(f, p, 7)),
      (d = Math.max(d, g, 7))
  }
  var m = f / c,
    y = d / h
  isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0)
  var _ = Math.max(0, Math.floor(Math.min(m, y))),
    x = Jp(r.model),
    A = r.getExtent(),
    S = x.lastAutoInterval,
    b = x.lastTickCount
  return (
    S != null &&
    b != null &&
    Math.abs(S - _) <= 1 &&
    Math.abs(b - o) <= 1 &&
    S > _ &&
    x.axisExtent0 === A[0] &&
    x.axisExtent1 === A[1]
      ? (_ = S)
      : ((x.lastTickCount = o),
        (x.lastAutoInterval = _),
        (x.axisExtent0 = A[0]),
        (x.axisExtent1 = A[1])),
    _
  )
}
function ist(r) {
  var t = r.getLabelModel()
  return {
    axisRotate: r.getRotate
      ? r.getRotate()
      : r.isHorizontal && !r.isHorizontal()
      ? 90
      : 0,
    labelRotate: t.get('rotate') || 0,
    font: t.getFont(),
  }
}
function jV(r, t, e) {
  var n = Pf(r),
    i = r.scale,
    a = i.getExtent(),
    o = r.getLabelModel(),
    s = [],
    l = Math.max((t || 0) + 1, 1),
    u = a[0],
    c = i.count()
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l))
  var h = GV(r),
    f = o.get('showMinLabel') || h,
    d = o.get('showMaxLabel') || h
  f && u !== a[0] && g(a[0])
  for (var p = u; p <= a[1]; p += l) g(p)
  d && p - l !== a[1] && g(a[1])
  function g(v) {
    var m = {
      value: v,
    }
    s.push(
      e
        ? v
        : {
            formattedLabel: n(m),
            rawLabel: i.getLabel(m),
            tickValue: v,
          },
    )
  }
  return s
}
function JV(r, t, e) {
  var n = r.scale,
    i = Pf(r),
    a = []
  return (
    R(n.getTicks(), function (o) {
      var s = n.getLabel(o),
        l = o.value
      t(o.value, s) &&
        a.push(
          e
            ? l
            : {
                formattedLabel: i(o),
                rawLabel: s,
                tickValue: l,
              },
        )
    }),
    a
  )
}
var lI = [0, 1],
  ast = (function () {
    function r(t, e, n) {
      ;(this.onBand = !1),
        (this.inverse = !1),
        (this.dim = t),
        (this.scale = e),
        (this._extent = n || [0, 0])
    }
    return (
      (r.prototype.contain = function (t) {
        var e = this._extent,
          n = Math.min(e[0], e[1]),
          i = Math.max(e[0], e[1])
        return t >= n && t <= i
      }),
      (r.prototype.containData = function (t) {
        return this.scale.contain(t)
      }),
      (r.prototype.getExtent = function () {
        return this._extent.slice()
      }),
      (r.prototype.getPixelPrecision = function (t) {
        return Nz(t || this.scale.getExtent(), this._extent)
      }),
      (r.prototype.setExtent = function (t, e) {
        var n = this._extent
        ;(n[0] = t), (n[1] = e)
      }),
      (r.prototype.dataToCoord = function (t, e) {
        var n = this._extent,
          i = this.scale
        return (
          (t = i.normalize(t)),
          this.onBand &&
            i.type === 'ordinal' &&
            ((n = n.slice()), uI(n, i.count())),
          Re(t, lI, n, e)
        )
      }),
      (r.prototype.coordToData = function (t, e) {
        var n = this._extent,
          i = this.scale
        this.onBand &&
          i.type === 'ordinal' &&
          ((n = n.slice()), uI(n, i.count()))
        var a = Re(t, n, lI, e)
        return this.scale.scale(a)
      }),
      (r.prototype.pointToData = function (t, e) {}),
      (r.prototype.getTicksCoords = function (t) {
        t = t || {}
        var e = t.tickModel || this.getTickModel(),
          n = Jot(this, e),
          i = n.ticks,
          a = st(
            i,
            function (s) {
              return {
                coord: this.dataToCoord(
                  this.scale.type === 'ordinal'
                    ? this.scale.getRawOrdinalNumber(s)
                    : s,
                ),
                tickValue: s,
              }
            },
            this,
          ),
          o = e.get('alignWithLabel')
        return ost(this, a, o, t.clamp), a
      }),
      (r.prototype.getMinorTicksCoords = function () {
        if (this.scale.type === 'ordinal') return []
        var t = this.model.getModel('minorTick'),
          e = t.get('splitNumber')
        ;(e > 0 && e < 100) || (e = 5)
        var n = this.scale.getMinorTicks(e),
          i = st(
            n,
            function (a) {
              return st(
                a,
                function (o) {
                  return {
                    coord: this.dataToCoord(o),
                    tickValue: o,
                  }
                },
                this,
              )
            },
            this,
          )
        return i
      }),
      (r.prototype.getViewLabels = function () {
        return jot(this).labels
      }),
      (r.prototype.getLabelModel = function () {
        return this.model.getModel('axisLabel')
      }),
      (r.prototype.getTickModel = function () {
        return this.model.getModel('axisTick')
      }),
      (r.prototype.getBandWidth = function () {
        var t = this._extent,
          e = this.scale.getExtent(),
          n = e[1] - e[0] + (this.onBand ? 1 : 0)
        n === 0 && (n = 1)
        var i = Math.abs(t[1] - t[0])
        return Math.abs(i) / n
      }),
      (r.prototype.calculateCategoryInterval = function () {
        return rst(this)
      }),
      r
    )
  })()
function uI(r, t) {
  var e = r[1] - r[0],
    n = t,
    i = e / n / 2
  ;(r[0] += i), (r[1] -= i)
}
function ost(r, t, e, n) {
  var i = t.length
  if (!r.onBand || e || !i) return
  var a = r.getExtent(),
    o,
    s
  if (i === 1)
    (t[0].coord = a[0]),
      (o = t[1] =
        {
          coord: a[1],
        })
  else {
    var l = t[i - 1].tickValue - t[0].tickValue,
      u = (t[i - 1].coord - t[0].coord) / l
    R(t, function (d) {
      d.coord -= u / 2
    })
    var c = r.scale.getExtent()
    ;(s = 1 + c[1] - t[i - 1].tickValue),
      (o = {
        coord: t[i - 1].coord + u * s,
      }),
      t.push(o)
  }
  var h = a[0] > a[1]
  f(t[0].coord, a[0]) && (n ? (t[0].coord = a[0]) : t.shift()),
    n &&
      f(a[0], t[0].coord) &&
      t.unshift({
        coord: a[0],
      }),
    f(a[1], o.coord) && (n ? (o.coord = a[1]) : t.pop()),
    n &&
      f(o.coord, a[1]) &&
      t.push({
        coord: a[1],
      })
  function f(d, p) {
    return (d = mn(d)), (p = mn(p)), h ? d > p : d < p
  }
}
const Ra = ast
var dd = Math.PI * 2,
  Zl = vo.CMD,
  sst = ['top', 'right', 'bottom', 'left']
function lst(r, t, e, n, i) {
  var a = e.width,
    o = e.height
  switch (r) {
    case 'top':
      n.set(e.x + a / 2, e.y - t), i.set(0, -1)
      break
    case 'bottom':
      n.set(e.x + a / 2, e.y + o + t), i.set(0, 1)
      break
    case 'left':
      n.set(e.x - t, e.y + o / 2), i.set(-1, 0)
      break
    case 'right':
      n.set(e.x + a + t, e.y + o / 2), i.set(1, 0)
      break
  }
}
function ust(r, t, e, n, i, a, o, s, l) {
  ;(o -= r), (s -= t)
  var u = Math.sqrt(o * o + s * s)
  ;(o /= u), (s /= u)
  var c = o * e + r,
    h = s * e + t
  if (Math.abs(n - i) % dd < 1e-4) return (l[0] = c), (l[1] = h), u - e
  if (a) {
    var f = n
    ;(n = xi(i)), (i = xi(f))
  } else (n = xi(n)), (i = xi(i))
  n > i && (i += dd)
  var d = Math.atan2(s, o)
  if ((d < 0 && (d += dd), (d >= n && d <= i) || (d + dd >= n && d + dd <= i)))
    return (l[0] = c), (l[1] = h), u - e
  var p = e * Math.cos(n) + r,
    g = e * Math.sin(n) + t,
    v = e * Math.cos(i) + r,
    m = e * Math.sin(i) + t,
    y = (p - o) * (p - o) + (g - s) * (g - s),
    _ = (v - o) * (v - o) + (m - s) * (m - s)
  return y < _
    ? ((l[0] = p), (l[1] = g), Math.sqrt(y))
    : ((l[0] = v), (l[1] = m), Math.sqrt(_))
}
function s0(r, t, e, n, i, a, o, s) {
  var l = i - r,
    u = a - t,
    c = e - r,
    h = n - t,
    f = Math.sqrt(c * c + h * h)
  ;(c /= f), (h /= f)
  var d = l * c + u * h,
    p = d / f
  s && (p = Math.min(Math.max(p, 0), 1)), (p *= f)
  var g = (o[0] = r + p * c),
    v = (o[1] = t + p * h)
  return Math.sqrt((g - i) * (g - i) + (v - a) * (v - a))
}
function QV(r, t, e, n, i, a, o) {
  e < 0 && ((r = r + e), (e = -e)), n < 0 && ((t = t + n), (n = -n))
  var s = r + e,
    l = t + n,
    u = (o[0] = Math.min(Math.max(i, r), s)),
    c = (o[1] = Math.min(Math.max(a, t), l))
  return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a))
}
var ga = []
function cst(r, t, e) {
  var n = QV(t.x, t.y, t.width, t.height, r.x, r.y, ga)
  return e.set(ga[0], ga[1]), n
}
function hst(r, t, e) {
  for (
    var n = 0,
      i = 0,
      a = 0,
      o = 0,
      s,
      l,
      u = 1 / 0,
      c = t.data,
      h = r.x,
      f = r.y,
      d = 0;
    d < c.length;

  ) {
    var p = c[d++]
    d === 1 && ((n = c[d]), (i = c[d + 1]), (a = n), (o = i))
    var g = u
    switch (p) {
      case Zl.M:
        ;(a = c[d++]), (o = c[d++]), (n = a), (i = o)
        break
      case Zl.L:
        ;(g = s0(n, i, c[d], c[d + 1], h, f, ga, !0)),
          (n = c[d++]),
          (i = c[d++])
        break
      case Zl.C:
        ;(g = vz(
          n,
          i,
          c[d++],
          c[d++],
          c[d++],
          c[d++],
          c[d],
          c[d + 1],
          h,
          f,
          ga,
        )),
          (n = c[d++]),
          (i = c[d++])
        break
      case Zl.Q:
        ;(g = mz(n, i, c[d++], c[d++], c[d], c[d + 1], h, f, ga)),
          (n = c[d++]),
          (i = c[d++])
        break
      case Zl.A:
        var v = c[d++],
          m = c[d++],
          y = c[d++],
          _ = c[d++],
          x = c[d++],
          A = c[d++]
        d += 1
        var S = !!(1 - c[d++])
        ;(s = Math.cos(x) * y + v),
          (l = Math.sin(x) * _ + m),
          d <= 1 && ((a = s), (o = l))
        var b = ((h - v) * _) / y + v
        ;(g = ust(v, m, _, x, x + A, S, b, f, ga)),
          (n = Math.cos(x + A) * y + v),
          (i = Math.sin(x + A) * _ + m)
        break
      case Zl.R:
        ;(a = n = c[d++]), (o = i = c[d++])
        var T = c[d++],
          w = c[d++]
        g = QV(a, o, T, w, h, f, ga)
        break
      case Zl.Z:
        ;(g = s0(n, i, a, o, h, f, ga, !0)), (n = a), (i = o)
        break
    }
    g < u && ((u = g), e.set(ga[0], ga[1]))
  }
  return u
}
var Sa = new Qt(),
  Ye = new Qt(),
  xn = new Qt(),
  no = new Qt(),
  ja = new Qt()
function cI(r, t) {
  if (r) {
    var e = r.getTextGuideLine(),
      n = r.getTextContent()
    if (n && e) {
      var i = r.textGuideLineConfig || {},
        a = [
          [0, 0],
          [0, 0],
          [0, 0],
        ],
        o = i.candidates || sst,
        s = n.getBoundingRect().clone()
      s.applyTransform(n.getComputedTransform())
      var l = 1 / 0,
        u = i.anchor,
        c = r.getComputedTransform(),
        h = c && mf([], c),
        f = t.get('length2') || 0
      u && xn.copy(u)
      for (var d = 0; d < o.length; d++) {
        var p = o[d]
        lst(p, 0, s, Sa, no), Qt.scaleAndAdd(Ye, Sa, no, f), Ye.transform(h)
        var g = r.getBoundingRect(),
          v = u
            ? u.distance(Ye)
            : r instanceof oe
            ? hst(Ye, r.path, xn)
            : cst(Ye, g, xn)
        v < l &&
          ((l = v),
          Ye.transform(c),
          xn.transform(c),
          xn.toArray(a[0]),
          Ye.toArray(a[1]),
          Sa.toArray(a[2]))
      }
      tG(a, t.get('minTurnAngle')),
        e.setShape({
          points: a,
        })
    }
  }
}
var l0 = [],
  Br = new Qt()
function tG(r, t) {
  if (t <= 180 && t > 0) {
    ;(t = (t / 180) * Math.PI),
      Sa.fromArray(r[0]),
      Ye.fromArray(r[1]),
      xn.fromArray(r[2]),
      Qt.sub(no, Sa, Ye),
      Qt.sub(ja, xn, Ye)
    var e = no.len(),
      n = ja.len()
    if (!(e < 0.001 || n < 0.001)) {
      no.scale(1 / e), ja.scale(1 / n)
      var i = no.dot(ja),
        a = Math.cos(t)
      if (a < i) {
        var o = s0(Ye.x, Ye.y, xn.x, xn.y, Sa.x, Sa.y, l0, !1)
        Br.fromArray(l0), Br.scaleAndAdd(ja, o / Math.tan(Math.PI - t))
        var s =
          xn.x !== Ye.x
            ? (Br.x - Ye.x) / (xn.x - Ye.x)
            : (Br.y - Ye.y) / (xn.y - Ye.y)
        if (isNaN(s)) return
        s < 0 ? Qt.copy(Br, Ye) : s > 1 && Qt.copy(Br, xn), Br.toArray(r[1])
      }
    }
  }
}
function fst(r, t, e) {
  if (e <= 180 && e > 0) {
    ;(e = (e / 180) * Math.PI),
      Sa.fromArray(r[0]),
      Ye.fromArray(r[1]),
      xn.fromArray(r[2]),
      Qt.sub(no, Ye, Sa),
      Qt.sub(ja, xn, Ye)
    var n = no.len(),
      i = ja.len()
    if (!(n < 0.001 || i < 0.001)) {
      no.scale(1 / n), ja.scale(1 / i)
      var a = no.dot(t),
        o = Math.cos(e)
      if (a < o) {
        var s = s0(Ye.x, Ye.y, xn.x, xn.y, Sa.x, Sa.y, l0, !1)
        Br.fromArray(l0)
        var l = Math.PI / 2,
          u = Math.acos(ja.dot(t)),
          c = l + u - e
        if (c >= l) Qt.copy(Br, xn)
        else {
          Br.scaleAndAdd(ja, s / Math.tan(Math.PI / 2 - c))
          var h =
            xn.x !== Ye.x
              ? (Br.x - Ye.x) / (xn.x - Ye.x)
              : (Br.y - Ye.y) / (xn.y - Ye.y)
          if (isNaN(h)) return
          h < 0 ? Qt.copy(Br, Ye) : h > 1 && Qt.copy(Br, xn)
        }
        Br.toArray(r[1])
      }
    }
  }
}
function q1(r, t, e, n) {
  var i = e === 'normal',
    a = i ? r : r.ensureState(e)
  a.ignore = t
  var o = n.get('smooth')
  o && o === !0 && (o = 0.3),
    (a.shape = a.shape || {}),
    o > 0 && (a.shape.smooth = o)
  var s = n.getModel('lineStyle').getLineStyle()
  i ? r.useStyle(s) : (a.style = s)
}
function dst(r, t) {
  var e = t.smooth,
    n = t.points
  if (n)
    if ((r.moveTo(n[0][0], n[0][1]), e > 0 && n.length >= 3)) {
      var i = ks(n[0], n[1]),
        a = ks(n[1], n[2])
      if (!i || !a) {
        r.lineTo(n[1][0], n[1][1]), r.lineTo(n[2][0], n[2][1])
        return
      }
      var o = Math.min(i, a) * e,
        s = Ym([], n[1], n[0], o / i),
        l = Ym([], n[1], n[2], o / a),
        u = Ym([], s, l, 0.5)
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]),
        r.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1])
    } else for (var c = 1; c < n.length; c++) r.lineTo(n[c][0], n[c][1])
}
function LC(r, t, e) {
  var n = r.getTextGuideLine(),
    i = r.getTextContent()
  if (!i) {
    n && r.removeTextGuideLine()
    return
  }
  for (
    var a = t.normal, o = a.get('show'), s = i.ignore, l = 0;
    l < Hp.length;
    l++
  ) {
    var u = Hp[l],
      c = t[u],
      h = u === 'normal'
    if (c) {
      var f = c.get('show'),
        d = h ? s : $t(i.states[u] && i.states[u].ignore, s)
      if (d || !$t(f, o)) {
        var p = h ? n : n && n.states[u]
        p && (p.ignore = !0), n && q1(n, !0, u, c)
        continue
      }
      n ||
        ((n = new li()),
        r.setTextGuideLine(n),
        !h && (s || !o) && q1(n, !0, 'normal', t.normal),
        r.stateProxy && (n.stateProxy = r.stateProxy)),
        q1(n, !1, u, c)
    }
  }
  if (n) {
    zt(n.style, e), (n.style.fill = null)
    var g = a.get('showAbove'),
      v = (r.textGuideLineConfig = r.textGuideLineConfig || {})
    ;(v.showAbove = g || !1), (n.buildPath = dst)
  }
}
function PC(r, t) {
  t = t || 'labelLine'
  for (
    var e = {
        normal: r.getModel(t),
      },
      n = 0;
    n < Hr.length;
    n++
  ) {
    var i = Hr[n]
    e[i] = r.getModel([i, t])
  }
  return e
}
function eG(r) {
  for (var t = [], e = 0; e < r.length; e++) {
    var n = r[e]
    if (!n.defaultAttr.ignore) {
      var i = n.label,
        a = i.getComputedTransform(),
        o = i.getBoundingRect(),
        s = !a || (a[1] < 1e-5 && a[2] < 1e-5),
        l = i.style.margin || 0,
        u = o.clone()
      u.applyTransform(a),
        (u.x -= l / 2),
        (u.y -= l / 2),
        (u.width += l),
        (u.height += l)
      var c = s ? new Yy(o, a) : null
      t.push({
        label: i,
        labelLine: n.labelLine,
        rect: u,
        localRect: o,
        obb: c,
        priority: n.priority,
        defaultAttr: n.defaultAttr,
        layoutOption: n.computedLayoutOption,
        axisAligned: s,
        transform: a,
      })
    }
  }
  return t
}
function nG(r, t, e, n, i, a) {
  var o = r.length
  if (o < 2) return
  r.sort(function (T, w) {
    return T.rect[t] - w.rect[t]
  })
  for (var s = 0, l, u = !1, c = 0, h = 0; h < o; h++) {
    var f = r[h],
      d = f.rect
    ;(l = d[t] - s), l < 0 && ((d[t] -= l), (f.label[t] -= l), (u = !0))
    var p = Math.max(-l, 0)
    ;(c += p), (s = d[t] + d[e])
  }
  c > 0 && a && A(-c / o, 0, o)
  var g = r[0],
    v = r[o - 1],
    m,
    y
  _(),
    m < 0 && S(-m, 0.8),
    y < 0 && S(y, 0.8),
    _(),
    x(m, y, 1),
    x(y, m, -1),
    _(),
    m < 0 && b(-m),
    y < 0 && b(y)
  function _() {
    ;(m = g.rect[t] - n), (y = i - v.rect[t] - v.rect[e])
  }
  function x(T, w, M) {
    if (T < 0) {
      var C = Math.min(w, -T)
      if (C > 0) {
        A(C * M, 0, o)
        var E = C + T
        E < 0 && S(-E * M, 1)
      } else S(-T * M, 1)
    }
  }
  function A(T, w, M) {
    T !== 0 && (u = !0)
    for (var C = w; C < M; C++) {
      var E = r[C],
        D = E.rect
      ;(D[t] += T), (E.label[t] += T)
    }
  }
  function S(T, w) {
    for (var M = [], C = 0, E = 1; E < o; E++) {
      var D = r[E - 1].rect,
        P = Math.max(r[E].rect[t] - D[t] - D[e], 0)
      M.push(P), (C += P)
    }
    if (C) {
      var L = Math.min(Math.abs(T) / C, w)
      if (T > 0)
        for (var E = 0; E < o - 1; E++) {
          var I = M[E] * L
          A(I, 0, E + 1)
        }
      else
        for (var E = o - 1; E > 0; E--) {
          var I = M[E - 1] * L
          A(-I, E, o)
        }
    }
  }
  function b(T) {
    var w = T < 0 ? -1 : 1
    T = Math.abs(T)
    for (var M = Math.ceil(T / (o - 1)), C = 0; C < o - 1; C++)
      if ((w > 0 ? A(M, 0, C + 1) : A(-M, o - C - 1, o), (T -= M), T <= 0))
        return
  }
  return u
}
function pst(r, t, e, n) {
  return nG(r, 'x', 'width', t, e, n)
}
function rG(r, t, e, n) {
  return nG(r, 'y', 'height', t, e, n)
}
function iG(r) {
  var t = []
  r.sort(function (g, v) {
    return v.priority - g.priority
  })
  var e = new ee(0, 0, 0, 0)
  function n(g) {
    if (!g.ignore) {
      var v = g.ensureState('emphasis')
      v.ignore == null && (v.ignore = !1)
    }
    g.ignore = !0
  }
  for (var i = 0; i < r.length; i++) {
    var a = r[i],
      o = a.axisAligned,
      s = a.localRect,
      l = a.transform,
      u = a.label,
      c = a.labelLine
    e.copy(a.rect),
      (e.width -= 0.1),
      (e.height -= 0.1),
      (e.x += 0.05),
      (e.y += 0.05)
    for (var h = a.obb, f = !1, d = 0; d < t.length; d++) {
      var p = t[d]
      if (e.intersect(p.rect)) {
        if (o && p.axisAligned) {
          f = !0
          break
        }
        if (
          (p.obb || (p.obb = new Yy(p.localRect, p.transform)),
          h || (h = new Yy(s, l)),
          h.intersect(p.obb))
        ) {
          f = !0
          break
        }
      }
    }
    f
      ? (n(u), c && n(c))
      : (u.attr('ignore', a.defaultAttr.ignore),
        c && c.attr('ignore', a.defaultAttr.labelGuideIgnore),
        t.push(a))
  }
}
function vst(r) {
  if (r) {
    for (var t = [], e = 0; e < r.length; e++) t.push(r[e].slice())
    return t
  }
}
function gst(r, t) {
  var e = r.label,
    n = t && t.getTextGuideLine()
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    align: e.style.align,
    verticalAlign: e.style.verticalAlign,
    labelLinePoints: vst(n && n.shape.points),
  }
}
var hI = ['align', 'verticalAlign', 'width', 'height', 'fontSize'],
  Pr = new Uo(),
  Z1 = ve(),
  mst = ve()
function sm(r, t, e) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n]
    t[i] != null && (r[i] = t[i])
  }
}
var lm = ['x', 'y', 'rotation'],
  yst = (function () {
    function r() {
      ;(this._labelList = []), (this._chartViewList = [])
    }
    return (
      (r.prototype.clearLabels = function () {
        ;(this._labelList = []), (this._chartViewList = [])
      }),
      (r.prototype._addLabel = function (t, e, n, i, a) {
        var o = i.style,
          s = i.__hostTarget,
          l = s.textConfig || {},
          u = i.getComputedTransform(),
          c = i.getBoundingRect().plain()
        ee.applyTransform(c, c, u),
          u
            ? Pr.setLocalTransform(u)
            : ((Pr.x = Pr.y = Pr.rotation = Pr.originX = Pr.originY = 0),
              (Pr.scaleX = Pr.scaleY = 1)),
          (Pr.rotation = xi(Pr.rotation))
        var h = i.__hostTarget,
          f
        if (h) {
          f = h.getBoundingRect().plain()
          var d = h.getComputedTransform()
          ee.applyTransform(f, f, d)
        }
        var p = f && h.getTextGuideLine()
        this._labelList.push({
          label: i,
          labelLine: p,
          seriesModel: n,
          dataIndex: t,
          dataType: e,
          layoutOption: a,
          computedLayoutOption: null,
          rect: c,
          hostRect: f,
          priority: f ? f.width * f.height : 0,
          defaultAttr: {
            ignore: i.ignore,
            labelGuideIgnore: p && p.ignore,
            x: Pr.x,
            y: Pr.y,
            scaleX: Pr.scaleX,
            scaleY: Pr.scaleY,
            rotation: Pr.rotation,
            style: {
              x: o.x,
              y: o.y,
              align: o.align,
              verticalAlign: o.verticalAlign,
              width: o.width,
              height: o.height,
              fontSize: o.fontSize,
            },
            cursor: i.cursor,
            attachedPos: l.position,
            attachedRot: l.rotation,
          },
        })
      }),
      (r.prototype.addLabelsOfSeries = function (t) {
        var e = this
        this._chartViewList.push(t)
        var n = t.__model,
          i = n.get('labelLayout')
        ;(Nt(i) || pe(i).length) &&
          t.group.traverse(function (a) {
            if (a.ignore) return !0
            var o = a.getTextContent(),
              s = Wt(a)
            o &&
              !o.disableLabelLayout &&
              e._addLabel(s.dataIndex, s.dataType, n, o, i)
          })
      }),
      (r.prototype.updateLayoutConfig = function (t) {
        var e = t.getWidth(),
          n = t.getHeight()
        function i(_, x) {
          return function () {
            cI(_, x)
          }
        }
        for (var a = 0; a < this._labelList.length; a++) {
          var o = this._labelList[a],
            s = o.label,
            l = s.__hostTarget,
            u = o.defaultAttr,
            c = void 0
          Nt(o.layoutOption)
            ? (c = o.layoutOption(gst(o, l)))
            : (c = o.layoutOption),
            (c = c || {}),
            (o.computedLayoutOption = c)
          var h = Math.PI / 180
          l &&
            l.setTextConfig({
              local: !1,
              position: c.x != null || c.y != null ? null : u.attachedPos,
              rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
              offset: [c.dx || 0, c.dy || 0],
            })
          var f = !1
          if (
            (c.x != null
              ? ((s.x = _t(c.x, e)), s.setStyle('x', 0), (f = !0))
              : ((s.x = u.x), s.setStyle('x', u.style.x)),
            c.y != null
              ? ((s.y = _t(c.y, n)), s.setStyle('y', 0), (f = !0))
              : ((s.y = u.y), s.setStyle('y', u.style.y)),
            c.labelLinePoints)
          ) {
            var d = l.getTextGuideLine()
            d &&
              (d.setShape({
                points: c.labelLinePoints,
              }),
              (f = !1))
          }
          var p = Z1(s)
          ;(p.needsUpdateLabelLine = f),
            (s.rotation = c.rotate != null ? c.rotate * h : u.rotation),
            (s.scaleX = u.scaleX),
            (s.scaleY = u.scaleY)
          for (var g = 0; g < hI.length; g++) {
            var v = hI[g]
            s.setStyle(v, c[v] != null ? c[v] : u.style[v])
          }
          if (c.draggable) {
            if (((s.draggable = !0), (s.cursor = 'move'), l)) {
              var m = o.seriesModel
              if (o.dataIndex != null) {
                var y = o.seriesModel.getData(o.dataType)
                m = y.getItemModel(o.dataIndex)
              }
              s.on('drag', i(l, m.getModel('labelLine')))
            }
          } else s.off('drag'), (s.cursor = u.cursor)
        }
      }),
      (r.prototype.layout = function (t) {
        var e = t.getWidth(),
          n = t.getHeight(),
          i = eG(this._labelList),
          a = Ne(i, function (l) {
            return l.layoutOption.moveOverlap === 'shiftX'
          }),
          o = Ne(i, function (l) {
            return l.layoutOption.moveOverlap === 'shiftY'
          })
        pst(a, 0, e), rG(o, 0, n)
        var s = Ne(i, function (l) {
          return l.layoutOption.hideOverlap
        })
        iG(s)
      }),
      (r.prototype.processLabelsOverall = function () {
        var t = this
        R(this._chartViewList, function (e) {
          var n = e.__model,
            i = e.ignoreLabelLineUpdate,
            a = n.isAnimationEnabled()
          e.group.traverse(function (o) {
            if (o.ignore && !o.forceLabelAnimation) return !0
            var s = !i,
              l = o.getTextContent()
            !s && l && (s = Z1(l).needsUpdateLabelLine),
              s && t._updateLabelLine(o, n),
              a && t._animateLabels(o, n)
          })
        })
      }),
      (r.prototype._updateLabelLine = function (t, e) {
        var n = t.getTextContent(),
          i = Wt(t),
          a = i.dataIndex
        if (n && a != null) {
          var o = e.getData(i.dataType),
            s = o.getItemModel(a),
            l = {},
            u = o.getItemVisual(a, 'style')
          if (u) {
            var c = o.getVisual('drawType')
            l.stroke = u[c]
          }
          var h = s.getModel('labelLine')
          LC(t, PC(s), l), cI(t, h)
        }
      }),
      (r.prototype._animateLabels = function (t, e) {
        var n = t.getTextContent(),
          i = t.getTextGuideLine()
        if (
          n &&
          (t.forceLabelAnimation ||
            (!n.ignore && !n.invisible && !t.disableLabelAnimation && !Rh(t)))
        ) {
          var a = Z1(n),
            o = a.oldLayout,
            s = Wt(t),
            l = s.dataIndex,
            u = {
              x: n.x,
              y: n.y,
              rotation: n.rotation,
            },
            c = e.getData(s.dataType)
          if (o) {
            n.attr(o)
            var f = t.prevStates
            f &&
              (re(f, 'select') >= 0 && n.attr(a.oldLayoutSelect),
              re(f, 'emphasis') >= 0 && n.attr(a.oldLayoutEmphasis)),
              we(n, u, e, l)
          } else if ((n.attr(u), !Af(n).valueAnimation)) {
            var h = $t(n.style.opacity, 1)
            ;(n.style.opacity = 0),
              Je(
                n,
                {
                  style: {
                    opacity: h,
                  },
                },
                e,
                l,
              )
          }
          if (((a.oldLayout = u), n.states.select)) {
            var d = (a.oldLayoutSelect = {})
            sm(d, u, lm), sm(d, n.states.select, lm)
          }
          if (n.states.emphasis) {
            var p = (a.oldLayoutEmphasis = {})
            sm(p, u, lm), sm(p, n.states.emphasis, lm)
          }
          HU(n, l, c, e, e)
        }
        if (i && !i.ignore && !i.invisible) {
          var a = mst(i),
            o = a.oldLayout,
            g = {
              points: i.shape.points,
            }
          o
            ? (i.attr({
                shape: o,
              }),
              we(
                i,
                {
                  shape: g,
                },
                e,
              ))
            : (i.setShape(g),
              (i.style.strokePercent = 0),
              Je(
                i,
                {
                  style: {
                    strokePercent: 1,
                  },
                },
                e,
              )),
            (a.oldLayout = g)
        }
      }),
      r
    )
  })()
const _st = yst
var K1 = ve()
function xst(r) {
  r.registerUpdateLifecycle('series:beforeupdate', function (t, e, n) {
    var i = K1(e).labelManager
    i || (i = K1(e).labelManager = new _st()), i.clearLabels()
  }),
    r.registerUpdateLifecycle('series:layoutlabels', function (t, e, n) {
      var i = K1(e).labelManager
      n.updatedSeries.forEach(function (a) {
        i.addLabelsOfSeries(e.getViewOfSeriesModel(a))
      }),
        i.updateLayoutConfig(e),
        i.layout(e),
        i.processLabelsOverall()
    })
}
var j1 = Math.sin,
  J1 = Math.cos,
  aG = Math.PI,
  Kl = Math.PI * 2,
  Sst = 180 / aG,
  Ast = (function () {
    function r() {}
    return (
      (r.prototype.reset = function (t) {
        ;(this._start = !0),
          (this._d = []),
          (this._str = ''),
          (this._p = Math.pow(10, t || 4))
      }),
      (r.prototype.moveTo = function (t, e) {
        this._add('M', t, e)
      }),
      (r.prototype.lineTo = function (t, e) {
        this._add('L', t, e)
      }),
      (r.prototype.bezierCurveTo = function (t, e, n, i, a, o) {
        this._add('C', t, e, n, i, a, o)
      }),
      (r.prototype.quadraticCurveTo = function (t, e, n, i) {
        this._add('Q', t, e, n, i)
      }),
      (r.prototype.arc = function (t, e, n, i, a, o) {
        this.ellipse(t, e, n, n, 0, i, a, o)
      }),
      (r.prototype.ellipse = function (t, e, n, i, a, o, s, l) {
        var u = s - o,
          c = !l,
          h = Math.abs(u),
          f = Vs(h - Kl) || (c ? u >= Kl : -u >= Kl),
          d = u > 0 ? u % Kl : (u % Kl) + Kl,
          p = !1
        f ? (p = !0) : Vs(h) ? (p = !1) : (p = d >= aG == !!c)
        var g = t + n * J1(o),
          v = e + i * j1(o)
        this._start && this._add('M', g, v)
        var m = Math.round(a * Sst)
        if (f) {
          var y = 1 / this._p,
            _ = (c ? 1 : -1) * (Kl - y)
          this._add('A', n, i, m, 1, +c, t + n * J1(o + _), e + i * j1(o + _)),
            y > 0.01 && this._add('A', n, i, m, 0, +c, g, v)
        } else {
          var x = t + n * J1(s),
            A = e + i * j1(s)
          this._add('A', n, i, m, +p, +c, x, A)
        }
      }),
      (r.prototype.rect = function (t, e, n, i) {
        this._add('M', t, e),
          this._add('l', n, 0),
          this._add('l', 0, i),
          this._add('l', -n, 0),
          this._add('Z')
      }),
      (r.prototype.closePath = function () {
        this._d.length > 0 && this._add('Z')
      }),
      (r.prototype._add = function (t, e, n, i, a, o, s, l, u) {
        for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
          var d = arguments[f]
          if (isNaN(d)) {
            this._invalid = !0
            return
          }
          c.push(Math.round(d * h) / h)
        }
        this._d.push(t + c.join(' ')), (this._start = t === 'Z')
      }),
      (r.prototype.generateStr = function () {
        ;(this._str = this._invalid ? '' : this._d.join('')), (this._d = [])
      }),
      (r.prototype.getStr = function () {
        return this._str
      }),
      r
    )
  })()
const oG = Ast
var dp = 'none',
  bst = Math.round
function wst(r) {
  var t = r.fill
  return t != null && t !== dp
}
function Mst(r) {
  var t = r.stroke
  return t != null && t !== dp
}
var Cw = ['lineCap', 'miterLimit', 'lineJoin'],
  Tst = st(Cw, function (r) {
    return 'stroke-' + r.toLowerCase()
  })
function Cst(r, t, e, n) {
  var i = t.opacity == null ? 1 : t.opacity
  if (e instanceof yr) {
    r('opacity', i)
    return
  }
  if (wst(t)) {
    var a = zp(t.fill)
    r('fill', a.color)
    var o =
      t.fillOpacity != null ? t.fillOpacity * a.opacity * i : a.opacity * i
    ;(n || o < 1) && r('fill-opacity', o)
  } else r('fill', dp)
  if (Mst(t)) {
    var s = zp(t.stroke)
    r('stroke', s.color)
    var l = t.strokeNoScale ? e.getLineScale() : 1,
      u = l ? (t.lineWidth || 0) / l : 0,
      c =
        t.strokeOpacity != null
          ? t.strokeOpacity * s.opacity * i
          : s.opacity * i,
      h = t.strokeFirst
    if (
      ((n || u !== 1) && r('stroke-width', u),
      (n || h) && r('paint-order', h ? 'stroke' : 'fill'),
      (n || c < 1) && r('stroke-opacity', c),
      t.lineDash)
    ) {
      var f = yC(e),
        d = f[0],
        p = f[1]
      d &&
        ((p = bst(p || 0)),
        r('stroke-dasharray', d.join(',')),
        (p || n) && r('stroke-dashoffset', p))
    } else n && r('stroke-dasharray', dp)
    for (var g = 0; g < Cw.length; g++) {
      var v = Cw[g]
      if (n || t[v] !== Wy[v]) {
        var m = t[v] || Wy[v]
        m && r(Tst[g], m)
      }
    }
  } else n && r('stroke', dp)
}
var sG = 'http://www.w3.org/2000/svg',
  lG = 'http://www.w3.org/1999/xlink',
  Est = 'http://www.w3.org/2000/xmlns/',
  Dst = 'http://www.w3.org/XML/1998/namespace',
  fI = 'ecmeta_'
function uG(r) {
  return document.createElementNS(sG, r)
}
function Xn(r, t, e, n, i) {
  return {
    tag: r,
    attrs: e || {},
    children: n,
    text: i,
    key: t,
  }
}
function Lst(r, t) {
  var e = []
  if (t)
    for (var n in t) {
      var i = t[n],
        a = n
      i !== !1 && (i !== !0 && i != null && (a += '="' + i + '"'), e.push(a))
    }
  return '<' + r + ' ' + e.join(' ') + '>'
}
function Pst(r) {
  return '</' + r + '>'
}
function RC(r, t) {
  t = t || {}
  var e = t.newline
    ? `
`
    : ''
  function n(i) {
    var a = i.children,
      o = i.tag,
      s = i.attrs,
      l = i.text
    return (
      Lst(o, s) +
      (o !== 'style' ? Fr(l) : l || '') +
      (a
        ? '' +
          e +
          st(a, function (u) {
            return n(u)
          }).join(e) +
          e
        : '') +
      Pst(o)
    )
  }
  return n(r)
}
function Rst(r, t, e) {
  e = e || {}
  var n = e.newline
      ? `
`
      : '',
    i = ' {' + n,
    a = n + '}',
    o = st(pe(r), function (l) {
      return (
        l +
        i +
        st(pe(r[l]), function (u) {
          return u + ':' + r[l][u] + ';'
        }).join(n) +
        a
      )
    }).join(n),
    s = st(pe(t), function (l) {
      return (
        '@keyframes ' +
        l +
        i +
        st(pe(t[l]), function (u) {
          return (
            u +
            i +
            st(pe(t[l][u]), function (c) {
              var h = t[l][u][c]
              return c === 'd' && (h = 'path("' + h + '")'), c + ':' + h + ';'
            }).join(n) +
            a
          )
        }).join(n) +
        a
      )
    }).join(n)
  return !o && !s ? '' : ['<![CDATA[', o, s, ']]>'].join(n)
}
function Ew(r) {
  return {
    zrId: r,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0,
  }
}
function dI(r, t, e, n) {
  return Xn(
    'svg',
    'root',
    {
      width: r,
      height: t,
      xmlns: sG,
      'xmlns:xlink': lG,
      version: '1.1',
      baseProfile: 'full',
      viewBox: n ? '0 0 ' + r + ' ' + t : !1,
    },
    e,
  )
}
var Ist = 0
function cG() {
  return Ist++
}
var pI = {
    cubicIn: '0.32,0,0.67,0',
    cubicOut: '0.33,1,0.68,1',
    cubicInOut: '0.65,0,0.35,1',
    quadraticIn: '0.11,0,0.5,0',
    quadraticOut: '0.5,1,0.89,1',
    quadraticInOut: '0.45,0,0.55,1',
    quarticIn: '0.5,0,0.75,0',
    quarticOut: '0.25,1,0.5,1',
    quarticInOut: '0.76,0,0.24,1',
    quinticIn: '0.64,0,0.78,0',
    quinticOut: '0.22,1,0.36,1',
    quinticInOut: '0.83,0,0.17,1',
    sinusoidalIn: '0.12,0,0.39,0',
    sinusoidalOut: '0.61,1,0.88,1',
    sinusoidalInOut: '0.37,0,0.63,1',
    exponentialIn: '0.7,0,0.84,0',
    exponentialOut: '0.16,1,0.3,1',
    exponentialInOut: '0.87,0,0.13,1',
    circularIn: '0.55,0,1,0.45',
    circularOut: '0,0.55,0.45,1',
    circularInOut: '0.85,0,0.15,1',
  },
  ru = 'transform-origin'
function Ost(r, t, e) {
  var n = Q({}, r.shape)
  Q(n, t), r.buildPath(e, n)
  var i = new oG()
  return i.reset(wz(r)), e.rebuildPath(i, 1), i.generateStr(), i.getStr()
}
function Nst(r, t) {
  var e = t.originX,
    n = t.originY
  ;(e || n) && (r[ru] = e + 'px ' + n + 'px')
}
var kst = {
  fill: 'fill',
  opacity: 'opacity',
  lineWidth: 'stroke-width',
  lineDashOffset: 'stroke-dashoffset',
}
function hG(r, t) {
  var e = t.zrId + '-ani-' + t.cssAnimIdx++
  return (t.cssAnims[e] = r), e
}
function Bst(r, t, e) {
  var n = r.shape.paths,
    i = {},
    a,
    o
  if (
    (R(n, function (l) {
      var u = Ew(e.zrId)
      ;(u.animation = !0), M_(l, {}, u, !0)
      var c = u.cssAnims,
        h = u.cssNodes,
        f = pe(c),
        d = f.length
      if (d) {
        o = f[d - 1]
        var p = c[o]
        for (var g in p) {
          var v = p[g]
          ;(i[g] = i[g] || {
            d: '',
          }),
            (i[g].d += v.d || '')
        }
        for (var m in h) {
          var y = h[m].animation
          y.indexOf(o) >= 0 && (a = y)
        }
      }
    }),
    !!a)
  ) {
    t.d = !1
    var s = hG(i, e)
    return a.replace(o, s)
  }
}
function vI(r) {
  return bt(r) ? (pI[r] ? 'cubic-bezier(' + pI[r] + ')' : OT(r) ? r : '') : ''
}
function M_(r, t, e, n) {
  var i = r.animators,
    a = i.length,
    o = []
  if (r instanceof JT) {
    var s = Bst(r, t, e)
    if (s) o.push(s)
    else if (!a) return
  } else if (!a) return
  for (var l = {}, u = 0; u < a; u++) {
    var c = i[u],
      h = [c.getMaxTime() / 1e3 + 's'],
      f = vI(c.getClip().easing),
      d = c.getDelay()
    f ? h.push(f) : h.push('linear'),
      d && h.push(d / 1e3 + 's'),
      c.getLoop() && h.push('infinite')
    var p = h.join(' ')
    ;(l[p] = l[p] || [p, []]), l[p][1].push(c)
  }
  function g(y) {
    var _ = y[1],
      x = _.length,
      A = {},
      S = {},
      b = {},
      T = 'animation-timing-function'
    function w(ct, At, gt) {
      for (
        var dt = ct.getTracks(), B = ct.getMaxTime(), ht = 0;
        ht < dt.length;
        ht++
      ) {
        var it = dt[ht]
        if (it.needsAnimate()) {
          var xt = it.keyframes,
            rt = it.propName
          if ((gt && (rt = gt(rt)), rt))
            for (var kt = 0; kt < xt.length; kt++) {
              var Ct = xt[kt],
                Lt = Math.round((Ct.time / B) * 100) + '%',
                G = vI(Ct.easing),
                N = Ct.rawValue
              ;(bt(N) || be(N)) &&
                ((At[Lt] = At[Lt] || {}),
                (At[Lt][rt] = Ct.rawValue),
                G && (At[Lt][T] = G))
            }
        }
      }
    }
    for (var M = 0; M < x; M++) {
      var C = _[M],
        E = C.targetName
      E ? E === 'shape' && w(C, S) : !n && w(C, A)
    }
    for (var D in A) {
      var P = {}
      Dz(P, r), Q(P, A[D])
      var L = Mz(P),
        I = A[D][T]
      ;(b[D] = L
        ? {
            transform: L,
          }
        : {}),
        Nst(b[D], P),
        I && (b[D][T] = I)
    }
    var F,
      k = !0
    for (var D in S) {
      b[D] = b[D] || {}
      var V = !F,
        I = S[D][T]
      V && (F = new vo())
      var H = F.len()
      F.reset(), (b[D].d = Ost(r, S[D], F))
      var Y = F.len()
      if (!V && H !== Y) {
        k = !1
        break
      }
      I && (b[D][T] = I)
    }
    if (!k) for (var D in b) delete b[D].d
    if (!n)
      for (var M = 0; M < x; M++) {
        var C = _[M],
          E = C.targetName
        E === 'style' &&
          w(C, b, function (dt) {
            return kst[dt]
          })
      }
    for (var K = pe(b), ut = !0, W, M = 1; M < K.length; M++) {
      var Z = K[M - 1],
        ft = K[M]
      if (b[Z][ru] !== b[ft][ru]) {
        ut = !1
        break
      }
      W = b[Z][ru]
    }
    if (ut && W) {
      for (var D in b) b[D][ru] && delete b[D][ru]
      t[ru] = W
    }
    if (
      Ne(K, function (ct) {
        return pe(b[ct]).length > 0
      }).length
    ) {
      var lt = hG(b, e)
      return lt + ' ' + y[0] + ' both'
    }
  }
  for (var v in l) {
    var s = g(l[v])
    s && o.push(s)
  }
  if (o.length) {
    var m = e.zrId + '-cls-' + cG()
    ;(e.cssNodes['.' + m] = {
      animation: o.join(','),
    }),
      (t.class = m)
  }
}
function Fst(r, t, e) {
  if (!r.ignore)
    if (r.isSilent()) {
      var n = {
        'pointer-events': 'none',
      }
      gI(n, t, e, !0)
    } else {
      var i =
          r.states.emphasis && r.states.emphasis.style
            ? r.states.emphasis.style
            : {},
        a = i.fill
      if (!a) {
        var o = r.style && r.style.fill,
          s =
            r.states.select &&
            r.states.select.style &&
            r.states.select.style.fill,
          l = (r.currentStates.indexOf('select') >= 0 && s) || o
        l && (a = Ub(l))
      }
      var u = i.lineWidth
      if (u) {
        var c = !i.strokeNoScale && r.transform ? r.transform[0] : 1
        u = u / c
      }
      var n = {
        cursor: 'pointer',
      }
      a && (n.fill = a),
        i.stroke && (n.stroke = i.stroke),
        u && (n['stroke-width'] = u),
        gI(n, t, e, !0)
    }
}
function gI(r, t, e, n) {
  var i = JSON.stringify(r),
    a = e.cssStyleCache[i]
  a ||
    ((a = e.zrId + '-cls-' + cG()),
    (e.cssStyleCache[i] = a),
    (e.cssNodes['.' + a + (n ? ':hover' : '')] = r)),
    (t.class = t.class ? t.class + ' ' + a : a)
}
var Qp = Math.round
function fG(r) {
  return r && bt(r.src)
}
function dG(r) {
  return r && Nt(r.toDataURL)
}
function IC(r, t, e, n) {
  Cst(
    function (i, a) {
      var o = i === 'fill' || i === 'stroke'
      o && bz(a)
        ? vG(t, r, i, n)
        : o && NT(a)
        ? gG(e, r, i, n)
        : o && a === 'none'
        ? (r[i] = 'transparent')
        : (r[i] = a)
    },
    t,
    e,
    !1,
  ),
    Xst(e, r, n)
}
function OC(r, t) {
  var e = ctt(t)
  e &&
    (e.each(function (n, i) {
      n != null && (r[(fI + i).toLowerCase()] = n + '')
    }),
    t.isSilent() && (r[fI + 'silent'] = 'true'))
}
function mI(r) {
  return Vs(r[0] - 1) && Vs(r[1]) && Vs(r[2]) && Vs(r[3] - 1)
}
function zst(r) {
  return Vs(r[4]) && Vs(r[5])
}
function NC(r, t, e) {
  if (t && !(zst(t) && mI(t))) {
    var n = e ? 10 : 1e4
    r.transform = mI(t)
      ? 'translate(' + Qp(t[4] * n) / n + ' ' + Qp(t[5] * n) / n + ')'
      : LQ(t)
  }
}
function yI(r, t, e) {
  for (var n = r.points, i = [], a = 0; a < n.length; a++)
    i.push(Qp(n[a][0] * e) / e), i.push(Qp(n[a][1] * e) / e)
  t.points = i.join(' ')
}
function _I(r) {
  return !r.smooth
}
function Ust(r) {
  var t = st(r, function (e) {
    return typeof e == 'string' ? [e, e] : e
  })
  return function (e, n, i) {
    for (var a = 0; a < t.length; a++) {
      var o = t[a],
        s = e[o[0]]
      s != null && (n[o[1]] = Qp(s * i) / i)
    }
  }
}
var Vst = {
  circle: [Ust(['cx', 'cy', 'r'])],
  polyline: [yI, _I],
  polygon: [yI, _I],
}
function Gst(r) {
  for (var t = r.animators, e = 0; e < t.length; e++)
    if (t[e].targetName === 'shape') return !0
  return !1
}
function pG(r, t) {
  var e = r.style,
    n = r.shape,
    i = Vst[r.type],
    a = {},
    o = t.animation,
    s = 'path',
    l = r.style.strokePercent,
    u = (t.compress && wz(r)) || 4
  if (i && !t.willUpdate && !(i[1] && !i[1](n)) && !(o && Gst(r)) && !(l < 1)) {
    s = r.type
    var c = Math.pow(10, u)
    i[0](n, a, c)
  } else {
    var h = !r.path || r.shapeChanged()
    r.path || r.createPathProxy()
    var f = r.path
    h && (f.beginPath(), r.buildPath(f, r.shape), r.pathUpdated())
    var d = f.getVersion(),
      p = r,
      g = p.__svgPathBuilder
    ;(p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) &&
      (g || (g = p.__svgPathBuilder = new oG()),
      g.reset(u),
      f.rebuildPath(g, l),
      g.generateStr(),
      (p.__svgPathVersion = d),
      (p.__svgPathStrokePercent = l)),
      (a.d = g.getStr())
  }
  return (
    NC(a, r.transform),
    IC(a, e, r, t),
    OC(a, r),
    t.animation && M_(r, a, t),
    t.emphasis && Fst(r, a, t),
    Xn(s, r.id + '', a)
  )
}
function Hst(r, t) {
  var e = r.style,
    n = e.image
  if (
    (n && !bt(n) && (fG(n) ? (n = n.src) : dG(n) && (n = n.toDataURL())), !!n)
  ) {
    var i = e.x || 0,
      a = e.y || 0,
      o = e.width,
      s = e.height,
      l = {
        href: n,
        width: o,
        height: s,
      }
    return (
      i && (l.x = i),
      a && (l.y = a),
      NC(l, r.transform),
      IC(l, e, r, t),
      OC(l, r),
      t.animation && M_(r, l, t),
      Xn('image', r.id + '', l)
    )
  }
}
function Wst(r, t) {
  var e = r.style,
    n = e.text
  if ((n != null && (n += ''), !(!n || isNaN(e.x) || isNaN(e.y)))) {
    var i = e.font || nl,
      a = e.x || 0,
      o = RQ(e.y || 0, j0(i), e.textBaseline),
      s = PQ[e.textAlign] || e.textAlign,
      l = {
        'dominant-baseline': 'central',
        'text-anchor': s,
      }
    if (sU(e)) {
      var u = '',
        c = e.fontStyle,
        h = oU(e.fontSize)
      if (!parseFloat(h)) return
      var f = e.fontFamily || JF,
        d = e.fontWeight
      ;(u += 'font-size:' + h + ';font-family:' + f + ';'),
        c && c !== 'normal' && (u += 'font-style:' + c + ';'),
        d && d !== 'normal' && (u += 'font-weight:' + d + ';'),
        (l.style = u)
    } else l.style = 'font: ' + i
    return (
      n.match(/\s/) && (l['xml:space'] = 'preserve'),
      a && (l.x = a),
      o && (l.y = o),
      NC(l, r.transform),
      IC(l, e, r, t),
      OC(l, r),
      t.animation && M_(r, l, t),
      Xn('text', r.id + '', l, void 0, n)
    )
  }
}
function xI(r, t) {
  if (r instanceof oe) return pG(r, t)
  if (r instanceof yr) return Hst(r, t)
  if (r instanceof Gp) return Wst(r, t)
}
function Xst(r, t, e) {
  var n = r.style
  if (IQ(n)) {
    var i = OQ(r),
      a = e.shadowCache,
      o = a[i]
    if (!o) {
      var s = r.getGlobalScale(),
        l = s[0],
        u = s[1]
      if (!l || !u) return
      var c = n.shadowOffsetX || 0,
        h = n.shadowOffsetY || 0,
        f = n.shadowBlur,
        d = zp(n.shadowColor),
        p = d.opacity,
        g = d.color,
        v = f / 2 / l,
        m = f / 2 / u,
        y = v + ' ' + m
      ;(o = e.zrId + '-s' + e.shadowIdx++),
        (e.defs[o] = Xn(
          'filter',
          o,
          {
            id: o,
            x: '-100%',
            y: '-100%',
            width: '300%',
            height: '300%',
          },
          [
            Xn('feDropShadow', '', {
              dx: c / l,
              dy: h / u,
              stdDeviation: y,
              'flood-color': g,
              'flood-opacity': p,
            }),
          ],
        )),
        (a[i] = o)
    }
    t.filter = K0(o)
  }
}
function vG(r, t, e, n) {
  var i = r[e],
    a,
    o = {
      gradientUnits: i.global ? 'userSpaceOnUse' : 'objectBoundingBox',
    }
  if (Sz(i))
    (a = 'linearGradient'),
      (o.x1 = i.x),
      (o.y1 = i.y),
      (o.x2 = i.x2),
      (o.y2 = i.y2)
  else if (Az(i))
    (a = 'radialGradient'),
      (o.cx = $t(i.x, 0.5)),
      (o.cy = $t(i.y, 0.5)),
      (o.r = $t(i.r, 0.5))
  else return
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var h = Vb(s[u].offset) * 100 + '%',
      f = s[u].color,
      d = zp(f),
      p = d.color,
      g = d.opacity,
      v = {
        offset: h,
      }
    ;(v['stop-color'] = p),
      g < 1 && (v['stop-opacity'] = g),
      l.push(Xn('stop', u + '', v))
  }
  var m = Xn(a, '', o, l),
    y = RC(m),
    _ = n.gradientCache,
    x = _[y]
  x ||
    ((x = n.zrId + '-g' + n.gradientIdx++),
    (_[y] = x),
    (o.id = x),
    (n.defs[x] = Xn(a, x, o, l))),
    (t[e] = K0(x))
}
function gG(r, t, e, n) {
  var i = r.style[e],
    a = r.getBoundingRect(),
    o = {},
    s = i.repeat,
    l = s === 'no-repeat',
    u = s === 'repeat-x',
    c = s === 'repeat-y',
    h
  if (xz(i)) {
    var f = i.imageWidth,
      d = i.imageHeight,
      p = void 0,
      g = i.image
    if (
      (bt(g) ? (p = g) : fG(g) ? (p = g.src) : dG(g) && (p = g.toDataURL()),
      typeof Image > 'u')
    ) {
      var v =
        'Image width/height must been given explictly in svg-ssr renderer.'
      Gr(f, v), Gr(d, v)
    } else if (f == null || d == null) {
      var m = function (M, C) {
          if (M) {
            var E = M.elm,
              D = f || C.width,
              P = d || C.height
            M.tag === 'pattern' &&
              (u ? ((P = 1), (D /= a.width)) : c && ((D = 1), (P /= a.height))),
              (M.attrs.width = D),
              (M.attrs.height = P),
              E && (E.setAttribute('width', D), E.setAttribute('height', P))
          }
        },
        y = GT(p, null, r, function (M) {
          l || m(S, M), m(h, M)
        })
      y && y.width && y.height && ((f = f || y.width), (d = d || y.height))
    }
    ;(h = Xn('image', 'img', {
      href: p,
      width: f,
      height: d,
    })),
      (o.width = f),
      (o.height = d)
  } else
    i.svgElement &&
      ((h = Vt(i.svgElement)), (o.width = i.svgWidth), (o.height = i.svgHeight))
  if (h) {
    var _, x
    l
      ? (_ = x = 1)
      : u
      ? ((x = 1), (_ = o.width / a.width))
      : c
      ? ((_ = 1), (x = o.height / a.height))
      : (o.patternUnits = 'userSpaceOnUse'),
      _ != null && !isNaN(_) && (o.width = _),
      x != null && !isNaN(x) && (o.height = x)
    var A = Mz(i)
    A && (o.patternTransform = A)
    var S = Xn('pattern', '', o, [h]),
      b = RC(S),
      T = n.patternCache,
      w = T[b]
    w ||
      ((w = n.zrId + '-p' + n.patternIdx++),
      (T[b] = w),
      (o.id = w),
      (S = n.defs[w] = Xn('pattern', w, o, [h]))),
      (t[e] = K0(w))
  }
}
function Yst(r, t, e) {
  var n = e.clipPathCache,
    i = e.defs,
    a = n[r.id]
  if (!a) {
    a = e.zrId + '-c' + e.clipPathIdx++
    var o = {
      id: a,
    }
    ;(n[r.id] = a), (i[a] = Xn('clipPath', a, o, [pG(r, e)]))
  }
  t['clip-path'] = K0(a)
}
function SI(r) {
  return document.createTextNode(r)
}
function fu(r, t, e) {
  r.insertBefore(t, e)
}
function AI(r, t) {
  r.removeChild(t)
}
function bI(r, t) {
  r.appendChild(t)
}
function mG(r) {
  return r.parentNode
}
function yG(r) {
  return r.nextSibling
}
function Q1(r, t) {
  r.textContent = t
}
var wI = 58,
  $st = 120,
  qst = Xn('', '')
function Dw(r) {
  return r === void 0
}
function $a(r) {
  return r !== void 0
}
function Zst(r, t, e) {
  for (var n = {}, i = t; i <= e; ++i) {
    var a = r[i].key
    a !== void 0 && (n[a] = i)
  }
  return n
}
function Vd(r, t) {
  var e = r.key === t.key,
    n = r.tag === t.tag
  return n && e
}
function tv(r) {
  var t,
    e = r.children,
    n = r.tag
  if ($a(n)) {
    var i = (r.elm = uG(n))
    if ((kC(qst, r), at(e)))
      for (t = 0; t < e.length; ++t) {
        var a = e[t]
        a != null && bI(i, tv(a))
      }
    else $a(r.text) && !Ut(r.text) && bI(i, SI(r.text))
  } else r.elm = SI(r.text)
  return r.elm
}
function _G(r, t, e, n, i) {
  for (; n <= i; ++n) {
    var a = e[n]
    a != null && fu(r, tv(a), t)
  }
}
function u0(r, t, e, n) {
  for (; e <= n; ++e) {
    var i = t[e]
    if (i != null)
      if ($a(i.tag)) {
        var a = mG(i.elm)
        AI(a, i.elm)
      } else AI(r, i.elm)
  }
}
function kC(r, t) {
  var e,
    n = t.elm,
    i = (r && r.attrs) || {},
    a = t.attrs || {}
  if (i !== a) {
    for (e in a) {
      var o = a[e],
        s = i[e]
      s !== o &&
        (o === !0
          ? n.setAttribute(e, '')
          : o === !1
          ? n.removeAttribute(e)
          : e === 'style'
          ? (n.style.cssText = o)
          : e.charCodeAt(0) !== $st
          ? n.setAttribute(e, o)
          : e === 'xmlns:xlink' || e === 'xmlns'
          ? n.setAttributeNS(Est, e, o)
          : e.charCodeAt(3) === wI
          ? n.setAttributeNS(Dst, e, o)
          : e.charCodeAt(5) === wI
          ? n.setAttributeNS(lG, e, o)
          : n.setAttribute(e, o))
    }
    for (e in i) e in a || n.removeAttribute(e)
  }
}
function Kst(r, t, e) {
  for (
    var n = 0,
      i = 0,
      a = t.length - 1,
      o = t[0],
      s = t[a],
      l = e.length - 1,
      u = e[0],
      c = e[l],
      h,
      f,
      d,
      p;
    n <= a && i <= l;

  )
    o == null
      ? (o = t[++n])
      : s == null
      ? (s = t[--a])
      : u == null
      ? (u = e[++i])
      : c == null
      ? (c = e[--l])
      : Vd(o, u)
      ? (lh(o, u), (o = t[++n]), (u = e[++i]))
      : Vd(s, c)
      ? (lh(s, c), (s = t[--a]), (c = e[--l]))
      : Vd(o, c)
      ? (lh(o, c), fu(r, o.elm, yG(s.elm)), (o = t[++n]), (c = e[--l]))
      : Vd(s, u)
      ? (lh(s, u), fu(r, s.elm, o.elm), (s = t[--a]), (u = e[++i]))
      : (Dw(h) && (h = Zst(t, n, a)),
        (f = h[u.key]),
        Dw(f)
          ? fu(r, tv(u), o.elm)
          : ((d = t[f]),
            d.tag !== u.tag
              ? fu(r, tv(u), o.elm)
              : (lh(d, u), (t[f] = void 0), fu(r, d.elm, o.elm))),
        (u = e[++i]))
  ;(n <= a || i <= l) &&
    (n > a
      ? ((p = e[l + 1] == null ? null : e[l + 1].elm), _G(r, p, e, i, l))
      : u0(r, t, n, a))
}
function lh(r, t) {
  var e = (t.elm = r.elm),
    n = r.children,
    i = t.children
  r !== t &&
    (kC(r, t),
    Dw(t.text)
      ? $a(n) && $a(i)
        ? n !== i && Kst(e, n, i)
        : $a(i)
        ? ($a(r.text) && Q1(e, ''), _G(e, null, i, 0, i.length - 1))
        : $a(n)
        ? u0(e, n, 0, n.length - 1)
        : $a(r.text) && Q1(e, '')
      : r.text !== t.text &&
        ($a(n) && u0(e, n, 0, n.length - 1), Q1(e, t.text)))
}
function jst(r, t) {
  if (Vd(r, t)) lh(r, t)
  else {
    var e = r.elm,
      n = mG(e)
    tv(t), n !== null && (fu(n, t.elm, yG(e)), u0(n, [r], 0, 0))
  }
  return t
}
var Jst = 0,
  Qst = (function () {
    function r(t, e, n) {
      if (
        ((this.type = 'svg'),
        (this.refreshHover = MI()),
        (this.configLayer = MI()),
        (this.storage = e),
        (this._opts = n = Q({}, n)),
        (this.root = t),
        (this._id = 'zr' + Jst++),
        (this._oldVNode = dI(n.width, n.height)),
        t && !n.ssr)
      ) {
        var i = (this._viewport = document.createElement('div'))
        i.style.cssText = 'position:relative;overflow:hidden'
        var a = (this._svgDom = this._oldVNode.elm = uG('svg'))
        kC(null, this._oldVNode), i.appendChild(a), t.appendChild(i)
      }
      this.resize(n.width, n.height)
    }
    return (
      (r.prototype.getType = function () {
        return this.type
      }),
      (r.prototype.getViewportRoot = function () {
        return this._viewport
      }),
      (r.prototype.getViewportRootOffset = function () {
        var t = this.getViewportRoot()
        if (t)
          return {
            offsetLeft: t.offsetLeft || 0,
            offsetTop: t.offsetTop || 0,
          }
      }),
      (r.prototype.getSvgDom = function () {
        return this._svgDom
      }),
      (r.prototype.refresh = function () {
        if (this.root) {
          var t = this.renderToVNode({
            willUpdate: !0,
          })
          ;(t.attrs.style = 'position:absolute;left:0;top:0;user-select:none'),
            jst(this._oldVNode, t),
            (this._oldVNode = t)
        }
      }),
      (r.prototype.renderOneToVNode = function (t) {
        return xI(t, Ew(this._id))
      }),
      (r.prototype.renderToVNode = function (t) {
        t = t || {}
        var e = this.storage.getDisplayList(!0),
          n = this._width,
          i = this._height,
          a = Ew(this._id)
        ;(a.animation = t.animation),
          (a.willUpdate = t.willUpdate),
          (a.compress = t.compress),
          (a.emphasis = t.emphasis)
        var o = [],
          s = (this._bgVNode = tlt(n, i, this._backgroundColor, a))
        s && o.push(s)
        var l = t.compress ? null : (this._mainVNode = Xn('g', 'main', {}, []))
        this._paintList(e, a, l ? l.children : o), l && o.push(l)
        var u = st(pe(a.defs), function (f) {
          return a.defs[f]
        })
        if ((u.length && o.push(Xn('defs', 'defs', {}, u)), t.animation)) {
          var c = Rst(a.cssNodes, a.cssAnims, {
            newline: !0,
          })
          if (c) {
            var h = Xn('style', 'stl', {}, [], c)
            o.push(h)
          }
        }
        return dI(n, i, o, t.useViewBox)
      }),
      (r.prototype.renderToString = function (t) {
        return (
          (t = t || {}),
          RC(
            this.renderToVNode({
              animation: $t(t.cssAnimation, !0),
              emphasis: $t(t.cssEmphasis, !0),
              willUpdate: !1,
              compress: !0,
              useViewBox: $t(t.useViewBox, !0),
            }),
            {
              newline: !0,
            },
          )
        )
      }),
      (r.prototype.setBackgroundColor = function (t) {
        this._backgroundColor = t
      }),
      (r.prototype.getSvgRoot = function () {
        return this._mainVNode && this._mainVNode.elm
      }),
      (r.prototype._paintList = function (t, e, n) {
        for (var i = t.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
          var h = t[c]
          if (!h.invisible) {
            var f = h.__clipPaths,
              d = (f && f.length) || 0,
              p = (l && l.length) || 0,
              g = void 0
            for (
              g = Math.max(d - 1, p - 1);
              g >= 0 && !(f && l && f[g] === l[g]);
              g--
            );
            for (var v = p - 1; v > g; v--) o--, (s = a[o - 1])
            for (var m = g + 1; m < d; m++) {
              var y = {}
              Yst(f[m], y, e)
              var _ = Xn('g', 'clip-g-' + u++, y, [])
              ;(s ? s.children : n).push(_), (a[o++] = _), (s = _)
            }
            l = f
            var x = xI(h, e)
            x && (s ? s.children : n).push(x)
          }
        }
      }),
      (r.prototype.resize = function (t, e) {
        var n = this._opts,
          i = this.root,
          a = this._viewport
        if (
          (t != null && (n.width = t),
          e != null && (n.height = e),
          i &&
            a &&
            ((a.style.display = 'none'),
            (t = xh(i, 0, n)),
            (e = xh(i, 1, n)),
            (a.style.display = '')),
          this._width !== t || this._height !== e)
        ) {
          if (((this._width = t), (this._height = e), a)) {
            var o = a.style
            ;(o.width = t + 'px'), (o.height = e + 'px')
          }
          if (NT(this._backgroundColor)) this.refresh()
          else {
            var s = this._svgDom
            s && (s.setAttribute('width', t), s.setAttribute('height', e))
            var l = this._bgVNode && this._bgVNode.elm
            l && (l.setAttribute('width', t), l.setAttribute('height', e))
          }
        }
      }),
      (r.prototype.getWidth = function () {
        return this._width
      }),
      (r.prototype.getHeight = function () {
        return this._height
      }),
      (r.prototype.dispose = function () {
        this.root && (this.root.innerHTML = ''),
          (this._svgDom =
            this._viewport =
            this.storage =
            this._oldVNode =
            this._bgVNode =
            this._mainVNode =
              null)
      }),
      (r.prototype.clear = function () {
        this._svgDom && (this._svgDom.innerHTML = null), (this._oldVNode = null)
      }),
      (r.prototype.toDataURL = function (t) {
        var e = this.renderToString(),
          n = 'data:image/svg+xml;'
        return t
          ? ((e = kQ(e)), e && n + 'base64,' + e)
          : n + 'charset=UTF-8,' + encodeURIComponent(e)
      }),
      r
    )
  })()
function MI(r) {
  return function () {}
}
function tlt(r, t, e, n) {
  var i
  if (e && e !== 'none')
    if (
      ((i = Xn('rect', 'bg', {
        width: r,
        height: t,
        x: '0',
        y: '0',
      })),
      bz(e))
    )
      vG(
        {
          fill: e,
        },
        i.attrs,
        'fill',
        n,
      )
    else if (NT(e))
      gG(
        {
          style: {
            fill: e,
          },
          dirty: wn,
          getBoundingRect: function () {
            return {
              width: r,
              height: t,
            }
          },
        },
        i.attrs,
        'fill',
        n,
      )
    else {
      var a = zp(e),
        o = a.color,
        s = a.opacity
      ;(i.attrs.fill = o), s < 1 && (i.attrs['fill-opacity'] = s)
    }
  return i
}
const elt = Qst
function nlt(r) {
  r.registerPainter('svg', elt)
}
function TI(r, t, e) {
  var n = rl.createCanvas(),
    i = t.getWidth(),
    a = t.getHeight(),
    o = n.style
  return (
    o &&
      ((o.position = 'absolute'),
      (o.left = '0'),
      (o.top = '0'),
      (o.width = i + 'px'),
      (o.height = a + 'px'),
      n.setAttribute('data-zr-dom-id', r)),
    (n.width = i * e),
    (n.height = a * e),
    n
  )
}
var rlt = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    ;(a.motionBlur = !1),
      (a.lastFrameAlpha = 0.7),
      (a.dpr = 1),
      (a.virtual = !1),
      (a.config = {}),
      (a.incremental = !1),
      (a.zlevel = 0),
      (a.maxRepaintRectCount = 5),
      (a.__dirty = !0),
      (a.__firstTimePaint = !0),
      (a.__used = !1),
      (a.__drawIndex = 0),
      (a.__startIndex = 0),
      (a.__endIndex = 0),
      (a.__prevStartIndex = null),
      (a.__prevEndIndex = null)
    var o
    ;(i = i || Gy),
      typeof e == 'string' ? (o = TI(e, n, i)) : Ut(e) && ((o = e), (e = o.id)),
      (a.id = e),
      (a.dom = o)
    var s = o.style
    return (
      s &&
        (iz(o),
        (o.onselectstart = function () {
          return !1
        }),
        (s.padding = '0'),
        (s.margin = '0'),
        (s.borderWidth = '0')),
      (a.painter = n),
      (a.dpr = i),
      a
    )
  }
  return (
    (t.prototype.getElementCount = function () {
      return this.__endIndex - this.__startIndex
    }),
    (t.prototype.afterBrush = function () {
      ;(this.__prevStartIndex = this.__startIndex),
        (this.__prevEndIndex = this.__endIndex)
    }),
    (t.prototype.initContext = function () {
      ;(this.ctx = this.dom.getContext('2d')), (this.ctx.dpr = this.dpr)
    }),
    (t.prototype.setUnpainted = function () {
      this.__firstTimePaint = !0
    }),
    (t.prototype.createBackBuffer = function () {
      var e = this.dpr
      ;(this.domBack = TI('back-' + this.id, this.painter, e)),
        (this.ctxBack = this.domBack.getContext('2d')),
        e !== 1 && this.ctxBack.scale(e, e)
    }),
    (t.prototype.createRepaintRects = function (e, n, i, a) {
      if (this.__firstTimePaint) return (this.__firstTimePaint = !1), null
      var o = [],
        s = this.maxRepaintRectCount,
        l = !1,
        u = new ee(0, 0, 0, 0)
      function c(y) {
        if (!(!y.isFinite() || y.isZero()))
          if (o.length === 0) {
            var _ = new ee(0, 0, 0, 0)
            _.copy(y), o.push(_)
          } else {
            for (var x = !1, A = 1 / 0, S = 0, b = 0; b < o.length; ++b) {
              var T = o[b]
              if (T.intersect(y)) {
                var w = new ee(0, 0, 0, 0)
                w.copy(T), w.union(y), (o[b] = w), (x = !0)
                break
              } else if (l) {
                u.copy(y), u.union(T)
                var M = y.width * y.height,
                  C = T.width * T.height,
                  E = u.width * u.height,
                  D = E - M - C
                D < A && ((A = D), (S = b))
              }
            }
            if ((l && (o[S].union(y), (x = !0)), !x)) {
              var _ = new ee(0, 0, 0, 0)
              _.copy(y), o.push(_)
            }
            l || (l = o.length >= s)
          }
      }
      for (var h = this.__startIndex; h < this.__endIndex; ++h) {
        var f = e[h]
        if (f) {
          var d = f.shouldBePainted(i, a, !0, !0),
            p =
              f.__isRendered && (f.__dirty & yi || !d)
                ? f.getPrevPaintRect()
                : null
          p && c(p)
          var g =
            d && (f.__dirty & yi || !f.__isRendered) ? f.getPaintRect() : null
          g && c(g)
        }
      }
      for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
        var f = n[h],
          d = f && f.shouldBePainted(i, a, !0, !0)
        if (f && (!d || !f.__zr) && f.__isRendered) {
          var p = f.getPrevPaintRect()
          p && c(p)
        }
      }
      var v
      do {
        v = !1
        for (var h = 0; h < o.length; ) {
          if (o[h].isZero()) {
            o.splice(h, 1)
            continue
          }
          for (var m = h + 1; m < o.length; )
            o[h].intersect(o[m])
              ? ((v = !0), o[h].union(o[m]), o.splice(m, 1))
              : m++
          h++
        }
      } while (v)
      return (this._paintRects = o), o
    }),
    (t.prototype.debugGetPaintRects = function () {
      return (this._paintRects || []).slice()
    }),
    (t.prototype.resize = function (e, n) {
      var i = this.dpr,
        a = this.dom,
        o = a.style,
        s = this.domBack
      o && ((o.width = e + 'px'), (o.height = n + 'px')),
        (a.width = e * i),
        (a.height = n * i),
        s &&
          ((s.width = e * i),
          (s.height = n * i),
          i !== 1 && this.ctxBack.scale(i, i))
    }),
    (t.prototype.clear = function (e, n, i) {
      var a = this.dom,
        o = this.ctx,
        s = a.width,
        l = a.height
      n = n || this.clearColor
      var u = this.motionBlur && !e,
        c = this.lastFrameAlpha,
        h = this.dpr,
        f = this
      u &&
        (this.domBack || this.createBackBuffer(),
        (this.ctxBack.globalCompositeOperation = 'copy'),
        this.ctxBack.drawImage(a, 0, 0, s / h, l / h))
      var d = this.domBack
      function p(g, v, m, y) {
        if ((o.clearRect(g, v, m, y), n && n !== 'transparent')) {
          var _ = void 0
          if ($0(n)) {
            var x = n.global || (n.__width === m && n.__height === y)
            ;(_ =
              (x && n.__canvasGradient) ||
              _w(o, n, {
                x: 0,
                y: 0,
                width: m,
                height: y,
              })),
              (n.__canvasGradient = _),
              (n.__width = m),
              (n.__height = y)
          } else
            kJ(n) &&
              ((n.scaleX = n.scaleX || h),
              (n.scaleY = n.scaleY || h),
              (_ = xw(o, n, {
                dirty: function () {
                  f.setUnpainted(), f.painter.refresh()
                },
              })))
          o.save(), (o.fillStyle = _ || n), o.fillRect(g, v, m, y), o.restore()
        }
        u &&
          (o.save(),
          (o.globalAlpha = c),
          o.drawImage(d, g, v, m, y),
          o.restore())
      }
      !i || u
        ? p(0, 0, s, l)
        : i.length &&
          R(i, function (g) {
            p(g.x * h, g.y * h, g.width * h, g.height * h)
          })
    }),
    t
  )
})(ra)
const tS = rlt
var CI = 1e5,
  jl = 314159,
  um = 0.01,
  ilt = 0.001
function alt(r) {
  return r
    ? r.__builtin__
      ? !0
      : !(typeof r.resize != 'function' || typeof r.refresh != 'function')
    : !1
}
function olt(r, t) {
  var e = document.createElement('div')
  return (
    (e.style.cssText =
      [
        'position:relative',
        'width:' + r + 'px',
        'height:' + t + 'px',
        'padding:0',
        'margin:0',
        'border-width:0',
      ].join(';') + ';'),
    e
  )
}
var slt = (function () {
  function r(t, e, n, i) {
    ;(this.type = 'canvas'),
      (this._zlevelList = []),
      (this._prevDisplayList = []),
      (this._layers = {}),
      (this._layerConfig = {}),
      (this._needsManuallyCompositing = !1),
      (this.type = 'canvas')
    var a = !t.nodeName || t.nodeName.toUpperCase() === 'CANVAS'
    ;(this._opts = n = Q({}, n || {})),
      (this.dpr = n.devicePixelRatio || Gy),
      (this._singleCanvas = a),
      (this.root = t)
    var o = t.style
    o && (iz(t), (t.innerHTML = '')), (this.storage = e)
    var s = this._zlevelList
    this._prevDisplayList = []
    var l = this._layers
    if (a) {
      var c = t,
        h = c.width,
        f = c.height
      n.width != null && (h = n.width),
        n.height != null && (f = n.height),
        (this.dpr = n.devicePixelRatio || 1),
        (c.width = h * this.dpr),
        (c.height = f * this.dpr),
        (this._width = h),
        (this._height = f)
      var d = new tS(c, this, this.dpr)
      ;(d.__builtin__ = !0),
        d.initContext(),
        (l[jl] = d),
        (d.zlevel = jl),
        s.push(jl),
        (this._domRoot = t)
    } else {
      ;(this._width = xh(t, 0, n)), (this._height = xh(t, 1, n))
      var u = (this._domRoot = olt(this._width, this._height))
      t.appendChild(u)
    }
  }
  return (
    (r.prototype.getType = function () {
      return 'canvas'
    }),
    (r.prototype.isSingleCanvas = function () {
      return this._singleCanvas
    }),
    (r.prototype.getViewportRoot = function () {
      return this._domRoot
    }),
    (r.prototype.getViewportRootOffset = function () {
      var t = this.getViewportRoot()
      if (t)
        return {
          offsetLeft: t.offsetLeft || 0,
          offsetTop: t.offsetTop || 0,
        }
    }),
    (r.prototype.refresh = function (t) {
      var e = this.storage.getDisplayList(!0),
        n = this._prevDisplayList,
        i = this._zlevelList
      ;(this._redrawId = Math.random()),
        this._paintList(e, n, t, this._redrawId)
      for (var a = 0; a < i.length; a++) {
        var o = i[a],
          s = this._layers[o]
        if (!s.__builtin__ && s.refresh) {
          var l = a === 0 ? this._backgroundColor : null
          s.refresh(l)
        }
      }
      return (
        this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this
      )
    }),
    (r.prototype.refreshHover = function () {
      this._paintHoverList(this.storage.getDisplayList(!1))
    }),
    (r.prototype._paintHoverList = function (t) {
      var e = t.length,
        n = this._hoverlayer
      if ((n && n.clear(), !!e)) {
        for (
          var i = {
              inHover: !0,
              viewWidth: this._width,
              viewHeight: this._height,
            },
            a,
            o = 0;
          o < e;
          o++
        ) {
          var s = t[o]
          s.__inHover &&
            (n || (n = this._hoverlayer = this.getLayer(CI)),
            a || ((a = n.ctx), a.save()),
            Au(a, s, i, o === e - 1))
        }
        a && a.restore()
      }
    }),
    (r.prototype.getHoverLayer = function () {
      return this.getLayer(CI)
    }),
    (r.prototype.paintOne = function (t, e) {
      Q5(t, e)
    }),
    (r.prototype._paintList = function (t, e, n, i) {
      if (this._redrawId === i) {
        ;(n = n || !1), this._updateLayerStatus(t)
        var a = this._doPaintList(t, e, n),
          o = a.finished,
          s = a.needsRefreshHover
        if (
          (this._needsManuallyCompositing && this._compositeManually(),
          s && this._paintHoverList(t),
          o)
        )
          this.eachLayer(function (u) {
            u.afterBrush && u.afterBrush()
          })
        else {
          var l = this
          Nb(function () {
            l._paintList(t, e, n, i)
          })
        }
      }
    }),
    (r.prototype._compositeManually = function () {
      var t = this.getLayer(jl).ctx,
        e = this._domRoot.width,
        n = this._domRoot.height
      t.clearRect(0, 0, e, n),
        this.eachBuiltinLayer(function (i) {
          i.virtual && t.drawImage(i.dom, 0, 0, e, n)
        })
    }),
    (r.prototype._doPaintList = function (t, e, n) {
      for (
        var i = this, a = [], o = this._opts.useDirtyRect, s = 0;
        s < this._zlevelList.length;
        s++
      ) {
        var l = this._zlevelList[s],
          u = this._layers[l]
        u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u)
      }
      for (
        var c = !0,
          h = !1,
          f = function (g) {
            var v = a[g],
              m = v.ctx,
              y = o && v.createRepaintRects(t, e, d._width, d._height),
              _ = n ? v.__startIndex : v.__drawIndex,
              x = !n && v.incremental && Date.now,
              A = x && Date.now(),
              S = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null
            if (v.__startIndex === v.__endIndex) v.clear(!1, S, y)
            else if (_ === v.__startIndex) {
              var b = t[_]
              ;(!b.incremental || !b.notClear || n) && v.clear(!1, S, y)
            }
            _ === -1 &&
              (console.error('For some unknown reason. drawIndex is -1'),
              (_ = v.__startIndex))
            var T,
              w = function (D) {
                var P = {
                  inHover: !1,
                  allClipped: !1,
                  prevEl: null,
                  viewWidth: i._width,
                  viewHeight: i._height,
                }
                for (T = _; T < v.__endIndex; T++) {
                  var L = t[T]
                  if (
                    (L.__inHover && (h = !0),
                    i._doPaintEl(L, v, o, D, P, T === v.__endIndex - 1),
                    x)
                  ) {
                    var I = Date.now() - A
                    if (I > 15) break
                  }
                }
                P.prevElClipPaths && m.restore()
              }
            if (y)
              if (y.length === 0) T = v.__endIndex
              else
                for (var M = d.dpr, C = 0; C < y.length; ++C) {
                  var E = y[C]
                  m.save(),
                    m.beginPath(),
                    m.rect(E.x * M, E.y * M, E.width * M, E.height * M),
                    m.clip(),
                    w(E),
                    m.restore()
                }
            else m.save(), w(), m.restore()
            ;(v.__drawIndex = T), v.__drawIndex < v.__endIndex && (c = !1)
          },
          d = this,
          p = 0;
        p < a.length;
        p++
      )
        f(p)
      return (
        Se.wxa &&
          R(this._layers, function (g) {
            g && g.ctx && g.ctx.draw && g.ctx.draw()
          }),
        {
          finished: c,
          needsRefreshHover: h,
        }
      )
    }),
    (r.prototype._doPaintEl = function (t, e, n, i, a, o) {
      var s = e.ctx
      if (n) {
        var l = t.getPaintRect()
        ;(!i || (l && l.intersect(i))) &&
          (Au(s, t, a, o), t.setPrevPaintRect(l))
      } else Au(s, t, a, o)
    }),
    (r.prototype.getLayer = function (t, e) {
      this._singleCanvas && !this._needsManuallyCompositing && (t = jl)
      var n = this._layers[t]
      return (
        n ||
          ((n = new tS('zr_' + t, this, this.dpr)),
          (n.zlevel = t),
          (n.__builtin__ = !0),
          this._layerConfig[t]
            ? te(n, this._layerConfig[t], !0)
            : this._layerConfig[t - um] && te(n, this._layerConfig[t - um], !0),
          e && (n.virtual = e),
          this.insertLayer(t, n),
          n.initContext()),
        n
      )
    }),
    (r.prototype.insertLayer = function (t, e) {
      var n = this._layers,
        i = this._zlevelList,
        a = i.length,
        o = this._domRoot,
        s = null,
        l = -1
      if (!n[t] && alt(e)) {
        if (a > 0 && t > i[0]) {
          for (l = 0; l < a - 1 && !(i[l] < t && i[l + 1] > t); l++);
          s = n[i[l]]
        }
        if ((i.splice(l + 1, 0, t), (n[t] = e), !e.virtual))
          if (s) {
            var u = s.dom
            u.nextSibling
              ? o.insertBefore(e.dom, u.nextSibling)
              : o.appendChild(e.dom)
          } else
            o.firstChild
              ? o.insertBefore(e.dom, o.firstChild)
              : o.appendChild(e.dom)
        e.painter || (e.painter = this)
      }
    }),
    (r.prototype.eachLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i]
        t.call(e, this._layers[a], a)
      }
    }),
    (r.prototype.eachBuiltinLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i],
          o = this._layers[a]
        o.__builtin__ && t.call(e, o, a)
      }
    }),
    (r.prototype.eachOtherLayer = function (t, e) {
      for (var n = this._zlevelList, i = 0; i < n.length; i++) {
        var a = n[i],
          o = this._layers[a]
        o.__builtin__ || t.call(e, o, a)
      }
    }),
    (r.prototype.getLayers = function () {
      return this._layers
    }),
    (r.prototype._updateLayerStatus = function (t) {
      this.eachBuiltinLayer(function (h, f) {
        h.__dirty = h.__used = !1
      })
      function e(h) {
        a && (a.__endIndex !== h && (a.__dirty = !0), (a.__endIndex = h))
      }
      if (this._singleCanvas)
        for (var n = 1; n < t.length; n++) {
          var i = t[n]
          if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
            this._needsManuallyCompositing = !0
            break
          }
        }
      var a = null,
        o = 0,
        s,
        l
      for (l = 0; l < t.length; l++) {
        var i = t[l],
          u = i.zlevel,
          c = void 0
        s !== u && ((s = u), (o = 0)),
          i.incremental
            ? ((c = this.getLayer(u + ilt, this._needsManuallyCompositing)),
              (c.incremental = !0),
              (o = 1))
            : (c = this.getLayer(
                u + (o > 0 ? um : 0),
                this._needsManuallyCompositing,
              )),
          c.__builtin__ ||
            CT('ZLevel ' + u + ' has been used by unkown layer ' + c.id),
          c !== a &&
            ((c.__used = !0),
            c.__startIndex !== l && (c.__dirty = !0),
            (c.__startIndex = l),
            c.incremental ? (c.__drawIndex = -1) : (c.__drawIndex = l),
            e(l),
            (a = c)),
          i.__dirty & yi &&
            !i.__inHover &&
            ((c.__dirty = !0),
            c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l))
      }
      e(l),
        this.eachBuiltinLayer(function (h, f) {
          !h.__used &&
            h.getElementCount() > 0 &&
            ((h.__dirty = !0),
            (h.__startIndex = h.__endIndex = h.__drawIndex = 0)),
            h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex)
        })
    }),
    (r.prototype.clear = function () {
      return this.eachBuiltinLayer(this._clearLayer), this
    }),
    (r.prototype._clearLayer = function (t) {
      t.clear()
    }),
    (r.prototype.setBackgroundColor = function (t) {
      ;(this._backgroundColor = t),
        R(this._layers, function (e) {
          e.setUnpainted()
        })
    }),
    (r.prototype.configLayer = function (t, e) {
      if (e) {
        var n = this._layerConfig
        n[t] ? te(n[t], e, !0) : (n[t] = e)
        for (var i = 0; i < this._zlevelList.length; i++) {
          var a = this._zlevelList[i]
          if (a === t || a === t + um) {
            var o = this._layers[a]
            te(o, n[t], !0)
          }
        }
      }
    }),
    (r.prototype.delLayer = function (t) {
      var e = this._layers,
        n = this._zlevelList,
        i = e[t]
      i &&
        (i.dom.parentNode.removeChild(i.dom),
        delete e[t],
        n.splice(re(n, t), 1))
    }),
    (r.prototype.resize = function (t, e) {
      if (this._domRoot.style) {
        var n = this._domRoot
        n.style.display = 'none'
        var i = this._opts,
          a = this.root
        if (
          (t != null && (i.width = t),
          e != null && (i.height = e),
          (t = xh(a, 0, i)),
          (e = xh(a, 1, i)),
          (n.style.display = ''),
          this._width !== t || e !== this._height)
        ) {
          ;(n.style.width = t + 'px'), (n.style.height = e + 'px')
          for (var o in this._layers)
            this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e)
          this.refresh(!0)
        }
        ;(this._width = t), (this._height = e)
      } else {
        if (t == null || e == null) return
        ;(this._width = t), (this._height = e), this.getLayer(jl).resize(t, e)
      }
      return this
    }),
    (r.prototype.clearLayer = function (t) {
      var e = this._layers[t]
      e && e.clear()
    }),
    (r.prototype.dispose = function () {
      ;(this.root.innerHTML = ''),
        (this.root = this.storage = this._domRoot = this._layers = null)
    }),
    (r.prototype.getRenderedCanvas = function (t) {
      if (((t = t || {}), this._singleCanvas && !this._compositeManually))
        return this._layers[jl].dom
      var e = new tS('image', this, t.pixelRatio || this.dpr)
      e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor)
      var n = e.ctx
      if (t.pixelRatio <= this.dpr) {
        this.refresh()
        var i = e.dom.width,
          a = e.dom.height
        this.eachLayer(function (h) {
          h.__builtin__
            ? n.drawImage(h.dom, 0, 0, i, a)
            : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore())
        })
      } else
        for (
          var o = {
              inHover: !1,
              viewWidth: this._width,
              viewHeight: this._height,
            },
            s = this.storage.getDisplayList(!0),
            l = 0,
            u = s.length;
          l < u;
          l++
        ) {
          var c = s[l]
          Au(n, c, o, l === u - 1)
        }
      return e.dom
    }),
    (r.prototype.getWidth = function () {
      return this._width
    }),
    (r.prototype.getHeight = function () {
      return this._height
    }),
    r
  )
})()
const llt = slt
function ult(r) {
  r.registerPainter('canvas', llt)
}
var clt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getLegendIcon = function (e) {
      var n = new Ht(),
        i = Rn(
          'line',
          0,
          e.itemHeight / 2,
          e.itemWidth,
          0,
          e.lineStyle.stroke,
          !1,
        )
      n.add(i), i.setStyle(e.lineStyle)
      var a = this.getData().getVisual('symbol'),
        o = this.getData().getVisual('symbolRotate'),
        s = a === 'none' ? 'circle' : a,
        l = e.itemHeight * 0.8,
        u = Rn(
          s,
          (e.itemWidth - l) / 2,
          (e.itemHeight - l) / 2,
          l,
          l,
          e.itemStyle.fill,
        )
      n.add(u), u.setStyle(e.itemStyle)
      var c = e.iconRotate === 'inherit' ? o : e.iconRotate || 0
      return (
        (u.rotation = (c * Math.PI) / 180),
        u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]),
        s.indexOf('empty') > -1 &&
          ((u.style.stroke = u.style.fill),
          (u.style.fill = '#fff'),
          (u.style.lineWidth = 2)),
        n
      )
    }),
    (t.type = 'series.line'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = {
      z: 3,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: 'top',
      },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8,
      },
      lineStyle: {
        width: 2,
        type: 'solid',
      },
      emphasis: {
        scale: !0,
      },
      step: !1,
      smooth: !1,
      smoothMonotone: null,
      symbol: 'emptyCircle',
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      showAllSymbol: 'auto',
      connectNulls: !1,
      sampling: 'none',
      animationEasing: 'linear',
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: 'clone',
      },
      triggerLineEvent: !1,
    }),
    t
  )
})(rn)
const hlt = clt
function of(r, t) {
  var e = r.mapDimensionsAll('defaultedLabel'),
    n = e.length
  if (n === 1) {
    var i = nf(r, t, e[0])
    return i != null ? i + '' : null
  } else if (n) {
    for (var a = [], o = 0; o < e.length; o++) a.push(nf(r, t, e[o]))
    return a.join(' ')
  }
}
function xG(r, t) {
  var e = r.mapDimensionsAll('defaultedLabel')
  if (!at(t)) return t + ''
  for (var n = [], i = 0; i < e.length; i++) {
    var a = r.getDimensionIndex(e[i])
    a >= 0 && n.push(t[a])
  }
  return n.join(' ')
}
var flt = (function (r) {
  X(t, r)
  function t(e, n, i, a) {
    var o = r.call(this) || this
    return o.updateData(e, n, i, a), o
  }
  return (
    (t.prototype._createSymbol = function (e, n, i, a, o) {
      this.removeAll()
      var s = Rn(e, -1, -1, 2, 2, null, o)
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2,
      }),
        (s.drift = dlt),
        (this._symbolType = e),
        this.add(s)
    }),
    (t.prototype.stopSymbolAnimation = function (e) {
      this.childAt(0).stopAnimation(null, e)
    }),
    (t.prototype.getSymbolType = function () {
      return this._symbolType
    }),
    (t.prototype.getSymbolPath = function () {
      return this.childAt(0)
    }),
    (t.prototype.highlight = function () {
      Qo(this.childAt(0))
    }),
    (t.prototype.downplay = function () {
      ts(this.childAt(0))
    }),
    (t.prototype.setZ = function (e, n) {
      var i = this.childAt(0)
      ;(i.zlevel = e), (i.z = n)
    }),
    (t.prototype.setDraggable = function (e, n) {
      var i = this.childAt(0)
      ;(i.draggable = e), (i.cursor = !n && e ? 'move' : i.cursor)
    }),
    (t.prototype.updateData = function (e, n, i, a) {
      this.silent = !1
      var o = e.getItemVisual(n, 'symbol') || 'circle',
        s = e.hostModel,
        l = t.getSymbolSize(e, n),
        u = o !== this._symbolType,
        c = a && a.disableAnimation
      if (u) {
        var h = e.getItemVisual(n, 'symbolKeepAspect')
        this._createSymbol(o, e, n, l, h)
      } else {
        var f = this.childAt(0)
        f.silent = !1
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2,
        }
        c ? f.attr(d) : we(f, d, s, n), Ca(f)
      }
      if ((this._updateCommon(e, n, l, i, a), u)) {
        var f = this.childAt(0)
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              opacity: f.style.opacity,
            },
          }
          ;(f.scaleX = f.scaleY = 0), (f.style.opacity = 0), Je(f, d, s, n)
        }
      }
      c && this.childAt(0).stopAnimation('leave')
    }),
    (t.prototype._updateCommon = function (e, n, i, a, o) {
      var s = this.childAt(0),
        l = e.hostModel,
        u,
        c,
        h,
        f,
        d,
        p,
        g,
        v,
        m
      if (
        (a &&
          ((u = a.emphasisItemStyle),
          (c = a.blurItemStyle),
          (h = a.selectItemStyle),
          (f = a.focus),
          (d = a.blurScope),
          (g = a.labelStatesModels),
          (v = a.hoverScale),
          (m = a.cursorStyle),
          (p = a.emphasisDisabled)),
        !a || e.hasItemOption)
      ) {
        var y = a && a.itemModel ? a.itemModel : e.getItemModel(n),
          _ = y.getModel('emphasis')
        ;(u = _.getModel('itemStyle').getItemStyle()),
          (h = y.getModel(['select', 'itemStyle']).getItemStyle()),
          (c = y.getModel(['blur', 'itemStyle']).getItemStyle()),
          (f = _.get('focus')),
          (d = _.get('blurScope')),
          (p = _.get('disabled')),
          (g = Zn(y)),
          (v = _.getShallow('scale')),
          (m = y.getShallow('cursor'))
      }
      var x = e.getItemVisual(n, 'symbolRotate')
      s.attr('rotation', ((x || 0) * Math.PI) / 180 || 0)
      var A = ic(e.getItemVisual(n, 'symbolOffset'), i)
      A && ((s.x = A[0]), (s.y = A[1])), m && s.attr('cursor', m)
      var S = e.getItemVisual(n, 'style'),
        b = S.fill
      if (s instanceof yr) {
        var T = s.style
        s.useStyle(
          Q(
            {
              image: T.image,
              x: T.x,
              y: T.y,
              width: T.width,
              height: T.height,
            },
            S,
          ),
        )
      } else
        s.__isEmptyBrush ? s.useStyle(Q({}, S)) : s.useStyle(S),
          (s.style.decal = null),
          s.setColor(b, o && o.symbolInnerColor),
          (s.style.strokeNoScale = !0)
      var w = e.getItemVisual(n, 'liftZ'),
        M = this._z2
      w != null
        ? M == null && ((this._z2 = s.z2), (s.z2 += w))
        : M != null && ((s.z2 = M), (this._z2 = null))
      var C = o && o.useNameLabel
      mr(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: E,
        inheritColor: b,
        defaultOpacity: S.opacity,
      })
      function E(L) {
        return C ? e.getName(L) : of(e, L)
      }
      ;(this._sizeX = i[0] / 2), (this._sizeY = i[1] / 2)
      var D = s.ensureState('emphasis')
      ;(D.style = u),
        (s.ensureState('select').style = h),
        (s.ensureState('blur').style = c)
      var P =
        v == null || v === !0
          ? Math.max(1.1, 3 / this._sizeY)
          : isFinite(v) && v > 0
          ? +v
          : 1
      ;(D.scaleX = this._sizeX * P),
        (D.scaleY = this._sizeY * P),
        this.setSymbolScale(1),
        fn(this, f, d, p)
    }),
    (t.prototype.setSymbolScale = function (e) {
      this.scaleX = this.scaleY = e
    }),
    (t.prototype.fadeOut = function (e, n, i) {
      var a = this.childAt(0),
        o = Wt(this).dataIndex,
        s = i && i.animation
      if (((this.silent = a.silent = !0), i && i.fadeLabel)) {
        var l = a.getTextContent()
        l &&
          al(
            l,
            {
              style: {
                opacity: 0,
              },
            },
            n,
            {
              dataIndex: o,
              removeOpt: s,
              cb: function () {
                a.removeTextContent()
              },
            },
          )
      } else a.removeTextContent()
      al(
        a,
        {
          style: {
            opacity: 0,
          },
          scaleX: 0,
          scaleY: 0,
        },
        n,
        {
          dataIndex: o,
          cb: e,
          removeOpt: s,
        },
      )
    }),
    (t.getSymbolSize = function (e, n) {
      return Lf(e.getItemVisual(n, 'symbolSize'))
    }),
    t
  )
})(Ht)
function dlt(r, t) {
  this.parent.drift(r, t)
}
const Tv = flt
function eS(r, t, e, n) {
  return (
    t &&
    !isNaN(t[0]) &&
    !isNaN(t[1]) &&
    !(n.isIgnore && n.isIgnore(e)) &&
    !(n.clipShape && !n.clipShape.contain(t[0], t[1])) &&
    r.getItemVisual(e, 'symbol') !== 'none'
  )
}
function EI(r) {
  return (
    r != null &&
      !Ut(r) &&
      (r = {
        isIgnore: r,
      }),
    r || {}
  )
}
function DI(r) {
  var t = r.hostModel,
    e = t.getModel('emphasis')
  return {
    emphasisItemStyle: e.getModel('itemStyle').getItemStyle(),
    blurItemStyle: t.getModel(['blur', 'itemStyle']).getItemStyle(),
    selectItemStyle: t.getModel(['select', 'itemStyle']).getItemStyle(),
    focus: e.get('focus'),
    blurScope: e.get('blurScope'),
    emphasisDisabled: e.get('disabled'),
    hoverScale: e.get('scale'),
    labelStatesModels: Zn(t),
    cursorStyle: t.get('cursor'),
  }
}
var plt = (function () {
  function r(t) {
    ;(this.group = new Ht()), (this._SymbolCtor = t || Tv)
  }
  return (
    (r.prototype.updateData = function (t, e) {
      ;(this._progressiveEls = null), (e = EI(e))
      var n = this.group,
        i = t.hostModel,
        a = this._data,
        o = this._SymbolCtor,
        s = e.disableAnimation,
        l = DI(t),
        u = {
          disableAnimation: s,
        },
        c =
          e.getSymbolPoint ||
          function (h) {
            return t.getItemLayout(h)
          }
      a || n.removeAll(),
        t
          .diff(a)
          .add(function (h) {
            var f = c(h)
            if (eS(t, f, h, e)) {
              var d = new o(t, h, l, u)
              d.setPosition(f), t.setItemGraphicEl(h, d), n.add(d)
            }
          })
          .update(function (h, f) {
            var d = a.getItemGraphicEl(f),
              p = c(h)
            if (!eS(t, p, h, e)) {
              n.remove(d)
              return
            }
            var g = t.getItemVisual(h, 'symbol') || 'circle',
              v = d && d.getSymbolType && d.getSymbolType()
            if (!d || (v && v !== g))
              n.remove(d), (d = new o(t, h, l, u)), d.setPosition(p)
            else {
              d.updateData(t, h, l, u)
              var m = {
                x: p[0],
                y: p[1],
              }
              s ? d.attr(m) : we(d, m, i)
            }
            n.add(d), t.setItemGraphicEl(h, d)
          })
          .remove(function (h) {
            var f = a.getItemGraphicEl(h)
            f &&
              f.fadeOut(function () {
                n.remove(f)
              }, i)
          })
          .execute(),
        (this._getSymbolPoint = c),
        (this._data = t)
    }),
    (r.prototype.updateLayout = function () {
      var t = this,
        e = this._data
      e &&
        e.eachItemGraphicEl(function (n, i) {
          var a = t._getSymbolPoint(i)
          n.setPosition(a), n.markRedraw()
        })
    }),
    (r.prototype.incrementalPrepareUpdate = function (t) {
      ;(this._seriesScope = DI(t)), (this._data = null), this.group.removeAll()
    }),
    (r.prototype.incrementalUpdate = function (t, e, n) {
      ;(this._progressiveEls = []), (n = EI(n))
      function i(l) {
        l.isGroup ||
          ((l.incremental = !0), (l.ensureState('emphasis').hoverLayer = !0))
      }
      for (var a = t.start; a < t.end; a++) {
        var o = e.getItemLayout(a)
        if (eS(e, o, a, n)) {
          var s = new this._SymbolCtor(e, a, this._seriesScope)
          s.traverse(i),
            s.setPosition(o),
            this.group.add(s),
            e.setItemGraphicEl(a, s),
            this._progressiveEls.push(s)
        }
      }
    }),
    (r.prototype.eachRendered = function (t) {
      vl(this._progressiveEls || this.group, t)
    }),
    (r.prototype.remove = function (t) {
      var e = this.group,
        n = this._data
      n && t
        ? n.eachItemGraphicEl(function (i) {
            i.fadeOut(function () {
              e.remove(i)
            }, n.hostModel)
          })
        : e.removeAll()
    }),
    r
  )
})()
const Cv = plt
function SG(r, t, e) {
  var n = r.getBaseAxis(),
    i = r.getOtherAxis(n),
    a = vlt(i, e),
    o = n.dim,
    s = i.dim,
    l = t.mapDimension(s),
    u = t.mapDimension(o),
    c = s === 'x' || s === 'radius' ? 1 : 0,
    h = st(r.dimensions, function (p) {
      return t.mapDimension(p)
    }),
    f = !1,
    d = t.getCalculationInfo('stackResultDimension')
  return (
    sl(t, h[0]) && ((f = !0), (h[0] = d)),
    sl(t, h[1]) && ((f = !0), (h[1] = d)),
    {
      dataDimsForPoint: h,
      valueStart: a,
      valueAxisDim: s,
      baseAxisDim: o,
      stacked: !!f,
      valueDim: l,
      baseDim: u,
      baseDataOffset: c,
      stackedOverDimension: t.getCalculationInfo('stackedOverDimension'),
    }
  )
}
function vlt(r, t) {
  var e = 0,
    n = r.scale.getExtent()
  return (
    t === 'start'
      ? (e = n[0])
      : t === 'end'
      ? (e = n[1])
      : be(t) && !isNaN(t)
      ? (e = t)
      : n[0] > 0
      ? (e = n[0])
      : n[1] < 0 && (e = n[1]),
    e
  )
}
function AG(r, t, e, n) {
  var i = NaN
  r.stacked && (i = e.get(e.getCalculationInfo('stackedOverDimension'), n)),
    isNaN(i) && (i = r.valueStart)
  var a = r.baseDataOffset,
    o = []
  return (o[a] = e.get(r.baseDim, n)), (o[1 - a] = i), t.dataToPoint(o)
}
function glt(r, t) {
  var e = []
  return (
    t
      .diff(r)
      .add(function (n) {
        e.push({
          cmd: '+',
          idx: n,
        })
      })
      .update(function (n, i) {
        e.push({
          cmd: '=',
          idx: i,
          idx1: n,
        })
      })
      .remove(function (n) {
        e.push({
          cmd: '-',
          idx: n,
        })
      })
      .execute(),
    e
  )
}
function mlt(r, t, e, n, i, a, o, s) {
  for (
    var l = glt(r, t),
      u = [],
      c = [],
      h = [],
      f = [],
      d = [],
      p = [],
      g = [],
      v = SG(i, t, o),
      m = r.getLayout('points') || [],
      y = t.getLayout('points') || [],
      _ = 0;
    _ < l.length;
    _++
  ) {
    var x = l[_],
      A = !0,
      S = void 0,
      b = void 0
    switch (x.cmd) {
      case '=':
        ;(S = x.idx * 2), (b = x.idx1 * 2)
        var T = m[S],
          w = m[S + 1],
          M = y[b],
          C = y[b + 1]
        ;(isNaN(T) || isNaN(w)) && ((T = M), (w = C)),
          u.push(T, w),
          c.push(M, C),
          h.push(e[S], e[S + 1]),
          f.push(n[b], n[b + 1]),
          g.push(t.getRawIndex(x.idx1))
        break
      case '+':
        var E = x.idx,
          D = v.dataDimsForPoint,
          P = i.dataToPoint([t.get(D[0], E), t.get(D[1], E)])
        ;(b = E * 2), u.push(P[0], P[1]), c.push(y[b], y[b + 1])
        var L = AG(v, i, t, E)
        h.push(L[0], L[1]), f.push(n[b], n[b + 1]), g.push(t.getRawIndex(E))
        break
      case '-':
        A = !1
    }
    A && (d.push(x), p.push(p.length))
  }
  p.sort(function (Z, ft) {
    return g[Z] - g[ft]
  })
  for (
    var I = u.length, F = eo(I), k = eo(I), V = eo(I), H = eo(I), Y = [], _ = 0;
    _ < p.length;
    _++
  ) {
    var K = p[_],
      ut = _ * 2,
      W = K * 2
    ;(F[ut] = u[W]),
      (F[ut + 1] = u[W + 1]),
      (k[ut] = c[W]),
      (k[ut + 1] = c[W + 1]),
      (V[ut] = h[W]),
      (V[ut + 1] = h[W + 1]),
      (H[ut] = f[W]),
      (H[ut + 1] = f[W + 1]),
      (Y[_] = d[K])
  }
  return {
    current: F,
    next: k,
    stackedOnCurrent: V,
    stackedOnNext: H,
    status: Y,
  }
}
var As = Math.min,
  bs = Math.max
function Bu(r, t) {
  return isNaN(r) || isNaN(t)
}
function Lw(r, t, e, n, i, a, o, s, l) {
  for (var u, c, h, f, d, p, g = e, v = 0; v < n; v++) {
    var m = t[g * 2],
      y = t[g * 2 + 1]
    if (g >= i || g < 0) break
    if (Bu(m, y)) {
      if (l) {
        g += a
        continue
      }
      break
    }
    if (g === e) r[a > 0 ? 'moveTo' : 'lineTo'](m, y), (h = m), (f = y)
    else {
      var _ = m - u,
        x = y - c
      if (_ * _ + x * x < 0.5) {
        g += a
        continue
      }
      if (o > 0) {
        for (
          var A = g + a, S = t[A * 2], b = t[A * 2 + 1];
          S === m && b === y && v < n;

        )
          v++,
            (A += a),
            (g += a),
            (S = t[A * 2]),
            (b = t[A * 2 + 1]),
            (m = t[g * 2]),
            (y = t[g * 2 + 1]),
            (_ = m - u),
            (x = y - c)
        var T = v + 1
        if (l)
          for (; Bu(S, b) && T < n; )
            T++, (A += a), (S = t[A * 2]), (b = t[A * 2 + 1])
        var w = 0.5,
          M = 0,
          C = 0,
          E = void 0,
          D = void 0
        if (T >= n || Bu(S, b)) (d = m), (p = y)
        else {
          ;(M = S - u), (C = b - c)
          var P = m - u,
            L = S - m,
            I = y - c,
            F = b - y,
            k = void 0,
            V = void 0
          if (s === 'x') {
            ;(k = Math.abs(P)), (V = Math.abs(L))
            var H = M > 0 ? 1 : -1
            ;(d = m - H * k * o), (p = y), (E = m + H * V * o), (D = y)
          } else if (s === 'y') {
            ;(k = Math.abs(I)), (V = Math.abs(F))
            var Y = C > 0 ? 1 : -1
            ;(d = m), (p = y - Y * k * o), (E = m), (D = y + Y * V * o)
          } else
            (k = Math.sqrt(P * P + I * I)),
              (V = Math.sqrt(L * L + F * F)),
              (w = V / (V + k)),
              (d = m - M * o * (1 - w)),
              (p = y - C * o * (1 - w)),
              (E = m + M * o * w),
              (D = y + C * o * w),
              (E = As(E, bs(S, m))),
              (D = As(D, bs(b, y))),
              (E = bs(E, As(S, m))),
              (D = bs(D, As(b, y))),
              (M = E - m),
              (C = D - y),
              (d = m - (M * k) / V),
              (p = y - (C * k) / V),
              (d = As(d, bs(u, m))),
              (p = As(p, bs(c, y))),
              (d = bs(d, As(u, m))),
              (p = bs(p, As(c, y))),
              (M = m - d),
              (C = y - p),
              (E = m + (M * V) / k),
              (D = y + (C * V) / k)
        }
        r.bezierCurveTo(h, f, d, p, m, y), (h = E), (f = D)
      } else r.lineTo(m, y)
    }
    ;(u = m), (c = y), (g += a)
  }
  return v
}
var bG = (function () {
    function r() {
      ;(this.smooth = 0), (this.smoothConstraint = !0)
    }
    return r
  })(),
  ylt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'ec-polyline'), n
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new bG()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = 0,
          o = i.length / 2
        if (n.connectNulls) {
          for (; o > 0 && Bu(i[o * 2 - 2], i[o * 2 - 1]); o--);
          for (; a < o && Bu(i[a * 2], i[a * 2 + 1]); a++);
        }
        for (; a < o; )
          a +=
            Lw(e, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1
      }),
      (t.prototype.getPointOn = function (e, n) {
        this.path ||
          (this.createPathProxy(), this.buildPath(this.path, this.shape))
        for (
          var i = this.path,
            a = i.data,
            o = vo.CMD,
            s,
            l,
            u = n === 'x',
            c = [],
            h = 0;
          h < a.length;

        ) {
          var f = a[h++],
            d = void 0,
            p = void 0,
            g = void 0,
            v = void 0,
            m = void 0,
            y = void 0,
            _ = void 0
          switch (f) {
            case o.M:
              ;(s = a[h++]), (l = a[h++])
              break
            case o.L:
              if (
                ((d = a[h++]),
                (p = a[h++]),
                (_ = u ? (e - s) / (d - s) : (e - l) / (p - l)),
                _ <= 1 && _ >= 0)
              ) {
                var x = u ? (p - l) * _ + l : (d - s) * _ + s
                return u ? [e, x] : [x, e]
              }
              ;(s = d), (l = p)
              break
            case o.C:
              ;(d = a[h++]),
                (p = a[h++]),
                (g = a[h++]),
                (v = a[h++]),
                (m = a[h++]),
                (y = a[h++])
              var A = u ? Fy(s, d, g, m, e, c) : Fy(l, p, v, y, e, c)
              if (A > 0)
                for (var S = 0; S < A; S++) {
                  var b = c[S]
                  if (b <= 1 && b >= 0) {
                    var x = u ? Wn(l, p, v, y, b) : Wn(s, d, g, m, b)
                    return u ? [e, x] : [x, e]
                  }
                }
              ;(s = m), (l = y)
              break
          }
        }
      }),
      t
    )
  })(oe),
  _lt = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return t
  })(bG),
  wG = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'ec-polygon'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new _lt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = n.stackedOnPoints,
          o = 0,
          s = i.length / 2,
          l = n.smoothMonotone
        if (n.connectNulls) {
          for (; s > 0 && Bu(i[s * 2 - 2], i[s * 2 - 1]); s--);
          for (; o < s && Bu(i[o * 2], i[o * 2 + 1]); o++);
        }
        for (; o < s; ) {
          var u = Lw(e, i, o, s, s, 1, n.smooth, l, n.connectNulls)
          Lw(e, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls),
            (o += u + 1),
            e.closePath()
        }
      }),
      t
    )
  })(oe)
function MG(r, t, e, n, i) {
  var a = r.getArea(),
    o = a.x,
    s = a.y,
    l = a.width,
    u = a.height,
    c = e.get(['lineStyle', 'width']) || 2
  ;(o -= c / 2),
    (s -= c / 2),
    (l += c),
    (u += c),
    (l = Math.ceil(l)),
    o !== Math.floor(o) && ((o = Math.floor(o)), l++)
  var h = new ge({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u,
    },
  })
  if (t) {
    var f = r.getBaseAxis(),
      d = f.isHorizontal(),
      p = f.inverse
    d
      ? (p && (h.shape.x += l), (h.shape.width = 0))
      : (p || (h.shape.y += u), (h.shape.height = 0))
    var g = Nt(i)
      ? function (v) {
          i(v, h)
        }
      : null
    Je(
      h,
      {
        shape: {
          width: l,
          height: u,
          x: o,
          y: s,
        },
      },
      e,
      null,
      n,
      g,
    )
  }
  return h
}
function TG(r, t, e) {
  var n = r.getArea(),
    i = mn(n.r0, 1),
    a = mn(n.r, 1),
    o = new oi({
      shape: {
        cx: mn(r.cx, 1),
        cy: mn(r.cy, 1),
        r0: i,
        r: a,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise,
      },
    })
  if (t) {
    var s = r.getBaseAxis().dim === 'angle'
    s ? (o.shape.endAngle = n.startAngle) : (o.shape.r = i),
      Je(
        o,
        {
          shape: {
            endAngle: n.endAngle,
            r: a,
          },
        },
        e,
      )
  }
  return o
}
function Ev(r, t, e, n, i) {
  if (r) {
    if (r.type === 'polar') return TG(r, t, e)
    if (r.type === 'cartesian2d') return MG(r, t, e, n, i)
  } else return null
  return null
}
function oc(r, t) {
  return r.type === t
}
function LI(r, t) {
  if (r.length === t.length) {
    for (var e = 0; e < r.length; e++) if (r[e] !== t[e]) return
    return !0
  }
}
function PI(r) {
  for (
    var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0;
    a < r.length;

  ) {
    var o = r[a++],
      s = r[a++]
    isNaN(o) || ((t = Math.min(o, t)), (n = Math.max(o, n))),
      isNaN(s) || ((e = Math.min(s, e)), (i = Math.max(s, i)))
  }
  return [
    [t, e],
    [n, i],
  ]
}
function RI(r, t) {
  var e = PI(r),
    n = e[0],
    i = e[1],
    a = PI(t),
    o = a[0],
    s = a[1]
  return Math.max(
    Math.abs(n[0] - o[0]),
    Math.abs(n[1] - o[1]),
    Math.abs(i[0] - s[0]),
    Math.abs(i[1] - s[1]),
  )
}
function II(r) {
  return be(r) ? r : r ? 0.5 : 0
}
function xlt(r, t, e) {
  if (!e.valueDim) return []
  for (var n = t.count(), i = eo(n * 2), a = 0; a < n; a++) {
    var o = AG(e, r, t, a)
    ;(i[a * 2] = o[0]), (i[a * 2 + 1] = o[1])
  }
  return i
}
function ws(r, t, e, n) {
  var i = t.getBaseAxis(),
    a = i.dim === 'x' || i.dim === 'radius' ? 0 : 1,
    o = [],
    s = 0,
    l = [],
    u = [],
    c = [],
    h = []
  if (n) {
    for (s = 0; s < r.length; s += 2)
      !isNaN(r[s]) && !isNaN(r[s + 1]) && h.push(r[s], r[s + 1])
    r = h
  }
  for (s = 0; s < r.length - 2; s += 2)
    switch (
      ((c[0] = r[s + 2]),
      (c[1] = r[s + 3]),
      (u[0] = r[s]),
      (u[1] = r[s + 1]),
      o.push(u[0], u[1]),
      e)
    ) {
      case 'end':
        ;(l[a] = c[a]), (l[1 - a] = u[1 - a]), o.push(l[0], l[1])
        break
      case 'middle':
        var f = (u[a] + c[a]) / 2,
          d = []
        ;(l[a] = d[a] = f),
          (l[1 - a] = u[1 - a]),
          (d[1 - a] = c[1 - a]),
          o.push(l[0], l[1]),
          o.push(d[0], d[1])
        break
      default:
        ;(l[a] = u[a]), (l[1 - a] = c[1 - a]), o.push(l[0], l[1])
    }
  return o.push(r[s++], r[s++]), o
}
function Slt(r, t) {
  var e = [],
    n = r.length,
    i,
    a
  function o(c, h, f) {
    var d = c.coord,
      p = (f - d) / (h.coord - d),
      g = DQ(p, [c.color, h.color])
    return {
      coord: f,
      color: g,
    }
  }
  for (var s = 0; s < n; s++) {
    var l = r[s],
      u = l.coord
    if (u < 0) i = l
    else if (u > t) {
      a ? e.push(o(a, l, t)) : i && e.push(o(i, l, 0), o(i, l, t))
      break
    } else i && (e.push(o(i, l, 0)), (i = null)), e.push(l), (a = l)
  }
  return e
}
function Alt(r, t, e) {
  var n = r.getVisual('visualMeta')
  if (!(!n || !n.length || !r.count()) && t.type === 'cartesian2d') {
    for (var i, a, o = n.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(n[o].dimension)
      if (((i = s && s.coordDim), i === 'x' || i === 'y')) {
        a = n[o]
        break
      }
    }
    if (a) {
      var l = t.getAxis(i),
        u = st(a.stops, function (_) {
          return {
            coord: l.toGlobalCoord(l.dataToCoord(_.value)),
            color: _.color,
          }
        }),
        c = u.length,
        h = a.outerColors.slice()
      c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse())
      var f = Slt(u, i === 'x' ? e.getWidth() : e.getHeight()),
        d = f.length
      if (!d && c)
        return u[0].coord < 0
          ? h[1]
            ? h[1]
            : u[c - 1].color
          : h[0]
          ? h[0]
          : u[0].color
      var p = 10,
        g = f[0].coord - p,
        v = f[d - 1].coord + p,
        m = v - g
      if (m < 0.001) return 'transparent'
      R(f, function (_) {
        _.offset = (_.coord - g) / m
      }),
        f.push({
          offset: d ? f[d - 1].offset : 0.5,
          color: h[1] || 'transparent',
        }),
        f.unshift({
          offset: d ? f[0].offset : 0.5,
          color: h[0] || 'transparent',
        })
      var y = new He(0, 0, 0, 0, f, !0)
      return (y[i] = g), (y[i + '2'] = v), y
    }
  }
}
function blt(r, t, e) {
  var n = r.get('showAllSymbol'),
    i = n === 'auto'
  if (!(n && !i)) {
    var a = e.getAxesByScale('ordinal')[0]
    if (a && !(i && wlt(a, t))) {
      var o = t.mapDimension(a.dim),
        s = {}
      return (
        R(a.getViewLabels(), function (l) {
          var u = a.scale.getRawOrdinalNumber(l.tickValue)
          s[u] = 1
        }),
        function (l) {
          return !s.hasOwnProperty(t.get(o, l))
        }
      )
    }
  }
}
function wlt(r, t) {
  var e = r.getExtent(),
    n = Math.abs(e[1] - e[0]) / r.scale.count()
  isNaN(n) && (n = 0)
  for (
    var i = t.count(), a = Math.max(1, Math.round(i / 5)), o = 0;
    o < i;
    o += a
  )
    if (Tv.getSymbolSize(t, o)[r.isHorizontal() ? 1 : 0] * 1.5 > n) return !1
  return !0
}
function Mlt(r, t) {
  return isNaN(r) || isNaN(t)
}
function Tlt(r) {
  for (var t = r.length / 2; t > 0 && Mlt(r[t * 2 - 2], r[t * 2 - 1]); t--);
  return t - 1
}
function OI(r, t) {
  return [r[t * 2], r[t * 2 + 1]]
}
function Clt(r, t, e) {
  for (
    var n = r.length / 2, i = e === 'x' ? 0 : 1, a, o, s = 0, l = -1, u = 0;
    u < n;
    u++
  )
    if (((o = r[u * 2 + i]), !(isNaN(o) || isNaN(r[u * 2 + 1 - i])))) {
      if (u === 0) {
        a = o
        continue
      }
      if ((a <= t && o >= t) || (a >= t && o <= t)) {
        l = u
        break
      }
      ;(s = u), (a = o)
    }
  return {
    range: [s, l],
    t: (t - a) / (o - a),
  }
}
function CG(r) {
  if (r.get(['endLabel', 'show'])) return !0
  for (var t = 0; t < Hr.length; t++)
    if (r.get([Hr[t], 'endLabel', 'show'])) return !0
  return !1
}
function nS(r, t, e, n) {
  if (oc(t, 'cartesian2d')) {
    var i = n.getModel('endLabel'),
      a = i.get('valueAnimation'),
      o = n.getData(),
      s = {
        lastFrameIndex: 0,
      },
      l = CG(n)
        ? function (d, p) {
            r._endLabelOnDuring(d, p, o, s, a, i, t)
          }
        : null,
      u = t.getBaseAxis().isHorizontal(),
      c = MG(
        t,
        e,
        n,
        function () {
          var d = r._endLabel
          d &&
            e &&
            s.originalX != null &&
            d.attr({
              x: s.originalX,
              y: s.originalY,
            })
        },
        l,
      )
    if (!n.get('clip', !0)) {
      var h = c.shape,
        f = Math.max(h.width, h.height)
      u ? ((h.y -= f), (h.height += f * 2)) : ((h.x -= f), (h.width += f * 2))
    }
    return l && l(1, c), c
  } else return TG(t, e, n)
}
function Elt(r, t) {
  var e = t.getBaseAxis(),
    n = e.isHorizontal(),
    i = e.inverse,
    a = n ? (i ? 'right' : 'left') : 'center',
    o = n ? 'middle' : i ? 'top' : 'bottom'
  return {
    normal: {
      align: r.get('align') || a,
      verticalAlign: r.get('verticalAlign') || o,
    },
  }
}
var Dlt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.init = function () {
      var e = new Ht(),
        n = new Cv()
      this.group.add(n.group), (this._symbolDraw = n), (this._lineGroup = e)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = this,
        o = e.coordinateSystem,
        s = this.group,
        l = e.getData(),
        u = e.getModel('lineStyle'),
        c = e.getModel('areaStyle'),
        h = l.getLayout('points') || [],
        f = o.type === 'polar',
        d = this._coordSys,
        p = this._symbolDraw,
        g = this._polyline,
        v = this._polygon,
        m = this._lineGroup,
        y = !n.ssr && e.get('animation'),
        _ = !c.isEmpty(),
        x = c.get('origin'),
        A = SG(o, l, x),
        S = _ && xlt(o, l, A),
        b = e.get('showSymbol'),
        T = e.get('connectNulls'),
        w = b && !f && blt(e, l, o),
        M = this._data
      M &&
        M.eachItemGraphicEl(function (ft, lt) {
          ft.__temp && (s.remove(ft), M.setItemGraphicEl(lt, null))
        }),
        b || p.remove(),
        s.add(m)
      var C = f ? !1 : e.get('step'),
        E
      o &&
        o.getArea &&
        e.get('clip', !0) &&
        ((E = o.getArea()),
        E.width != null
          ? ((E.x -= 0.1), (E.y -= 0.1), (E.width += 0.2), (E.height += 0.2))
          : E.r0 && ((E.r0 -= 0.5), (E.r += 0.5))),
        (this._clipShapeForSymbol = E)
      var D = Alt(l, o, i) || l.getVisual('style')[l.getVisual('drawType')]
      if (!(g && d.type === o.type && C === this._step))
        b &&
          p.updateData(l, {
            isIgnore: w,
            clipShape: E,
            disableAnimation: !0,
            getSymbolPoint: function (ft) {
              return [h[ft * 2], h[ft * 2 + 1]]
            },
          }),
          y && this._initSymbolLabelAnimation(l, o, E),
          C && ((h = ws(h, o, C, T)), S && (S = ws(S, o, C, T))),
          (g = this._newPolyline(h)),
          _
            ? (v = this._newPolygon(h, S))
            : v && (m.remove(v), (v = this._polygon = null)),
          f || this._initOrUpdateEndLabel(e, o, Zu(D)),
          m.setClipPath(nS(this, o, !0, e))
      else {
        _ && !v
          ? (v = this._newPolygon(h, S))
          : v && !_ && (m.remove(v), (v = this._polygon = null)),
          f || this._initOrUpdateEndLabel(e, o, Zu(D))
        var P = m.getClipPath()
        if (P) {
          var L = nS(this, o, !1, e)
          Je(
            P,
            {
              shape: L.shape,
            },
            e,
          )
        } else m.setClipPath(nS(this, o, !0, e))
        b &&
          p.updateData(l, {
            isIgnore: w,
            clipShape: E,
            disableAnimation: !0,
            getSymbolPoint: function (ft) {
              return [h[ft * 2], h[ft * 2 + 1]]
            },
          }),
          (!LI(this._stackedOnPoints, S) || !LI(this._points, h)) &&
            (y
              ? this._doUpdateAnimation(l, S, o, i, C, x, T)
              : (C && ((h = ws(h, o, C, T)), S && (S = ws(S, o, C, T))),
                g.setShape({
                  points: h,
                }),
                v &&
                  v.setShape({
                    points: h,
                    stackedOnPoints: S,
                  })))
      }
      var I = e.getModel('emphasis'),
        F = I.get('focus'),
        k = I.get('blurScope'),
        V = I.get('disabled')
      if (
        (g.useStyle(
          zt(u.getLineStyle(), {
            fill: 'none',
            stroke: D,
            lineJoin: 'bevel',
          }),
        ),
        gr(g, e, 'lineStyle'),
        g.style.lineWidth > 0 &&
          e.get(['emphasis', 'lineStyle', 'width']) === 'bolder')
      ) {
        var H = g.getState('emphasis').style
        H.lineWidth = +g.style.lineWidth + 1
      }
      ;(Wt(g).seriesIndex = e.seriesIndex), fn(g, F, k, V)
      var Y = II(e.get('smooth')),
        K = e.get('smoothMonotone')
      if (
        (g.setShape({
          smooth: Y,
          smoothMonotone: K,
          connectNulls: T,
        }),
        v)
      ) {
        var ut = l.getCalculationInfo('stackedOnSeries'),
          W = 0
        v.useStyle(
          zt(c.getAreaStyle(), {
            fill: D,
            opacity: 0.7,
            lineJoin: 'bevel',
            decal: l.getVisual('style').decal,
          }),
        ),
          ut && (W = II(ut.get('smooth'))),
          v.setShape({
            smooth: Y,
            stackedOnSmooth: W,
            smoothMonotone: K,
            connectNulls: T,
          }),
          gr(v, e, 'areaStyle'),
          (Wt(v).seriesIndex = e.seriesIndex),
          fn(v, F, k, V)
      }
      var Z = function (ft) {
        a._changePolyState(ft)
      }
      l.eachItemGraphicEl(function (ft) {
        ft && (ft.onHoverStateChange = Z)
      }),
        (this._polyline.onHoverStateChange = Z),
        (this._data = l),
        (this._coordSys = o),
        (this._stackedOnPoints = S),
        (this._points = h),
        (this._step = C),
        (this._valueOrigin = x),
        e.get('triggerLineEvent') &&
          (this.packEventData(e, g), v && this.packEventData(e, v))
    }),
    (t.prototype.packEventData = function (e, n) {
      Wt(n).eventData = {
        componentType: 'series',
        componentSubType: 'line',
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: 'line',
      }
    }),
    (t.prototype.highlight = function (e, n, i, a) {
      var o = e.getData(),
        s = Yu(o, a)
      if (
        (this._changePolyState('emphasis'),
        !(s instanceof Array) && s != null && s >= 0)
      ) {
        var l = o.getLayout('points'),
          u = o.getItemGraphicEl(s)
        if (!u) {
          var c = l[s * 2],
            h = l[s * 2 + 1]
          if (
            isNaN(c) ||
            isNaN(h) ||
            (this._clipShapeForSymbol &&
              !this._clipShapeForSymbol.contain(c, h))
          )
            return
          var f = e.get('zlevel') || 0,
            d = e.get('z') || 0
          ;(u = new Tv(o, s)), (u.x = c), (u.y = h), u.setZ(f, d)
          var p = u.getSymbolPath().getTextContent()
          p && ((p.zlevel = f), (p.z = d), (p.z2 = this._polyline.z2 + 1)),
            (u.__temp = !0),
            o.setItemGraphicEl(s, u),
            u.stopSymbolAnimation(!0),
            this.group.add(u)
        }
        u.highlight()
      } else Ze.prototype.highlight.call(this, e, n, i, a)
    }),
    (t.prototype.downplay = function (e, n, i, a) {
      var o = e.getData(),
        s = Yu(o, a)
      if ((this._changePolyState('normal'), s != null && s >= 0)) {
        var l = o.getItemGraphicEl(s)
        l &&
          (l.__temp
            ? (o.setItemGraphicEl(s, null), this.group.remove(l))
            : l.downplay())
      } else Ze.prototype.downplay.call(this, e, n, i, a)
    }),
    (t.prototype._changePolyState = function (e) {
      var n = this._polygon
      Xy(this._polyline, e), n && Xy(n, e)
    }),
    (t.prototype._newPolyline = function (e) {
      var n = this._polyline
      return (
        n && this._lineGroup.remove(n),
        (n = new ylt({
          shape: {
            points: e,
          },
          segmentIgnoreThreshold: 2,
          z2: 10,
        })),
        this._lineGroup.add(n),
        (this._polyline = n),
        n
      )
    }),
    (t.prototype._newPolygon = function (e, n) {
      var i = this._polygon
      return (
        i && this._lineGroup.remove(i),
        (i = new wG({
          shape: {
            points: e,
            stackedOnPoints: n,
          },
          segmentIgnoreThreshold: 2,
        })),
        this._lineGroup.add(i),
        (this._polygon = i),
        i
      )
    }),
    (t.prototype._initSymbolLabelAnimation = function (e, n, i) {
      var a,
        o,
        s = n.getBaseAxis(),
        l = s.inverse
      n.type === 'cartesian2d'
        ? ((a = s.isHorizontal()), (o = !1))
        : n.type === 'polar' && ((a = s.dim === 'angle'), (o = !0))
      var u = e.hostModel,
        c = u.get('animationDuration')
      Nt(c) && (c = c(null))
      var h = u.get('animationDelay') || 0,
        f = Nt(h) ? h(null) : h
      e.eachItemGraphicEl(function (d, p) {
        var g = d
        if (g) {
          var v = [d.x, d.y],
            m = void 0,
            y = void 0,
            _ = void 0
          if (i)
            if (o) {
              var x = i,
                A = n.pointToCoord(v)
              a
                ? ((m = x.startAngle),
                  (y = x.endAngle),
                  (_ = (-A[1] / 180) * Math.PI))
                : ((m = x.r0), (y = x.r), (_ = A[0]))
            } else {
              var S = i
              a
                ? ((m = S.x), (y = S.x + S.width), (_ = d.x))
                : ((m = S.y + S.height), (y = S.y), (_ = d.y))
            }
          var b = y === m ? 0 : (_ - m) / (y - m)
          l && (b = 1 - b)
          var T = Nt(h) ? h(p) : c * b + f,
            w = g.getSymbolPath(),
            M = w.getTextContent()
          g.attr({
            scaleX: 0,
            scaleY: 0,
          }),
            g.animateTo(
              {
                scaleX: 1,
                scaleY: 1,
              },
              {
                duration: 200,
                setToFinal: !0,
                delay: T,
              },
            ),
            M &&
              M.animateFrom(
                {
                  style: {
                    opacity: 0,
                  },
                },
                {
                  duration: 300,
                  delay: T,
                },
              ),
            (w.disableLabelAnimation = !0)
        }
      })
    }),
    (t.prototype._initOrUpdateEndLabel = function (e, n, i) {
      var a = e.getModel('endLabel')
      if (CG(e)) {
        var o = e.getData(),
          s = this._polyline,
          l = o.getLayout('points')
        if (!l) {
          s.removeTextContent(), (this._endLabel = null)
          return
        }
        var u = this._endLabel
        u ||
          ((u = this._endLabel =
            new Ae({
              z2: 200,
            })),
          (u.ignoreClip = !0),
          s.setTextContent(this._endLabel),
          (s.disableLabelAnimation = !0))
        var c = Tlt(l)
        c >= 0 &&
          (mr(
            s,
            Zn(e, 'endLabel'),
            {
              inheritColor: i,
              labelFetcher: e,
              labelDataIndex: c,
              defaultText: function (h, f, d) {
                return d != null ? xG(o, d) : of(o, h)
              },
              enableTextSetter: !0,
            },
            Elt(a, n),
          ),
          (s.textConfig.position = null))
      } else
        this._endLabel &&
          (this._polyline.removeTextContent(), (this._endLabel = null))
    }),
    (t.prototype._endLabelOnDuring = function (e, n, i, a, o, s, l) {
      var u = this._endLabel,
        c = this._polyline
      if (u) {
        e < 1 &&
          a.originalX == null &&
          ((a.originalX = u.x), (a.originalY = u.y))
        var h = i.getLayout('points'),
          f = i.hostModel,
          d = f.get('connectNulls'),
          p = s.get('precision'),
          g = s.get('distance') || 0,
          v = l.getBaseAxis(),
          m = v.isHorizontal(),
          y = v.inverse,
          _ = n.shape,
          x = y ? (m ? _.x : _.y + _.height) : m ? _.x + _.width : _.y,
          A = (m ? g : 0) * (y ? -1 : 1),
          S = (m ? 0 : -g) * (y ? -1 : 1),
          b = m ? 'x' : 'y',
          T = Clt(h, x, b),
          w = T.range,
          M = w[1] - w[0],
          C = void 0
        if (M >= 1) {
          if (M > 1 && !d) {
            var E = OI(h, w[0])
            u.attr({
              x: E[0] + A,
              y: E[1] + S,
            }),
              o && (C = f.getRawValue(w[0]))
          } else {
            var E = c.getPointOn(x, b)
            E &&
              u.attr({
                x: E[0] + A,
                y: E[1] + S,
              })
            var D = f.getRawValue(w[0]),
              P = f.getRawValue(w[1])
            o && (C = Yz(i, p, D, P, T.t))
          }
          a.lastFrameIndex = w[0]
        } else {
          var L = e === 1 || a.lastFrameIndex > 0 ? w[0] : 0,
            E = OI(h, L)
          o && (C = f.getRawValue(L)),
            u.attr({
              x: E[0] + A,
              y: E[1] + S,
            })
        }
        if (o) {
          var I = Af(u)
          typeof I.setLabelText == 'function' && I.setLabelText(C)
        }
      }
    }),
    (t.prototype._doUpdateAnimation = function (e, n, i, a, o, s, l) {
      var u = this._polyline,
        c = this._polygon,
        h = e.hostModel,
        f = mlt(
          this._data,
          e,
          this._stackedOnPoints,
          n,
          this._coordSys,
          i,
          this._valueOrigin,
        ),
        d = f.current,
        p = f.stackedOnCurrent,
        g = f.next,
        v = f.stackedOnNext
      if (
        (o &&
          ((d = ws(f.current, i, o, l)),
          (p = ws(f.stackedOnCurrent, i, o, l)),
          (g = ws(f.next, i, o, l)),
          (v = ws(f.stackedOnNext, i, o, l))),
        RI(d, g) > 3e3 || (c && RI(p, v) > 3e3))
      ) {
        u.stopAnimation(),
          u.setShape({
            points: g,
          }),
          c &&
            (c.stopAnimation(),
            c.setShape({
              points: g,
              stackedOnPoints: v,
            }))
        return
      }
      ;(u.shape.__points = f.current), (u.shape.points = d)
      var m = {
        shape: {
          points: g,
        },
      }
      f.current !== d && (m.shape.__points = f.next),
        u.stopAnimation(),
        we(u, m, h),
        c &&
          (c.setShape({
            points: d,
            stackedOnPoints: p,
          }),
          c.stopAnimation(),
          we(
            c,
            {
              shape: {
                stackedOnPoints: v,
              },
            },
            h,
          ),
          u.shape.points !== c.shape.points &&
            (c.shape.points = u.shape.points))
      for (var y = [], _ = f.status, x = 0; x < _.length; x++) {
        var A = _[x].cmd
        if (A === '=') {
          var S = e.getItemGraphicEl(_[x].idx1)
          S &&
            y.push({
              el: S,
              ptIdx: x,
            })
        }
      }
      u.animators &&
        u.animators.length &&
        u.animators[0].during(function () {
          c && c.dirtyShape()
          for (var b = u.shape.__points, T = 0; T < y.length; T++) {
            var w = y[T].el,
              M = y[T].ptIdx * 2
            ;(w.x = b[M]), (w.y = b[M + 1]), w.markRedraw()
          }
        })
    }),
    (t.prototype.remove = function (e) {
      var n = this.group,
        i = this._data
      this._lineGroup.removeAll(),
        this._symbolDraw.remove(!0),
        i &&
          i.eachItemGraphicEl(function (a, o) {
            a.__temp && (n.remove(a), i.setItemGraphicEl(o, null))
          }),
        (this._polyline =
          this._polygon =
          this._coordSys =
          this._points =
          this._stackedOnPoints =
          this._endLabel =
          this._data =
            null)
    }),
    (t.type = 'line'),
    t
  )
})(Ze)
const Llt = Dlt
function Dv(r, t) {
  return {
    seriesType: r,
    plan: Ef(),
    reset: function (e) {
      var n = e.getData(),
        i = e.coordinateSystem,
        a = e.pipelineContext,
        o = t || a.large
      if (i) {
        var s = st(i.dimensions, function (d) {
            return n.mapDimension(d)
          }).slice(0, 2),
          l = s.length,
          u = n.getCalculationInfo('stackResultDimension')
        sl(n, s[0]) && (s[0] = u), sl(n, s[1]) && (s[1] = u)
        var c = n.getStore(),
          h = n.getDimensionIndex(s[0]),
          f = n.getDimensionIndex(s[1])
        return (
          l && {
            progress: function (d, p) {
              for (
                var g = d.end - d.start,
                  v = o && eo(g * l),
                  m = [],
                  y = [],
                  _ = d.start,
                  x = 0;
                _ < d.end;
                _++
              ) {
                var A = void 0
                if (l === 1) {
                  var S = c.get(h, _)
                  A = i.dataToPoint(S, null, y)
                } else
                  (m[0] = c.get(h, _)),
                    (m[1] = c.get(f, _)),
                    (A = i.dataToPoint(m, null, y))
                o
                  ? ((v[x++] = A[0]), (v[x++] = A[1]))
                  : p.setItemLayout(_, A.slice())
              }
              o && p.setLayout('points', v)
            },
          }
        )
      }
    },
  }
}
var Plt = {
    average: function (r) {
      for (var t = 0, e = 0, n = 0; n < r.length; n++)
        isNaN(r[n]) || ((t += r[n]), e++)
      return e === 0 ? NaN : t / e
    },
    sum: function (r) {
      for (var t = 0, e = 0; e < r.length; e++) t += r[e] || 0
      return t
    },
    max: function (r) {
      for (var t = -1 / 0, e = 0; e < r.length; e++) r[e] > t && (t = r[e])
      return isFinite(t) ? t : NaN
    },
    min: function (r) {
      for (var t = 1 / 0, e = 0; e < r.length; e++) r[e] < t && (t = r[e])
      return isFinite(t) ? t : NaN
    },
    minmax: function (r) {
      for (var t = -1 / 0, e = -1 / 0, n = 0; n < r.length; n++) {
        var i = r[n],
          a = Math.abs(i)
        a > t && ((t = a), (e = i))
      }
      return isFinite(e) ? e : NaN
    },
    nearest: function (r) {
      return r[0]
    },
  },
  Rlt = function (r) {
    return Math.round(r.length / 2)
  }
function EG(r) {
  return {
    seriesType: r,
    reset: function (t, e, n) {
      var i = t.getData(),
        a = t.get('sampling'),
        o = t.coordinateSystem,
        s = i.count()
      if (s > 10 && o.type === 'cartesian2d' && a) {
        var l = o.getBaseAxis(),
          u = o.getOtherAxis(l),
          c = l.getExtent(),
          h = n.getDevicePixelRatio(),
          f = Math.abs(c[1] - c[0]) * (h || 1),
          d = Math.round(s / f)
        if (isFinite(d) && d > 1) {
          a === 'lttb' &&
            t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d))
          var p = void 0
          bt(a) ? (p = Plt[a]) : Nt(a) && (p = a),
            p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, Rlt))
        }
      }
    },
  }
}
function Ilt(r) {
  r.registerChartView(Llt),
    r.registerSeriesModel(hlt),
    r.registerLayout(Dv('line', !0)),
    r.registerVisual({
      seriesType: 'line',
      reset: function (t) {
        var e = t.getData(),
          n = t.getModel('lineStyle').getLineStyle()
        n && !n.stroke && (n.stroke = e.getVisual('style').fill),
          e.setVisual('legendLineStyle', n)
      },
    }),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, EG('line'))
}
var DG = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getMarkerPosition = function (e, n, i) {
      var a = this.coordinateSystem
      if (a && a.clampData) {
        var o = a.clampData(e),
          s = a.dataToPoint(o)
        if (i)
          R(a.getAxes(), function (f, d) {
            if (f.type === 'category' && n != null) {
              var p = f.getTicksCoords(),
                g = f.getTickModel().get('alignWithLabel'),
                v = o[d],
                m = n[d] === 'x1' || n[d] === 'y1'
              if ((m && !g && (v += 1), p.length < 2)) return
              if (p.length === 2) {
                s[d] = f.toGlobalCoord(f.getExtent()[m ? 1 : 0])
                return
              }
              for (
                var y = void 0, _ = void 0, x = 1, A = 0;
                A < p.length;
                A++
              ) {
                var S = p[A].coord,
                  b =
                    A === p.length - 1 ? p[A - 1].tickValue + x : p[A].tickValue
                if (b === v) {
                  _ = S
                  break
                } else if (b < v) y = S
                else if (y != null && b > v) {
                  _ = (S + y) / 2
                  break
                }
                A === 1 && (x = b - p[0].tickValue)
              }
              _ == null &&
                (y ? y && (_ = p[p.length - 1].coord) : (_ = p[0].coord)),
                (s[d] = f.toGlobalCoord(_))
            }
          })
        else {
          var l = this.getData(),
            u = l.getLayout('offset'),
            c = l.getLayout('size'),
            h = a.getBaseAxis().isHorizontal() ? 0 : 1
          s[h] += u + c / 2
        }
        return s
      }
      return [NaN, NaN]
    }),
    (t.type = 'series.__base_bar__'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      barMinHeight: 0,
      barMinAngle: 0,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: 'mod',
    }),
    t
  )
})(rn)
rn.registerClass(DG)
const c0 = DG
var Olt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function () {
      return as(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get('realtimeSort', !0) || null,
      })
    }),
    (t.prototype.getProgressive = function () {
      return this.get('large') ? this.get('progressive') : !1
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.get('progressiveThreshold'),
        n = this.get('largeThreshold')
      return n > e && (e = n), e
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.rect(n.getItemLayout(e))
    }),
    (t.type = 'series.bar'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = gl(c0.defaultOption, {
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: 'rgba(180, 180, 180, 0.2)',
        borderColor: null,
        borderWidth: 0,
        borderType: 'solid',
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1,
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      realtimeSort: !1,
    })),
    t
  )
})(c0)
const Nlt = Olt
var klt = (function () {
    function r() {
      ;(this.cx = 0),
        (this.cy = 0),
        (this.r0 = 0),
        (this.r = 0),
        (this.startAngle = 0),
        (this.endAngle = Math.PI * 2),
        (this.clockwise = !0)
    }
    return r
  })(),
  Blt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'sausage'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new klt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.cx,
          a = n.cy,
          o = Math.max(n.r0 || 0, 0),
          s = Math.max(n.r, 0),
          l = (s - o) * 0.5,
          u = o + l,
          c = n.startAngle,
          h = n.endAngle,
          f = n.clockwise,
          d = Math.PI * 2,
          p = f ? h - c < d : c - h < d
        p || (c = h - (f ? d : -d))
        var g = Math.cos(c),
          v = Math.sin(c),
          m = Math.cos(h),
          y = Math.sin(h)
        p
          ? (e.moveTo(g * o + i, v * o + a),
            e.arc(g * u + i, v * u + a, l, -Math.PI + c, c, !f))
          : e.moveTo(g * s + i, v * s + a),
          e.arc(i, a, s, c, h, !f),
          e.arc(m * u + i, y * u + a, l, h - Math.PI * 2, h - Math.PI, !f),
          o !== 0 && e.arc(i, a, o, h, c, f)
      }),
      t
    )
  })(oe)
const h0 = Blt
function Flt(r, t) {
  t = t || {}
  var e = t.isRoundCap
  return function (n, i, a) {
    var o = i.position
    if (!o || o instanceof Array) return Hy(n, i, a)
    var s = r(o),
      l = i.distance != null ? i.distance : 5,
      u = this.shape,
      c = u.cx,
      h = u.cy,
      f = u.r,
      d = u.r0,
      p = (f + d) / 2,
      g = u.startAngle,
      v = u.endAngle,
      m = (g + v) / 2,
      y = e ? Math.abs(f - d) / 2 : 0,
      _ = Math.cos,
      x = Math.sin,
      A = c + f * _(g),
      S = h + f * x(g),
      b = 'left',
      T = 'top'
    switch (s) {
      case 'startArc':
        ;(A = c + (d - l) * _(m)),
          (S = h + (d - l) * x(m)),
          (b = 'center'),
          (T = 'top')
        break
      case 'insideStartArc':
        ;(A = c + (d + l) * _(m)),
          (S = h + (d + l) * x(m)),
          (b = 'center'),
          (T = 'bottom')
        break
      case 'startAngle':
        ;(A = c + p * _(g) + cm(g, l + y, !1)),
          (S = h + p * x(g) + hm(g, l + y, !1)),
          (b = 'right'),
          (T = 'middle')
        break
      case 'insideStartAngle':
        ;(A = c + p * _(g) + cm(g, -l + y, !1)),
          (S = h + p * x(g) + hm(g, -l + y, !1)),
          (b = 'left'),
          (T = 'middle')
        break
      case 'middle':
        ;(A = c + p * _(m)), (S = h + p * x(m)), (b = 'center'), (T = 'middle')
        break
      case 'endArc':
        ;(A = c + (f + l) * _(m)),
          (S = h + (f + l) * x(m)),
          (b = 'center'),
          (T = 'bottom')
        break
      case 'insideEndArc':
        ;(A = c + (f - l) * _(m)),
          (S = h + (f - l) * x(m)),
          (b = 'center'),
          (T = 'top')
        break
      case 'endAngle':
        ;(A = c + p * _(v) + cm(v, l + y, !0)),
          (S = h + p * x(v) + hm(v, l + y, !0)),
          (b = 'left'),
          (T = 'middle')
        break
      case 'insideEndAngle':
        ;(A = c + p * _(v) + cm(v, -l + y, !0)),
          (S = h + p * x(v) + hm(v, -l + y, !0)),
          (b = 'right'),
          (T = 'middle')
        break
      default:
        return Hy(n, i, a)
    }
    return (
      (n = n || {}),
      (n.x = A),
      (n.y = S),
      (n.align = b),
      (n.verticalAlign = T),
      n
    )
  }
}
function zlt(r, t, e, n) {
  if (be(n)) {
    r.setTextConfig({
      rotation: n,
    })
    return
  } else if (at(t)) {
    r.setTextConfig({
      rotation: 0,
    })
    return
  }
  var i = r.shape,
    a = i.clockwise ? i.startAngle : i.endAngle,
    o = i.clockwise ? i.endAngle : i.startAngle,
    s = (a + o) / 2,
    l,
    u = e(t)
  switch (u) {
    case 'startArc':
    case 'insideStartArc':
    case 'middle':
    case 'insideEndArc':
    case 'endArc':
      l = s
      break
    case 'startAngle':
    case 'insideStartAngle':
      l = a
      break
    case 'endAngle':
    case 'insideEndAngle':
      l = o
      break
    default:
      r.setTextConfig({
        rotation: 0,
      })
      return
  }
  var c = Math.PI * 1.5 - l
  u === 'middle' && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI),
    r.setTextConfig({
      rotation: c,
    })
}
function cm(r, t, e) {
  return t * Math.sin(r) * (e ? -1 : 1)
}
function hm(r, t, e) {
  return t * Math.cos(r) * (e ? 1 : -1)
}
function bu(r, t, e) {
  var n = r.get('borderRadius')
  if (n == null)
    return e
      ? {
          cornerRadius: 0,
        }
      : null
  at(n) || (n = [n, n, n, n])
  var i = Math.abs(t.r || 0 - t.r0 || 0)
  return {
    cornerRadius: st(n, function (a) {
      return Ta(a, i)
    }),
  }
}
var rS = Math.max,
  iS = Math.min
function Ult(r, t) {
  var e = r.getArea && r.getArea()
  if (oc(r, 'cartesian2d')) {
    var n = r.getBaseAxis()
    if (n.type !== 'category' || !n.onBand) {
      var i = t.getLayout('bandWidth')
      n.isHorizontal()
        ? ((e.x -= i), (e.width += i * 2))
        : ((e.y -= i), (e.height += i * 2))
    }
  }
  return e
}
var Vlt = (function (r) {
    X(t, r)
    function t() {
      var e = r.call(this) || this
      return (e.type = t.type), (e._isFirstFrame = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        ;(this._model = e),
          this._removeOnRenderedListener(i),
          this._updateDrawMode(e)
        var o = e.get('coordinateSystem')
        ;(o === 'cartesian2d' || o === 'polar') &&
          ((this._progressiveEls = null),
          this._isLargeDraw
            ? this._renderLarge(e, n, i)
            : this._renderNormal(e, n, i, a))
      }),
      (t.prototype.incrementalPrepareRender = function (e) {
        this._clear(), this._updateDrawMode(e), this._updateLargeClip(e)
      }),
      (t.prototype.incrementalRender = function (e, n) {
        ;(this._progressiveEls = []), this._incrementalRenderLarge(e, n)
      }),
      (t.prototype.eachRendered = function (e) {
        vl(this._progressiveEls || this.group, e)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var n = e.pipelineContext.large
        ;(this._isLargeDraw == null || n !== this._isLargeDraw) &&
          ((this._isLargeDraw = n), this._clear())
      }),
      (t.prototype._renderNormal = function (e, n, i, a) {
        var o = this.group,
          s = e.getData(),
          l = this._data,
          u = e.coordinateSystem,
          c = u.getBaseAxis(),
          h
        u.type === 'cartesian2d'
          ? (h = c.isHorizontal())
          : u.type === 'polar' && (h = c.dim === 'angle')
        var f = e.isAnimationEnabled() ? e : null,
          d = Glt(e, u)
        d && this._enableRealtimeSort(d, s, i)
        var p = e.get('clip', !0) || d,
          g = Ult(u, s)
        o.removeClipPath()
        var v = e.get('roundCap', !0),
          m = e.get('showBackground', !0),
          y = e.getModel('backgroundStyle'),
          _ = y.get('borderRadius') || 0,
          x = [],
          A = this._backgroundEls,
          S = a && a.isInitSort,
          b = a && a.type === 'changeAxisOrder'
        function T(C) {
          var E = fm[u.type](s, C),
            D = Zlt(u, h, E)
          return (
            D.useStyle(y.getItemStyle()),
            u.type === 'cartesian2d'
              ? D.setShape('r', _)
              : D.setShape('cornerRadius', _),
            (x[C] = D),
            D
          )
        }
        s.diff(l)
          .add(function (C) {
            var E = s.getItemModel(C),
              D = fm[u.type](s, C, E)
            if ((m && T(C), !(!s.hasValue(C) || !zI[u.type](D)))) {
              var P = !1
              p && (P = NI[u.type](g, D))
              var L = kI[u.type](e, s, C, D, h, f, c.model, !1, v)
              d && (L.forceLabelAnimation = !0),
                UI(L, s, C, E, D, e, h, u.type === 'polar'),
                S
                  ? L.attr({
                      shape: D,
                    })
                  : d
                  ? BI(d, f, L, D, C, h, !1, !1)
                  : Je(
                      L,
                      {
                        shape: D,
                      },
                      e,
                      C,
                    ),
                s.setItemGraphicEl(C, L),
                o.add(L),
                (L.ignore = P)
            }
          })
          .update(function (C, E) {
            var D = s.getItemModel(C),
              P = fm[u.type](s, C, D)
            if (m) {
              var L = void 0
              A.length === 0
                ? (L = T(E))
                : ((L = A[E]),
                  L.useStyle(y.getItemStyle()),
                  u.type === 'cartesian2d'
                    ? L.setShape('r', _)
                    : L.setShape('cornerRadius', _),
                  (x[C] = L))
              var I = fm[u.type](s, C),
                F = PG(h, I, u)
              we(
                L,
                {
                  shape: F,
                },
                f,
                C,
              )
            }
            var k = l.getItemGraphicEl(E)
            if (!s.hasValue(C) || !zI[u.type](P)) {
              o.remove(k)
              return
            }
            var V = !1
            if (
              (p && ((V = NI[u.type](g, P)), V && o.remove(k)),
              k ? Ca(k) : (k = kI[u.type](e, s, C, P, h, f, c.model, !!k, v)),
              d && (k.forceLabelAnimation = !0),
              b)
            ) {
              var H = k.getTextContent()
              if (H) {
                var Y = Af(H)
                Y.prevValue != null && (Y.prevValue = Y.value)
              }
            } else UI(k, s, C, D, P, e, h, u.type === 'polar')
            S
              ? k.attr({
                  shape: P,
                })
              : d
              ? BI(d, f, k, P, C, h, !0, b)
              : we(
                  k,
                  {
                    shape: P,
                  },
                  e,
                  C,
                  null,
                ),
              s.setItemGraphicEl(C, k),
              (k.ignore = V),
              o.add(k)
          })
          .remove(function (C) {
            var E = l.getItemGraphicEl(C)
            E && Xp(E, e, C)
          })
          .execute()
        var w = this._backgroundGroup || (this._backgroundGroup = new Ht())
        w.removeAll()
        for (var M = 0; M < x.length; ++M) w.add(x[M])
        o.add(w), (this._backgroundEls = x), (this._data = s)
      }),
      (t.prototype._renderLarge = function (e, n, i) {
        this._clear(), GI(e, this.group), this._updateLargeClip(e)
      }),
      (t.prototype._incrementalRenderLarge = function (e, n) {
        this._removeBackground(), GI(n, this.group, this._progressiveEls, !0)
      }),
      (t.prototype._updateLargeClip = function (e) {
        var n = e.get('clip', !0) && Ev(e.coordinateSystem, !1, e),
          i = this.group
        n ? i.setClipPath(n) : i.removeClipPath()
      }),
      (t.prototype._enableRealtimeSort = function (e, n, i) {
        var a = this
        if (n.count()) {
          var o = e.baseAxis
          if (this._isFirstFrame)
            this._dispatchInitSort(n, e, i), (this._isFirstFrame = !1)
          else {
            var s = function (l) {
              var u = n.getItemGraphicEl(l),
                c = u && u.shape
              return (c && Math.abs(o.isHorizontal() ? c.height : c.width)) || 0
            }
            ;(this._onRendered = function () {
              a._updateSortWithinSameData(n, s, o, i)
            }),
              i.getZr().on('rendered', this._onRendered)
          }
        }
      }),
      (t.prototype._dataSort = function (e, n, i) {
        var a = []
        return (
          e.each(e.mapDimension(n.dim), function (o, s) {
            var l = i(s)
            ;(l = l ?? NaN),
              a.push({
                dataIndex: s,
                mappedValue: l,
                ordinalNumber: o,
              })
          }),
          a.sort(function (o, s) {
            return s.mappedValue - o.mappedValue
          }),
          {
            ordinalNumbers: st(a, function (o) {
              return o.ordinalNumber
            }),
          }
        )
      }),
      (t.prototype._isOrderChangedWithinSameData = function (e, n, i) {
        for (
          var a = i.scale,
            o = e.mapDimension(i.dim),
            s = Number.MAX_VALUE,
            l = 0,
            u = a.getOrdinalMeta().categories.length;
          l < u;
          ++l
        ) {
          var c = e.rawIndexOf(o, a.getRawOrdinalNumber(l)),
            h = c < 0 ? Number.MIN_VALUE : n(e.indexOfRawIndex(c))
          if (h > s) return !0
          s = h
        }
        return !1
      }),
      (t.prototype._isOrderDifferentInView = function (e, n) {
        for (
          var i = n.scale,
            a = i.getExtent(),
            o = Math.max(0, a[0]),
            s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1);
          o <= s;
          ++o
        )
          if (e.ordinalNumbers[o] !== i.getRawOrdinalNumber(o)) return !0
      }),
      (t.prototype._updateSortWithinSameData = function (e, n, i, a) {
        if (this._isOrderChangedWithinSameData(e, n, i)) {
          var o = this._dataSort(e, i, n)
          this._isOrderDifferentInView(o, i) &&
            (this._removeOnRenderedListener(a),
            a.dispatchAction({
              type: 'changeAxisOrder',
              componentType: i.dim + 'Axis',
              axisId: i.index,
              sortInfo: o,
            }))
        }
      }),
      (t.prototype._dispatchInitSort = function (e, n, i) {
        var a = n.baseAxis,
          o = this._dataSort(e, a, function (s) {
            return e.get(e.mapDimension(n.otherAxis.dim), s)
          })
        i.dispatchAction({
          type: 'changeAxisOrder',
          componentType: a.dim + 'Axis',
          isInitSort: !0,
          axisId: a.index,
          sortInfo: o,
        })
      }),
      (t.prototype.remove = function (e, n) {
        this._clear(this._model), this._removeOnRenderedListener(n)
      }),
      (t.prototype.dispose = function (e, n) {
        this._removeOnRenderedListener(n)
      }),
      (t.prototype._removeOnRenderedListener = function (e) {
        this._onRendered &&
          (e.getZr().off('rendered', this._onRendered),
          (this._onRendered = null))
      }),
      (t.prototype._clear = function (e) {
        var n = this.group,
          i = this._data
        e && e.isAnimationEnabled() && i && !this._isLargeDraw
          ? (this._removeBackground(),
            (this._backgroundEls = []),
            i.eachItemGraphicEl(function (a) {
              Xp(a, e, Wt(a).dataIndex)
            }))
          : n.removeAll(),
          (this._data = null),
          (this._isFirstFrame = !0)
      }),
      (t.prototype._removeBackground = function () {
        this.group.remove(this._backgroundGroup), (this._backgroundGroup = null)
      }),
      (t.type = 'bar'),
      t
    )
  })(Ze),
  NI = {
    cartesian2d: function (r, t) {
      var e = t.width < 0 ? -1 : 1,
        n = t.height < 0 ? -1 : 1
      e < 0 && ((t.x += t.width), (t.width = -t.width)),
        n < 0 && ((t.y += t.height), (t.height = -t.height))
      var i = r.x + r.width,
        a = r.y + r.height,
        o = rS(t.x, r.x),
        s = iS(t.x + t.width, i),
        l = rS(t.y, r.y),
        u = iS(t.y + t.height, a),
        c = s < o,
        h = u < l
      return (
        (t.x = c && o > i ? s : o),
        (t.y = h && l > a ? u : l),
        (t.width = c ? 0 : s - o),
        (t.height = h ? 0 : u - l),
        e < 0 && ((t.x += t.width), (t.width = -t.width)),
        n < 0 && ((t.y += t.height), (t.height = -t.height)),
        c || h
      )
    },
    polar: function (r, t) {
      var e = t.r0 <= t.r ? 1 : -1
      if (e < 0) {
        var n = t.r
        ;(t.r = t.r0), (t.r0 = n)
      }
      var i = iS(t.r, r.r),
        a = rS(t.r0, r.r0)
      ;(t.r = i), (t.r0 = a)
      var o = i - a < 0
      if (e < 0) {
        var n = t.r
        ;(t.r = t.r0), (t.r0 = n)
      }
      return o
    },
  },
  kI = {
    cartesian2d: function (r, t, e, n, i, a, o, s, l) {
      var u = new ge({
        shape: Q({}, n),
        z2: 1,
      })
      if (((u.__dataIndex = e), (u.name = 'item'), a)) {
        var c = u.shape,
          h = i ? 'height' : 'width'
        c[h] = 0
      }
      return u
    },
    polar: function (r, t, e, n, i, a, o, s, l) {
      var u = !i && l ? h0 : oi,
        c = new u({
          shape: n,
          z2: 1,
        })
      c.name = 'item'
      var h = LG(i)
      if (
        ((c.calculateTextPosition = Flt(h, {
          isRoundCap: u === h0,
        })),
        a)
      ) {
        var f = c.shape,
          d = i ? 'r' : 'endAngle',
          p = {}
        ;(f[d] = i ? n.r0 : n.startAngle),
          (p[d] = n[d]),
          (s ? we : Je)(
            c,
            {
              shape: p,
            },
            a,
          )
      }
      return c
    },
  }
function Glt(r, t) {
  var e = r.get('realtimeSort', !0),
    n = t.getBaseAxis()
  if (e && n.type === 'category' && t.type === 'cartesian2d')
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n),
    }
}
function BI(r, t, e, n, i, a, o, s) {
  var l, u
  a
    ? ((u = {
        x: n.x,
        width: n.width,
      }),
      (l = {
        y: n.y,
        height: n.height,
      }))
    : ((u = {
        y: n.y,
        height: n.height,
      }),
      (l = {
        x: n.x,
        width: n.width,
      })),
    s ||
      (o ? we : Je)(
        e,
        {
          shape: l,
        },
        t,
        i,
        null,
      )
  var c = t ? r.baseAxis.model : null
  ;(o ? we : Je)(
    e,
    {
      shape: u,
    },
    c,
    i,
  )
}
function FI(r, t) {
  for (var e = 0; e < t.length; e++) if (!isFinite(r[t[e]])) return !0
  return !1
}
var Hlt = ['x', 'y', 'width', 'height'],
  Wlt = ['cx', 'cy', 'r', 'startAngle', 'endAngle'],
  zI = {
    cartesian2d: function (r) {
      return !FI(r, Hlt)
    },
    polar: function (r) {
      return !FI(r, Wlt)
    },
  },
  fm = {
    cartesian2d: function (r, t, e) {
      var n = r.getItemLayout(t),
        i = e ? Ylt(e, n) : 0,
        a = n.width > 0 ? 1 : -1,
        o = n.height > 0 ? 1 : -1
      return {
        x: n.x + (a * i) / 2,
        y: n.y + (o * i) / 2,
        width: n.width - a * i,
        height: n.height - o * i,
      }
    },
    polar: function (r, t, e) {
      var n = r.getItemLayout(t)
      return {
        cx: n.cx,
        cy: n.cy,
        r0: n.r0,
        r: n.r,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        clockwise: n.clockwise,
      }
    },
  }
function Xlt(r) {
  return (
    r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle
  )
}
function LG(r) {
  return (function (t) {
    var e = t ? 'Arc' : 'Angle'
    return function (n) {
      switch (n) {
        case 'start':
        case 'insideStart':
        case 'end':
        case 'insideEnd':
          return n + e
        default:
          return n
      }
    }
  })(r)
}
function UI(r, t, e, n, i, a, o, s) {
  var l = t.getItemVisual(e, 'style')
  if (s) {
    if (!a.get('roundCap')) {
      var c = r.shape,
        h = bu(n.getModel('itemStyle'), c, !0)
      Q(c, h), r.setShape(c)
    }
  } else {
    var u = n.get(['itemStyle', 'borderRadius']) || 0
    r.setShape('r', u)
  }
  r.useStyle(l)
  var f = n.getShallow('cursor')
  f && r.attr('cursor', f)
  var d = s
      ? o
        ? i.r >= i.r0
          ? 'endArc'
          : 'startArc'
        : i.endAngle >= i.startAngle
        ? 'endAngle'
        : 'startAngle'
      : o
      ? i.height >= 0
        ? 'bottom'
        : 'top'
      : i.width >= 0
      ? 'right'
      : 'left',
    p = Zn(n)
  mr(r, p, {
    labelFetcher: a,
    labelDataIndex: e,
    defaultText: of(a.getData(), e),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d,
  })
  var g = r.getTextContent()
  if (s && g) {
    var v = n.get(['label', 'position'])
    ;(r.textConfig.inside = v === 'middle' ? !0 : null),
      zlt(r, v === 'outside' ? d : v, LG(o), n.get(['label', 'rotate']))
  }
  GU(g, p, a.getRawValue(e), function (y) {
    return xG(t, y)
  })
  var m = n.getModel(['emphasis'])
  fn(r, m.get('focus'), m.get('blurScope'), m.get('disabled')),
    gr(r, n),
    Xlt(i) &&
      ((r.style.fill = 'none'),
      (r.style.stroke = 'none'),
      R(r.states, function (y) {
        y.style && (y.style.fill = y.style.stroke = 'none')
      }))
}
function Ylt(r, t) {
  var e = r.get(['itemStyle', 'borderColor'])
  if (!e || e === 'none') return 0
  var n = r.get(['itemStyle', 'borderWidth']) || 0,
    i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width),
    a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height)
  return Math.min(n, i, a)
}
var $lt = (function () {
    function r() {}
    return r
  })(),
  VI = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'largeBar'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new $lt()
      }),
      (t.prototype.buildPath = function (e, n) {
        for (
          var i = n.points,
            a = this.baseDimIdx,
            o = 1 - this.baseDimIdx,
            s = [],
            l = [],
            u = this.barWidth,
            c = 0;
          c < i.length;
          c += 3
        )
          (l[a] = u),
            (l[o] = i[c + 2]),
            (s[a] = i[c + a]),
            (s[o] = i[c + o]),
            e.rect(s[0], s[1], l[0], l[1])
      }),
      t
    )
  })(oe)
function GI(r, t, e, n) {
  var i = r.getData(),
    a = i.getLayout('valueAxisHorizontal') ? 1 : 0,
    o = i.getLayout('largeDataIndices'),
    s = i.getLayout('size'),
    l = r.getModel('backgroundStyle'),
    u = i.getLayout('largeBackgroundPoints')
  if (u) {
    var c = new VI({
      shape: {
        points: u,
      },
      incremental: !!n,
      silent: !0,
      z2: 0,
    })
    ;(c.baseDimIdx = a),
      (c.largeDataIndices = o),
      (c.barWidth = s),
      c.useStyle(l.getItemStyle()),
      t.add(c),
      e && e.push(c)
  }
  var h = new VI({
    shape: {
      points: i.getLayout('largePoints'),
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1,
  })
  ;(h.baseDimIdx = a),
    (h.largeDataIndices = o),
    (h.barWidth = s),
    t.add(h),
    h.useStyle(i.getVisual('style')),
    (Wt(h).seriesIndex = r.seriesIndex),
    r.get('silent') || (h.on('mousedown', HI), h.on('mousemove', HI)),
    e && e.push(h)
}
var HI = __(
  function (r) {
    var t = this,
      e = qlt(t, r.offsetX, r.offsetY)
    Wt(t).dataIndex = e >= 0 ? e : null
  },
  30,
  !1,
)
function qlt(r, t, e) {
  for (
    var n = r.baseDimIdx,
      i = 1 - n,
      a = r.shape.points,
      o = r.largeDataIndices,
      s = [],
      l = [],
      u = r.barWidth,
      c = 0,
      h = a.length / 3;
    c < h;
    c++
  ) {
    var f = c * 3
    if (
      ((l[n] = u),
      (l[i] = a[f + 2]),
      (s[n] = a[f + n]),
      (s[i] = a[f + i]),
      l[i] < 0 && ((s[i] += l[i]), (l[i] = -l[i])),
      t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1])
    )
      return o[c]
  }
  return -1
}
function PG(r, t, e) {
  if (oc(e, 'cartesian2d')) {
    var n = t,
      i = e.getArea()
    return {
      x: r ? n.x : i.x,
      y: r ? i.y : n.y,
      width: r ? n.width : i.width,
      height: r ? i.height : n.height,
    }
  } else {
    var i = e.getArea(),
      a = t
    return {
      cx: i.cx,
      cy: i.cy,
      r0: r ? i.r0 : a.r0,
      r: r ? i.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2,
    }
  }
}
function Zlt(r, t, e) {
  var n = r.type === 'polar' ? oi : ge
  return new n({
    shape: PG(t, e, r),
    silent: !0,
    z2: 0,
  })
}
const Klt = Vlt
function jlt(r) {
  r.registerChartView(Klt),
    r.registerSeriesModel(Nlt),
    r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Zt(IV, 'bar')),
    r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OV('bar')),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, EG('bar')),
    r.registerAction(
      {
        type: 'changeAxisOrder',
        event: 'changeAxisOrder',
        update: 'update',
      },
      function (t, e) {
        var n = t.componentType || 'series'
        e.eachComponent(
          {
            mainType: n,
            query: t,
          },
          function (i) {
            t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo)
          },
        )
      },
    )
}
var WI = Math.PI * 2,
  dm = Math.PI / 180
function RG(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function IG(r, t) {
  var e = RG(r, t),
    n = r.get('center'),
    i = r.get('radius')
  at(i) || (i = [0, i])
  var a = _t(e.width, t.getWidth()),
    o = _t(e.height, t.getHeight()),
    s = Math.min(a, o),
    l = _t(i[0], s / 2),
    u = _t(i[1], s / 2),
    c,
    h,
    f = r.coordinateSystem
  if (f) {
    var d = f.dataToPoint(n)
    ;(c = d[0] || 0), (h = d[1] || 0)
  } else at(n) || (n = [n, n]), (c = _t(n[0], a) + e.x), (h = _t(n[1], o) + e.y)
  return {
    cx: c,
    cy: h,
    r0: l,
    r: u,
  }
}
function Jlt(r, t, e) {
  t.eachSeriesByType(r, function (n) {
    var i = n.getData(),
      a = i.mapDimension('value'),
      o = RG(n, e),
      s = IG(n, e),
      l = s.cx,
      u = s.cy,
      c = s.r,
      h = s.r0,
      f = -n.get('startAngle') * dm,
      d = n.get('endAngle'),
      p = n.get('padAngle') * dm
    d = d === 'auto' ? f - WI : -d * dm
    var g = n.get('minAngle') * dm,
      v = g + p,
      m = 0
    i.each(a, function (F) {
      !isNaN(F) && m++
    })
    var y = i.getSum(a),
      _ = (Math.PI / (y || m)) * 2,
      x = n.get('clockwise'),
      A = n.get('roseType'),
      S = n.get('stillShowZeroSum'),
      b = i.getDataExtent(a)
    b[0] = 0
    var T = x ? 1 : -1,
      w = [f, d],
      M = (T * p) / 2
    HT(w, !x), (f = w[0]), (d = w[1])
    var C = OG(n)
    ;(C.startAngle = f), (C.endAngle = d), (C.clockwise = x)
    var E = Math.abs(d - f),
      D = E,
      P = 0,
      L = f
    if (
      (i.setLayout({
        viewRect: o,
        r: c,
      }),
      i.each(a, function (F, k) {
        var V
        if (isNaN(F)) {
          i.setItemLayout(k, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: x,
            cx: l,
            cy: u,
            r0: h,
            r: A ? NaN : c,
          })
          return
        }
        A !== 'area' ? (V = y === 0 && S ? _ : F * _) : (V = E / m),
          V < v ? ((V = v), (D -= v)) : (P += F)
        var H = L + T * V,
          Y = 0,
          K = 0
        p > V ? ((Y = L + (T * V) / 2), (K = Y)) : ((Y = L + M), (K = H - M)),
          i.setItemLayout(k, {
            angle: V,
            startAngle: Y,
            endAngle: K,
            clockwise: x,
            cx: l,
            cy: u,
            r0: h,
            r: A ? Re(F, b, [h, c]) : c,
          }),
          (L = H)
      }),
      D < WI && m)
    )
      if (D <= 0.001) {
        var I = E / m
        i.each(a, function (F, k) {
          if (!isNaN(F)) {
            var V = i.getItemLayout(k)
            V.angle = I
            var H = 0,
              Y = 0
            I < p
              ? ((H = f + T * (k + 1 / 2) * I), (Y = H))
              : ((H = f + T * k * I + M), (Y = f + T * (k + 1) * I - M)),
              (V.startAngle = H),
              (V.endAngle = Y)
          }
        })
      } else
        (_ = D / P),
          (L = f),
          i.each(a, function (F, k) {
            if (!isNaN(F)) {
              var V = i.getItemLayout(k),
                H = V.angle === v ? v : F * _,
                Y = 0,
                K = 0
              H < p
                ? ((Y = L + (T * H) / 2), (K = Y))
                : ((Y = L + M), (K = L + T * H - M)),
                (V.startAngle = Y),
                (V.endAngle = K),
                (L += T * H)
            }
          })
  })
}
var OG = ve()
function Lv(r) {
  return {
    seriesType: r,
    reset: function (t, e) {
      var n = e.findComponents({
        mainType: 'legend',
      })
      if (!(!n || !n.length)) {
        var i = t.getData()
        i.filterSelf(function (a) {
          for (var o = i.getName(a), s = 0; s < n.length; s++)
            if (!n[s].isSelected(o)) return !1
          return !0
        })
      }
    },
  }
}
var Qlt = Math.PI / 180
function XI(r, t, e, n, i, a, o, s, l, u) {
  if (r.length < 2) return
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var _ = g.list[y],
        x = Math.abs(_.label.y - e),
        A = n + _.len,
        S = A * A,
        b = Math.sqrt((1 - Math.abs((x * x) / m)) * S),
        T = t + (b + _.len2) * i,
        w = T - _.label.x,
        M = _.targetTextWidth - w * i
      NG(_, M, !0), (_.label.x = T)
    }
  }
  function h(g) {
    for (
      var v = {
          list: [],
          maxY: 0,
        },
        m = {
          list: [],
          maxY: 0,
        },
        y = 0;
      y < g.length;
      y++
    )
      if (g[y].labelAlignTo === 'none') {
        var _ = g[y],
          x = _.label.y > e ? m : v,
          A = Math.abs(_.label.y - e)
        if (A >= x.maxY) {
          var S = _.label.x - t - _.len2 * i,
            b = n + _.len,
            T = Math.abs(S) < b ? Math.sqrt((A * A) / (1 - (S * S) / b / b)) : b
          ;(x.rB = T), (x.maxY = A)
        }
        x.list.push(_)
      }
    c(v), c(m)
  }
  for (var f = r.length, d = 0; d < f; d++)
    if (r[d].position === 'outer' && r[d].labelAlignTo === 'labelLine') {
      var p = r[d].label.x - u
      ;(r[d].linePoints[1][0] += p), (r[d].label.x = u)
    }
  rG(r, l, l + o) && h(r)
}
function tut(r, t, e, n, i, a, o, s) {
  for (
    var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0;
    f < r.length;
    f++
  ) {
    var d = r[f].label
    aS(r[f]) ||
      (d.x < t
        ? ((c = Math.min(c, d.x)), l.push(r[f]))
        : ((h = Math.max(h, d.x)), u.push(r[f])))
  }
  for (var f = 0; f < r.length; f++) {
    var p = r[f]
    if (!aS(p) && p.linePoints) {
      if (p.labelStyleWidth != null) continue
      var d = p.label,
        g = p.linePoints,
        v = void 0
      p.labelAlignTo === 'edge'
        ? d.x < t
          ? (v = g[2][0] - p.labelDistance - o - p.edgeDistance)
          : (v = o + i - p.edgeDistance - g[2][0] - p.labelDistance)
        : p.labelAlignTo === 'labelLine'
        ? d.x < t
          ? (v = c - o - p.bleedMargin)
          : (v = o + i - h - p.bleedMargin)
        : d.x < t
        ? (v = d.x - o - p.bleedMargin)
        : (v = o + i - d.x - p.bleedMargin),
        (p.targetTextWidth = v),
        NG(p, v)
    }
  }
  XI(u, t, e, n, 1, i, a, o, s, h), XI(l, t, e, n, -1, i, a, o, s, c)
  for (var f = 0; f < r.length; f++) {
    var p = r[f]
    if (!aS(p) && p.linePoints) {
      var d = p.label,
        g = p.linePoints,
        m = p.labelAlignTo === 'edge',
        y = d.style.padding,
        _ = y ? y[1] + y[3] : 0,
        x = d.style.backgroundColor ? 0 : _,
        A = p.rect.width + x,
        S = g[1][0] - g[2][0]
      m
        ? d.x < t
          ? (g[2][0] = o + p.edgeDistance + A + p.labelDistance)
          : (g[2][0] = o + i - p.edgeDistance - A - p.labelDistance)
        : (d.x < t
            ? (g[2][0] = d.x + p.labelDistance)
            : (g[2][0] = d.x - p.labelDistance),
          (g[1][0] = g[2][0] + S)),
        (g[1][1] = g[2][1] = d.y)
    }
  }
}
function NG(r, t, e) {
  if ((e === void 0 && (e = !1), r.labelStyleWidth == null)) {
    var n = r.label,
      i = n.style,
      a = r.rect,
      o = i.backgroundColor,
      s = i.padding,
      l = s ? s[1] + s[3] : 0,
      u = i.overflow,
      c = a.width + (o ? 0 : l)
    if (t < c || e) {
      var h = a.height
      if (u && u.match('break')) {
        n.setStyle('backgroundColor', null), n.setStyle('width', t - l)
        var f = n.getBoundingRect()
        n.setStyle('width', Math.ceil(f.width)),
          n.setStyle('backgroundColor', o)
      } else {
        var d = t - l,
          p = t < c ? d : e ? (d > r.unconstrainedWidth ? null : d) : null
        n.setStyle('width', p)
      }
      var g = n.getBoundingRect()
      a.width = g.width
      var v = (n.style.margin || 0) + 2.1
      ;(a.height = g.height + v), (a.y -= (a.height - h) / 2)
    }
  }
}
function aS(r) {
  return r.position === 'center'
}
function eut(r) {
  var t = r.getData(),
    e = [],
    n,
    i,
    a = !1,
    o = (r.get('minShowLabelAngle') || 0) * Qlt,
    s = t.getLayout('viewRect'),
    l = t.getLayout('r'),
    u = s.width,
    c = s.x,
    h = s.y,
    f = s.height
  function d(S) {
    S.ignore = !0
  }
  function p(S) {
    if (!S.ignore) return !0
    for (var b in S.states) if (S.states[b].ignore === !1) return !0
    return !1
  }
  t.each(function (S) {
    var b = t.getItemGraphicEl(S),
      T = b.shape,
      w = b.getTextContent(),
      M = b.getTextGuideLine(),
      C = t.getItemModel(S),
      E = C.getModel('label'),
      D = E.get('position') || C.get(['emphasis', 'label', 'position']),
      P = E.get('distanceToLabelLine'),
      L = E.get('alignTo'),
      I = _t(E.get('edgeDistance'), u),
      F = E.get('bleedMargin'),
      k = C.getModel('labelLine'),
      V = k.get('length')
    V = _t(V, u)
    var H = k.get('length2')
    if (((H = _t(H, u)), Math.abs(T.endAngle - T.startAngle) < o)) {
      R(w.states, d), (w.ignore = !0), M && (R(M.states, d), (M.ignore = !0))
      return
    }
    if (p(w)) {
      var Y = (T.startAngle + T.endAngle) / 2,
        K = Math.cos(Y),
        ut = Math.sin(Y),
        W,
        Z,
        ft,
        lt
      ;(n = T.cx), (i = T.cy)
      var ct = D === 'inside' || D === 'inner'
      if (D === 'center') (W = T.cx), (Z = T.cy), (lt = 'center')
      else {
        var At = (ct ? ((T.r + T.r0) / 2) * K : T.r * K) + n,
          gt = (ct ? ((T.r + T.r0) / 2) * ut : T.r * ut) + i
        if (((W = At + K * 3), (Z = gt + ut * 3), !ct)) {
          var dt = At + K * (V + l - T.r),
            B = gt + ut * (V + l - T.r),
            ht = dt + (K < 0 ? -1 : 1) * H,
            it = B
          L === 'edge'
            ? (W = K < 0 ? c + I : c + u - I)
            : (W = ht + (K < 0 ? -P : P)),
            (Z = it),
            (ft = [
              [At, gt],
              [dt, B],
              [ht, it],
            ])
        }
        lt = ct
          ? 'center'
          : L === 'edge'
          ? K > 0
            ? 'right'
            : 'left'
          : K > 0
          ? 'left'
          : 'right'
      }
      var xt = Math.PI,
        rt = 0,
        kt = E.get('rotate')
      if (be(kt)) rt = kt * (xt / 180)
      else if (D === 'center') rt = 0
      else if (kt === 'radial' || kt === !0) {
        var Ct = K < 0 ? -Y + xt : -Y
        rt = Ct
      } else if (kt === 'tangential' && D !== 'outside' && D !== 'outer') {
        var Lt = Math.atan2(K, ut)
        Lt < 0 && (Lt = xt * 2 + Lt)
        var G = ut > 0
        G && (Lt = xt + Lt), (rt = Lt - xt)
      }
      if (
        ((a = !!rt),
        (w.x = W),
        (w.y = Z),
        (w.rotation = rt),
        w.setStyle({
          verticalAlign: 'middle',
        }),
        ct)
      ) {
        w.setStyle({
          align: lt,
        })
        var vt = w.states.select
        vt && ((vt.x += w.x), (vt.y += w.y))
      } else {
        var N = w.getBoundingRect().clone()
        N.applyTransform(w.getComputedTransform())
        var J = (w.style.margin || 0) + 2.1
        ;(N.y -= J / 2),
          (N.height += J),
          e.push({
            label: w,
            labelLine: M,
            position: D,
            len: V,
            len2: H,
            minTurnAngle: k.get('minTurnAngle'),
            maxSurfaceAngle: k.get('maxSurfaceAngle'),
            surfaceNormal: new Qt(K, ut),
            linePoints: ft,
            textAlign: lt,
            labelDistance: P,
            labelAlignTo: L,
            edgeDistance: I,
            bleedMargin: F,
            rect: N,
            unconstrainedWidth: N.width,
            labelStyleWidth: w.style.width,
          })
      }
      b.setTextConfig({
        inside: ct,
      })
    }
  }),
    !a && r.get('avoidLabelOverlap') && tut(e, n, i, l, u, f, c, h)
  for (var g = 0; g < e.length; g++) {
    var v = e[g],
      m = v.label,
      y = v.labelLine,
      _ = isNaN(m.x) || isNaN(m.y)
    if (m) {
      m.setStyle({
        align: v.textAlign,
      }),
        _ && (R(m.states, d), (m.ignore = !0))
      var x = m.states.select
      x && ((x.x += m.x), (x.y += m.y))
    }
    if (y) {
      var A = v.linePoints
      _ || !A
        ? (R(y.states, d), (y.ignore = !0))
        : (tG(A, v.minTurnAngle),
          fst(A, v.surfaceNormal, v.maxSurfaceAngle),
          y.setShape({
            points: A,
          }),
          (m.__hostTarget.textGuideLineConfig = {
            anchor: new Qt(A[0][0], A[0][1]),
          }))
    }
  }
}
var nut = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this) || this
      a.z2 = 2
      var o = new Ae()
      return a.setTextContent(o), a.updateData(e, n, i, !0), a
    }
    return (
      (t.prototype.updateData = function (e, n, i, a) {
        var o = this,
          s = e.hostModel,
          l = e.getItemModel(n),
          u = l.getModel('emphasis'),
          c = e.getItemLayout(n),
          h = Q(bu(l.getModel('itemStyle'), c, !0), c)
        if (isNaN(h.startAngle)) {
          o.setShape(h)
          return
        }
        if (a) {
          o.setShape(h)
          var f = s.getShallow('animationType')
          s.ecModel.ssr
            ? (Je(
                o,
                {
                  scaleX: 0,
                  scaleY: 0,
                },
                s,
                {
                  dataIndex: n,
                  isFrom: !0,
                },
              ),
              (o.originX = h.cx),
              (o.originY = h.cy))
            : f === 'scale'
            ? ((o.shape.r = c.r0),
              Je(
                o,
                {
                  shape: {
                    r: c.r,
                  },
                },
                s,
                n,
              ))
            : i != null
            ? (o.setShape({
                startAngle: i,
                endAngle: i,
              }),
              Je(
                o,
                {
                  shape: {
                    startAngle: c.startAngle,
                    endAngle: c.endAngle,
                  },
                },
                s,
                n,
              ))
            : ((o.shape.endAngle = c.startAngle),
              we(
                o,
                {
                  shape: {
                    endAngle: c.endAngle,
                  },
                },
                s,
                n,
              ))
        } else
          Ca(o),
            we(
              o,
              {
                shape: h,
              },
              s,
              n,
            )
        o.useStyle(e.getItemVisual(n, 'style')), gr(o, l)
        var d = (c.startAngle + c.endAngle) / 2,
          p = s.get('selectedOffset'),
          g = Math.cos(d) * p,
          v = Math.sin(d) * p,
          m = l.getShallow('cursor')
        m && o.attr('cursor', m),
          this._updateLabel(s, e, n),
          (o.ensureState('emphasis').shape = Q(
            {
              r: c.r + ((u.get('scale') && u.get('scaleSize')) || 0),
            },
            bu(u.getModel('itemStyle'), c),
          )),
          Q(o.ensureState('select'), {
            x: g,
            y: v,
            shape: bu(l.getModel(['select', 'itemStyle']), c),
          }),
          Q(o.ensureState('blur'), {
            shape: bu(l.getModel(['blur', 'itemStyle']), c),
          })
        var y = o.getTextGuideLine(),
          _ = o.getTextContent()
        y &&
          Q(y.ensureState('select'), {
            x: g,
            y: v,
          }),
          Q(_.ensureState('select'), {
            x: g,
            y: v,
          }),
          fn(this, u.get('focus'), u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e, n, i) {
        var a = this,
          o = n.getItemModel(i),
          s = o.getModel('labelLine'),
          l = n.getItemVisual(i, 'style'),
          u = l && l.fill,
          c = l && l.opacity
        mr(a, Zn(o), {
          labelFetcher: n.hostModel,
          labelDataIndex: i,
          inheritColor: u,
          defaultOpacity: c,
          defaultText: e.getFormattedLabel(i, 'normal') || n.getName(i),
        })
        var h = a.getTextContent()
        a.setTextConfig({
          position: null,
          rotation: null,
        }),
          h.attr({
            z2: 10,
          })
        var f = e.get(['label', 'position'])
        if (f !== 'outside' && f !== 'outer') a.removeTextGuideLine()
        else {
          var d = this.getTextGuideLine()
          d || ((d = new li()), this.setTextGuideLine(d)),
            LC(this, PC(o), {
              stroke: u,
              opacity: ao(s.get(['lineStyle', 'opacity']), c, 1),
            })
        }
      }),
      t
    )
  })(oi),
  rut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.ignoreLabelLineUpdate = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = e.getData(),
          s = this._data,
          l = this.group,
          u
        if (!s && o.count() > 0) {
          for (
            var c = o.getItemLayout(0), h = 1;
            isNaN(c && c.startAngle) && h < o.count();
            ++h
          )
            c = o.getItemLayout(h)
          c && (u = c.startAngle)
        }
        if (
          (this._emptyCircleSector && l.remove(this._emptyCircleSector),
          o.count() === 0 && e.get('showEmptyCircle'))
        ) {
          var f = OG(e),
            d = new oi({
              shape: Q(IG(e, i), f),
            })
          d.useStyle(e.getModel('emptyCircleStyle').getItemStyle()),
            (this._emptyCircleSector = d),
            l.add(d)
        }
        o
          .diff(s)
          .add(function (p) {
            var g = new nut(o, p, u)
            o.setItemGraphicEl(p, g), l.add(g)
          })
          .update(function (p, g) {
            var v = s.getItemGraphicEl(g)
            v.updateData(o, p, u),
              v.off('click'),
              l.add(v),
              o.setItemGraphicEl(p, v)
          })
          .remove(function (p) {
            var g = s.getItemGraphicEl(p)
            Xp(g, e, p)
          })
          .execute(),
          eut(e),
          e.get('animationTypeUpdate') !== 'expansion' && (this._data = o)
      }),
      (t.prototype.dispose = function () {}),
      (t.prototype.containPoint = function (e, n) {
        var i = n.getData(),
          a = i.getItemLayout(0)
        if (a) {
          var o = e[0] - a.cx,
            s = e[1] - a.cy,
            l = Math.sqrt(o * o + s * s)
          return l <= a.r && l >= a.r0
        }
      }),
      (t.type = 'pie'),
      t
    )
  })(Ze)
const iut = rut
function Rf(r, t, e) {
  t =
    (at(t) && {
      coordDimensions: t,
    }) ||
    Q(
      {
        encodeDefine: r.getEncode(),
      },
      t,
    )
  var n = r.getSource(),
    i = wv(n, t).dimensions,
    a = new Vr(i, r)
  return a.initData(n, e), a
}
var aut = (function () {
  function r(t, e) {
    ;(this._getDataWithEncodedVisual = t), (this._getRawData = e)
  }
  return (
    (r.prototype.getAllNames = function () {
      var t = this._getRawData()
      return t.mapArray(t.getName)
    }),
    (r.prototype.containName = function (t) {
      var e = this._getRawData()
      return e.indexOfName(t) >= 0
    }),
    (r.prototype.indexOfName = function (t) {
      var e = this._getDataWithEncodedVisual()
      return e.indexOfName(t)
    }),
    (r.prototype.getItemVisual = function (t, e) {
      var n = this._getDataWithEncodedVisual()
      return n.getItemVisual(t, e)
    }),
    r
  )
})()
const Pv = aut
var out = ve(),
  sut = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.init = function (e) {
        r.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new Pv(
            Tt(this.getData, this),
            Tt(this.getRawData, this),
          )),
          this._defaultLabelLine(e)
      }),
      (t.prototype.mergeOption = function () {
        r.prototype.mergeOption.apply(this, arguments)
      }),
      (t.prototype.getInitialData = function () {
        return Rf(this, {
          coordDimensions: ['value'],
          encodeDefaulter: Zt(lC, this),
        })
      }),
      (t.prototype.getDataParams = function (e) {
        var n = this.getData(),
          i = out(n),
          a = i.seats
        if (!a) {
          var o = []
          n.each(n.mapDimension('value'), function (l) {
            o.push(l)
          }),
            (a = i.seats = ptt(o, n.hostModel.get('percentPrecision')))
        }
        var s = r.prototype.getDataParams.call(this, e)
        return (s.percent = a[e] || 0), s.$vars.push('percent'), s
      }),
      (t.prototype._defaultLabelLine = function (e) {
        Xu(e, 'labelLine', ['show'])
        var n = e.labelLine,
          i = e.emphasis.labelLine
        ;(n.show = n.show && e.label.show),
          (i.show = i.show && e.emphasis.label.show)
      }),
      (t.type = 'series.pie'),
      (t.defaultOption = {
        z: 2,
        legendHoverLink: !0,
        colorBy: 'data',
        center: ['50%', '50%'],
        radius: [0, '75%'],
        clockwise: !0,
        startAngle: 90,
        endAngle: 'auto',
        padAngle: 0,
        minAngle: 0,
        minShowLabelAngle: 0,
        selectedOffset: 10,
        percentPrecision: 2,
        stillShowZeroSum: !0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          rotate: 0,
          show: !0,
          overflow: 'truncate',
          position: 'outer',
          alignTo: 'none',
          edgeDistance: '25%',
          bleedMargin: 10,
          distanceToLabelLine: 5,
        },
        labelLine: {
          show: !0,
          length: 15,
          length2: 15,
          smooth: !1,
          minTurnAngle: 90,
          maxSurfaceAngle: 90,
          lineStyle: {
            width: 1,
            type: 'solid',
          },
        },
        itemStyle: {
          borderWidth: 1,
          borderJoin: 'round',
        },
        showEmptyCircle: !0,
        emptyCircleStyle: {
          color: 'lightgray',
          opacity: 1,
        },
        labelLayout: {
          hideOverlap: !0,
        },
        emphasis: {
          scale: !0,
          scaleSize: 5,
        },
        avoidLabelOverlap: !0,
        animationType: 'expansion',
        animationDuration: 1e3,
        animationTypeUpdate: 'transition',
        animationEasingUpdate: 'cubicInOut',
        animationDurationUpdate: 500,
        animationEasing: 'cubicInOut',
      }),
      t
    )
  })(rn)
const lut = sut
function uut(r) {
  return {
    seriesType: r,
    reset: function (t, e) {
      var n = t.getData()
      n.filterSelf(function (i) {
        var a = n.mapDimension('value'),
          o = n.get(a, i)
        return !(be(o) && !isNaN(o) && o < 0)
      })
    },
  }
}
function cut(r) {
  r.registerChartView(iut),
    r.registerSeriesModel(lut),
    K5('pie', r.registerAction),
    r.registerLayout(Zt(Jlt, 'pie')),
    r.registerProcessor(Lv('pie')),
    r.registerProcessor(uut('pie'))
}
var hut = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.getProgressive = function () {
      var e = this.option.progressive
      return e ?? (this.option.large ? 5e3 : this.get('progressive'))
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.option.progressiveThreshold
      return e ?? (this.option.large ? 1e4 : this.get('progressiveThreshold'))
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.point(n.getItemLayout(e))
    }),
    (t.prototype.getZLevelKey = function () {
      return this.getData().count() > this.getProgressiveThreshold()
        ? this.id
        : ''
    }),
    (t.type = 'series.scatter'),
    (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      large: !1,
      largeThreshold: 2e3,
      itemStyle: {
        opacity: 0.8,
      },
      emphasis: {
        scale: !0,
      },
      clip: !0,
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      universalTransition: {
        divideShape: 'clone',
      },
    }),
    t
  )
})(rn)
const fut = hut
var kG = 4,
  dut = (function () {
    function r() {}
    return r
  })(),
  put = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n._off = 0), (n.hoverDataIdx = -1), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new dut()
      }),
      (t.prototype.reset = function () {
        ;(this.notClear = !1), (this._off = 0)
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = n.size,
          o = this.symbolProxy,
          s = o.shape,
          l = e.getContext ? e.getContext() : e,
          u = l && a[0] < kG,
          c = this.softClipShape,
          h
        if (u) {
          this._ctx = l
          return
        }
        for (this._ctx = null, h = this._off; h < i.length; ) {
          var f = i[h++],
            d = i[h++]
          isNaN(f) ||
            isNaN(d) ||
            (c && !c.contain(f, d)) ||
            ((s.x = f - a[0] / 2),
            (s.y = d - a[1] / 2),
            (s.width = a[0]),
            (s.height = a[1]),
            o.buildPath(e, s, !0))
        }
        this.incremental && ((this._off = h), (this.notClear = !0))
      }),
      (t.prototype.afterBrush = function () {
        var e = this.shape,
          n = e.points,
          i = e.size,
          a = this._ctx,
          o = this.softClipShape,
          s
        if (a) {
          for (s = this._off; s < n.length; ) {
            var l = n[s++],
              u = n[s++]
            isNaN(l) ||
              isNaN(u) ||
              (o && !o.contain(l, u)) ||
              a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1])
          }
          this.incremental && ((this._off = s), (this.notClear = !0))
        }
      }),
      (t.prototype.findDataIndex = function (e, n) {
        for (
          var i = this.shape,
            a = i.points,
            o = i.size,
            s = Math.max(o[0], 4),
            l = Math.max(o[1], 4),
            u = a.length / 2 - 1;
          u >= 0;
          u--
        ) {
          var c = u * 2,
            h = a[c] - s / 2,
            f = a[c + 1] - l / 2
          if (e >= h && n >= f && e <= h + s && n <= f + l) return u
        }
        return -1
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        if (((e = i[0]), (n = i[1]), a.contain(e, n))) {
          var o = (this.hoverDataIdx = this.findDataIndex(e, n))
          return o >= 0
        }
        return (this.hoverDataIdx = -1), !1
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect
        if (!e) {
          for (
            var n = this.shape,
              i = n.points,
              a = n.size,
              o = a[0],
              s = a[1],
              l = 1 / 0,
              u = 1 / 0,
              c = -1 / 0,
              h = -1 / 0,
              f = 0;
            f < i.length;

          ) {
            var d = i[f++],
              p = i[f++]
            ;(l = Math.min(d, l)),
              (c = Math.max(d, c)),
              (u = Math.min(p, u)),
              (h = Math.max(p, h))
          }
          e = this._rect = new ee(l - o / 2, u - s / 2, c - l + o, h - u + s)
        }
        return e
      }),
      t
    )
  })(oe),
  vut = (function () {
    function r() {
      this.group = new Ht()
    }
    return (
      (r.prototype.updateData = function (t, e) {
        this._clear()
        var n = this._create()
        n.setShape({
          points: t.getLayout('points'),
        }),
          this._setCommon(n, t, e)
      }),
      (r.prototype.updateLayout = function (t) {
        var e = t.getLayout('points')
        this.group.eachChild(function (n) {
          if (n.startIndex != null) {
            var i = (n.endIndex - n.startIndex) * 2,
              a = n.startIndex * 4 * 2
            e = new Float32Array(e.buffer, a, i)
          }
          n.setShape('points', e), n.reset()
        })
      }),
      (r.prototype.incrementalPrepareUpdate = function (t) {
        this._clear()
      }),
      (r.prototype.incrementalUpdate = function (t, e, n) {
        var i = this._newAdded[0],
          a = e.getLayout('points'),
          o = i && i.shape.points
        if (o && o.length < 2e4) {
          var s = o.length,
            l = new Float32Array(s + a.length)
          l.set(o),
            l.set(a, s),
            (i.endIndex = t.end),
            i.setShape({
              points: l,
            })
        } else {
          this._newAdded = []
          var u = this._create()
          ;(u.startIndex = t.start),
            (u.endIndex = t.end),
            (u.incremental = !0),
            u.setShape({
              points: a,
            }),
            this._setCommon(u, e, n)
        }
      }),
      (r.prototype.eachRendered = function (t) {
        this._newAdded[0] && t(this._newAdded[0])
      }),
      (r.prototype._create = function () {
        var t = new put({
          cursor: 'default',
        })
        return (
          (t.ignoreCoarsePointer = !0),
          this.group.add(t),
          this._newAdded.push(t),
          t
        )
      }),
      (r.prototype._setCommon = function (t, e, n) {
        var i = e.hostModel
        n = n || {}
        var a = e.getVisual('symbolSize')
        t.setShape('size', a instanceof Array ? a : [a, a]),
          (t.softClipShape = n.clipShape || null),
          (t.symbolProxy = Rn(e.getVisual('symbol'), 0, 0, 0, 0)),
          (t.setColor = t.symbolProxy.setColor)
        var o = t.shape.size[0] < kG
        t.useStyle(
          i
            .getModel('itemStyle')
            .getItemStyle(
              o ? ['color', 'shadowBlur', 'shadowColor'] : ['color'],
            ),
        )
        var s = e.getVisual('style'),
          l = s && s.fill
        l && t.setColor(l)
        var u = Wt(t)
        ;(u.seriesIndex = i.seriesIndex),
          t.on('mousemove', function (c) {
            u.dataIndex = null
            var h = t.hoverDataIdx
            h >= 0 && (u.dataIndex = h + (t.startIndex || 0))
          })
      }),
      (r.prototype.remove = function () {
        this._clear()
      }),
      (r.prototype._clear = function () {
        ;(this._newAdded = []), this.group.removeAll()
      }),
      r
    )
  })()
const gut = vut
var mut = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._updateSymbolDraw(a, e)
      o.updateData(a, {
        clipShape: this._getClipShape(e),
      }),
        (this._finished = !0)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      var a = e.getData(),
        o = this._updateSymbolDraw(a, e)
      o.incrementalPrepareUpdate(a), (this._finished = !1)
    }),
    (t.prototype.incrementalRender = function (e, n, i) {
      this._symbolDraw.incrementalUpdate(e, n.getData(), {
        clipShape: this._getClipShape(n),
      }),
        (this._finished = e.end === n.getData().count())
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData()
      if ((this.group.dirty(), !this._finished || a.count() > 1e4))
        return {
          update: !0,
        }
      var o = Dv('').reset(e, n, i)
      o.progress &&
        o.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._symbolDraw.updateLayout(a)
    }),
    (t.prototype.eachRendered = function (e) {
      this._symbolDraw && this._symbolDraw.eachRendered(e)
    }),
    (t.prototype._getClipShape = function (e) {
      if (e.get('clip', !0)) {
        var n = e.coordinateSystem
        return n && n.getArea && n.getArea(0.1)
      }
    }),
    (t.prototype._updateSymbolDraw = function (e, n) {
      var i = this._symbolDraw,
        a = n.pipelineContext,
        o = a.large
      return (
        (!i || o !== this._isLargeDraw) &&
          (i && i.remove(),
          (i = this._symbolDraw = o ? new gut() : new Cv()),
          (this._isLargeDraw = o),
          this.group.removeAll()),
        this.group.add(i.group),
        i
      )
    }),
    (t.prototype.remove = function (e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), (this._symbolDraw = null)
    }),
    (t.prototype.dispose = function () {}),
    (t.type = 'scatter'),
    t
  )
})(Ze)
const yut = mut
var _ut = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.type = 'grid'),
    (t.dependencies = ['xAxis', 'yAxis']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      show: !1,
      z: 0,
      left: '10%',
      top: 60,
      right: '10%',
      bottom: 70,
      containLabel: !1,
      backgroundColor: 'rgba(0,0,0,0)',
      borderWidth: 1,
      borderColor: '#ccc',
    }),
    t
  )
})(xe)
const xut = _ut
var Pw = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this.getReferringComponents('grid', Pn).models[0]
    }),
    (t.type = 'cartesian2dAxis'),
    t
  )
})(xe)
In(Pw, Mv)
var BG = {
    show: !0,
    z: 0,
    inverse: !1,
    name: '',
    nameLocation: 'end',
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: '...',
      placeholder: '.',
    },
    nameTextStyle: {},
    nameGap: 15,
    silent: !1,
    triggerEvent: !1,
    tooltip: {
      show: !1,
    },
    axisPointer: {},
    axisLine: {
      show: !0,
      onZero: !0,
      onZeroAxisIndex: null,
      lineStyle: {
        color: '#6E7079',
        width: 1,
        type: 'solid',
      },
      symbol: ['none', 'none'],
      symbolSize: [10, 15],
    },
    axisTick: {
      show: !0,
      inside: !1,
      length: 5,
      lineStyle: {
        width: 1,
      },
    },
    axisLabel: {
      show: !0,
      inside: !1,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12,
    },
    splitLine: {
      show: !0,
      lineStyle: {
        color: ['#E0E6F1'],
        width: 1,
        type: 'solid',
      },
    },
    splitArea: {
      show: !1,
      areaStyle: {
        color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)'],
      },
    },
  },
  Sut = te(
    {
      boundaryGap: !0,
      deduplication: null,
      splitLine: {
        show: !1,
      },
      axisTick: {
        alignWithLabel: !1,
        interval: 'auto',
      },
      axisLabel: {
        interval: 'auto',
      },
    },
    BG,
  ),
  BC = te(
    {
      boundaryGap: [0, 0],
      axisLine: {
        show: 'auto',
      },
      axisTick: {
        show: 'auto',
      },
      splitNumber: 5,
      minorTick: {
        show: !1,
        splitNumber: 5,
        length: 3,
        lineStyle: {},
      },
      minorSplitLine: {
        show: !1,
        lineStyle: {
          color: '#F4F7FD',
          width: 1,
        },
      },
    },
    BG,
  ),
  Aut = te(
    {
      splitNumber: 6,
      axisLabel: {
        showMinLabel: !1,
        showMaxLabel: !1,
        rich: {
          primary: {
            fontWeight: 'bold',
          },
        },
      },
      splitLine: {
        show: !1,
      },
    },
    BC,
  ),
  but = zt(
    {
      logBase: 10,
    },
    BC,
  )
const FG = {
  category: Sut,
  value: BC,
  time: Aut,
  log: but,
}
var wut = {
  value: 1,
  category: 1,
  time: 1,
  log: 1,
}
function sf(r, t, e, n) {
  R(wut, function (i, a) {
    var o = te(te({}, FG[a], !0), n, !0),
      s = (function (l) {
        X(u, l)
        function u() {
          var c = (l !== null && l.apply(this, arguments)) || this
          return (c.type = t + 'Axis.' + a), c
        }
        return (
          (u.prototype.mergeDefaultAndTheme = function (c, h) {
            var f = $p(this),
              d = f ? Mf(c) : {},
              p = h.getTheme()
            te(c, p.get(a + 'Axis')),
              te(c, this.getDefaultOption()),
              (c.type = YI(c)),
              f && ol(c, d, f)
          }),
          (u.prototype.optionUpdated = function () {
            var c = this.option
            c.type === 'category' &&
              (this.__ordinalMeta = ww.createByAxisModel(this))
          }),
          (u.prototype.getCategories = function (c) {
            var h = this.option
            if (h.type === 'category')
              return c ? h.data : this.__ordinalMeta.categories
          }),
          (u.prototype.getOrdinalMeta = function () {
            return this.__ordinalMeta
          }),
          (u.type = t + 'Axis.' + a),
          (u.defaultOption = o),
          u
        )
      })(e)
    r.registerComponentModel(s)
  }),
    r.registerSubTypeDefaulter(t + 'Axis', YI)
}
function YI(r) {
  return r.type || (r.data ? 'category' : 'value')
}
var Mut = (function () {
  function r(t) {
    ;(this.type = 'cartesian'),
      (this._dimList = []),
      (this._axes = {}),
      (this.name = t || '')
  }
  return (
    (r.prototype.getAxis = function (t) {
      return this._axes[t]
    }),
    (r.prototype.getAxes = function () {
      return st(
        this._dimList,
        function (t) {
          return this._axes[t]
        },
        this,
      )
    }),
    (r.prototype.getAxesByScale = function (t) {
      return (
        (t = t.toLowerCase()),
        Ne(this.getAxes(), function (e) {
          return e.scale.type === t
        })
      )
    }),
    (r.prototype.addAxis = function (t) {
      var e = t.dim
      ;(this._axes[e] = t), this._dimList.push(e)
    }),
    r
  )
})()
const Tut = Mut
var Rw = ['x', 'y']
function $I(r) {
  return r.type === 'interval' || r.type === 'time'
}
var Cut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'cartesian2d'), (e.dimensions = Rw), e
    }
    return (
      (t.prototype.calcAffineTransform = function () {
        this._transform = this._invTransform = null
        var e = this.getAxis('x').scale,
          n = this.getAxis('y').scale
        if (!(!$I(e) || !$I(n))) {
          var i = e.getExtent(),
            a = n.getExtent(),
            o = this.dataToPoint([i[0], a[0]]),
            s = this.dataToPoint([i[1], a[1]]),
            l = i[1] - i[0],
            u = a[1] - a[0]
          if (!(!l || !u)) {
            var c = (s[0] - o[0]) / l,
              h = (s[1] - o[1]) / u,
              f = o[0] - i[0] * c,
              d = o[1] - a[0] * h,
              p = (this._transform = [c, 0, 0, h, f, d])
            this._invTransform = mf([], p)
          }
        }
      }),
      (t.prototype.getBaseAxis = function () {
        return (
          this.getAxesByScale('ordinal')[0] ||
          this.getAxesByScale('time')[0] ||
          this.getAxis('x')
        )
      }),
      (t.prototype.containPoint = function (e) {
        var n = this.getAxis('x'),
          i = this.getAxis('y')
        return (
          n.contain(n.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]))
        )
      }),
      (t.prototype.containData = function (e) {
        return (
          this.getAxis('x').containData(e[0]) &&
          this.getAxis('y').containData(e[1])
        )
      }),
      (t.prototype.containZone = function (e, n) {
        var i = this.dataToPoint(e),
          a = this.dataToPoint(n),
          o = this.getArea(),
          s = new ee(i[0], i[1], a[0] - i[0], a[1] - i[1])
        return o.intersect(s)
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        i = i || []
        var a = e[0],
          o = e[1]
        if (
          this._transform &&
          a != null &&
          isFinite(a) &&
          o != null &&
          isFinite(o)
        )
          return pr(i, e, this._transform)
        var s = this.getAxis('x'),
          l = this.getAxis('y')
        return (
          (i[0] = s.toGlobalCoord(s.dataToCoord(a, n))),
          (i[1] = l.toGlobalCoord(l.dataToCoord(o, n))),
          i
        )
      }),
      (t.prototype.clampData = function (e, n) {
        var i = this.getAxis('x').scale,
          a = this.getAxis('y').scale,
          o = i.getExtent(),
          s = a.getExtent(),
          l = i.parse(e[0]),
          u = a.parse(e[1])
        return (
          (n = n || []),
          (n[0] = Math.min(
            Math.max(Math.min(o[0], o[1]), l),
            Math.max(o[0], o[1]),
          )),
          (n[1] = Math.min(
            Math.max(Math.min(s[0], s[1]), u),
            Math.max(s[0], s[1]),
          )),
          n
        )
      }),
      (t.prototype.pointToData = function (e, n) {
        var i = []
        if (this._invTransform) return pr(i, e, this._invTransform)
        var a = this.getAxis('x'),
          o = this.getAxis('y')
        return (
          (i[0] = a.coordToData(a.toLocalCoord(e[0]), n)),
          (i[1] = o.coordToData(o.toLocalCoord(e[1]), n)),
          i
        )
      }),
      (t.prototype.getOtherAxis = function (e) {
        return this.getAxis(e.dim === 'x' ? 'y' : 'x')
      }),
      (t.prototype.getArea = function (e) {
        e = e || 0
        var n = this.getAxis('x').getGlobalExtent(),
          i = this.getAxis('y').getGlobalExtent(),
          a = Math.min(n[0], n[1]) - e,
          o = Math.min(i[0], i[1]) - e,
          s = Math.max(n[0], n[1]) - a + e,
          l = Math.max(i[0], i[1]) - o + e
        return new ee(a, o, s, l)
      }),
      t
    )
  })(Tut),
  Eut = (function (r) {
    X(t, r)
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this
      return (
        (s.index = 0), (s.type = a || 'value'), (s.position = o || 'bottom'), s
      )
    }
    return (
      (t.prototype.isHorizontal = function () {
        var e = this.position
        return e === 'top' || e === 'bottom'
      }),
      (t.prototype.getGlobalExtent = function (e) {
        var n = this.getExtent()
        return (
          (n[0] = this.toGlobalCoord(n[0])),
          (n[1] = this.toGlobalCoord(n[1])),
          e && n[0] > n[1] && n.reverse(),
          n
        )
      }),
      (t.prototype.pointToData = function (e, n) {
        return this.coordToData(
          this.toLocalCoord(e[this.dim === 'x' ? 0 : 1]),
          n,
        )
      }),
      (t.prototype.setCategorySortInfo = function (e) {
        if (this.type !== 'category') return !1
        ;(this.model.option.categorySortInfo = e), this.scale.setSortInfo(e)
      }),
      t
    )
  })(Ra)
const Dut = Eut
function Iw(r, t, e) {
  e = e || {}
  var n = r.coordinateSystem,
    i = t.axis,
    a = {},
    o = i.getAxesOnZeroOf()[0],
    s = i.position,
    l = o ? 'onZero' : s,
    u = i.dim,
    c = n.getRect(),
    h = [c.x, c.x + c.width, c.y, c.y + c.height],
    f = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2,
    },
    d = t.get('offset') || 0,
    p = u === 'x' ? [h[2] - d, h[3] + d] : [h[0] - d, h[1] + d]
  if (o) {
    var g = o.toGlobalCoord(o.dataToCoord(0))
    p[f.onZero] = Math.max(Math.min(g, p[1]), p[0])
  }
  ;(a.position = [u === 'y' ? p[f[l]] : h[0], u === 'x' ? p[f[l]] : h[3]]),
    (a.rotation = (Math.PI / 2) * (u === 'x' ? 0 : 1))
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1,
  }
  ;(a.labelDirection = a.tickDirection = a.nameDirection = v[s]),
    (a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0),
    t.get(['axisTick', 'inside']) && (a.tickDirection = -a.tickDirection),
    nr(e.labelInside, t.get(['axisLabel', 'inside'])) &&
      (a.labelDirection = -a.labelDirection)
  var m = t.get(['axisLabel', 'rotate'])
  return (a.labelRotate = l === 'top' ? -m : m), (a.z2 = 1), a
}
function qI(r) {
  return r.get('coordinateSystem') === 'cartesian2d'
}
function ZI(r) {
  var t = {
    xAxisModel: null,
    yAxisModel: null,
  }
  return (
    R(t, function (e, n) {
      var i = n.replace(/Model$/, ''),
        a = r.getReferringComponents(i, Pn).models[0]
      t[n] = a
    }),
    t
  )
}
var oS = Math.log
function zG(r, t, e) {
  var n = ll.prototype,
    i = n.getTicks.call(e),
    a = n.getTicks.call(e, !0),
    o = i.length - 1,
    s = n.getInterval.call(e),
    l = VV(r, t),
    u = l.extent,
    c = l.fixMin,
    h = l.fixMax
  if (r.type === 'log') {
    var f = oS(r.base)
    u = [oS(u[0]) / f, oS(u[1]) / f]
  }
  r.setExtent(u[0], u[1]),
    r.calcNiceExtent({
      splitNumber: o,
      fixMin: c,
      fixMax: h,
    })
  var d = n.getExtent.call(r)
  c && (u[0] = d[0]), h && (u[1] = d[1])
  var p = n.getInterval.call(r),
    g = u[0],
    v = u[1]
  if (c && h) p = (v - g) / o
  else if (c)
    for (v = u[0] + p * o; v < u[1] && isFinite(v) && isFinite(u[1]); )
      (p = X1(p)), (v = u[0] + p * o)
  else if (h)
    for (g = u[1] - p * o; g > u[0] && isFinite(g) && isFinite(u[0]); )
      (p = X1(p)), (g = u[1] - p * o)
  else {
    var m = r.getTicks().length - 1
    m > o && (p = X1(p))
    var y = p * o
    ;(v = Math.ceil(u[1] / p) * p),
      (g = mn(v - y)),
      g < 0 && u[0] >= 0
        ? ((g = 0), (v = mn(y)))
        : v > 0 && u[1] <= 0 && ((v = 0), (g = -mn(y)))
  }
  var _ = (i[0].value - a[0].value) / s,
    x = (i[o].value - a[o].value) / s
  n.setExtent.call(r, g + p * _, v + p * x),
    n.setInterval.call(r, p),
    (_ || x) && n.setNiceExtent.call(r, g + p, v - p)
}
var Lut = (function () {
  function r(t, e, n) {
    ;(this.type = 'grid'),
      (this._coordsMap = {}),
      (this._coordsList = []),
      (this._axesMap = {}),
      (this._axesList = []),
      (this.axisPointerEnabled = !0),
      (this.dimensions = Rw),
      this._initCartesian(t, e, n),
      (this.model = t)
  }
  return (
    (r.prototype.getRect = function () {
      return this._rect
    }),
    (r.prototype.update = function (t, e) {
      var n = this._axesMap
      this._updateScale(t, this.model)
      function i(o) {
        var s,
          l = pe(o),
          u = l.length
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h],
              d = o[f],
              p = d.model,
              g = d.scale
            Mw(g) && p.get('alignTicks') && p.get('interval') == null
              ? c.push(d)
              : (af(g, p), Mw(g) && (s = d))
          }
          c.length &&
            (s || ((s = c.pop()), af(s.scale, s.model)),
            R(c, function (v) {
              zG(v.scale, v.model, s.scale)
            }))
        }
      }
      i(n.x), i(n.y)
      var a = {}
      R(n.x, function (o) {
        KI(n, 'y', o, a)
      }),
        R(n.y, function (o) {
          KI(n, 'x', o, a)
        }),
        this.resize(this.model, e)
    }),
    (r.prototype.resize = function (t, e, n) {
      var i = t.getBoxLayoutParams(),
        a = !n && t.get('containLabel'),
        o = Vn(i, {
          width: e.getWidth(),
          height: e.getHeight(),
        })
      this._rect = o
      var s = this._axesList
      l(),
        a &&
          (R(s, function (u) {
            if (!u.model.get(['axisLabel', 'inside'])) {
              var c = Got(u)
              if (c) {
                var h = u.isHorizontal() ? 'height' : 'width',
                  f = u.model.get(['axisLabel', 'margin'])
                ;(o[h] -= c[h] + f),
                  u.position === 'top'
                    ? (o.y += c.height + f)
                    : u.position === 'left' && (o.x += c.width + f)
              }
            }
          }),
          l()),
        R(this._coordsList, function (u) {
          u.calcAffineTransform()
        })
      function l() {
        R(s, function (u) {
          var c = u.isHorizontal(),
            h = c ? [0, o.width] : [0, o.height],
            f = u.inverse ? 1 : 0
          u.setExtent(h[f], h[1 - f]), Put(u, c ? o.x : o.y)
        })
      }
    }),
    (r.prototype.getAxis = function (t, e) {
      var n = this._axesMap[t]
      if (n != null) return n[e || 0]
    }),
    (r.prototype.getAxes = function () {
      return this._axesList.slice()
    }),
    (r.prototype.getCartesian = function (t, e) {
      if (t != null && e != null) {
        var n = 'x' + t + 'y' + e
        return this._coordsMap[n]
      }
      Ut(t) && ((e = t.yAxisIndex), (t = t.xAxisIndex))
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis('x').index === t || a[i].getAxis('y').index === e)
          return a[i]
    }),
    (r.prototype.getCartesians = function () {
      return this._coordsList.slice()
    }),
    (r.prototype.convertToPixel = function (t, e, n) {
      var i = this._findConvertTarget(e)
      return i.cartesian
        ? i.cartesian.dataToPoint(n)
        : i.axis
        ? i.axis.toGlobalCoord(i.axis.dataToCoord(n))
        : null
    }),
    (r.prototype.convertFromPixel = function (t, e, n) {
      var i = this._findConvertTarget(e)
      return i.cartesian
        ? i.cartesian.pointToData(n)
        : i.axis
        ? i.axis.coordToData(i.axis.toLocalCoord(n))
        : null
    }),
    (r.prototype._findConvertTarget = function (t) {
      var e = t.seriesModel,
        n =
          t.xAxisModel ||
          (e && e.getReferringComponents('xAxis', Pn).models[0]),
        i =
          t.yAxisModel ||
          (e && e.getReferringComponents('yAxis', Pn).models[0]),
        a = t.gridModel,
        o = this._coordsList,
        s,
        l
      if (e) (s = e.coordinateSystem), re(o, s) < 0 && (s = null)
      else if (n && i) s = this.getCartesian(n.componentIndex, i.componentIndex)
      else if (n) l = this.getAxis('x', n.componentIndex)
      else if (i) l = this.getAxis('y', i.componentIndex)
      else if (a) {
        var u = a.coordinateSystem
        u === this && (s = this._coordsList[0])
      }
      return {
        cartesian: s,
        axis: l,
      }
    }),
    (r.prototype.containPoint = function (t) {
      var e = this._coordsList[0]
      if (e) return e.containPoint(t)
    }),
    (r.prototype._initCartesian = function (t, e, n) {
      var i = this,
        a = this,
        o = {
          left: !1,
          right: !1,
          top: !1,
          bottom: !1,
        },
        s = {
          x: {},
          y: {},
        },
        l = {
          x: 0,
          y: 0,
        }
      if (
        (e.eachComponent('xAxis', u('x'), this),
        e.eachComponent('yAxis', u('y'), this),
        !l.x || !l.y)
      ) {
        ;(this._axesMap = {}), (this._axesList = [])
        return
      }
      ;(this._axesMap = s),
        R(s.x, function (c, h) {
          R(s.y, function (f, d) {
            var p = 'x' + h + 'y' + d,
              g = new Cut(p)
            ;(g.master = i),
              (g.model = t),
              (i._coordsMap[p] = g),
              i._coordsList.push(g),
              g.addAxis(c),
              g.addAxis(f)
          })
        })
      function u(c) {
        return function (h, f) {
          if (sS(h, t)) {
            var d = h.get('position')
            c === 'x'
              ? d !== 'top' &&
                d !== 'bottom' &&
                (d = o.bottom ? 'top' : 'bottom')
              : d !== 'left' &&
                d !== 'right' &&
                (d = o.left ? 'right' : 'left'),
              (o[d] = !0)
            var p = new Dut(c, w_(h), [0, 0], h.get('type'), d),
              g = p.type === 'category'
            ;(p.onBand = g && h.get('boundaryGap')),
              (p.inverse = h.get('inverse')),
              (h.axis = p),
              (p.model = h),
              (p.grid = a),
              (p.index = f),
              a._axesList.push(p),
              (s[c][f] = p),
              l[c]++
          }
        }
      }
    }),
    (r.prototype._updateScale = function (t, e) {
      R(this._axesList, function (i) {
        if ((i.scale.setExtent(1 / 0, -1 / 0), i.type === 'category')) {
          var a = i.model.get('categorySortInfo')
          i.scale.setSortInfo(a)
        }
      }),
        t.eachSeries(function (i) {
          if (qI(i)) {
            var a = ZI(i),
              o = a.xAxisModel,
              s = a.yAxisModel
            if (!sS(o, e) || !sS(s, e)) return
            var l = this.getCartesian(o.componentIndex, s.componentIndex),
              u = i.getData(),
              c = l.getAxis('x'),
              h = l.getAxis('y')
            n(u, c), n(u, h)
          }
        }, this)
      function n(i, a) {
        R(o0(i, a.dim), function (o) {
          a.scale.unionExtentFromData(i, o)
        })
      }
    }),
    (r.prototype.getTooltipAxes = function (t) {
      var e = [],
        n = []
      return (
        R(this.getCartesians(), function (i) {
          var a = t != null && t !== 'auto' ? i.getAxis(t) : i.getBaseAxis(),
            o = i.getOtherAxis(a)
          re(e, a) < 0 && e.push(a), re(n, o) < 0 && n.push(o)
        }),
        {
          baseAxes: e,
          otherAxes: n,
        }
      )
    }),
    (r.create = function (t, e) {
      var n = []
      return (
        t.eachComponent('grid', function (i, a) {
          var o = new r(i, t, e)
          ;(o.name = 'grid_' + a),
            o.resize(i, e, !0),
            (i.coordinateSystem = o),
            n.push(o)
        }),
        t.eachSeries(function (i) {
          if (qI(i)) {
            var a = ZI(i),
              o = a.xAxisModel,
              s = a.yAxisModel,
              l = o.getCoordSysModel(),
              u = l.coordinateSystem
            i.coordinateSystem = u.getCartesian(
              o.componentIndex,
              s.componentIndex,
            )
          }
        }),
        n
      )
    }),
    (r.dimensions = Rw),
    r
  )
})()
function sS(r, t) {
  return r.getCoordSysModel() === t
}
function KI(r, t, e, n) {
  e.getAxesOnZeroOf = function () {
    return a ? [a] : []
  }
  var i = r[t],
    a,
    o = e.model,
    s = o.get(['axisLine', 'onZero']),
    l = o.get(['axisLine', 'onZeroAxisIndex'])
  if (!s) return
  if (l != null) jI(i[l]) && (a = i[l])
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && jI(i[u]) && !n[c(i[u])]) {
        a = i[u]
        break
      }
  a && (n[c(a)] = !0)
  function c(h) {
    return h.dim + '_' + h.index
  }
}
function jI(r) {
  return r && r.type !== 'category' && r.type !== 'time' && Vot(r)
}
function Put(r, t) {
  var e = r.getExtent(),
    n = e[0] + e[1]
  ;(r.toGlobalCoord =
    r.dim === 'x'
      ? function (i) {
          return i + t
        }
      : function (i) {
          return n - i + t
        }),
    (r.toLocalCoord =
      r.dim === 'x'
        ? function (i) {
            return i - t
          }
        : function (i) {
            return n - i + t
          })
}
const Rut = Lut
var Gs = Math.PI,
  Fu = (function () {
    function r(t, e) {
      ;(this.group = new Ht()),
        (this.opt = e),
        (this.axisModel = t),
        zt(e, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: !0,
          handleAutoShown: function () {
            return !0
          },
        })
      var n = new Ht({
        x: e.position[0],
        y: e.position[1],
        rotation: e.rotation,
      })
      n.updateTransform(), (this._transformGroup = n)
    }
    return (
      (r.prototype.hasBuilder = function (t) {
        return !!JI[t]
      }),
      (r.prototype.add = function (t) {
        JI[t](this.opt, this.axisModel, this.group, this._transformGroup)
      }),
      (r.prototype.getGroup = function () {
        return this.group
      }),
      (r.innerTextLayout = function (t, e, n) {
        var i = kz(e - t),
          a,
          o
        return (
          Up(i)
            ? ((o = n > 0 ? 'top' : 'bottom'), (a = 'center'))
            : Up(i - Gs)
            ? ((o = n > 0 ? 'bottom' : 'top'), (a = 'center'))
            : ((o = 'middle'),
              i > 0 && i < Gs
                ? (a = n > 0 ? 'right' : 'left')
                : (a = n > 0 ? 'left' : 'right')),
          {
            rotation: i,
            textAlign: a,
            textVerticalAlign: o,
          }
        )
      }),
      (r.makeAxisEventDataBase = function (t) {
        var e = {
          componentType: t.mainType,
          componentIndex: t.componentIndex,
        }
        return (e[t.mainType + 'Index'] = t.componentIndex), e
      }),
      (r.isLabelSilent = function (t) {
        var e = t.get('tooltip')
        return t.get('silent') || !(t.get('triggerEvent') || (e && e.show))
      }),
      r
    )
  })(),
  JI = {
    axisLine: function (r, t, e, n) {
      var i = t.get(['axisLine', 'show'])
      if (
        (i === 'auto' &&
          r.handleAutoShown &&
          (i = r.handleAutoShown('axisLine')),
        !!i)
      ) {
        var a = t.axis.getExtent(),
          o = n.transform,
          s = [a[0], 0],
          l = [a[1], 0],
          u = s[0] > l[0]
        o && (pr(s, s, o), pr(l, l, o))
        var c = Q(
            {
              lineCap: 'round',
            },
            t.getModel(['axisLine', 'lineStyle']).getLineStyle(),
          ),
          h = new rr({
            shape: {
              x1: s[0],
              y1: s[1],
              x2: l[0],
              y2: l[1],
            },
            style: c,
            strokeContainThreshold: r.strokeContainThreshold || 5,
            silent: !0,
            z2: 1,
          })
        ef(h.shape, h.style.lineWidth), (h.anid = 'line'), e.add(h)
        var f = t.get(['axisLine', 'symbol'])
        if (f != null) {
          var d = t.get(['axisLine', 'symbolSize'])
          bt(f) && (f = [f, f]), (bt(d) || be(d)) && (d = [d, d])
          var p = ic(t.get(['axisLine', 'symbolOffset']) || 0, d),
            g = d[0],
            v = d[1]
          R(
            [
              {
                rotate: r.rotation + Math.PI / 2,
                offset: p[0],
                r: 0,
              },
              {
                rotate: r.rotation - Math.PI / 2,
                offset: p[1],
                r: Math.sqrt(
                  (s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]),
                ),
              },
            ],
            function (m, y) {
              if (f[y] !== 'none' && f[y] != null) {
                var _ = Rn(f[y], -g / 2, -v / 2, g, v, c.stroke, !0),
                  x = m.r + m.offset,
                  A = u ? l : s
                _.attr({
                  rotation: m.rotate,
                  x: A[0] + x * Math.cos(r.rotation),
                  y: A[1] - x * Math.sin(r.rotation),
                  silent: !0,
                  z2: 11,
                }),
                  e.add(_)
              }
            },
          )
        }
      }
    },
    axisTickLabel: function (r, t, e, n) {
      var i = Nut(e, n, t, r),
        a = But(e, n, t, r)
      if (
        (Out(t, a, i),
        kut(e, n, t, r.tickDirection),
        t.get(['axisLabel', 'hideOverlap']))
      ) {
        var o = eG(
          st(a, function (s) {
            return {
              label: s,
              priority: s.z2,
              defaultAttr: {
                ignore: s.ignore,
              },
            }
          }),
        )
        iG(o)
      }
    },
    axisName: function (r, t, e, n) {
      var i = nr(r.axisName, t.get('name'))
      if (i) {
        var a = t.get('nameLocation'),
          o = r.nameDirection,
          s = t.getModel('nameTextStyle'),
          l = t.get('nameGap') || 0,
          u = t.axis.getExtent(),
          c = u[0] > u[1] ? -1 : 1,
          h = [
            a === 'start'
              ? u[0] - c * l
              : a === 'end'
              ? u[1] + c * l
              : (u[0] + u[1]) / 2,
            tO(a) ? r.labelOffset + o * l : 0,
          ],
          f,
          d = t.get('nameRotate')
        d != null && (d = (d * Gs) / 180)
        var p
        tO(a)
          ? (f = Fu.innerTextLayout(r.rotation, d ?? r.rotation, o))
          : ((f = Iut(r.rotation, a, d || 0, u)),
            (p = r.axisNameAvailableWidth),
            p != null &&
              ((p = Math.abs(p / Math.sin(f.rotation))),
              !isFinite(p) && (p = null)))
        var g = s.getFont(),
          v = t.get('nameTruncate', !0) || {},
          m = v.ellipsis,
          y = nr(r.nameTruncateMaxWidth, v.maxWidth, p),
          _ = new Ae({
            x: h[0],
            y: h[1],
            rotation: f.rotation,
            silent: Fu.isLabelSilent(t),
            style: $e(s, {
              text: i,
              font: g,
              overflow: 'truncate',
              width: y,
              ellipsis: m,
              fill:
                s.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              align: s.get('align') || f.textAlign,
              verticalAlign: s.get('verticalAlign') || f.textVerticalAlign,
            }),
            z2: 1,
          })
        if (
          (Sf({
            el: _,
            componentModel: t,
            itemName: i,
          }),
          (_.__fullText = i),
          (_.anid = 'name'),
          t.get('triggerEvent'))
        ) {
          var x = Fu.makeAxisEventDataBase(t)
          ;(x.targetType = 'axisName'), (x.name = i), (Wt(_).eventData = x)
        }
        n.add(_), _.updateTransform(), e.add(_), _.decomposeTransform()
      }
    },
  }
function Iut(r, t, e, n) {
  var i = kz(e - r),
    a,
    o,
    s = n[0] > n[1],
    l = (t === 'start' && !s) || (t !== 'start' && s)
  return (
    Up(i - Gs / 2)
      ? ((o = l ? 'bottom' : 'top'), (a = 'center'))
      : Up(i - Gs * 1.5)
      ? ((o = l ? 'top' : 'bottom'), (a = 'center'))
      : ((o = 'middle'),
        i < Gs * 1.5 && i > Gs / 2
          ? (a = l ? 'left' : 'right')
          : (a = l ? 'right' : 'left')),
    {
      rotation: i,
      textAlign: a,
      textVerticalAlign: o,
    }
  )
}
function Out(r, t, e) {
  if (!GV(r.axis)) {
    var n = r.get(['axisLabel', 'showMinLabel']),
      i = r.get(['axisLabel', 'showMaxLabel'])
    ;(t = t || []), (e = e || [])
    var a = t[0],
      o = t[1],
      s = t[t.length - 1],
      l = t[t.length - 2],
      u = e[0],
      c = e[1],
      h = e[e.length - 1],
      f = e[e.length - 2]
    n === !1
      ? (Ri(a), Ri(u))
      : QI(a, o) && (n ? (Ri(o), Ri(c)) : (Ri(a), Ri(u))),
      i === !1
        ? (Ri(s), Ri(h))
        : QI(l, s) && (i ? (Ri(l), Ri(f)) : (Ri(s), Ri(h)))
  }
}
function Ri(r) {
  r && (r.ignore = !0)
}
function QI(r, t) {
  var e = r && r.getBoundingRect().clone(),
    n = t && t.getBoundingRect().clone()
  if (!(!e || !n)) {
    var i = Z0([])
    return (
      ec(i, i, -r.rotation),
      e.applyTransform(Ho([], i, r.getLocalTransform())),
      n.applyTransform(Ho([], i, t.getLocalTransform())),
      e.intersect(n)
    )
  }
}
function tO(r) {
  return r === 'middle' || r === 'center'
}
function UG(r, t, e, n, i) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord
    ;(o[0] = u),
      (o[1] = 0),
      (s[0] = u),
      (s[1] = e),
      t && (pr(o, o, t), pr(s, s, t))
    var c = new rr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1],
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0,
    })
    ef(c.shape, c.style.lineWidth),
      (c.anid = i + '_' + r[l].tickValue),
      a.push(c)
  }
  return a
}
function Nut(r, t, e, n) {
  var i = e.axis,
    a = e.getModel('axisTick'),
    o = a.get('show')
  if (
    (o === 'auto' && n.handleAutoShown && (o = n.handleAutoShown('axisTick')),
    !(!o || i.scale.isBlank()))
  ) {
    for (
      var s = a.getModel('lineStyle'),
        l = n.tickDirection * a.get('length'),
        u = i.getTicksCoords(),
        c = UG(
          u,
          t.transform,
          l,
          zt(s.getLineStyle(), {
            stroke: e.get(['axisLine', 'lineStyle', 'color']),
          }),
          'ticks',
        ),
        h = 0;
      h < c.length;
      h++
    )
      r.add(c[h])
    return c
  }
}
function kut(r, t, e, n) {
  var i = e.axis,
    a = e.getModel('minorTick')
  if (!(!a.get('show') || i.scale.isBlank())) {
    var o = i.getMinorTicksCoords()
    if (o.length)
      for (
        var s = a.getModel('lineStyle'),
          l = n * a.get('length'),
          u = zt(
            s.getLineStyle(),
            zt(e.getModel('axisTick').getLineStyle(), {
              stroke: e.get(['axisLine', 'lineStyle', 'color']),
            }),
          ),
          c = 0;
        c < o.length;
        c++
      )
        for (
          var h = UG(o[c], t.transform, l, u, 'minorticks_' + c), f = 0;
          f < h.length;
          f++
        )
          r.add(h[f])
  }
}
function But(r, t, e, n) {
  var i = e.axis,
    a = nr(n.axisLabelShow, e.get(['axisLabel', 'show']))
  if (!(!a || i.scale.isBlank())) {
    var o = e.getModel('axisLabel'),
      s = o.get('margin'),
      l = i.getViewLabels(),
      u = ((nr(n.labelRotate, o.get('rotate')) || 0) * Gs) / 180,
      c = Fu.innerTextLayout(n.rotation, u, n.labelDirection),
      h = e.getCategories && e.getCategories(!0),
      f = [],
      d = Fu.isLabelSilent(e),
      p = e.get('triggerEvent')
    return (
      R(l, function (g, v) {
        var m =
            i.scale.type === 'ordinal'
              ? i.scale.getRawOrdinalNumber(g.tickValue)
              : g.tickValue,
          y = g.formattedLabel,
          _ = g.rawLabel,
          x = o
        if (h && h[m]) {
          var A = h[m]
          Ut(A) && A.textStyle && (x = new qe(A.textStyle, o, e.ecModel))
        }
        var S = x.getTextColor() || e.get(['axisLine', 'lineStyle', 'color']),
          b = i.dataToCoord(m),
          T = x.getShallow('align', !0) || c.textAlign,
          w = $t(x.getShallow('alignMinLabel', !0), T),
          M = $t(x.getShallow('alignMaxLabel', !0), T),
          C =
            x.getShallow('verticalAlign', !0) ||
            x.getShallow('baseline', !0) ||
            c.textVerticalAlign,
          E = $t(x.getShallow('verticalAlignMinLabel', !0), C),
          D = $t(x.getShallow('verticalAlignMaxLabel', !0), C),
          P = new Ae({
            x: b,
            y: n.labelOffset + n.labelDirection * s,
            rotation: c.rotation,
            silent: d,
            z2: 10 + (g.level || 0),
            style: $e(x, {
              text: y,
              align: v === 0 ? w : v === l.length - 1 ? M : T,
              verticalAlign: v === 0 ? E : v === l.length - 1 ? D : C,
              fill: Nt(S)
                ? S(
                    i.type === 'category' ? _ : i.type === 'value' ? m + '' : m,
                    v,
                  )
                : S,
            }),
          })
        if (((P.anid = 'label_' + m), p)) {
          var L = Fu.makeAxisEventDataBase(e)
          ;(L.targetType = 'axisLabel'),
            (L.value = _),
            (L.tickIndex = v),
            i.type === 'category' && (L.dataIndex = m),
            (Wt(P).eventData = L)
        }
        t.add(P),
          P.updateTransform(),
          f.push(P),
          r.add(P),
          P.decomposeTransform()
      }),
      f
    )
  }
}
const ns = Fu
function Fut(r, t) {
  var e = {
    axesInfo: {},
    seriesInvolved: !1,
    coordSysAxesInfo: {},
    coordSysMap: {},
  }
  return zut(e, r, t), e.seriesInvolved && Vut(e, r), e
}
function zut(r, t, e) {
  var n = t.getComponent('tooltip'),
    i = t.getComponent('axisPointer'),
    a = i.get('link', !0) || [],
    o = []
  R(e.getCoordinateSystems(), function (s) {
    if (!s.axisPointerEnabled) return
    var l = ev(s.model),
      u = (r.coordSysAxesInfo[l] = {})
    r.coordSysMap[l] = s
    var c = s.model,
      h = c.getModel('tooltip', n)
    if (
      (R(s.getAxes(), Zt(g, !1, null)), s.getTooltipAxes && n && h.get('show'))
    ) {
      var f = h.get('trigger') === 'axis',
        d = h.get(['axisPointer', 'type']) === 'cross',
        p = s.getTooltipAxes(h.get(['axisPointer', 'axis']))
      ;(f || d) && R(p.baseAxes, Zt(g, d ? 'cross' : !0, f)),
        d && R(p.otherAxes, Zt(g, 'cross', !1))
    }
    function g(v, m, y) {
      var _ = y.model.getModel('axisPointer', i),
        x = _.get('show')
      if (!(!x || (x === 'auto' && !v && !Ow(_)))) {
        m == null && (m = _.get('triggerTooltip')),
          (_ = v ? Uut(y, h, i, t, v, m) : _)
        var A = _.get('snap'),
          S = _.get('triggerEmphasis'),
          b = ev(y.model),
          T = m || A || y.type === 'category',
          w = (r.axesInfo[b] = {
            key: b,
            axis: y,
            coordSys: s,
            axisPointerModel: _,
            triggerTooltip: m,
            triggerEmphasis: S,
            involveSeries: T,
            snap: A,
            useHandle: Ow(_),
            seriesModels: [],
            linkGroup: null,
          })
        ;(u[b] = w), (r.seriesInvolved = r.seriesInvolved || T)
        var M = Gut(a, y)
        if (M != null) {
          var C =
            o[M] ||
            (o[M] = {
              axesInfo: {},
            })
          ;(C.axesInfo[b] = w), (C.mapper = a[M].mapper), (w.linkGroup = C)
        }
      }
    }
  })
}
function Uut(r, t, e, n, i, a) {
  var o = t.getModel('axisPointer'),
    s = [
      'type',
      'snap',
      'lineStyle',
      'shadowStyle',
      'label',
      'animation',
      'animationDurationUpdate',
      'animationEasingUpdate',
      'z',
    ],
    l = {}
  R(s, function (f) {
    l[f] = Vt(o.get(f))
  }),
    (l.snap = r.type !== 'category' && !!a),
    o.get('type') === 'cross' && (l.type = 'line')
  var u = l.label || (l.label = {})
  if ((u.show == null && (u.show = !1), i === 'cross')) {
    var c = o.get(['label', 'show'])
    if (((u.show = c ?? !0), !a)) {
      var h = (l.lineStyle = o.get('crossStyle'))
      h && zt(u, h.textStyle)
    }
  }
  return r.model.getModel('axisPointer', new qe(l, e, n))
}
function Vut(r, t) {
  t.eachSeries(function (e) {
    var n = e.coordinateSystem,
      i = e.get(['tooltip', 'trigger'], !0),
      a = e.get(['tooltip', 'show'], !0)
    !n ||
      i === 'none' ||
      i === !1 ||
      i === 'item' ||
      a === !1 ||
      e.get(['axisPointer', 'show'], !0) === !1 ||
      R(r.coordSysAxesInfo[ev(n.model)], function (o) {
        var s = o.axis
        n.getAxis(s.dim) === s &&
          (o.seriesModels.push(e),
          o.seriesDataCount == null && (o.seriesDataCount = 0),
          (o.seriesDataCount += e.getData().count()))
      })
  })
}
function Gut(r, t) {
  for (var e = t.model, n = t.dim, i = 0; i < r.length; i++) {
    var a = r[i] || {}
    if (
      lS(a[n + 'AxisId'], e.id) ||
      lS(a[n + 'AxisIndex'], e.componentIndex) ||
      lS(a[n + 'AxisName'], e.name)
    )
      return i
  }
}
function lS(r, t) {
  return r === 'all' || (at(r) && re(r, t) >= 0) || r === t
}
function Hut(r) {
  var t = FC(r)
  if (t) {
    var e = t.axisPointerModel,
      n = t.axis.scale,
      i = e.option,
      a = e.get('status'),
      o = e.get('value')
    o != null && (o = n.parse(o))
    var s = Ow(e)
    a == null && (i.status = s ? 'show' : 'hide')
    var l = n.getExtent().slice()
    l[0] > l[1] && l.reverse(),
      (o == null || o > l[1]) && (o = l[1]),
      o < l[0] && (o = l[0]),
      (i.value = o),
      s && (i.status = t.axis.scale.isBlank() ? 'hide' : 'show')
  }
}
function FC(r) {
  var t = (r.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo
  return t && t.axesInfo[ev(r)]
}
function Wut(r) {
  var t = FC(r)
  return t && t.axisPointerModel
}
function Ow(r) {
  return !!r.get(['handle', 'show'])
}
function ev(r) {
  return r.type + '||' + r.id
}
var eO = {},
  Xut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this.axisPointerClass && Hut(e),
          r.prototype.render.apply(this, arguments),
          this._doUpdateAxisPointerClass(e, i, !0)
      }),
      (t.prototype.updateAxisPointer = function (e, n, i, a) {
        this._doUpdateAxisPointerClass(e, i, !1)
      }),
      (t.prototype.remove = function (e, n) {
        var i = this._axisPointer
        i && i.remove(n)
      }),
      (t.prototype.dispose = function (e, n) {
        this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._doUpdateAxisPointerClass = function (e, n, i) {
        var a = t.getAxisPointerClass(this.axisPointerClass)
        if (a) {
          var o = Wut(e)
          o
            ? (this._axisPointer || (this._axisPointer = new a())).render(
                e,
                o,
                n,
                i,
              )
            : this._disposeAxisPointer(n)
        }
      }),
      (t.prototype._disposeAxisPointer = function (e) {
        this._axisPointer && this._axisPointer.dispose(e),
          (this._axisPointer = null)
      }),
      (t.registerAxisPointerClass = function (e, n) {
        eO[e] = n
      }),
      (t.getAxisPointerClass = function (e) {
        return e && eO[e]
      }),
      (t.type = 'axis'),
      t
    )
  })(dn)
const sc = Xut
var Nw = ve()
function VG(r, t, e, n) {
  var i = e.axis
  if (!i.scale.isBlank()) {
    var a = e.getModel('splitArea'),
      o = a.getModel('areaStyle'),
      s = o.get('color'),
      l = n.coordinateSystem.getRect(),
      u = i.getTicksCoords({
        tickModel: a,
        clamp: !0,
      })
    if (u.length) {
      var c = s.length,
        h = Nw(r).splitAreaColors,
        f = Pt(),
        d = 0
      if (h)
        for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue)
          if (g != null) {
            d = (g + (c - 1) * p) % c
            break
          }
        }
      var v = i.toGlobalCoord(u[0].coord),
        m = o.getAreaStyle()
      s = at(s) ? s : [s]
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord),
          _ = void 0,
          x = void 0,
          A = void 0,
          S = void 0
        i.isHorizontal()
          ? ((_ = v), (x = l.y), (A = y - _), (S = l.height), (v = _ + A))
          : ((_ = l.x), (x = v), (A = l.width), (S = y - x), (v = x + S))
        var b = u[p - 1].tickValue
        b != null && f.set(b, d),
          t.add(
            new ge({
              anid: b != null ? 'area_' + b : null,
              shape: {
                x: _,
                y: x,
                width: A,
                height: S,
              },
              style: zt(
                {
                  fill: s[d],
                },
                m,
              ),
              autoBatch: !0,
              silent: !0,
            }),
          ),
          (d = (d + 1) % c)
      }
      Nw(r).splitAreaColors = f
    }
  }
}
function GG(r) {
  Nw(r).splitAreaColors = null
}
var Yut = ['axisLine', 'axisTickLabel', 'axisName'],
  $ut = ['splitArea', 'splitLine', 'minorSplitLine'],
  HG = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'CartesianAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this.group.removeAll()
        var o = this._axisGroup
        if (
          ((this._axisGroup = new Ht()),
          this.group.add(this._axisGroup),
          !!e.get('show'))
        ) {
          var s = e.getCoordSysModel(),
            l = Iw(s, e),
            u = new ns(
              e,
              Q(
                {
                  handleAutoShown: function (h) {
                    for (
                      var f = s.coordinateSystem.getCartesians(), d = 0;
                      d < f.length;
                      d++
                    )
                      if (Mw(f[d].getOtherAxis(e.axis).scale)) return !0
                    return !1
                  },
                },
                l,
              ),
            )
          R(Yut, u.add, u),
            this._axisGroup.add(u.getGroup()),
            R(
              $ut,
              function (h) {
                e.get([h, 'show']) && qut[h](this, this._axisGroup, e, s)
              },
              this,
            )
          var c = a && a.type === 'changeAxisOrder' && a.isInitSort
          c || xv(o, this._axisGroup, e),
            r.prototype.render.call(this, e, n, i, a)
        }
      }),
      (t.prototype.remove = function () {
        GG(this)
      }),
      (t.type = 'cartesianAxis'),
      t
    )
  })(sc),
  qut = {
    splitLine: function (r, t, e, n) {
      var i = e.axis
      if (!i.scale.isBlank()) {
        var a = e.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = at(s) ? s : [s]
        for (
          var l = n.coordinateSystem.getRect(),
            u = i.isHorizontal(),
            c = 0,
            h = i.getTicksCoords({
              tickModel: a,
            }),
            f = [],
            d = [],
            p = o.getLineStyle(),
            g = 0;
          g < h.length;
          g++
        ) {
          var v = i.toGlobalCoord(h[g].coord)
          u
            ? ((f[0] = v), (f[1] = l.y), (d[0] = v), (d[1] = l.y + l.height))
            : ((f[0] = l.x), (f[1] = v), (d[0] = l.x + l.width), (d[1] = v))
          var m = c++ % s.length,
            y = h[g].tickValue,
            _ = new rr({
              anid: y != null ? 'line_' + h[g].tickValue : null,
              autoBatch: !0,
              shape: {
                x1: f[0],
                y1: f[1],
                x2: d[0],
                y2: d[1],
              },
              style: zt(
                {
                  stroke: s[m],
                },
                p,
              ),
              silent: !0,
            })
          ef(_.shape, p.lineWidth), t.add(_)
        }
      }
    },
    minorSplitLine: function (r, t, e, n) {
      var i = e.axis,
        a = e.getModel('minorSplitLine'),
        o = a.getModel('lineStyle'),
        s = n.coordinateSystem.getRect(),
        l = i.isHorizontal(),
        u = i.getMinorTicksCoords()
      if (u.length)
        for (var c = [], h = [], f = o.getLineStyle(), d = 0; d < u.length; d++)
          for (var p = 0; p < u[d].length; p++) {
            var g = i.toGlobalCoord(u[d][p].coord)
            l
              ? ((c[0] = g), (c[1] = s.y), (h[0] = g), (h[1] = s.y + s.height))
              : ((c[0] = s.x), (c[1] = g), (h[0] = s.x + s.width), (h[1] = g))
            var v = new rr({
              anid: 'minor_line_' + u[d][p].tickValue,
              autoBatch: !0,
              shape: {
                x1: c[0],
                y1: c[1],
                x2: h[0],
                y2: h[1],
              },
              style: f,
              silent: !0,
            })
            ef(v.shape, f.lineWidth), t.add(v)
          }
    },
    splitArea: function (r, t, e, n) {
      VG(r, t, e, n)
    },
  },
  WG = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'xAxis'), t
  })(HG),
  Zut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = WG.type), e
    }
    return (t.type = 'yAxis'), t
  })(HG),
  Kut = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'grid'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        this.group.removeAll(),
          e.get('show') &&
            this.group.add(
              new ge({
                shape: e.coordinateSystem.getRect(),
                style: zt(
                  {
                    fill: e.get('backgroundColor'),
                  },
                  e.getItemStyle(),
                ),
                silent: !0,
                z2: -1,
              }),
            )
      }),
      (t.type = 'grid'),
      t
    )
  })(dn),
  nO = {
    offset: 0,
  }
function XG(r) {
  r.registerComponentView(Kut),
    r.registerComponentModel(xut),
    r.registerCoordinateSystem('cartesian2d', Rut),
    sf(r, 'x', Pw, nO),
    sf(r, 'y', Pw, nO),
    r.registerComponentView(WG),
    r.registerComponentView(Zut),
    r.registerPreprocessor(function (t) {
      t.xAxis && t.yAxis && !t.grid && (t.grid = {})
    })
}
function jut(r) {
  ie(XG),
    r.registerSeriesModel(fut),
    r.registerChartView(yut),
    r.registerLayout(Dv('scatter'))
}
function Jut(r) {
  r.eachSeriesByType('radar', function (t) {
    var e = t.getData(),
      n = [],
      i = t.coordinateSystem
    if (i) {
      var a = i.getIndicatorAxes()
      R(a, function (o, s) {
        e.each(e.mapDimension(a[s].dim), function (l, u) {
          n[u] = n[u] || []
          var c = i.dataToPoint(l, s)
          n[u][s] = rO(c) ? c : iO(i)
        })
      }),
        e.each(function (o) {
          var s =
            OJ(n[o], function (l) {
              return rO(l)
            }) || iO(i)
          n[o].push(s.slice()), e.setItemLayout(o, n[o])
        })
    }
  })
}
function rO(r) {
  return !isNaN(r[0]) && !isNaN(r[1])
}
function iO(r) {
  return [r.cx, r.cy]
}
function Qut(r) {
  var t = r.polar
  if (t) {
    at(t) || (t = [t])
    var e = []
    R(t, function (n, i) {
      n.indicator
        ? (n.type && !n.shape && (n.shape = n.type),
          (r.radar = r.radar || []),
          at(r.radar) || (r.radar = [r.radar]),
          r.radar.push(n))
        : e.push(n)
    }),
      (r.polar = e)
  }
  R(r.series, function (n) {
    n && n.type === 'radar' && n.polarIndex && (n.radarIndex = n.polarIndex)
  })
}
var tct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.coordinateSystem,
        o = this.group,
        s = e.getData(),
        l = this._data
      function u(f, d) {
        var p = f.getItemVisual(d, 'symbol') || 'circle'
        if (p !== 'none') {
          var g = Lf(f.getItemVisual(d, 'symbolSize')),
            v = Rn(p, -1, -1, 2, 2),
            m = f.getItemVisual(d, 'symbolRotate') || 0
          return (
            v.attr({
              style: {
                strokeNoScale: !0,
              },
              z2: 100,
              scaleX: g[0] / 2,
              scaleY: g[1] / 2,
              rotation: (m * Math.PI) / 180 || 0,
            }),
            v
          )
        }
      }
      function c(f, d, p, g, v, m) {
        p.removeAll()
        for (var y = 0; y < d.length - 1; y++) {
          var _ = u(g, v)
          _ &&
            ((_.__dimIdx = y),
            f[y]
              ? (_.setPosition(f[y]),
                nc[m ? 'initProps' : 'updateProps'](
                  _,
                  {
                    x: d[y][0],
                    y: d[y][1],
                  },
                  e,
                  v,
                ))
              : _.setPosition(d[y]),
            p.add(_))
        }
      }
      function h(f) {
        return st(f, function (d) {
          return [a.cx, a.cy]
        })
      }
      s
        .diff(l)
        .add(function (f) {
          var d = s.getItemLayout(f)
          if (d) {
            var p = new si(),
              g = new li(),
              v = {
                shape: {
                  points: d,
                },
              }
            ;(p.shape.points = h(d)),
              (g.shape.points = h(d)),
              Je(p, v, e, f),
              Je(g, v, e, f)
            var m = new Ht(),
              y = new Ht()
            m.add(g),
              m.add(p),
              m.add(y),
              c(g.shape.points, d, y, s, f, !0),
              s.setItemGraphicEl(f, m)
          }
        })
        .update(function (f, d) {
          var p = l.getItemGraphicEl(d),
            g = p.childAt(0),
            v = p.childAt(1),
            m = p.childAt(2),
            y = {
              shape: {
                points: s.getItemLayout(f),
              },
            }
          y.shape.points &&
            (c(g.shape.points, y.shape.points, m, s, f, !1),
            Ca(v),
            Ca(g),
            we(g, y, e),
            we(v, y, e),
            s.setItemGraphicEl(f, p))
        })
        .remove(function (f) {
          o.remove(l.getItemGraphicEl(f))
        })
        .execute(),
        s.eachItemGraphicEl(function (f, d) {
          var p = s.getItemModel(d),
            g = f.childAt(0),
            v = f.childAt(1),
            m = f.childAt(2),
            y = s.getItemVisual(d, 'style'),
            _ = y.fill
          o.add(f),
            g.useStyle(
              zt(p.getModel('lineStyle').getLineStyle(), {
                fill: 'none',
                stroke: _,
              }),
            ),
            gr(g, p, 'lineStyle'),
            gr(v, p, 'areaStyle')
          var x = p.getModel('areaStyle'),
            A = x.isEmpty() && x.parentModel.isEmpty()
          ;(v.ignore = A),
            R(['emphasis', 'select', 'blur'], function (T) {
              var w = p.getModel([T, 'areaStyle']),
                M = w.isEmpty() && w.parentModel.isEmpty()
              v.ensureState(T).ignore = M && A
            }),
            v.useStyle(
              zt(x.getAreaStyle(), {
                fill: _,
                opacity: 0.7,
                decal: y.decal,
              }),
            )
          var S = p.getModel('emphasis'),
            b = S.getModel('itemStyle').getItemStyle()
          m.eachChild(function (T) {
            if (T instanceof yr) {
              var w = T.style
              T.useStyle(
                Q(
                  {
                    image: w.image,
                    x: w.x,
                    y: w.y,
                    width: w.width,
                    height: w.height,
                  },
                  y,
                ),
              )
            } else T.useStyle(y), T.setColor(_), (T.style.strokeNoScale = !0)
            var M = T.ensureState('emphasis')
            M.style = Vt(b)
            var C = s.getStore().get(s.getDimensionIndex(T.__dimIdx), d)
            ;(C == null || isNaN(C)) && (C = ''),
              mr(T, Zn(p), {
                labelFetcher: s.hostModel,
                labelDataIndex: d,
                labelDimIndex: T.__dimIdx,
                defaultText: C,
                inheritColor: _,
                defaultOpacity: y.opacity,
              })
          }),
            fn(f, S.get('focus'), S.get('blurScope'), S.get('disabled'))
        }),
        (this._data = s)
    }),
    (t.prototype.remove = function () {
      this.group.removeAll(), (this._data = null)
    }),
    (t.type = 'radar'),
    t
  )
})(Ze)
const ect = tct
var nct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments),
        (this.legendVisualProvider = new Pv(
          Tt(this.getData, this),
          Tt(this.getRawData, this),
        ))
    }),
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, {
        generateCoord: 'indicator_',
        generateCoordCount: 1 / 0,
      })
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = this.coordinateSystem,
        s = o.getIndicatorAxes(),
        l = this.getData().getName(e),
        u = l === '' ? this.name : l,
        c = F5(this, e)
      return Kn('section', {
        header: u,
        sortBlocks: !0,
        blocks: st(s, function (h) {
          var f = a.get(a.mapDimension(h.dim), e)
          return Kn('nameValue', {
            markerType: 'subItem',
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f,
          })
        }),
      })
    }),
    (t.prototype.getTooltipPosition = function (e) {
      if (e != null) {
        for (
          var n = this.getData(),
            i = this.coordinateSystem,
            a = n.getValues(
              st(i.dimensions, function (u) {
                return n.mapDimension(u)
              }),
              e,
            ),
            o = 0,
            s = a.length;
          o < s;
          o++
        )
          if (!isNaN(a[o])) {
            var l = i.getIndicatorAxes()
            return i.coordToPoint(l[o].dataToCoord(a[o]), o)
          }
      }
    }),
    (t.type = 'series.radar'),
    (t.dependencies = ['radar']),
    (t.defaultOption = {
      z: 2,
      colorBy: 'data',
      coordinateSystem: 'radar',
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: 'solid',
        join: 'round',
      },
      label: {
        position: 'top',
      },
      symbolSize: 8,
    }),
    t
  )
})(rn)
const rct = nct
var pd = FG.value
function pm(r, t) {
  return zt(
    {
      show: t,
    },
    r,
  )
}
var ict = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.optionUpdated = function () {
      var e = this.get('boundaryGap'),
        n = this.get('splitNumber'),
        i = this.get('scale'),
        a = this.get('axisLine'),
        o = this.get('axisTick'),
        s = this.get('axisLabel'),
        l = this.get('axisName'),
        u = this.get(['axisName', 'show']),
        c = this.get(['axisName', 'formatter']),
        h = this.get('axisNameGap'),
        f = this.get('triggerEvent'),
        d = st(
          this.get('indicator') || [],
          function (p) {
            p.max != null && p.max > 0 && !p.min
              ? (p.min = 0)
              : p.min != null && p.min < 0 && !p.max && (p.max = 0)
            var g = l
            p.color != null &&
              (g = zt(
                {
                  color: p.color,
                },
                l,
              ))
            var v = te(
              Vt(p),
              {
                boundaryGap: e,
                splitNumber: n,
                scale: i,
                axisLine: a,
                axisTick: o,
                axisLabel: s,
                name: p.text,
                showName: u,
                nameLocation: 'end',
                nameGap: h,
                nameTextStyle: g,
                triggerEvent: f,
              },
              !1,
            )
            if (bt(c)) {
              var m = v.name
              v.name = c.replace('{value}', m ?? '')
            } else Nt(c) && (v.name = c(v.name, v))
            var y = new qe(v, null, this.ecModel)
            return (
              In(y, Mv.prototype),
              (y.mainType = 'radar'),
              (y.componentIndex = this.componentIndex),
              y
            )
          },
          this,
        )
      this._indicatorModels = d
    }),
    (t.prototype.getIndicatorModels = function () {
      return this._indicatorModels
    }),
    (t.type = 'radar'),
    (t.defaultOption = {
      z: 0,
      center: ['50%', '50%'],
      radius: '75%',
      startAngle: 90,
      axisName: {
        show: !0,
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      shape: 'polygon',
      axisLine: te(
        {
          lineStyle: {
            color: '#bbb',
          },
        },
        pd.axisLine,
      ),
      axisLabel: pm(pd.axisLabel, !1),
      axisTick: pm(pd.axisTick, !1),
      splitLine: pm(pd.splitLine, !0),
      splitArea: pm(pd.splitArea, !0),
      indicator: [],
    }),
    t
  )
})(xe)
const act = ict
var oct = ['axisLine', 'axisTickLabel', 'axisName'],
  sct = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this.group
        a.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e)
      }),
      (t.prototype._buildAxes = function (e) {
        var n = e.coordinateSystem,
          i = n.getIndicatorAxes(),
          a = st(i, function (o) {
            var s = o.model.get('showName') ? o.name : '',
              l = new ns(o.model, {
                axisName: s,
                position: [n.cx, n.cy],
                rotation: o.angle,
                labelDirection: -1,
                tickDirection: -1,
                nameDirection: 1,
              })
            return l
          })
        R(
          a,
          function (o) {
            R(oct, o.add, o), this.group.add(o.getGroup())
          },
          this,
        )
      }),
      (t.prototype._buildSplitLineAndArea = function (e) {
        var n = e.coordinateSystem,
          i = n.getIndicatorAxes()
        if (!i.length) return
        var a = e.get('shape'),
          o = e.getModel('splitLine'),
          s = e.getModel('splitArea'),
          l = o.getModel('lineStyle'),
          u = s.getModel('areaStyle'),
          c = o.get('show'),
          h = s.get('show'),
          f = l.get('color'),
          d = u.get('color'),
          p = at(f) ? f : [f],
          g = at(d) ? d : [d],
          v = [],
          m = []
        function y(L, I, F) {
          var k = F % I.length
          return (L[k] = L[k] || []), k
        }
        if (a === 'circle')
          for (
            var _ = i[0].getTicksCoords(), x = n.cx, A = n.cy, S = 0;
            S < _.length;
            S++
          ) {
            if (c) {
              var b = y(v, p, S)
              v[b].push(
                new pl({
                  shape: {
                    cx: x,
                    cy: A,
                    r: _[S].coord,
                  },
                }),
              )
            }
            if (h && S < _.length - 1) {
              var b = y(m, g, S)
              m[b].push(
                new i_({
                  shape: {
                    cx: x,
                    cy: A,
                    r0: _[S].coord,
                    r: _[S + 1].coord,
                  },
                }),
              )
            }
          }
        else
          for (
            var T,
              w = st(i, function (L, I) {
                var F = L.getTicksCoords()
                return (
                  (T = T == null ? F.length - 1 : Math.min(F.length - 1, T)),
                  st(F, function (k) {
                    return n.coordToPoint(k.coord, I)
                  })
                )
              }),
              M = [],
              S = 0;
            S <= T;
            S++
          ) {
            for (var C = [], E = 0; E < i.length; E++) C.push(w[E][S])
            if ((C[0] && C.push(C[0].slice()), c)) {
              var b = y(v, p, S)
              v[b].push(
                new li({
                  shape: {
                    points: C,
                  },
                }),
              )
            }
            if (h && M) {
              var b = y(m, g, S - 1)
              m[b].push(
                new si({
                  shape: {
                    points: C.concat(M),
                  },
                }),
              )
            }
            M = C.slice().reverse()
          }
        var D = l.getLineStyle(),
          P = u.getAreaStyle()
        R(
          m,
          function (L, I) {
            this.group.add(
              Wi(L, {
                style: zt(
                  {
                    stroke: 'none',
                    fill: g[I % g.length],
                  },
                  P,
                ),
                silent: !0,
              }),
            )
          },
          this,
        ),
          R(
            v,
            function (L, I) {
              this.group.add(
                Wi(L, {
                  style: zt(
                    {
                      fill: 'none',
                      stroke: p[I % p.length],
                    },
                    D,
                  ),
                  silent: !0,
                }),
              )
            },
            this,
          )
      }),
      (t.type = 'radar'),
      t
    )
  })(dn)
const lct = sct
var uct = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this, e, n, i) || this
    return (a.type = 'value'), (a.angle = 0), (a.name = ''), a
  }
  return t
})(Ra)
const cct = uct
var hct = (function () {
  function r(t, e, n) {
    ;(this.dimensions = []),
      (this._model = t),
      (this._indicatorAxes = st(
        t.getIndicatorModels(),
        function (i, a) {
          var o = 'indicator_' + a,
            s = new cct(o, new ll())
          return (
            (s.name = i.get('name')),
            (s.model = i),
            (i.axis = s),
            this.dimensions.push(o),
            s
          )
        },
        this,
      )),
      this.resize(t, n)
  }
  return (
    (r.prototype.getIndicatorAxes = function () {
      return this._indicatorAxes
    }),
    (r.prototype.dataToPoint = function (t, e) {
      var n = this._indicatorAxes[e]
      return this.coordToPoint(n.dataToCoord(t), e)
    }),
    (r.prototype.coordToPoint = function (t, e) {
      var n = this._indicatorAxes[e],
        i = n.angle,
        a = this.cx + t * Math.cos(i),
        o = this.cy - t * Math.sin(i)
      return [a, o]
    }),
    (r.prototype.pointToData = function (t) {
      var e = t[0] - this.cx,
        n = t[1] - this.cy,
        i = Math.sqrt(e * e + n * n)
      ;(e /= i), (n /= i)
      for (
        var a = Math.atan2(-n, e), o = 1 / 0, s, l = -1, u = 0;
        u < this._indicatorAxes.length;
        u++
      ) {
        var c = this._indicatorAxes[u],
          h = Math.abs(a - c.angle)
        h < o && ((s = c), (l = u), (o = h))
      }
      return [l, +(s && s.coordToData(i))]
    }),
    (r.prototype.resize = function (t, e) {
      var n = t.get('center'),
        i = e.getWidth(),
        a = e.getHeight(),
        o = Math.min(i, a) / 2
      ;(this.cx = _t(n[0], i)),
        (this.cy = _t(n[1], a)),
        (this.startAngle = (t.get('startAngle') * Math.PI) / 180)
      var s = t.get('radius')
      ;(bt(s) || be(s)) && (s = [0, s]),
        (this.r0 = _t(s[0], o)),
        (this.r = _t(s[1], o)),
        R(
          this._indicatorAxes,
          function (l, u) {
            l.setExtent(this.r0, this.r)
            var c =
              this.startAngle + (u * Math.PI * 2) / this._indicatorAxes.length
            ;(c = Math.atan2(Math.sin(c), Math.cos(c))), (l.angle = c)
          },
          this,
        )
    }),
    (r.prototype.update = function (t, e) {
      var n = this._indicatorAxes,
        i = this._model
      R(n, function (s) {
        s.scale.setExtent(1 / 0, -1 / 0)
      }),
        t.eachSeriesByType(
          'radar',
          function (s, l) {
            if (
              !(
                s.get('coordinateSystem') !== 'radar' ||
                t.getComponent('radar', s.get('radarIndex')) !== i
              )
            ) {
              var u = s.getData()
              R(n, function (c) {
                c.scale.unionExtentFromData(u, u.mapDimension(c.dim))
              })
            }
          },
          this,
        )
      var a = i.get('splitNumber'),
        o = new ll()
      o.setExtent(0, a),
        o.setInterval(1),
        R(n, function (s, l) {
          zG(s.scale, s.model, o)
        })
    }),
    (r.prototype.convertToPixel = function (t, e, n) {
      return console.warn('Not implemented.'), null
    }),
    (r.prototype.convertFromPixel = function (t, e, n) {
      return console.warn('Not implemented.'), null
    }),
    (r.prototype.containPoint = function (t) {
      return console.warn('Not implemented.'), !1
    }),
    (r.create = function (t, e) {
      var n = []
      return (
        t.eachComponent('radar', function (i) {
          var a = new r(i, t, e)
          n.push(a), (i.coordinateSystem = a)
        }),
        t.eachSeriesByType('radar', function (i) {
          i.get('coordinateSystem') === 'radar' &&
            (i.coordinateSystem = n[i.get('radarIndex') || 0])
        }),
        n
      )
    }),
    (r.dimensions = []),
    r
  )
})()
const fct = hct
function dct(r) {
  r.registerCoordinateSystem('radar', fct),
    r.registerComponentModel(act),
    r.registerComponentView(lct),
    r.registerVisual({
      seriesType: 'radar',
      reset: function (t) {
        var e = t.getData()
        e.each(function (n) {
          e.setItemVisual(n, 'legendIcon', 'roundRect')
        }),
          e.setVisual('legendIcon', 'roundRect')
      },
    })
}
function pct(r) {
  ie(dct),
    r.registerChartView(ect),
    r.registerSeriesModel(rct),
    r.registerLayout(Jut),
    r.registerProcessor(Lv('radar')),
    r.registerPreprocessor(Qut)
}
var aO = '\0_ec_interaction_mutex'
function vct(r, t, e) {
  var n = zC(r)
  n[t] = e
}
function gct(r, t, e) {
  var n = zC(r),
    i = n[t]
  i === e && (n[t] = null)
}
function oO(r, t) {
  return !!zC(r)[t]
}
function zC(r) {
  return r[aO] || (r[aO] = {})
}
xo(
  {
    type: 'takeGlobalCursor',
    event: 'globalCursorTaken',
    update: 'update',
  },
  wn,
)
var mct = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this) || this
    n._zr = e
    var i = Tt(n._mousedownHandler, n),
      a = Tt(n._mousemoveHandler, n),
      o = Tt(n._mouseupHandler, n),
      s = Tt(n._mousewheelHandler, n),
      l = Tt(n._pinchHandler, n)
    return (
      (n.enable = function (u, c) {
        this.disable(),
          (this._opt = zt(Vt(c) || {}, {
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            moveOnMouseWheel: !1,
            preventDefaultMouseMove: !0,
          })),
          u == null && (u = !0),
          (u === !0 || u === 'move' || u === 'pan') &&
            (e.on('mousedown', i), e.on('mousemove', a), e.on('mouseup', o)),
          (u === !0 || u === 'scale' || u === 'zoom') &&
            (e.on('mousewheel', s), e.on('pinch', l))
      }),
      (n.disable = function () {
        e.off('mousedown', i),
          e.off('mousemove', a),
          e.off('mouseup', o),
          e.off('mousewheel', s),
          e.off('pinch', l)
      }),
      n
    )
  }
  return (
    (t.prototype.isDragging = function () {
      return this._dragging
    }),
    (t.prototype.isPinching = function () {
      return this._pinching
    }),
    (t.prototype.setPointerChecker = function (e) {
      this.pointerChecker = e
    }),
    (t.prototype.dispose = function () {
      this.disable()
    }),
    (t.prototype._mousedownHandler = function (e) {
      if (!RL(e)) {
        for (var n = e.target; n; ) {
          if (n.draggable) return
          n = n.__hostTarget || n.parent
        }
        var i = e.offsetX,
          a = e.offsetY
        this.pointerChecker &&
          this.pointerChecker(e, i, a) &&
          ((this._x = i), (this._y = a), (this._dragging = !0))
      }
    }),
    (t.prototype._mousemoveHandler = function (e) {
      if (
        !(
          !this._dragging ||
          !oy('moveOnMouseMove', e, this._opt) ||
          e.gestureEvent === 'pinch' ||
          oO(this._zr, 'globalPan')
        )
      ) {
        var n = e.offsetX,
          i = e.offsetY,
          a = this._x,
          o = this._y,
          s = n - a,
          l = i - o
        ;(this._x = n),
          (this._y = i),
          this._opt.preventDefaultMouseMove && jo(e.event),
          YG(this, 'pan', 'moveOnMouseMove', e, {
            dx: s,
            dy: l,
            oldX: a,
            oldY: o,
            newX: n,
            newY: i,
            isAvailableBehavior: null,
          })
      }
    }),
    (t.prototype._mouseupHandler = function (e) {
      RL(e) || (this._dragging = !1)
    }),
    (t.prototype._mousewheelHandler = function (e) {
      var n = oy('zoomOnMouseWheel', e, this._opt),
        i = oy('moveOnMouseWheel', e, this._opt),
        a = e.wheelDelta,
        o = Math.abs(a),
        s = e.offsetX,
        l = e.offsetY
      if (!(a === 0 || (!n && !i))) {
        if (n) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1,
            c = a > 0 ? u : 1 / u
          uS(this, 'zoom', 'zoomOnMouseWheel', e, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null,
          })
        }
        if (i) {
          var h = Math.abs(a),
            f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05)
          uS(this, 'scrollMove', 'moveOnMouseWheel', e, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null,
          })
        }
      }
    }),
    (t.prototype._pinchHandler = function (e) {
      if (!oO(this._zr, 'globalPan')) {
        var n = e.pinchScale > 1 ? 1.1 : 1 / 1.1
        uS(this, 'zoom', null, e, {
          scale: n,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null,
        })
      }
    }),
    t
  )
})(ra)
function uS(r, t, e, n, i) {
  r.pointerChecker &&
    r.pointerChecker(n, i.originX, i.originY) &&
    (jo(n.event), YG(r, t, e, n, i))
}
function YG(r, t, e, n, i) {
  ;(i.isAvailableBehavior = Tt(oy, null, e, n)), r.trigger(t, i)
}
function oy(r, t, e) {
  var n = e[r]
  return !r || (n && (!bt(n) || t.event[n + 'Key']))
}
const Rv = mct
function UC(r, t, e) {
  var n = r.target
  ;(n.x += t), (n.y += e), n.dirty()
}
function VC(r, t, e, n) {
  var i = r.target,
    a = r.zoomLimit,
    o = (r.zoom = r.zoom || 1)
  if (((o *= t), a)) {
    var s = a.min || 0,
      l = a.max || 1 / 0
    o = Math.max(Math.min(l, o), s)
  }
  var u = o / r.zoom
  ;(r.zoom = o),
    (i.x -= (e - i.x) * (u - 1)),
    (i.y -= (n - i.y) * (u - 1)),
    (i.scaleX *= u),
    (i.scaleY *= u),
    i.dirty()
}
var yct = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1,
}
function T_(r, t, e) {
  var n = t.getComponentByElement(r.topTarget),
    i = n && n.coordinateSystem
  return n && n !== e && !yct.hasOwnProperty(n.mainType) && i && i.model !== e
}
function $G(r) {
  if (bt(r)) {
    var t = new DOMParser()
    r = t.parseFromString(r, 'text/xml')
  }
  var e = r
  for (
    e.nodeType === 9 && (e = e.firstChild);
    e.nodeName.toLowerCase() !== 'svg' || e.nodeType !== 1;

  )
    e = e.nextSibling
  return e
}
var cS,
  f0 = {
    fill: 'fill',
    stroke: 'stroke',
    'stroke-width': 'lineWidth',
    opacity: 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-anchor': 'textAlign',
    visibility: 'visibility',
    display: 'display',
  },
  sO = pe(f0),
  d0 = {
    'alignment-baseline': 'textBaseline',
    'stop-color': 'stopColor',
  },
  lO = pe(d0),
  _ct = (function () {
    function r() {
      ;(this._defs = {}), (this._root = null)
    }
    return (
      (r.prototype.parse = function (t, e) {
        e = e || {}
        var n = $G(t)
        this._defsUsePending = []
        var i = new Ht()
        this._root = i
        var a = [],
          o = n.getAttribute('viewBox') || '',
          s = parseFloat(n.getAttribute('width') || e.width),
          l = parseFloat(n.getAttribute('height') || e.height)
        isNaN(s) && (s = null), isNaN(l) && (l = null), di(n, i, null, !0, !1)
        for (var u = n.firstChild; u; )
          this._parseNode(u, i, a, null, !1, !1), (u = u.nextSibling)
        Act(this._defs, this._defsUsePending), (this._defsUsePending = [])
        var c, h
        if (o) {
          var f = C_(o)
          f.length >= 4 &&
            (c = {
              x: parseFloat(f[0] || 0),
              y: parseFloat(f[1] || 0),
              width: parseFloat(f[2]),
              height: parseFloat(f[3]),
            })
        }
        if (
          c &&
          s != null &&
          l != null &&
          ((h = ZG(c, {
            x: 0,
            y: 0,
            width: s,
            height: l,
          })),
          !e.ignoreViewBox)
        ) {
          var d = i
          ;(i = new Ht()),
            i.add(d),
            (d.scaleX = d.scaleY = h.scale),
            (d.x = h.x),
            (d.y = h.y)
        }
        return (
          !e.ignoreRootClip &&
            s != null &&
            l != null &&
            i.setClipPath(
              new ge({
                shape: {
                  x: 0,
                  y: 0,
                  width: s,
                  height: l,
                },
              }),
            ),
          {
            root: i,
            width: s,
            height: l,
            viewBoxRect: c,
            viewBoxTransform: h,
            named: a,
          }
        )
      }),
      (r.prototype._parseNode = function (t, e, n, i, a, o) {
        var s = t.nodeName.toLowerCase(),
          l,
          u = i
        if (
          (s === 'defs' && (a = !0),
          s === 'text' && (o = !0),
          s === 'defs' || s === 'switch')
        )
          l = e
        else {
          if (!a) {
            var c = cS[s]
            if (c && Et(cS, s)) {
              l = c.call(this, t, e)
              var h = t.getAttribute('name')
              if (h) {
                var f = {
                  name: h,
                  namedFrom: null,
                  svgNodeTagLower: s,
                  el: l,
                }
                n.push(f), s === 'g' && (u = f)
              } else
                i &&
                  n.push({
                    name: i.name,
                    namedFrom: i,
                    svgNodeTagLower: s,
                    el: l,
                  })
              e.add(l)
            }
          }
          var d = uO[s]
          if (d && Et(uO, s)) {
            var p = d.call(this, t),
              g = t.getAttribute('id')
            g && (this._defs[g] = p)
          }
        }
        if (l && l.isGroup)
          for (var v = t.firstChild; v; )
            v.nodeType === 1
              ? this._parseNode(v, l, n, u, a, o)
              : v.nodeType === 3 && o && this._parseText(v, l),
              (v = v.nextSibling)
      }),
      (r.prototype._parseText = function (t, e) {
        var n = new Gp({
          style: {
            text: t.textContent,
          },
          silent: !0,
          x: this._textX || 0,
          y: this._textY || 0,
        })
        Ii(e, n), di(t, n, this._defsUsePending, !1, !1), xct(n, e)
        var i = n.style,
          a = i.fontSize
        a &&
          a < 9 &&
          ((i.fontSize = 9), (n.scaleX *= a / 9), (n.scaleY *= a / 9))
        var o =
          (i.fontSize || i.fontFamily) &&
          [
            i.fontStyle,
            i.fontWeight,
            (i.fontSize || 12) + 'px',
            i.fontFamily || 'sans-serif',
          ].join(' ')
        i.font = o
        var s = n.getBoundingRect()
        return (this._textX += s.width), e.add(n), n
      }),
      (r.internalField = (function () {
        cS = {
          g: function (t, e) {
            var n = new Ht()
            return Ii(e, n), di(t, n, this._defsUsePending, !1, !1), n
          },
          rect: function (t, e) {
            var n = new ge()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                x: parseFloat(t.getAttribute('x') || '0'),
                y: parseFloat(t.getAttribute('y') || '0'),
                width: parseFloat(t.getAttribute('width') || '0'),
                height: parseFloat(t.getAttribute('height') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          circle: function (t, e) {
            var n = new pl()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                cx: parseFloat(t.getAttribute('cx') || '0'),
                cy: parseFloat(t.getAttribute('cy') || '0'),
                r: parseFloat(t.getAttribute('r') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          line: function (t, e) {
            var n = new rr()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                x1: parseFloat(t.getAttribute('x1') || '0'),
                y1: parseFloat(t.getAttribute('y1') || '0'),
                x2: parseFloat(t.getAttribute('x2') || '0'),
                y2: parseFloat(t.getAttribute('y2') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          ellipse: function (t, e) {
            var n = new KT()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setShape({
                cx: parseFloat(t.getAttribute('cx') || '0'),
                cy: parseFloat(t.getAttribute('cy') || '0'),
                rx: parseFloat(t.getAttribute('rx') || '0'),
                ry: parseFloat(t.getAttribute('ry') || '0'),
              }),
              (n.silent = !0),
              n
            )
          },
          polygon: function (t, e) {
            var n = t.getAttribute('points'),
              i
            n && (i = fO(n))
            var a = new si({
              shape: {
                points: i || [],
              },
              silent: !0,
            })
            return Ii(e, a), di(t, a, this._defsUsePending, !1, !1), a
          },
          polyline: function (t, e) {
            var n = t.getAttribute('points'),
              i
            n && (i = fO(n))
            var a = new li({
              shape: {
                points: i || [],
              },
              silent: !0,
            })
            return Ii(e, a), di(t, a, this._defsUsePending, !1, !1), a
          },
          image: function (t, e) {
            var n = new yr()
            return (
              Ii(e, n),
              di(t, n, this._defsUsePending, !1, !1),
              n.setStyle({
                image: t.getAttribute('xlink:href') || t.getAttribute('href'),
                x: +t.getAttribute('x'),
                y: +t.getAttribute('y'),
                width: +t.getAttribute('width'),
                height: +t.getAttribute('height'),
              }),
              (n.silent = !0),
              n
            )
          },
          text: function (t, e) {
            var n = t.getAttribute('x') || '0',
              i = t.getAttribute('y') || '0',
              a = t.getAttribute('dx') || '0',
              o = t.getAttribute('dy') || '0'
            ;(this._textX = parseFloat(n) + parseFloat(a)),
              (this._textY = parseFloat(i) + parseFloat(o))
            var s = new Ht()
            return Ii(e, s), di(t, s, this._defsUsePending, !1, !0), s
          },
          tspan: function (t, e) {
            var n = t.getAttribute('x'),
              i = t.getAttribute('y')
            n != null && (this._textX = parseFloat(n)),
              i != null && (this._textY = parseFloat(i))
            var a = t.getAttribute('dx') || '0',
              o = t.getAttribute('dy') || '0',
              s = new Ht()
            return (
              Ii(e, s),
              di(t, s, this._defsUsePending, !1, !0),
              (this._textX += parseFloat(a)),
              (this._textY += parseFloat(o)),
              s
            )
          },
          path: function (t, e) {
            var n = t.getAttribute('d') || '',
              i = SU(n)
            return (
              Ii(e, i),
              di(t, i, this._defsUsePending, !1, !1),
              (i.silent = !0),
              i
            )
          },
        }
      })()),
      r
    )
  })(),
  uO = {
    lineargradient: function (r) {
      var t = parseInt(r.getAttribute('x1') || '0', 10),
        e = parseInt(r.getAttribute('y1') || '0', 10),
        n = parseInt(r.getAttribute('x2') || '10', 10),
        i = parseInt(r.getAttribute('y2') || '0', 10),
        a = new He(t, e, n, i)
      return cO(r, a), hO(r, a), a
    },
    radialgradient: function (r) {
      var t = parseInt(r.getAttribute('cx') || '0', 10),
        e = parseInt(r.getAttribute('cy') || '0', 10),
        n = parseInt(r.getAttribute('r') || '0', 10),
        i = new OU(t, e, n)
      return cO(r, i), hO(r, i), i
    },
  }
function cO(r, t) {
  var e = r.getAttribute('gradientUnits')
  e === 'userSpaceOnUse' && (t.global = !0)
}
function hO(r, t) {
  for (var e = r.firstChild; e; ) {
    if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === 'stop') {
      var n = e.getAttribute('offset'),
        i = void 0
      n && n.indexOf('%') > 0
        ? (i = parseInt(n, 10) / 100)
        : n
        ? (i = parseFloat(n))
        : (i = 0)
      var a = {}
      qG(e, a, a)
      var o = a.stopColor || e.getAttribute('stop-color') || '#000000'
      t.colorStops.push({
        offset: i,
        color: o,
      })
    }
    e = e.nextSibling
  }
}
function Ii(r, t) {
  r &&
    r.__inheritedStyle &&
    (t.__inheritedStyle || (t.__inheritedStyle = {}),
    zt(t.__inheritedStyle, r.__inheritedStyle))
}
function fO(r) {
  for (var t = C_(r), e = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]),
      a = parseFloat(t[n + 1])
    e.push([i, a])
  }
  return e
}
function di(r, t, e, n, i) {
  var a = t,
    o = (a.__inheritedStyle = a.__inheritedStyle || {}),
    s = {}
  r.nodeType === 1 && (Mct(r, t), qG(r, o, s), n || Tct(r, o, s)),
    (a.style = a.style || {}),
    o.fill != null && (a.style.fill = dO(a, 'fill', o.fill, e)),
    o.stroke != null && (a.style.stroke = dO(a, 'stroke', o.stroke, e)),
    R(
      [
        'lineWidth',
        'opacity',
        'fillOpacity',
        'strokeOpacity',
        'miterLimit',
        'fontSize',
      ],
      function (l) {
        o[l] != null && (a.style[l] = parseFloat(o[l]))
      },
    ),
    R(
      [
        'lineDashOffset',
        'lineCap',
        'lineJoin',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'textAlign',
      ],
      function (l) {
        o[l] != null && (a.style[l] = o[l])
      },
    ),
    i && (a.__selfStyle = s),
    o.lineDash &&
      (a.style.lineDash = st(C_(o.lineDash), function (l) {
        return parseFloat(l)
      })),
    (o.visibility === 'hidden' || o.visibility === 'collapse') &&
      (a.invisible = !0),
    o.display === 'none' && (a.ignore = !0)
}
function xct(r, t) {
  var e = t.__selfStyle
  if (e) {
    var n = e.textBaseline,
      i = n
    !n || n === 'auto' || n === 'baseline'
      ? (i = 'alphabetic')
      : n === 'before-edge' || n === 'text-before-edge'
      ? (i = 'top')
      : n === 'after-edge' || n === 'text-after-edge'
      ? (i = 'bottom')
      : (n === 'central' || n === 'mathematical') && (i = 'middle'),
      (r.style.textBaseline = i)
  }
  var a = t.__inheritedStyle
  if (a) {
    var o = a.textAlign,
      s = o
    o && (o === 'middle' && (s = 'center'), (r.style.textAlign = s))
  }
}
var Sct = /^url\(\s*#(.*?)\)/
function dO(r, t, e, n) {
  var i = e && e.match(Sct)
  if (i) {
    var a = xa(i[1])
    n.push([r, t, a])
    return
  }
  return e === 'none' && (e = null), e
}
function Act(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e]
    n[0].style[n[1]] = r[n[2]]
  }
}
var bct = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
function C_(r) {
  return r.match(bct) || []
}
var wct = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g,
  hS = Math.PI / 180
function Mct(r, t) {
  var e = r.getAttribute('transform')
  if (e) {
    e = e.replace(/,/g, ' ')
    var n = [],
      i = null
    e.replace(wct, function (h, f, d) {
      return n.push(f, d), ''
    })
    for (var a = n.length - 1; a > 0; a -= 2) {
      var o = n[a],
        s = n[a - 1],
        l = C_(o)
      switch (((i = i || bi()), s)) {
        case 'translate':
          ho(i, i, [parseFloat(l[0]), parseFloat(l[1] || '0')])
          break
        case 'scale':
          IT(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])])
          break
        case 'rotate':
          ec(i, i, -parseFloat(l[0]) * hS, [
            parseFloat(l[1] || '0'),
            parseFloat(l[2] || '0'),
          ])
          break
        case 'skewX':
          var u = Math.tan(parseFloat(l[0]) * hS)
          Ho(i, [1, 0, u, 1, 0, 0], i)
          break
        case 'skewY':
          var c = Math.tan(parseFloat(l[0]) * hS)
          Ho(i, [1, c, 0, 1, 0, 0], i)
          break
        case 'matrix':
          ;(i[0] = parseFloat(l[0])),
            (i[1] = parseFloat(l[1])),
            (i[2] = parseFloat(l[2])),
            (i[3] = parseFloat(l[3])),
            (i[4] = parseFloat(l[4])),
            (i[5] = parseFloat(l[5]))
          break
      }
    }
    t.setLocalTransform(i)
  }
}
var pO = /([^\s:;]+)\s*:\s*([^:;]+)/g
function qG(r, t, e) {
  var n = r.getAttribute('style')
  if (n) {
    pO.lastIndex = 0
    for (var i; (i = pO.exec(n)) != null; ) {
      var a = i[1],
        o = Et(f0, a) ? f0[a] : null
      o && (t[o] = i[2])
      var s = Et(d0, a) ? d0[a] : null
      s && (e[s] = i[2])
    }
  }
}
function Tct(r, t, e) {
  for (var n = 0; n < sO.length; n++) {
    var i = sO[n],
      a = r.getAttribute(i)
    a != null && (t[f0[i]] = a)
  }
  for (var n = 0; n < lO.length; n++) {
    var i = lO[n],
      a = r.getAttribute(i)
    a != null && (e[d0[i]] = a)
  }
}
function ZG(r, t) {
  var e = t.width / r.width,
    n = t.height / r.height,
    i = Math.min(e, n)
  return {
    scale: i,
    x: -(r.x + r.width / 2) * i + (t.x + t.width / 2),
    y: -(r.y + r.height / 2) * i + (t.y + t.height / 2),
  }
}
function Cct(r, t) {
  var e = new _ct()
  return e.parse(r, t)
}
var Ect = Pt([
    'rect',
    'circle',
    'line',
    'ellipse',
    'polygon',
    'polyline',
    'path',
    'text',
    'tspan',
    'g',
  ]),
  Dct = (function () {
    function r(t, e) {
      ;(this.type = 'geoSVG'),
        (this._usedGraphicMap = Pt()),
        (this._freedGraphics = []),
        (this._mapName = t),
        (this._parsedXML = $G(e))
    }
    return (
      (r.prototype.load = function () {
        var t = this._firstGraphic
        if (!t) {
          ;(t = this._firstGraphic = this._buildGraphic(this._parsedXML)),
            this._freedGraphics.push(t),
            (this._boundingRect = this._firstGraphic.boundingRect.clone())
          var e = Pct(t.named),
            n = e.regions,
            i = e.regionsMap
          ;(this._regions = n), (this._regionsMap = i)
        }
        return {
          boundingRect: this._boundingRect,
          regions: this._regions,
          regionsMap: this._regionsMap,
        }
      }),
      (r.prototype._buildGraphic = function (t) {
        var e, n
        try {
          ;(e =
            (t &&
              Cct(t, {
                ignoreViewBox: !0,
                ignoreRootClip: !0,
              })) ||
            {}),
            (n = e.root),
            Gr(n != null)
        } catch (v) {
          throw new Error(
            `Invalid svg format
` + v.message,
          )
        }
        var i = new Ht()
        i.add(n), (i.isGeoSVGGraphicRoot = !0)
        var a = e.width,
          o = e.height,
          s = e.viewBoxRect,
          l = this._boundingRect
        if (!l) {
          var u = void 0,
            c = void 0,
            h = void 0,
            f = void 0
          if (
            (a != null ? ((u = 0), (h = a)) : s && ((u = s.x), (h = s.width)),
            o != null ? ((c = 0), (f = o)) : s && ((c = s.y), (f = s.height)),
            u == null || c == null)
          ) {
            var d = n.getBoundingRect()
            u == null && ((u = d.x), (h = d.width)),
              c == null && ((c = d.y), (f = d.height))
          }
          l = this._boundingRect = new ee(u, c, h, f)
        }
        if (s) {
          var p = ZG(s, l)
          ;(n.scaleX = n.scaleY = p.scale), (n.x = p.x), (n.y = p.y)
        }
        i.setClipPath(
          new ge({
            shape: l.plain(),
          }),
        )
        var g = []
        return (
          R(e.named, function (v) {
            Ect.get(v.svgNodeTagLower) != null && (g.push(v), Lct(v.el))
          }),
          {
            root: i,
            boundingRect: l,
            named: g,
          }
        )
      }),
      (r.prototype.useGraphic = function (t) {
        var e = this._usedGraphicMap,
          n = e.get(t)
        return (
          n ||
          ((n =
            this._freedGraphics.pop() || this._buildGraphic(this._parsedXML)),
          e.set(t, n),
          n)
        )
      }),
      (r.prototype.freeGraphic = function (t) {
        var e = this._usedGraphicMap,
          n = e.get(t)
        n && (e.removeKey(t), this._freedGraphics.push(n))
      }),
      r
    )
  })()
function Lct(r) {
  ;(r.silent = !1),
    r.isGroup &&
      r.traverse(function (t) {
        t.silent = !1
      })
}
function Pct(r) {
  var t = [],
    e = Pt()
  return (
    R(r, function (n) {
      if (n.namedFrom == null) {
        var i = new qot(n.name, n.el)
        t.push(i), e.set(n.name, i)
      }
    }),
    {
      regions: t,
      regionsMap: e,
    }
  )
}
var kw = [126, 25],
  vO = '南海诸岛',
  iu = [
    [
      [0, 3.5],
      [7, 11.2],
      [15, 11.9],
      [30, 7],
      [42, 0.7],
      [52, 0.7],
      [56, 7.7],
      [59, 0.7],
      [64, 0.7],
      [64, 0],
      [5, 0],
      [0, 3.5],
    ],
    [
      [13, 16.1],
      [19, 14.7],
      [16, 21.7],
      [11, 23.1],
      [13, 16.1],
    ],
    [
      [12, 32.2],
      [14, 38.5],
      [15, 38.5],
      [13, 32.2],
      [12, 32.2],
    ],
    [
      [16, 47.6],
      [12, 53.2],
      [13, 53.2],
      [18, 47.6],
      [16, 47.6],
    ],
    [
      [6, 64.4],
      [8, 70],
      [9, 70],
      [8, 64.4],
      [6, 64.4],
    ],
    [
      [23, 82.6],
      [29, 79.8],
      [30, 79.8],
      [25, 82.6],
      [23, 82.6],
    ],
    [
      [37, 70.7],
      [43, 62.3],
      [44, 62.3],
      [39, 70.7],
      [37, 70.7],
    ],
    [
      [48, 51.1],
      [51, 45.5],
      [53, 45.5],
      [50, 51.1],
      [48, 51.1],
    ],
    [
      [51, 35],
      [51, 28.7],
      [53, 28.7],
      [53, 35],
      [51, 35],
    ],
    [
      [52, 22.4],
      [55, 17.5],
      [56, 17.5],
      [53, 22.4],
      [52, 22.4],
    ],
    [
      [58, 12.6],
      [62, 7],
      [63, 7],
      [60, 12.6],
      [58, 12.6],
    ],
    [
      [0, 3.5],
      [0, 93.1],
      [64, 93.1],
      [64, 0],
      [63, 0],
      [63, 92.4],
      [1, 92.4],
      [1, 3.5],
      [0, 3.5],
    ],
  ]
for (var Jl = 0; Jl < iu.length; Jl++)
  for (var Kc = 0; Kc < iu[Jl].length; Kc++)
    (iu[Jl][Kc][0] /= 10.5),
      (iu[Jl][Kc][1] /= -10.5 / 0.75),
      (iu[Jl][Kc][0] += kw[0]),
      (iu[Jl][Kc][1] += kw[1])
function Rct(r, t) {
  if (r === 'china') {
    for (var e = 0; e < t.length; e++) if (t[e].name === vO) return
    t.push(
      new WV(
        vO,
        st(iu, function (n) {
          return {
            type: 'polygon',
            exterior: n,
          }
        }),
        kw,
      ),
    )
  }
}
var Ict = {
  南海诸岛: [32, 80],
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  天津: [5, 5],
}
function Oct(r, t) {
  if (r === 'china') {
    var e = Ict[t.name]
    if (e) {
      var n = t.getCenter()
      ;(n[0] += e[0] / 10.5), (n[1] += -e[1] / (10.5 / 0.75)), t.setCenter(n)
    }
  }
}
var Nct = [
  [
    [123.45165252685547, 25.73527164402261],
    [123.49731445312499, 25.73527164402261],
    [123.49731445312499, 25.750734064600884],
    [123.45165252685547, 25.750734064600884],
    [123.45165252685547, 25.73527164402261],
  ],
]
function kct(r, t) {
  r === 'china' &&
    t.name === '台湾' &&
    t.geometries.push({
      type: 'polygon',
      exterior: Nct[0],
    })
}
var Bct = 'name',
  Fct = (function () {
    function r(t, e, n) {
      ;(this.type = 'geoJSON'),
        (this._parsedMap = Pt()),
        (this._mapName = t),
        (this._specialAreas = n),
        (this._geoJSON = Uct(e))
    }
    return (
      (r.prototype.load = function (t, e) {
        e = e || Bct
        var n = this._parsedMap.get(e)
        if (!n) {
          var i = this._parseToRegions(e)
          n = this._parsedMap.set(e, {
            regions: i,
            boundingRect: zct(i),
          })
        }
        var a = Pt(),
          o = []
        return (
          R(n.regions, function (s) {
            var l = s.name
            t && Et(t, l) && (s = s.cloneShallow((l = t[l]))),
              o.push(s),
              a.set(l, s)
          }),
          {
            regions: o,
            boundingRect: n.boundingRect || new ee(0, 0, 0, 0),
            regionsMap: a,
          }
        )
      }),
      (r.prototype._parseToRegions = function (t) {
        var e = this._mapName,
          n = this._geoJSON,
          i
        try {
          i = n ? Kot(n, t) : []
        } catch (a) {
          throw new Error(
            `Invalid geoJson format
` + a.message,
          )
        }
        return (
          Rct(e, i),
          R(
            i,
            function (a) {
              var o = a.name
              Oct(e, a), kct(e, a)
              var s = this._specialAreas && this._specialAreas[o]
              s && a.transformTo(s.left, s.top, s.width, s.height)
            },
            this,
          ),
          i
        )
      }),
      (r.prototype.getMapForUser = function () {
        return {
          geoJson: this._geoJSON,
          geoJSON: this._geoJSON,
          specialAreas: this._specialAreas,
        }
      }),
      r
    )
  })()
function zct(r) {
  for (var t, e = 0; e < r.length; e++) {
    var n = r[e].getBoundingRect()
    ;(t = t || n.clone()), t.union(n)
  }
  return t
}
function Uct(r) {
  return bt(r)
    ? typeof JSON < 'u' && JSON.parse
      ? JSON.parse(r)
      : new Function('return (' + r + ');')()
    : r
}
var vd = Pt()
const rs = {
  registerMap: function (r, t, e) {
    if (t.svg) {
      var n = new Dct(r, t.svg)
      vd.set(r, n)
    } else {
      var i = t.geoJson || t.geoJSON
      i && !t.features ? (e = t.specialAreas) : (i = t)
      var n = new Fct(r, i, e)
      vd.set(r, n)
    }
  },
  getGeoResource: function (r) {
    return vd.get(r)
  },
  getMapForUser: function (r) {
    var t = vd.get(r)
    return t && t.type === 'geoJSON' && t.getMapForUser()
  },
  load: function (r, t, e) {
    var n = vd.get(r)
    if (n) return n.load(t, e)
  },
}
var GC = ['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path'],
  Vct = Pt(GC),
  Gct = Pt(GC.concat(['g'])),
  Hct = Pt(GC.concat(['g'])),
  KG = ve()
function vm(r) {
  var t = r.getItemStyle(),
    e = r.get('areaColor')
  return e != null && (t.fill = e), t
}
function gO(r) {
  var t = r.style
  t && ((t.stroke = t.stroke || t.fill), (t.fill = null))
}
var Wct = (function () {
  function r(t) {
    var e = new Ht()
    ;(this.uid = bf('ec_map_draw')),
      (this._controller = new Rv(t.getZr())),
      (this._controllerHost = {
        target: e,
      }),
      (this.group = e),
      e.add((this._regionsGroup = new Ht())),
      e.add((this._svgGroup = new Ht()))
  }
  return (
    (r.prototype.draw = function (t, e, n, i, a) {
      var o = t.mainType === 'geo',
        s = t.getData && t.getData()
      o &&
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'map',
          },
          function (m) {
            !s && m.getHostGeoModel() === t && (s = m.getData())
          },
        )
      var l = t.coordinateSystem,
        u = this._regionsGroup,
        c = this.group,
        h = l.getTransformInfo(),
        f = h.raw,
        d = h.roam,
        p = !u.childAt(0) || a
      p
        ? ((c.x = d.x),
          (c.y = d.y),
          (c.scaleX = d.scaleX),
          (c.scaleY = d.scaleY),
          c.dirty())
        : we(c, d, t)
      var g =
          s &&
          s.getVisual('visualMeta') &&
          s.getVisual('visualMeta').length > 0,
        v = {
          api: n,
          geo: l,
          mapOrGeoModel: t,
          data: s,
          isVisualEncodedByVisualMap: g,
          isGeo: o,
          transformInfoRaw: f,
        }
      l.resourceType === 'geoJSON'
        ? this._buildGeoJSON(v)
        : l.resourceType === 'geoSVG' && this._buildSVG(v),
        this._updateController(t, e, n),
        this._updateMapSelectHandler(t, u, n, i)
    }),
    (r.prototype._buildGeoJSON = function (t) {
      var e = (this._regionsGroupByName = Pt()),
        n = Pt(),
        i = this._regionsGroup,
        a = t.transformInfoRaw,
        o = t.mapOrGeoModel,
        s = t.data,
        l = t.geo.projection,
        u = l && l.stream
      function c(d, p) {
        return (
          p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y]
        )
      }
      function h(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g)
          m && p.push(m)
        }
        return p
      }
      function f(d) {
        return {
          shape: {
            points: h(d),
          },
        }
      }
      i.removeAll(),
        R(t.geo.regions, function (d) {
          var p = d.name,
            g = e.get(p),
            v = n.get(p) || {},
            m = v.dataIdx,
            y = v.regionModel
          g ||
            ((g = e.set(p, new Ht())),
            i.add(g),
            (m = s ? s.indexOfName(p) : null),
            (y = t.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null),
            n.set(p, {
              dataIdx: m,
              regionModel: y,
            }))
          var _ = [],
            x = []
          R(d.geometries, function (b) {
            if (b.type === 'polygon') {
              var T = [b.exterior].concat(b.interiors || [])
              u && (T = AO(T, u)),
                R(T, function (M) {
                  _.push(new si(f(M)))
                })
            } else {
              var w = b.points
              u && (w = AO(w, u, !0)),
                R(w, function (M) {
                  x.push(new li(f(M)))
                })
            }
          })
          var A = c(d.getCenter(), l && l.project)
          function S(b, T) {
            if (b.length) {
              var w = new JT({
                culling: !0,
                segmentIgnoreThreshold: 1,
                shape: {
                  paths: b,
                },
              })
              g.add(w),
                mO(t, w, m, y),
                yO(t, w, p, y, o, m, A),
                T && (gO(w), R(w.states, gO))
            }
          }
          S(_), S(x, !0)
        }),
        e.each(function (d, p) {
          var g = n.get(p),
            v = g.dataIdx,
            m = g.regionModel
          _O(t, d, p, m, o, v), xO(t, d, p, m, o), SO(t, d, p, m, o)
        }, this)
    }),
    (r.prototype._buildSVG = function (t) {
      var e = t.geo.map,
        n = t.transformInfoRaw
      ;(this._svgGroup.x = n.x),
        (this._svgGroup.y = n.y),
        (this._svgGroup.scaleX = n.scaleX),
        (this._svgGroup.scaleY = n.scaleY),
        this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e))
      var i = (this._svgDispatcherMap = Pt()),
        a = !1
      R(
        this._svgGraphicRecord.named,
        function (o) {
          var s = o.name,
            l = t.mapOrGeoModel,
            u = t.data,
            c = o.svgNodeTagLower,
            h = o.el,
            f = u ? u.indexOfName(s) : null,
            d = l.getRegionModel(s)
          if (
            (Vct.get(c) != null && h instanceof ea && mO(t, h, f, d),
            h instanceof ea && (h.culling = !0),
            (h.z2EmphasisLift = 0),
            !o.namedFrom &&
              (Hct.get(c) != null && yO(t, h, s, d, l, f, null),
              _O(t, h, s, d, l, f),
              xO(t, h, s, d, l),
              Gct.get(c) != null))
          ) {
            var p = SO(t, h, s, d, l)
            p === 'self' && (a = !0)
            var g = i.get(s) || i.set(s, [])
            g.push(h)
          }
        },
        this,
      ),
        this._enableBlurEntireSVG(a, t)
    }),
    (r.prototype._enableBlurEntireSVG = function (t, e) {
      if (t && e.isGeo) {
        var n = e.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle(),
          i = n.opacity
        this._svgGraphicRecord.root.traverse(function (a) {
          if (!a.isGroup) {
            qu(a)
            var o = a.ensureState('blur').style || {}
            o.opacity == null && i != null && (o.opacity = i),
              a.ensureState('emphasis')
          }
        })
      }
    }),
    (r.prototype.remove = function () {
      this._regionsGroup.removeAll(),
        (this._regionsGroupByName = null),
        this._svgGroup.removeAll(),
        this._freeSVG(),
        this._controller.dispose(),
        (this._controllerHost = null)
    }),
    (r.prototype.findHighDownDispatchers = function (t, e) {
      if (t == null) return []
      var n = e.coordinateSystem
      if (n.resourceType === 'geoJSON') {
        var i = this._regionsGroupByName
        if (i) {
          var a = i.get(t)
          return a ? [a] : []
        }
      } else if (n.resourceType === 'geoSVG')
        return (this._svgDispatcherMap && this._svgDispatcherMap.get(t)) || []
    }),
    (r.prototype._svgResourceChanged = function (t) {
      return this._svgMapName !== t
    }),
    (r.prototype._useSVG = function (t) {
      var e = rs.getGeoResource(t)
      if (e && e.type === 'geoSVG') {
        var n = e.useGraphic(this.uid)
        this._svgGroup.add(n.root),
          (this._svgGraphicRecord = n),
          (this._svgMapName = t)
      }
    }),
    (r.prototype._freeSVG = function () {
      var t = this._svgMapName
      if (t != null) {
        var e = rs.getGeoResource(t)
        e && e.type === 'geoSVG' && e.freeGraphic(this.uid),
          (this._svgGraphicRecord = null),
          (this._svgDispatcherMap = null),
          this._svgGroup.removeAll(),
          (this._svgMapName = null)
      }
    }),
    (r.prototype._updateController = function (t, e, n) {
      var i = t.coordinateSystem,
        a = this._controller,
        o = this._controllerHost
      ;(o.zoomLimit = t.get('scaleLimit')),
        (o.zoom = i.getZoom()),
        a.enable(t.get('roam') || !1)
      var s = t.mainType
      function l() {
        var u = {
          type: 'geoRoam',
          componentType: s,
        }
        return (u[s + 'Id'] = t.id), u
      }
      a.off('pan').on(
        'pan',
        function (u) {
          ;(this._mouseDownFlag = !1),
            UC(o, u.dx, u.dy),
            n.dispatchAction(
              Q(l(), {
                dx: u.dx,
                dy: u.dy,
                animation: {
                  duration: 0,
                },
              }),
            )
        },
        this,
      ),
        a.off('zoom').on(
          'zoom',
          function (u) {
            ;(this._mouseDownFlag = !1),
              VC(o, u.scale, u.originX, u.originY),
              n.dispatchAction(
                Q(l(), {
                  totalZoom: o.zoom,
                  zoom: u.scale,
                  originX: u.originX,
                  originY: u.originY,
                  animation: {
                    duration: 0,
                  },
                }),
              )
          },
          this,
        ),
        a.setPointerChecker(function (u, c, h) {
          return i.containPoint([c, h]) && !T_(u, n, t)
        })
    }),
    (r.prototype.resetForLabelLayout = function () {
      this.group.traverse(function (t) {
        var e = t.getTextContent()
        e && (e.ignore = KG(e).ignore)
      })
    }),
    (r.prototype._updateMapSelectHandler = function (t, e, n, i) {
      var a = this
      e.off('mousedown'),
        e.off('click'),
        t.get('selectedMode') &&
          (e.on('mousedown', function () {
            a._mouseDownFlag = !0
          }),
          e.on('click', function (o) {
            a._mouseDownFlag && (a._mouseDownFlag = !1)
          }))
    }),
    r
  )
})()
function mO(r, t, e, n) {
  var i = n.getModel('itemStyle'),
    a = n.getModel(['emphasis', 'itemStyle']),
    o = n.getModel(['blur', 'itemStyle']),
    s = n.getModel(['select', 'itemStyle']),
    l = vm(i),
    u = vm(a),
    c = vm(s),
    h = vm(o),
    f = r.data
  if (f) {
    var d = f.getItemVisual(e, 'style'),
      p = f.getItemVisual(e, 'decal')
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill),
      p && (l.decal = rf(p, r.api))
  }
  t.setStyle(l),
    (t.style.strokeNoScale = !0),
    (t.ensureState('emphasis').style = u),
    (t.ensureState('select').style = c),
    (t.ensureState('blur').style = h),
    qu(t)
}
function yO(r, t, e, n, i, a, o) {
  var s = r.data,
    l = r.isGeo,
    u = s && isNaN(s.get(s.mapDimension('value'), a)),
    c = s && s.getItemLayout(a)
  if (l || u || (c && c.showLabel)) {
    var h = l ? e : a,
      f = void 0
    ;(!s || a >= 0) && (f = i)
    var d = o
      ? {
          normal: {
            align: 'center',
            verticalAlign: 'middle',
          },
        }
      : null
    mr(
      t,
      Zn(n),
      {
        labelFetcher: f,
        labelDataIndex: h,
        defaultText: e,
      },
      d,
    )
    var p = t.getTextContent()
    if (p && ((KG(p).ignore = p.ignore), t.textConfig && o)) {
      var g = t.getBoundingRect().clone()
      ;(t.textConfig.layoutRect = g),
        (t.textConfig.position = [
          ((o[0] - g.x) / g.width) * 100 + '%',
          ((o[1] - g.y) / g.height) * 100 + '%',
        ])
    }
    t.disableLabelAnimation = !0
  } else
    t.removeTextContent(),
      t.removeTextConfig(),
      (t.disableLabelAnimation = null)
}
function _O(r, t, e, n, i, a) {
  r.data
    ? r.data.setItemGraphicEl(a, t)
    : (Wt(t).eventData = {
        componentType: 'geo',
        componentIndex: i.componentIndex,
        geoIndex: i.componentIndex,
        name: e,
        region: (n && n.option) || {},
      })
}
function xO(r, t, e, n, i) {
  r.data ||
    Sf({
      el: t,
      componentModel: i,
      itemName: e,
      itemTooltipOption: n.get('tooltip'),
    })
}
function SO(r, t, e, n, i) {
  t.highDownSilentOnTouch = !!i.get('selectedMode')
  var a = n.getModel('emphasis'),
    o = a.get('focus')
  return (
    fn(t, o, a.get('blurScope'), a.get('disabled')), r.isGeo && Xet(t, i, e), o
  )
}
function AO(r, t, e) {
  var n = [],
    i
  function a() {
    i = []
  }
  function o() {
    i.length && (n.push(i), (i = []))
  }
  var s = t({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function (l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u])
    },
    sphere: function () {},
  })
  return (
    !e && s.polygonStart(),
    R(r, function (l) {
      s.lineStart()
      for (var u = 0; u < l.length; u++) s.point(l[u][0], l[u][1])
      s.lineEnd()
    }),
    !e && s.polygonEnd(),
    n
  )
}
const jG = Wct
var Xct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      if (!(a && a.type === 'mapToggleSelect' && a.from === this.uid)) {
        var o = this.group
        if ((o.removeAll(), !e.getHostGeoModel())) {
          if (
            (this._mapDraw &&
              a &&
              a.type === 'geoRoam' &&
              this._mapDraw.resetForLabelLayout(),
            a &&
              a.type === 'geoRoam' &&
              a.componentType === 'series' &&
              a.seriesId === e.id)
          ) {
            var s = this._mapDraw
            s && o.add(s.group)
          } else if (e.needsDrawMap) {
            var s = this._mapDraw || new jG(i)
            o.add(s.group), s.draw(e, n, i, this, a), (this._mapDraw = s)
          } else this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
          e.get('showLegendSymbol') &&
            n.getComponent('legend') &&
            this._renderSymbols(e, n, i)
        }
      }
    }),
    (t.prototype.remove = function () {
      this._mapDraw && this._mapDraw.remove(),
        (this._mapDraw = null),
        this.group.removeAll()
    }),
    (t.prototype.dispose = function () {
      this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
    }),
    (t.prototype._renderSymbols = function (e, n, i) {
      var a = e.originalData,
        o = this.group
      a.each(a.mapDimension('value'), function (s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l)
          if (!(!u || !u.point)) {
            var c = u.point,
              h = u.offset,
              f = new pl({
                style: {
                  fill: e.getData().getVisual('style').fill,
                },
                shape: {
                  cx: c[0] + h * 9,
                  cy: c[1],
                  r: 3,
                },
                silent: !0,
                z2: 8 + (h ? 0 : _f + 1),
              })
            if (!h) {
              var d = e.mainSeries.getData(),
                p = a.getName(l),
                g = d.indexOfName(p),
                v = a.getItemModel(l),
                m = v.getModel('label'),
                y = d.getItemGraphicEl(g)
              mr(f, Zn(v), {
                labelFetcher: {
                  getFormattedLabel: function (_, x) {
                    return e.getFormattedLabel(g, x)
                  },
                },
                defaultText: p,
              }),
                (f.disableLabelAnimation = !0),
                m.get('position') ||
                  f.setTextConfig({
                    position: 'bottom',
                  }),
                (y.onHoverStateChange = function (_) {
                  Xy(f, _)
                })
            }
            o.add(f)
          }
        }
      })
    }),
    (t.type = 'map'),
    t
  )
})(Ze)
const Yct = Xct
var $ct = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.needsDrawMap = !1),
      (e.seriesGroup = []),
      (e.getTooltipPosition = function (n) {
        if (n != null) {
          var i = this.getData().getName(n),
            a = this.coordinateSystem,
            o = a.getRegion(i)
          return o && a.dataToPoint(o.getCenter())
        }
      }),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e) {
      for (
        var n = Rf(this, {
            coordDimensions: ['value'],
            encodeDefaulter: Zt(lC, this),
          }),
          i = Pt(),
          a = [],
          o = 0,
          s = n.count();
        o < s;
        o++
      ) {
        var l = n.getName(o)
        i.set(l, !0)
      }
      var u = rs.load(
        this.getMapType(),
        this.option.nameMap,
        this.option.nameProperty,
      )
      return (
        R(u.regions, function (c) {
          var h = c.name
          i.get(h) || a.push(h)
        }),
        n.appendValues([], a),
        n
      )
    }),
    (t.prototype.getHostGeoModel = function () {
      var e = this.option.geoIndex
      return e != null ? this.ecModel.getComponent('geo', e) : null
    }),
    (t.prototype.getMapType = function () {
      return (this.getHostGeoModel() || this).option.map
    }),
    (t.prototype.getRawValue = function (e) {
      var n = this.getData()
      return n.get(n.mapDimension('value'), e)
    }),
    (t.prototype.getRegionModel = function (e) {
      var n = this.getData()
      return n.getItemModel(n.indexOfName(e))
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      for (
        var a = this.getData(),
          o = this.getRawValue(e),
          s = a.getName(e),
          l = this.seriesGroup,
          u = [],
          c = 0;
        c < l.length;
        c++
      ) {
        var h = l[c].originalData.indexOfName(s),
          f = a.mapDimension('value')
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name)
      }
      return Kn('section', {
        header: u.join(', '),
        noHeader: !u.length,
        blocks: [
          Kn('nameValue', {
            name: s,
            value: o,
          }),
        ],
      })
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.getLegendIcon = function (e) {
      var n = e.icon || 'roundRect',
        i = Rn(n, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill)
      return (
        i.setStyle(e.itemStyle),
        (i.style.stroke = 'none'),
        n.indexOf('empty') > -1 &&
          ((i.style.stroke = i.style.fill),
          (i.style.fill = '#fff'),
          (i.style.lineWidth = 2)),
        i
      )
    }),
    (t.type = 'series.map'),
    (t.dependencies = ['geo']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'geo',
      map: '',
      left: 'center',
      top: 'center',
      aspectScale: null,
      showLegendSymbol: !0,
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: '#000',
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: '#444',
        areaColor: '#eee',
      },
      emphasis: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          areaColor: 'rgba(255,215,0,0.8)',
        },
      },
      select: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      nameProperty: 'name',
    }),
    t
  )
})(rn)
const qct = $ct
function Zct(r, t) {
  var e = {}
  return (
    R(r, function (n) {
      n.each(n.mapDimension('value'), function (i, a) {
        var o = 'ec-' + n.getName(a)
        ;(e[o] = e[o] || []), isNaN(i) || e[o].push(i)
      })
    }),
    r[0].map(r[0].mapDimension('value'), function (n, i) {
      for (
        var a = 'ec-' + r[0].getName(i),
          o = 0,
          s = 1 / 0,
          l = -1 / 0,
          u = e[a].length,
          c = 0;
        c < u;
        c++
      )
        (s = Math.min(s, e[a][c])), (l = Math.max(l, e[a][c])), (o += e[a][c])
      var h
      return (
        t === 'min'
          ? (h = s)
          : t === 'max'
          ? (h = l)
          : t === 'average'
          ? (h = o / u)
          : (h = o),
        u === 0 ? NaN : h
      )
    })
  )
}
function Kct(r) {
  var t = {}
  r.eachSeriesByType('map', function (e) {
    var n = e.getHostGeoModel(),
      i = n ? 'o' + n.id : 'i' + e.getMapType()
    ;(t[i] = t[i] || []).push(e)
  }),
    R(t, function (e, n) {
      for (
        var i = Zct(
            st(e, function (o) {
              return o.getData()
            }),
            e[0].get('mapValueCalculation'),
          ),
          a = 0;
        a < e.length;
        a++
      )
        e[a].originalData = e[a].getData()
      for (var a = 0; a < e.length; a++)
        (e[a].seriesGroup = e),
          (e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel()),
          e[a].setData(i.cloneShallow()),
          (e[a].mainSeries = e[0])
    })
}
function jct(r) {
  var t = {}
  r.eachSeriesByType('map', function (e) {
    var n = e.getMapType()
    if (!(e.getHostGeoModel() || t[n])) {
      var i = {}
      R(e.seriesGroup, function (o) {
        var s = o.coordinateSystem,
          l = o.originalData
        o.get('showLegendSymbol') &&
          r.getComponent('legend') &&
          l.each(l.mapDimension('value'), function (u, c) {
            var h = l.getName(c),
              f = s.getRegion(h)
            if (!(!f || isNaN(u))) {
              var d = i[h] || 0,
                p = s.dataToPoint(f.getCenter())
              ;(i[h] = d + 1),
                l.setItemLayout(c, {
                  point: p,
                  offset: d,
                })
            }
          })
      })
      var a = e.getData()
      a.each(function (o) {
        var s = a.getName(o),
          l = a.getItemLayout(o) || {}
        ;(l.showLabel = !i[s]), a.setItemLayout(o, l)
      }),
        (t[n] = !0)
    }
  })
}
var bO = pr,
  Jct = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this) || this
      return (
        (n.type = 'view'),
        (n.dimensions = ['x', 'y']),
        (n._roamTransformable = new Uo()),
        (n._rawTransformable = new Uo()),
        (n.name = e),
        n
      )
    }
    return (
      (t.prototype.setBoundingRect = function (e, n, i, a) {
        return (this._rect = new ee(e, n, i, a)), this._rect
      }),
      (t.prototype.getBoundingRect = function () {
        return this._rect
      }),
      (t.prototype.setViewRect = function (e, n, i, a) {
        this._transformTo(e, n, i, a), (this._viewRect = new ee(e, n, i, a))
      }),
      (t.prototype._transformTo = function (e, n, i, a) {
        var o = this.getBoundingRect(),
          s = this._rawTransformable
        s.transform = o.calculateTransform(new ee(e, n, i, a))
        var l = s.parent
        ;(s.parent = null),
          s.decomposeTransform(),
          (s.parent = l),
          this._updateTransform()
      }),
      (t.prototype.setCenter = function (e, n) {
        e &&
          ((this._center = [_t(e[0], n.getWidth()), _t(e[1], n.getHeight())]),
          this._updateCenterAndZoom())
      }),
      (t.prototype.setZoom = function (e) {
        e = e || 1
        var n = this.zoomLimit
        n &&
          (n.max != null && (e = Math.min(n.max, e)),
          n.min != null && (e = Math.max(n.min, e))),
          (this._zoom = e),
          this._updateCenterAndZoom()
      }),
      (t.prototype.getDefaultCenter = function () {
        var e = this.getBoundingRect(),
          n = e.x + e.width / 2,
          i = e.y + e.height / 2
        return [n, i]
      }),
      (t.prototype.getCenter = function () {
        return this._center || this.getDefaultCenter()
      }),
      (t.prototype.getZoom = function () {
        return this._zoom || 1
      }),
      (t.prototype.getRoamTransform = function () {
        return this._roamTransformable.getLocalTransform()
      }),
      (t.prototype._updateCenterAndZoom = function () {
        var e = this._rawTransformable.getLocalTransform(),
          n = this._roamTransformable,
          i = this.getDefaultCenter(),
          a = this.getCenter(),
          o = this.getZoom()
        ;(a = pr([], a, e)),
          (i = pr([], i, e)),
          (n.originX = a[0]),
          (n.originY = a[1]),
          (n.x = i[0] - a[0]),
          (n.y = i[1] - a[1]),
          (n.scaleX = n.scaleY = o),
          this._updateTransform()
      }),
      (t.prototype._updateTransform = function () {
        var e = this._roamTransformable,
          n = this._rawTransformable
        ;(n.parent = e),
          e.updateTransform(),
          n.updateTransform(),
          RT(this.transform || (this.transform = []), n.transform || bi()),
          (this._rawTransform = n.getLocalTransform()),
          (this.invTransform = this.invTransform || []),
          mf(this.invTransform, this.transform),
          this.decomposeTransform()
      }),
      (t.prototype.getTransformInfo = function () {
        var e = this._rawTransformable,
          n = this._roamTransformable,
          i = new Uo()
        return (
          (i.transform = n.transform),
          i.decomposeTransform(),
          {
            roam: {
              x: i.x,
              y: i.y,
              scaleX: i.scaleX,
              scaleY: i.scaleY,
            },
            raw: {
              x: e.x,
              y: e.y,
              scaleX: e.scaleX,
              scaleY: e.scaleY,
            },
          }
        )
      }),
      (t.prototype.getViewRect = function () {
        return this._viewRect
      }),
      (t.prototype.getViewRectAfterRoam = function () {
        var e = this.getBoundingRect().clone()
        return e.applyTransform(this.transform), e
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        var a = n ? this._rawTransform : this.transform
        return (i = i || []), a ? bO(i, e, a) : Nr(i, e)
      }),
      (t.prototype.pointToData = function (e) {
        var n = this.invTransform
        return n ? bO([], e, n) : [e[0], e[1]]
      }),
      (t.prototype.convertToPixel = function (e, n, i) {
        var a = wO(n)
        return a === this ? a.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, n, i) {
        var a = wO(n)
        return a === this ? a.pointToData(i) : null
      }),
      (t.prototype.containPoint = function (e) {
        return this.getViewRectAfterRoam().contain(e[0], e[1])
      }),
      (t.dimensions = ['x', 'y']),
      t
    )
  })(Uo)
function wO(r) {
  var t = r.seriesModel
  return t ? t.coordinateSystem : null
}
const Iv = Jct
var Qct = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: !0,
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: !1,
    },
  },
  JG = ['lng', 'lat'],
  QG = (function (r) {
    X(t, r)
    function t(e, n, i) {
      var a = r.call(this, e) || this
      ;(a.dimensions = JG),
        (a.type = 'geo'),
        (a._nameCoordMap = Pt()),
        (a.map = n)
      var o = i.projection,
        s = rs.load(n, i.nameMap, i.nameProperty),
        l = rs.getGeoResource(n)
      a.resourceType = l ? l.type : null
      var u = (a.regions = s.regions),
        c = Qct[l.type]
      ;(a._regionsMap = s.regionsMap),
        (a.regions = s.regions),
        (a.projection = o)
      var h
      if (o)
        for (var f = 0; f < u.length; f++) {
          var d = u[f].getBoundingRect(o)
          ;(h = h || d.clone()), h.union(d)
        }
      else h = s.boundingRect
      return (
        a.setBoundingRect(h.x, h.y, h.width, h.height),
        (a.aspectScale = o ? 1 : $t(i.aspectScale, c.aspectScale)),
        (a._invertLongitute = o ? !1 : c.invertLongitute),
        a
      )
    }
    return (
      (t.prototype._transformTo = function (e, n, i, a) {
        var o = this.getBoundingRect(),
          s = this._invertLongitute
        ;(o = o.clone()), s && (o.y = -o.y - o.height)
        var l = this._rawTransformable
        l.transform = o.calculateTransform(new ee(e, n, i, a))
        var u = l.parent
        ;(l.parent = null),
          l.decomposeTransform(),
          (l.parent = u),
          s && (l.scaleY = -l.scaleY),
          this._updateTransform()
      }),
      (t.prototype.getRegion = function (e) {
        return this._regionsMap.get(e)
      }),
      (t.prototype.getRegionByCoord = function (e) {
        for (var n = this.regions, i = 0; i < n.length; i++) {
          var a = n[i]
          if (a.type === 'geoJSON' && a.contain(e)) return n[i]
        }
      }),
      (t.prototype.addGeoCoord = function (e, n) {
        this._nameCoordMap.set(e, n)
      }),
      (t.prototype.getGeoCoord = function (e) {
        var n = this._regionsMap.get(e)
        return this._nameCoordMap.get(e) || (n && n.getCenter())
      }),
      (t.prototype.dataToPoint = function (e, n, i) {
        if ((bt(e) && (e = this.getGeoCoord(e)), e)) {
          var a = this.projection
          return a && (e = a.project(e)), e && this.projectedToPoint(e, n, i)
        }
      }),
      (t.prototype.pointToData = function (e) {
        var n = this.projection
        return n && (e = n.unproject(e)), e && this.pointToProjected(e)
      }),
      (t.prototype.pointToProjected = function (e) {
        return r.prototype.pointToData.call(this, e)
      }),
      (t.prototype.projectedToPoint = function (e, n, i) {
        return r.prototype.dataToPoint.call(this, e, n, i)
      }),
      (t.prototype.convertToPixel = function (e, n, i) {
        var a = MO(n)
        return a === this ? a.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, n, i) {
        var a = MO(n)
        return a === this ? a.pointToData(i) : null
      }),
      t
    )
  })(Iv)
In(QG, Iv)
function MO(r) {
  var t = r.geoModel,
    e = r.seriesModel
  return t
    ? t.coordinateSystem
    : e
    ? e.coordinateSystem ||
      (e.getReferringComponents('geo', Pn).models[0] || {}).coordinateSystem
    : null
}
const TO = QG
function CO(r, t) {
  var e = r.get('boundingCoords')
  if (e != null) {
    var n = e[0],
      i = e[1]
    if (isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])) {
      var a = this.projection
      if (a) {
        var o = n[0],
          s = n[1],
          l = i[0],
          u = i[1]
        ;(n = [1 / 0, 1 / 0]), (i = [-1 / 0, -1 / 0])
        var c = function (S, b, T, w) {
          for (var M = T - S, C = w - b, E = 0; E <= 100; E++) {
            var D = E / 100,
              P = a.project([S + M * D, b + C * D])
            Bs(n, n, P), Fs(i, i, P)
          }
        }
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s)
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1])
    }
  }
  var h = this.getBoundingRect(),
    f = r.get('layoutCenter'),
    d = r.get('layoutSize'),
    p = t.getWidth(),
    g = t.getHeight(),
    v = (h.width / h.height) * this.aspectScale,
    m = !1,
    y,
    _
  f &&
    d &&
    ((y = [_t(f[0], p), _t(f[1], g)]),
    (_ = _t(d, Math.min(p, g))),
    !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(_) && (m = !0))
  var x
  if (m)
    (x = {}),
      v > 1
        ? ((x.width = _), (x.height = _ / v))
        : ((x.height = _), (x.width = _ * v)),
      (x.y = y[1] - x.height / 2),
      (x.x = y[0] - x.width / 2)
  else {
    var A = r.getBoxLayoutParams()
    ;(A.aspect = v),
      (x = Vn(A, {
        width: p,
        height: g,
      }))
  }
  this.setViewRect(x.x, x.y, x.width, x.height),
    this.setCenter(r.get('center'), t),
    this.setZoom(r.get('zoom'))
}
function tht(r, t) {
  R(t.get('geoCoord'), function (e, n) {
    r.addGeoCoord(n, e)
  })
}
var eht = (function () {
    function r() {
      this.dimensions = JG
    }
    return (
      (r.prototype.create = function (t, e) {
        var n = []
        function i(o) {
          return {
            nameProperty: o.get('nameProperty'),
            aspectScale: o.get('aspectScale'),
            projection: o.get('projection'),
          }
        }
        t.eachComponent('geo', function (o, s) {
          var l = o.get('map'),
            u = new TO(
              l + s,
              l,
              Q(
                {
                  nameMap: o.get('nameMap'),
                },
                i(o),
              ),
            )
          ;(u.zoomLimit = o.get('scaleLimit')),
            n.push(u),
            (o.coordinateSystem = u),
            (u.model = o),
            (u.resize = CO),
            u.resize(o, e)
        }),
          t.eachSeries(function (o) {
            var s = o.get('coordinateSystem')
            if (s === 'geo') {
              var l = o.get('geoIndex') || 0
              o.coordinateSystem = n[l]
            }
          })
        var a = {}
        return (
          t.eachSeriesByType('map', function (o) {
            if (!o.getHostGeoModel()) {
              var s = o.getMapType()
              ;(a[s] = a[s] || []), a[s].push(o)
            }
          }),
          R(a, function (o, s) {
            var l = st(o, function (c) {
                return c.get('nameMap')
              }),
              u = new TO(
                s,
                s,
                Q(
                  {
                    nameMap: ET(l),
                  },
                  i(o[0]),
                ),
              )
            ;(u.zoomLimit = nr.apply(
              null,
              st(o, function (c) {
                return c.get('scaleLimit')
              }),
            )),
              n.push(u),
              (u.resize = CO),
              u.resize(o[0], e),
              R(o, function (c) {
                ;(c.coordinateSystem = u), tht(u, c)
              })
          }),
          n
        )
      }),
      (r.prototype.getFilledRegions = function (t, e, n, i) {
        for (var a = (t || []).slice(), o = Pt(), s = 0; s < a.length; s++)
          o.set(a[s].name, a[s])
        var l = rs.load(e, n, i)
        return (
          R(l.regions, function (u) {
            var c = u.name
            !o.get(c) &&
              a.push({
                name: c,
              })
          }),
          a
        )
      }),
      r
    )
  })(),
  nht = new eht()
const t4 = nht
var rht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      var a = rs.getGeoResource(e.map)
      if (a && a.type === 'geoJSON') {
        var o = (e.itemStyle = e.itemStyle || {})
        'color' in o || (o.color = '#eee')
      }
      this.mergeDefaultAndTheme(e, i), Xu(e, 'label', ['show'])
    }),
    (t.prototype.optionUpdated = function () {
      var e = this,
        n = this.option
      n.regions = t4.getFilledRegions(
        n.regions,
        n.map,
        n.nameMap,
        n.nameProperty,
      )
      var i = {}
      ;(this._optionModelMap = co(
        n.regions || [],
        function (a, o) {
          var s = o.name
          return (
            s && (a.set(s, new qe(o, e, e.ecModel)), o.selected && (i[s] = !0)),
            a
          )
        },
        Pt(),
      )),
        n.selectedMap || (n.selectedMap = i)
    }),
    (t.prototype.getRegionModel = function (e) {
      return this._optionModelMap.get(e) || new qe(null, this, this.ecModel)
    }),
    (t.prototype.getFormattedLabel = function (e, n) {
      var i = this.getRegionModel(e),
        a =
          n === 'normal'
            ? i.get(['label', 'formatter'])
            : i.get(['emphasis', 'label', 'formatter']),
        o = {
          name: e,
        }
      if (Nt(a)) return (o.status = n), a(o)
      if (bt(a)) return a.replace('{a}', e ?? '')
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.select = function (e) {
      var n = this.option,
        i = n.selectedMode
      if (i) {
        i !== 'multiple' && (n.selectedMap = null)
        var a = n.selectedMap || (n.selectedMap = {})
        a[e] = !0
      }
    }),
    (t.prototype.unSelect = function (e) {
      var n = this.option.selectedMap
      n && (n[e] = !1)
    }),
    (t.prototype.toggleSelected = function (e) {
      this[this.isSelected(e) ? 'unSelect' : 'select'](e)
    }),
    (t.prototype.isSelected = function (e) {
      var n = this.option.selectedMap
      return !!(n && n[e])
    }),
    (t.type = 'geo'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 0,
      show: !0,
      left: 'center',
      top: 'center',
      aspectScale: null,
      silent: !1,
      map: '',
      boundingCoords: null,
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: !1,
        color: '#000',
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: '#444',
      },
      emphasis: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      select: {
        label: {
          show: !0,
          color: 'rgb(100,0,0)',
        },
        itemStyle: {
          color: 'rgba(255,215,0,0.8)',
        },
      },
      regions: [],
    }),
    t
  )
})(xe)
const iht = rht
function EO(r, t) {
  return r.pointToProjected ? r.pointToProjected(t) : r.pointToData(t)
}
function HC(r, t, e, n) {
  var i = r.getZoom(),
    a = r.getCenter(),
    o = t.zoom,
    s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a)
  if (
    (t.dx != null &&
      t.dy != null &&
      ((s[0] -= t.dx), (s[1] -= t.dy), r.setCenter(EO(r, s), n)),
    o != null)
  ) {
    if (e) {
      var l = e.min || 0,
        u = e.max || 1 / 0
      o = Math.max(Math.min(i * o, u), l) / i
    }
    ;(r.scaleX *= o), (r.scaleY *= o)
    var c = (t.originX - r.x) * (o - 1),
      h = (t.originY - r.y) * (o - 1)
    ;(r.x -= c),
      (r.y -= h),
      r.updateTransform(),
      r.setCenter(EO(r, s), n),
      r.setZoom(o * i)
  }
  return {
    center: r.getCenter(),
    zoom: r.getZoom(),
  }
}
var aht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.focusBlurEnabled = !0), e
  }
  return (
    (t.prototype.init = function (e, n) {
      this._api = n
    }),
    (t.prototype.render = function (e, n, i, a) {
      if (((this._model = e), !e.get('show'))) {
        this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
        return
      }
      this._mapDraw || (this._mapDraw = new jG(i))
      var o = this._mapDraw
      o.draw(e, n, i, this, a),
        o.group.on('click', this._handleRegionClick, this),
        (o.group.silent = e.get('silent')),
        this.group.add(o.group),
        this.updateSelectStatus(e, n, i)
    }),
    (t.prototype._handleRegionClick = function (e) {
      var n
      xu(
        e.target,
        function (i) {
          return (n = Wt(i).eventData) != null
        },
        !0,
      ),
        n &&
          this._api.dispatchAction({
            type: 'geoToggleSelect',
            geoId: this._model.id,
            name: n.name,
          })
    }),
    (t.prototype.updateSelectStatus = function (e, n, i) {
      var a = this
      this._mapDraw.group.traverse(function (o) {
        var s = Wt(o).eventData
        if (s)
          return (
            a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o),
            !0
          )
      })
    }),
    (t.prototype.findHighDownDispatchers = function (e) {
      return (
        this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model)
      )
    }),
    (t.prototype.dispose = function () {
      this._mapDraw && this._mapDraw.remove()
    }),
    (t.type = 'geo'),
    t
  )
})(dn)
const oht = aht
function sht(r, t, e) {
  rs.registerMap(r, t, e)
}
function e4(r) {
  r.registerCoordinateSystem('geo', t4),
    r.registerComponentModel(iht),
    r.registerComponentView(oht),
    r.registerImpl('registerMap', sht),
    r.registerImpl('getMap', function (e) {
      return rs.getMapForUser(e)
    })
  function t(e, n) {
    ;(n.update = 'geo:updateSelectStatus'),
      r.registerAction(n, function (i, a) {
        var o = {},
          s = []
        return (
          a.eachComponent(
            {
              mainType: 'geo',
              query: i,
            },
            function (l) {
              l[e](i.name)
              var u = l.coordinateSystem
              R(u.regions, function (h) {
                o[h.name] = l.isSelected(h.name) || !1
              })
              var c = []
              R(o, function (h, f) {
                o[f] && c.push(f)
              }),
                s.push({
                  geoIndex: l.componentIndex,
                  name: c,
                })
            },
          ),
          {
            selected: o,
            allSelected: s,
            name: i.name,
          }
        )
      })
  }
  t('toggleSelected', {
    type: 'geoToggleSelect',
    event: 'geoselectchanged',
  }),
    t('select', {
      type: 'geoSelect',
      event: 'geoselected',
    }),
    t('unSelect', {
      type: 'geoUnSelect',
      event: 'geounselected',
    }),
    r.registerAction(
      {
        type: 'geoRoam',
        event: 'geoRoam',
        update: 'updateTransform',
      },
      function (e, n, i) {
        var a = e.componentType || 'series'
        n.eachComponent(
          {
            mainType: a,
            query: e,
          },
          function (o) {
            var s = o.coordinateSystem
            if (s.type === 'geo') {
              var l = HC(s, e, o.get('scaleLimit'), i)
              o.setCenter && o.setCenter(l.center),
                o.setZoom && o.setZoom(l.zoom),
                a === 'series' &&
                  R(o.seriesGroup, function (u) {
                    u.setCenter(l.center), u.setZoom(l.zoom)
                  })
            }
          },
        )
      },
    )
}
function lht(r) {
  ie(e4),
    r.registerChartView(Yct),
    r.registerSeriesModel(qct),
    r.registerLayout(jct),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, Kct),
    K5('map', r.registerAction)
}
function uht(r) {
  var t = r
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null,
  }
  for (var e = [t], n, i; (n = e.pop()); )
    if (((i = n.children), n.isExpand && i.length))
      for (var a = i.length, o = a - 1; o >= 0; o--) {
        var s = i[o]
        ;(s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null,
        }),
          e.push(s)
      }
}
function cht(r, t) {
  var e = r.isExpand ? r.children : [],
    n = r.parentNode.children,
    i = r.hierNode.i ? n[r.hierNode.i - 1] : null
  if (e.length) {
    dht(r)
    var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2
    i
      ? ((r.hierNode.prelim = i.hierNode.prelim + t(r, i)),
        (r.hierNode.modifier = r.hierNode.prelim - a))
      : (r.hierNode.prelim = a)
  } else i && (r.hierNode.prelim = i.hierNode.prelim + t(r, i))
  r.parentNode.hierNode.defaultAncestor = pht(
    r,
    i,
    r.parentNode.hierNode.defaultAncestor || n[0],
    t,
  )
}
function hht(r) {
  var t = r.hierNode.prelim + r.parentNode.hierNode.modifier
  r.setLayout(
    {
      x: t,
    },
    !0,
  ),
    (r.hierNode.modifier += r.parentNode.hierNode.modifier)
}
function DO(r) {
  return arguments.length ? r : mht
}
function Gd(r, t) {
  return (
    (r -= Math.PI / 2),
    {
      x: t * Math.cos(r),
      y: t * Math.sin(r),
    }
  )
}
function fht(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function dht(r) {
  for (var t = r.children, e = t.length, n = 0, i = 0; --e >= 0; ) {
    var a = t[e]
    ;(a.hierNode.prelim += n),
      (a.hierNode.modifier += n),
      (i += a.hierNode.change),
      (n += a.hierNode.shift + i)
  }
}
function pht(r, t, e, n) {
  if (t) {
    for (
      var i = r,
        a = r,
        o = a.parentNode.children[0],
        s = t,
        l = i.hierNode.modifier,
        u = a.hierNode.modifier,
        c = o.hierNode.modifier,
        h = s.hierNode.modifier;
      (s = fS(s)), (a = dS(a)), s && a;

    ) {
      ;(i = fS(i)), (o = dS(o)), (i.hierNode.ancestor = r)
      var f = s.hierNode.prelim + h - a.hierNode.prelim - u + n(s, a)
      f > 0 && (ght(vht(s, r, e), r, f), (u += f), (l += f)),
        (h += s.hierNode.modifier),
        (u += a.hierNode.modifier),
        (l += i.hierNode.modifier),
        (c += o.hierNode.modifier)
    }
    s && !fS(i) && ((i.hierNode.thread = s), (i.hierNode.modifier += h - l)),
      a &&
        !dS(o) &&
        ((o.hierNode.thread = a), (o.hierNode.modifier += u - c), (e = r))
  }
  return e
}
function fS(r) {
  var t = r.children
  return t.length && r.isExpand ? t[t.length - 1] : r.hierNode.thread
}
function dS(r) {
  var t = r.children
  return t.length && r.isExpand ? t[0] : r.hierNode.thread
}
function vht(r, t, e) {
  return r.hierNode.ancestor.parentNode === t.parentNode
    ? r.hierNode.ancestor
    : e
}
function ght(r, t, e) {
  var n = e / (t.hierNode.i - r.hierNode.i)
  ;(t.hierNode.change -= n),
    (t.hierNode.shift += e),
    (t.hierNode.modifier += e),
    (t.hierNode.prelim += e),
    (r.hierNode.change += n)
}
function mht(r, t) {
  return r.parentNode === t.parentNode ? 1 : 2
}
var yht = (function () {
    function r() {
      ;(this.parentPoint = []), (this.childPoints = [])
    }
    return r
  })(),
  _ht = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new yht()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.childPoints,
          a = i.length,
          o = n.parentPoint,
          s = i[0],
          l = i[a - 1]
        if (a === 1) {
          e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1])
          return
        }
        var u = n.orient,
          c = u === 'TB' || u === 'BT' ? 0 : 1,
          h = 1 - c,
          f = _t(n.forkPosition, 1),
          d = []
        ;(d[c] = o[c]),
          (d[h] = o[h] + (l[h] - o[h]) * f),
          e.moveTo(o[0], o[1]),
          e.lineTo(d[0], d[1]),
          e.moveTo(s[0], s[1]),
          (d[c] = s[c]),
          e.lineTo(d[0], d[1]),
          (d[c] = l[c]),
          e.lineTo(d[0], d[1]),
          e.lineTo(l[0], l[1])
        for (var p = 1; p < a - 1; p++) {
          var g = i[p]
          e.moveTo(g[0], g[1]), (d[c] = g[c]), e.lineTo(d[0], d[1])
        }
      }),
      t
    )
  })(oe),
  xht = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._mainGroup = new Ht()), e
    }
    return (
      (t.prototype.init = function (e, n) {
        ;(this._controller = new Rv(n.getZr())),
          (this._controllerHost = {
            target: this.group,
          }),
          this.group.add(this._mainGroup)
      }),
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = e.layoutInfo,
          s = this._mainGroup,
          l = e.get('layout')
        l === 'radial'
          ? ((s.x = o.x + o.width / 2), (s.y = o.y + o.height / 2))
          : ((s.x = o.x), (s.y = o.y)),
          this._updateViewCoordSys(e, i),
          this._updateController(e, n, i)
        var u = this._data
        a
          .diff(u)
          .add(function (c) {
            LO(a, c) && PO(a, c, null, s, e)
          })
          .update(function (c, h) {
            var f = u.getItemGraphicEl(h)
            if (!LO(a, c)) {
              f && IO(u, h, f, s, e)
              return
            }
            PO(a, c, f, s, e)
          })
          .remove(function (c) {
            var h = u.getItemGraphicEl(c)
            h && IO(u, c, h, s, e)
          })
          .execute(),
          (this._nodeScaleRatio = e.get('nodeScaleRatio')),
          this._updateNodeAndLinkScale(e),
          e.get('expandAndCollapse') === !0 &&
            a.eachItemGraphicEl(function (c, h) {
              c.off('click').on('click', function () {
                i.dispatchAction({
                  type: 'treeExpandAndCollapse',
                  seriesId: e.id,
                  dataIndex: h,
                })
              })
            }),
          (this._data = a)
      }),
      (t.prototype._updateViewCoordSys = function (e, n) {
        var i = e.getData(),
          a = []
        i.each(function (h) {
          var f = i.getItemLayout(h)
          f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y])
        })
        var o = [],
          s = []
        e_(a, o, s)
        var l = this._min,
          u = this._max
        s[0] - o[0] === 0 &&
          ((o[0] = l ? l[0] : o[0] - 1), (s[0] = u ? u[0] : s[0] + 1)),
          s[1] - o[1] === 0 &&
            ((o[1] = l ? l[1] : o[1] - 1), (s[1] = u ? u[1] : s[1] + 1))
        var c = (e.coordinateSystem = new Iv())
        ;(c.zoomLimit = e.get('scaleLimit')),
          c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]),
          c.setCenter(e.get('center'), n),
          c.setZoom(e.get('zoom')),
          this.group.attr({
            x: c.x,
            y: c.y,
            scaleX: c.scaleX,
            scaleY: c.scaleY,
          }),
          (this._min = o),
          (this._max = s)
      }),
      (t.prototype._updateController = function (e, n, i) {
        var a = this,
          o = this._controller,
          s = this._controllerHost,
          l = this.group
        o.setPointerChecker(function (u, c, h) {
          var f = l.getBoundingRect()
          return f.applyTransform(l.transform), f.contain(c, h) && !T_(u, i, e)
        }),
          o.enable(e.get('roam')),
          (s.zoomLimit = e.get('scaleLimit')),
          (s.zoom = e.coordinateSystem.getZoom()),
          o
            .off('pan')
            .off('zoom')
            .on('pan', function (u) {
              UC(s, u.dx, u.dy),
                i.dispatchAction({
                  seriesId: e.id,
                  type: 'treeRoam',
                  dx: u.dx,
                  dy: u.dy,
                })
            })
            .on('zoom', function (u) {
              VC(s, u.scale, u.originX, u.originY),
                i.dispatchAction({
                  seriesId: e.id,
                  type: 'treeRoam',
                  zoom: u.scale,
                  originX: u.originX,
                  originY: u.originY,
                }),
                a._updateNodeAndLinkScale(e),
                i.updateLabelLayout()
            })
      }),
      (t.prototype._updateNodeAndLinkScale = function (e) {
        var n = e.getData(),
          i = this._getNodeGlobalScale(e)
        n.eachItemGraphicEl(function (a, o) {
          a.setSymbolScale(i)
        })
      }),
      (t.prototype._getNodeGlobalScale = function (e) {
        var n = e.coordinateSystem
        if (n.type !== 'view') return 1
        var i = this._nodeScaleRatio,
          a = n.scaleX || 1,
          o = n.getZoom(),
          s = (o - 1) * i + 1
        return s / a
      }),
      (t.prototype.dispose = function () {
        this._controller && this._controller.dispose(),
          (this._controllerHost = null)
      }),
      (t.prototype.remove = function () {
        this._mainGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'tree'),
      t
    )
  })(Ze)
function LO(r, t) {
  var e = r.getItemLayout(t)
  return e && !isNaN(e.x) && !isNaN(e.y)
}
function PO(r, t, e, n, i) {
  var a = !e,
    o = r.tree.getNodeByDataIndex(t),
    s = o.getModel(),
    l = o.getVisual('style').fill,
    u = o.isExpand === !1 && o.children.length !== 0 ? l : '#fff',
    c = r.tree.root,
    h = o.parentNode === c ? o : o.parentNode || o,
    f = r.getItemGraphicEl(h.dataIndex),
    d = h.getLayout(),
    p = f
      ? {
          x: f.__oldX,
          y: f.__oldY,
          rawX: f.__radialOldRawX,
          rawY: f.__radialOldRawY,
        }
      : d,
    g = o.getLayout()
  a
    ? ((e = new Tv(r, t, null, {
        symbolInnerColor: u,
        useNameLabel: !0,
      })),
      (e.x = p.x),
      (e.y = p.y))
    : e.updateData(r, t, null, {
        symbolInnerColor: u,
        useNameLabel: !0,
      }),
    (e.__radialOldRawX = e.__radialRawX),
    (e.__radialOldRawY = e.__radialRawY),
    (e.__radialRawX = g.rawX),
    (e.__radialRawY = g.rawY),
    n.add(e),
    r.setItemGraphicEl(t, e),
    (e.__oldX = e.x),
    (e.__oldY = e.y),
    we(
      e,
      {
        x: g.x,
        y: g.y,
      },
      i,
    )
  var v = e.getSymbolPath()
  if (i.get('layout') === 'radial') {
    var m = c.children[0],
      y = m.getLayout(),
      _ = m.children.length,
      x = void 0,
      A = void 0
    if (g.x === y.x && o.isExpand === !0 && m.children.length) {
      var S = {
        x: (m.children[0].getLayout().x + m.children[_ - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[_ - 1].getLayout().y) / 2,
      }
      ;(x = Math.atan2(S.y - y.y, S.x - y.x)),
        x < 0 && (x = Math.PI * 2 + x),
        (A = S.x < y.x),
        A && (x = x - Math.PI)
    } else
      (x = Math.atan2(g.y - y.y, g.x - y.x)),
        x < 0 && (x = Math.PI * 2 + x),
        o.children.length === 0 ||
        (o.children.length !== 0 && o.isExpand === !1)
          ? ((A = g.x < y.x), A && (x = x - Math.PI))
          : ((A = g.x > y.x), A || (x = x - Math.PI))
    var b = A ? 'left' : 'right',
      T = s.getModel('label'),
      w = T.get('rotate'),
      M = w * (Math.PI / 180),
      C = v.getTextContent()
    C &&
      (v.setTextConfig({
        position: T.get('position') || b,
        rotation: w == null ? -x : M,
        origin: 'center',
      }),
      C.setStyle('verticalAlign', 'middle'))
  }
  var E = s.get(['emphasis', 'focus']),
    D =
      E === 'relative'
        ? ky(o.getAncestorsIndices(), o.getDescendantIndices())
        : E === 'ancestor'
        ? o.getAncestorsIndices()
        : E === 'descendant'
        ? o.getDescendantIndices()
        : null
  D && (Wt(e).focus = D),
    Sht(i, o, c, e, p, d, g, n),
    e.__edge &&
      (e.onHoverStateChange = function (P) {
        if (P !== 'blur') {
          var L = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex)
          ;(L && L.hoverState === _v) || Xy(e.__edge, P)
        }
      })
}
function Sht(r, t, e, n, i, a, o, s) {
  var l = t.getModel(),
    u = r.get('edgeShape'),
    c = r.get('layout'),
    h = r.getOrient(),
    f = r.get(['lineStyle', 'curveness']),
    d = r.get('edgeForkPosition'),
    p = l.getModel('lineStyle').getLineStyle(),
    g = n.__edge
  if (u === 'curve')
    t.parentNode &&
      t.parentNode !== e &&
      (g ||
        (g = n.__edge =
          new a_({
            shape: Bw(c, h, f, i, i),
          })),
      we(
        g,
        {
          shape: Bw(c, h, f, a, o),
        },
        r,
      ))
  else if (
    u === 'polyline' &&
    c === 'orthogonal' &&
    t !== e &&
    t.children &&
    t.children.length !== 0 &&
    t.isExpand === !0
  ) {
    for (var v = t.children, m = [], y = 0; y < v.length; y++) {
      var _ = v[y].getLayout()
      m.push([_.x, _.y])
    }
    g ||
      (g = n.__edge =
        new _ht({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: h,
            forkPosition: d,
          },
        })),
      we(
        g,
        {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: m,
          },
        },
        r,
      )
  }
  g &&
    !(u === 'polyline' && !t.isExpand) &&
    (g.useStyle(
      zt(
        {
          strokeNoScale: !0,
          fill: null,
        },
        p,
      ),
    ),
    gr(g, l, 'lineStyle'),
    qu(g),
    s.add(g))
}
function RO(r, t, e, n, i) {
  var a = t.tree.root,
    o = n4(a, r),
    s = o.source,
    l = o.sourceLayout,
    u = t.getItemGraphicEl(r.dataIndex)
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex),
      h = c.__edge,
      f =
        u.__edge || (s.isExpand === !1 || s.children.length === 1 ? h : void 0),
      d = n.get('edgeShape'),
      p = n.get('layout'),
      g = n.get('orient'),
      v = n.get(['lineStyle', 'curveness'])
    f &&
      (d === 'curve'
        ? al(
            f,
            {
              shape: Bw(p, g, v, l, l),
              style: {
                opacity: 0,
              },
            },
            n,
            {
              cb: function () {
                e.remove(f)
              },
              removeOpt: i,
            },
          )
        : d === 'polyline' &&
          n.get('layout') === 'orthogonal' &&
          al(
            f,
            {
              shape: {
                parentPoint: [l.x, l.y],
                childPoints: [[l.x, l.y]],
              },
              style: {
                opacity: 0,
              },
            },
            n,
            {
              cb: function () {
                e.remove(f)
              },
              removeOpt: i,
            },
          ))
  }
}
function n4(r, t) {
  for (
    var e = t.parentNode === r ? t : t.parentNode || t, n;
    (n = e.getLayout()), n == null;

  )
    e = e.parentNode === r ? e : e.parentNode || e
  return {
    source: e,
    sourceLayout: n,
  }
}
function IO(r, t, e, n, i) {
  var a = r.tree.getNodeByDataIndex(t),
    o = r.tree.root,
    s = n4(o, a).sourceLayout,
    l = {
      duration: i.get('animationDurationUpdate'),
      easing: i.get('animationEasingUpdate'),
    }
  al(
    e,
    {
      x: s.x + 1,
      y: s.y + 1,
    },
    i,
    {
      cb: function () {
        n.remove(e), r.setItemGraphicEl(t, null)
      },
      removeOpt: l,
    },
  ),
    e.fadeOut(null, r.hostModel, {
      fadeLabel: !0,
      animation: l,
    }),
    a.children.forEach(function (u) {
      RO(u, r, n, i, l)
    }),
    RO(a, r, n, i, l)
}
function Bw(r, t, e, n, i) {
  var a, o, s, l, u, c, h, f
  if (r === 'radial') {
    ;(u = n.rawX), (h = n.rawY), (c = i.rawX), (f = i.rawY)
    var d = Gd(u, h),
      p = Gd(u, h + (f - h) * e),
      g = Gd(c, f + (h - f) * e),
      v = Gd(c, f)
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0,
    }
  } else
    (u = n.x),
      (h = n.y),
      (c = i.x),
      (f = i.y),
      (t === 'LR' || t === 'RL') &&
        ((a = u + (c - u) * e), (o = h), (s = c + (u - c) * e), (l = f)),
      (t === 'TB' || t === 'BT') &&
        ((a = u), (o = h + (f - h) * e), (s = c), (l = f + (h - f) * e))
  return {
    x1: u,
    y1: h,
    x2: c,
    y2: f,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l,
  }
}
const Aht = xht
var Ji = ve()
function r4(r) {
  var t = r.mainData,
    e = r.datas
  e ||
    ((e = {
      main: t,
    }),
    (r.datasAttr = {
      main: 'data',
    })),
    (r.datas = r.mainData = null),
    i4(t, e, r),
    R(e, function (n) {
      R(t.TRANSFERABLE_METHODS, function (i) {
        n.wrapMethod(i, Zt(bht, r))
      })
    }),
    t.wrapMethod('cloneShallow', Zt(Mht, r)),
    R(t.CHANGABLE_METHODS, function (n) {
      t.wrapMethod(n, Zt(wht, r))
    }),
    Gr(e[t.dataType] === t)
}
function bht(r, t) {
  if (Eht(this)) {
    var e = Q({}, Ji(this).datas)
    ;(e[this.dataType] = t), i4(t, e, r)
  } else WC(t, this.dataType, Ji(this).mainData, r)
  return t
}
function wht(r, t) {
  return r.struct && r.struct.update(), t
}
function Mht(r, t) {
  return (
    R(Ji(t).datas, function (e, n) {
      e !== t && WC(e.cloneShallow(), n, t, r)
    }),
    t
  )
}
function Tht(r) {
  var t = Ji(this).mainData
  return r == null || t == null ? t : Ji(t).datas[r]
}
function Cht() {
  var r = Ji(this).mainData
  return r == null
    ? [
        {
          data: r,
        },
      ]
    : st(pe(Ji(r).datas), function (t) {
        return {
          type: t,
          data: Ji(r).datas[t],
        }
      })
}
function Eht(r) {
  return Ji(r).mainData === r
}
function i4(r, t, e) {
  ;(Ji(r).datas = {}),
    R(t, function (n, i) {
      WC(n, i, r, e)
    })
}
function WC(r, t, e, n) {
  ;(Ji(e).datas[t] = r),
    (Ji(r).mainData = e),
    (r.dataType = t),
    n.struct && ((r[n.structAttr] = n.struct), (n.struct[n.datasAttr[t]] = r)),
    (r.getLinkedData = Tht),
    (r.getLinkedDataAll = Cht)
}
var Dht = (function () {
    function r(t, e) {
      ;(this.depth = 0),
        (this.height = 0),
        (this.dataIndex = -1),
        (this.children = []),
        (this.viewChildren = []),
        (this.isExpand = !1),
        (this.name = t || ''),
        (this.hostTree = e)
    }
    return (
      (r.prototype.isRemoved = function () {
        return this.dataIndex < 0
      }),
      (r.prototype.eachNode = function (t, e, n) {
        Nt(t) && ((n = e), (e = t), (t = null)),
          (t = t || {}),
          bt(t) &&
            (t = {
              order: t,
            })
        var i = t.order || 'preorder',
          a = this[t.attr || 'children'],
          o
        i === 'preorder' && (o = e.call(n, this))
        for (var s = 0; !o && s < a.length; s++) a[s].eachNode(t, e, n)
        i === 'postorder' && e.call(n, this)
      }),
      (r.prototype.updateDepthAndHeight = function (t) {
        var e = 0
        this.depth = t
        for (var n = 0; n < this.children.length; n++) {
          var i = this.children[n]
          i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height)
        }
        this.height = e + 1
      }),
      (r.prototype.getNodeById = function (t) {
        if (this.getId() === t) return this
        for (var e = 0, n = this.children, i = n.length; e < i; e++) {
          var a = n[e].getNodeById(t)
          if (a) return a
        }
      }),
      (r.prototype.contains = function (t) {
        if (t === this) return !0
        for (var e = 0, n = this.children, i = n.length; e < i; e++) {
          var a = n[e].contains(t)
          if (a) return a
        }
      }),
      (r.prototype.getAncestors = function (t) {
        for (var e = [], n = t ? this : this.parentNode; n; )
          e.push(n), (n = n.parentNode)
        return e.reverse(), e
      }),
      (r.prototype.getAncestorsIndices = function () {
        for (var t = [], e = this; e; ) t.push(e.dataIndex), (e = e.parentNode)
        return t.reverse(), t
      }),
      (r.prototype.getDescendantIndices = function () {
        var t = []
        return (
          this.eachNode(function (e) {
            t.push(e.dataIndex)
          }),
          t
        )
      }),
      (r.prototype.getValue = function (t) {
        var e = this.hostTree.data
        return e
          .getStore()
          .get(e.getDimensionIndex(t || 'value'), this.dataIndex)
      }),
      (r.prototype.setLayout = function (t, e) {
        this.dataIndex >= 0 &&
          this.hostTree.data.setItemLayout(this.dataIndex, t, e)
      }),
      (r.prototype.getLayout = function () {
        return this.hostTree.data.getItemLayout(this.dataIndex)
      }),
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostTree,
            n = e.data.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getLevelModel = function () {
        return (this.hostTree.levelModels || [])[this.depth]
      }),
      (r.prototype.setVisual = function (t, e) {
        this.dataIndex >= 0 &&
          this.hostTree.data.setItemVisual(this.dataIndex, t, e)
      }),
      (r.prototype.getVisual = function (t) {
        return this.hostTree.data.getItemVisual(this.dataIndex, t)
      }),
      (r.prototype.getRawIndex = function () {
        return this.hostTree.data.getRawIndex(this.dataIndex)
      }),
      (r.prototype.getId = function () {
        return this.hostTree.data.getId(this.dataIndex)
      }),
      (r.prototype.getChildIndex = function () {
        if (this.parentNode) {
          for (var t = this.parentNode.children, e = 0; e < t.length; ++e)
            if (t[e] === this) return e
          return -1
        }
        return -1
      }),
      (r.prototype.isAncestorOf = function (t) {
        for (var e = t.parentNode; e; ) {
          if (e === this) return !0
          e = e.parentNode
        }
        return !1
      }),
      (r.prototype.isDescendantOf = function (t) {
        return t !== this && t.isAncestorOf(this)
      }),
      r
    )
  })(),
  Lht = (function () {
    function r(t) {
      ;(this.type = 'tree'), (this._nodes = []), (this.hostModel = t)
    }
    return (
      (r.prototype.eachNode = function (t, e, n) {
        this.root.eachNode(t, e, n)
      }),
      (r.prototype.getNodeByDataIndex = function (t) {
        var e = this.data.getRawIndex(t)
        return this._nodes[e]
      }),
      (r.prototype.getNodeById = function (t) {
        return this.root.getNodeById(t)
      }),
      (r.prototype.update = function () {
        for (
          var t = this.data, e = this._nodes, n = 0, i = e.length;
          n < i;
          n++
        )
          e[n].dataIndex = -1
        for (var n = 0, i = t.count(); n < i; n++)
          e[t.getRawIndex(n)].dataIndex = n
      }),
      (r.prototype.clearLayouts = function () {
        this.data.clearItemLayouts()
      }),
      (r.createTree = function (t, e, n) {
        var i = new r(e),
          a = [],
          o = 1
        s(t)
        function s(c, h) {
          var f = c.value
          ;(o = Math.max(o, at(f) ? f.length : 1)), a.push(c)
          var d = new Dht(Un(c.name, ''), i)
          h ? Pht(d, h) : (i.root = d), i._nodes.push(d)
          var p = c.children
          if (p) for (var g = 0; g < p.length; g++) s(p[g], d)
        }
        i.root.updateDepthAndHeight(0)
        var l = wv(a, {
            coordDimensions: ['value'],
            dimensionsCount: o,
          }).dimensions,
          u = new Vr(l, e)
        return (
          u.initData(a),
          n && n(u),
          r4({
            mainData: u,
            struct: i,
            structAttr: 'tree',
          }),
          i.update(),
          i
        )
      }),
      r
    )
  })()
function Pht(r, t) {
  var e = t.children
  r.parentNode !== t && (e.push(r), (r.parentNode = t))
}
const XC = Lht
function nv(r, t, e) {
  if (r && re(t, r.type) >= 0) {
    var n = e.getData().tree.root,
      i = r.targetNode
    if ((bt(i) && (i = n.getNodeById(i)), i && n.contains(i)))
      return {
        node: i,
      }
    var a = r.targetNodeId
    if (a != null && (i = n.getNodeById(a)))
      return {
        node: i,
      }
  }
}
function a4(r) {
  for (var t = []; r; ) (r = r.parentNode), r && t.push(r)
  return t.reverse()
}
function YC(r, t) {
  var e = a4(r)
  return re(e, t) >= 0
}
function E_(r, t) {
  for (var e = []; r; ) {
    var n = r.dataIndex
    e.push({
      name: r.name,
      dataIndex: n,
      value: t.getRawValue(n),
    }),
      (r = r.parentNode)
  }
  return e.reverse(), e
}
var Rht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.hasSymbolVisual = !0), (e.ignoreStyleOnData = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e) {
      var n = {
          name: e.name,
          children: e.data,
        },
        i = e.leaves || {},
        a = new qe(i, this, this.ecModel),
        o = XC.createTree(n, this, s)
      function s(h) {
        h.wrapMethod('getItemModel', function (f, d) {
          var p = o.getNodeByDataIndex(d)
          return (
            (p && p.children.length && p.isExpand) || (f.parentModel = a), f
          )
        })
      }
      var l = 0
      o.eachNode('preorder', function (h) {
        h.depth > l && (l = h.depth)
      })
      var u = e.expandAndCollapse,
        c = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l
      return (
        o.root.eachNode('preorder', function (h) {
          var f = h.hostTree.data.getRawDataItem(h.dataIndex)
          h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c
        }),
        o.data
      )
    }),
    (t.prototype.getOrient = function () {
      var e = this.get('orient')
      return e === 'horizontal' ? (e = 'LR') : e === 'vertical' && (e = 'TB'), e
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      for (
        var a = this.getData().tree,
          o = a.root.children[0],
          s = a.getNodeByDataIndex(e),
          l = s.getValue(),
          u = s.name;
        s && s !== o;

      )
        (u = s.parentNode.name + '.' + u), (s = s.parentNode)
      return Kn('nameValue', {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null,
      })
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (n.treeAncestors = E_(i, this)), (n.collapsed = !i.isExpand), n
    }),
    (t.type = 'series.tree'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      left: '12%',
      top: '12%',
      right: '12%',
      bottom: '12%',
      layout: 'orthogonal',
      edgeShape: 'curve',
      edgeForkPosition: '50%',
      roam: !1,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: 'LR',
      symbol: 'emptyCircle',
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: '#ccc',
        width: 1.5,
        curveness: 0.5,
      },
      itemStyle: {
        color: 'lightsteelblue',
        borderWidth: 1.5,
      },
      label: {
        show: !0,
      },
      animationEasing: 'linear',
      animationDuration: 700,
      animationDurationUpdate: 500,
    }),
    t
  )
})(rn)
const Iht = Rht
function Oht(r, t, e) {
  for (var n = [r], i = [], a; (a = n.pop()); )
    if ((i.push(a), a.isExpand)) {
      var o = a.children
      if (o.length) for (var s = 0; s < o.length; s++) n.push(o[s])
    }
  for (; (a = i.pop()); ) t(a, e)
}
function gd(r, t) {
  for (var e = [r], n; (n = e.pop()); )
    if ((t(n), n.isExpand)) {
      var i = n.children
      if (i.length) for (var a = i.length - 1; a >= 0; a--) e.push(i[a])
    }
}
function Nht(r, t) {
  r.eachSeriesByType('tree', function (e) {
    kht(e, t)
  })
}
function kht(r, t) {
  var e = fht(r, t)
  r.layoutInfo = e
  var n = r.get('layout'),
    i = 0,
    a = 0,
    o = null
  n === 'radial'
    ? ((i = 2 * Math.PI),
      (a = Math.min(e.height, e.width) / 2),
      (o = DO(function (_, x) {
        return (_.parentNode === x.parentNode ? 1 : 2) / _.depth
      })))
    : ((i = e.width), (a = e.height), (o = DO()))
  var s = r.getData().tree.root,
    l = s.children[0]
  if (l) {
    uht(s),
      Oht(l, cht, o),
      (s.hierNode.modifier = -l.hierNode.prelim),
      gd(l, hht)
    var u = l,
      c = l,
      h = l
    gd(l, function (_) {
      var x = _.getLayout().x
      x < u.getLayout().x && (u = _),
        x > c.getLayout().x && (c = _),
        _.depth > h.depth && (h = _)
    })
    var f = u === c ? 1 : o(u, c) / 2,
      d = f - u.getLayout().x,
      p = 0,
      g = 0,
      v = 0,
      m = 0
    if (n === 'radial')
      (p = i / (c.getLayout().x + f + d)),
        (g = a / (h.depth - 1 || 1)),
        gd(l, function (_) {
          ;(v = (_.getLayout().x + d) * p), (m = (_.depth - 1) * g)
          var x = Gd(v, m)
          _.setLayout(
            {
              x: x.x,
              y: x.y,
              rawX: v,
              rawY: m,
            },
            !0,
          )
        })
    else {
      var y = r.getOrient()
      y === 'RL' || y === 'LR'
        ? ((g = a / (c.getLayout().x + f + d)),
          (p = i / (h.depth - 1 || 1)),
          gd(l, function (_) {
            ;(m = (_.getLayout().x + d) * g),
              (v = y === 'LR' ? (_.depth - 1) * p : i - (_.depth - 1) * p),
              _.setLayout(
                {
                  x: v,
                  y: m,
                },
                !0,
              )
          }))
        : (y === 'TB' || y === 'BT') &&
          ((p = i / (c.getLayout().x + f + d)),
          (g = a / (h.depth - 1 || 1)),
          gd(l, function (_) {
            ;(v = (_.getLayout().x + d) * p),
              (m = y === 'TB' ? (_.depth - 1) * g : a - (_.depth - 1) * g),
              _.setLayout(
                {
                  x: v,
                  y: m,
                },
                !0,
              )
          }))
    }
  }
}
function Bht(r) {
  r.eachSeriesByType('tree', function (t) {
    var e = t.getData(),
      n = e.tree
    n.eachNode(function (i) {
      var a = i.getModel(),
        o = a.getModel('itemStyle').getItemStyle(),
        s = e.ensureUniqueItemVisual(i.dataIndex, 'style')
      Q(s, o)
    })
  })
}
function Fht(r) {
  r.registerAction(
    {
      type: 'treeExpandAndCollapse',
      event: 'treeExpandAndCollapse',
      update: 'update',
    },
    function (t, e) {
      e.eachComponent(
        {
          mainType: 'series',
          subType: 'tree',
          query: t,
        },
        function (n) {
          var i = t.dataIndex,
            a = n.getData().tree,
            o = a.getNodeByDataIndex(i)
          o.isExpand = !o.isExpand
        },
      )
    },
  ),
    r.registerAction(
      {
        type: 'treeRoam',
        event: 'treeRoam',
        update: 'none',
      },
      function (t, e, n) {
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'tree',
            query: t,
          },
          function (i) {
            var a = i.coordinateSystem,
              o = HC(a, t, void 0, n)
            i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
          },
        )
      },
    )
}
function zht(r) {
  r.registerChartView(Aht),
    r.registerSeriesModel(Iht),
    r.registerLayout(Nht),
    r.registerVisual(Bht),
    Fht(r)
}
var OO = ['treemapZoomToNode', 'treemapRender', 'treemapMove']
function Uht(r) {
  for (var t = 0; t < OO.length; t++)
    r.registerAction(
      {
        type: OO[t],
        update: 'updateView',
      },
      wn,
    )
  r.registerAction(
    {
      type: 'treemapRootToNode',
      update: 'updateView',
    },
    function (e, n) {
      n.eachComponent(
        {
          mainType: 'series',
          subType: 'treemap',
          query: e,
        },
        i,
      )
      function i(a, o) {
        var s = ['treemapZoomToNode', 'treemapRootToNode'],
          l = nv(e, s, a)
        if (l) {
          var u = a.getViewRoot()
          u && (e.direction = YC(u, l.node) ? 'rollUp' : 'drillDown'),
            a.resetViewRoot(l.node)
        }
      }
    },
  )
}
function o4(r) {
  var t = r.getData(),
    e = t.tree,
    n = {}
  e.eachNode(function (i) {
    for (var a = i; a && a.depth > 1; ) a = a.parentNode
    var o = fw(r.ecModel, a.name || a.dataIndex + '', n)
    i.setVisual('decal', o)
  })
}
var Vht = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.preventUsingHoverLayer = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = {
        name: e.name,
        children: e.data,
      }
      s4(i)
      var a = e.levels || [],
        o = (this.designatedVisualItemStyle = {}),
        s = new qe(
          {
            itemStyle: o,
          },
          this,
          n,
        )
      a = e.levels = Ght(a, n)
      var l = st(
          a || [],
          function (h) {
            return new qe(h, s, n)
          },
          this,
        ),
        u = XC.createTree(i, this, c)
      function c(h) {
        h.wrapMethod('getItemModel', function (f, d) {
          var p = u.getNodeByDataIndex(d),
            g = p ? l[p.depth] : null
          return (f.parentModel = g || s), f
        })
      }
      return u.data
    }),
    (t.prototype.optionUpdated = function () {
      this.resetViewRoot()
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = this.getRawValue(e),
        s = a.getName(e)
      return Kn('nameValue', {
        name: s,
        value: o,
      })
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (
        (n.treeAncestors = E_(i, this)), (n.treePathInfo = n.treeAncestors), n
      )
    }),
    (t.prototype.setLayoutInfo = function (e) {
      ;(this.layoutInfo = this.layoutInfo || {}), Q(this.layoutInfo, e)
    }),
    (t.prototype.mapIdToIndex = function (e) {
      var n = this._idIndexMap
      n || ((n = this._idIndexMap = Pt()), (this._idIndexMapCount = 0))
      var i = n.get(e)
      return i == null && n.set(e, (i = this._idIndexMapCount++)), i
    }),
    (t.prototype.getViewRoot = function () {
      return this._viewRoot
    }),
    (t.prototype.resetViewRoot = function (e) {
      e ? (this._viewRoot = e) : (e = this._viewRoot)
      var n = this.getRawData().tree.root
      ;(!e || (e !== n && !n.contains(e))) && (this._viewRoot = n)
    }),
    (t.prototype.enableAriaDecal = function () {
      o4(this)
    }),
    (t.type = 'series.treemap'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      progressive: 0,
      left: 'center',
      top: 'middle',
      width: '80%',
      height: '80%',
      sort: !0,
      clipWindow: 'origin',
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: '▶',
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: 'zoomToNode',
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: 'quinticInOut',
      breadcrumb: {
        show: !0,
        height: 22,
        left: 'center',
        top: 'bottom',
        emptyItemWidth: 25,
        itemStyle: {
          color: 'rgba(0,0,0,0.7)',
          textStyle: {
            color: '#fff',
          },
        },
        emphasis: {
          itemStyle: {
            color: 'rgba(0,0,0,0.9)',
          },
        },
      },
      label: {
        show: !0,
        distance: 0,
        padding: 5,
        position: 'inside',
        color: '#fff',
        overflow: 'truncate',
      },
      upperLabel: {
        show: !1,
        position: [0, '50%'],
        height: 20,
        overflow: 'truncate',
        verticalAlign: 'middle',
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: '#fff',
        borderColorSaturation: null,
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, '50%'],
          overflow: 'truncate',
          verticalAlign: 'middle',
        },
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: 'index',
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: [],
    }),
    t
  )
})(rn)
function s4(r) {
  var t = 0
  R(r.children, function (n) {
    s4(n)
    var i = n.value
    at(i) && (i = i[0]), (t += i)
  })
  var e = r.value
  at(e) && (e = e[0]),
    (e == null || isNaN(e)) && (e = t),
    e < 0 && (e = 0),
    at(r.value) ? (r.value[0] = e) : (r.value = e)
}
function Ght(r, t) {
  var e = ke(t.get('color')),
    n = ke(t.get(['aria', 'decal', 'decals']))
  if (e) {
    r = r || []
    var i, a
    R(r, function (s) {
      var l = new qe(s),
        u = l.get('color'),
        c = l.get('decal')
      ;(l.get(['itemStyle', 'color']) || (u && u !== 'none')) && (i = !0),
        (l.get(['itemStyle', 'decal']) || (c && c !== 'none')) && (a = !0)
    })
    var o = r[0] || (r[0] = {})
    return i || (o.color = e.slice()), !a && n && (o.decal = n.slice()), r
  }
}
const Hht = Vht
var Wht = 8,
  NO = 8,
  pS = 5,
  Xht = (function () {
    function r(t) {
      ;(this.group = new Ht()), t.add(this.group)
    }
    return (
      (r.prototype.render = function (t, e, n, i) {
        var a = t.getModel('breadcrumb'),
          o = this.group
        if ((o.removeAll(), !(!a.get('show') || !n))) {
          var s = a.getModel('itemStyle'),
            l = a.getModel('emphasis'),
            u = s.getModel('textStyle'),
            c = l.getModel(['itemStyle', 'textStyle']),
            h = {
              pos: {
                left: a.get('left'),
                right: a.get('right'),
                top: a.get('top'),
                bottom: a.get('bottom'),
              },
              box: {
                width: e.getWidth(),
                height: e.getHeight(),
              },
              emptyItemWidth: a.get('emptyItemWidth'),
              totalWidth: 0,
              renderList: [],
            }
          this._prepare(n, h, u),
            this._renderContent(t, h, s, l, u, c, i),
            p_(o, h.pos, h.box)
        }
      }),
      (r.prototype._prepare = function (t, e, n) {
        for (var i = t; i; i = i.parentNode) {
          var a = Un(i.getModel().get('name'), ''),
            o = n.getTextRect(a),
            s = Math.max(o.width + Wht * 2, e.emptyItemWidth)
          ;(e.totalWidth += s + NO),
            e.renderList.push({
              node: i,
              text: a,
              width: s,
            })
        }
      }),
      (r.prototype._renderContent = function (t, e, n, i, a, o, s) {
        for (
          var l = 0,
            u = e.emptyItemWidth,
            c = t.get(['breadcrumb', 'height']),
            h = trt(e.pos, e.box),
            f = e.totalWidth,
            d = e.renderList,
            p = i.getModel('itemStyle').getItemStyle(),
            g = d.length - 1;
          g >= 0;
          g--
        ) {
          var v = d[g],
            m = v.node,
            y = v.width,
            _ = v.text
          f > h.width && ((f -= y - u), (y = u), (_ = null))
          var x = new si({
            shape: {
              points: Yht(l, 0, y, c, g === d.length - 1, g === 0),
            },
            style: zt(n.getItemStyle(), {
              lineJoin: 'bevel',
            }),
            textContent: new Ae({
              style: $e(a, {
                text: _,
              }),
            }),
            textConfig: {
              position: 'inside',
            },
            z2: _f * 1e4,
            onclick: Zt(s, m),
          })
          ;(x.disableLabelAnimation = !0),
            (x.getTextContent().ensureState('emphasis').style = $e(o, {
              text: _,
            })),
            (x.ensureState('emphasis').style = p),
            fn(x, i.get('focus'), i.get('blurScope'), i.get('disabled')),
            this.group.add(x),
            $ht(x, t, m),
            (l += y + NO)
        }
      }),
      (r.prototype.remove = function () {
        this.group.removeAll()
      }),
      r
    )
  })()
function Yht(r, t, e, n, i, a) {
  var o = [
    [i ? r : r - pS, t],
    [r + e, t],
    [r + e, t + n],
    [i ? r : r - pS, t + n],
  ]
  return (
    !a && o.splice(2, 0, [r + e + pS, t + n / 2]),
    !i && o.push([r, t + n / 2]),
    o
  )
}
function $ht(r, t, e) {
  Wt(r).eventData = {
    componentType: 'series',
    componentSubType: 'treemap',
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: 'treemap',
    selfType: 'breadcrumb',
    nodeData: {
      dataIndex: e && e.dataIndex,
      name: e && e.name,
    },
    treePathInfo: e && E_(e, t),
  }
}
const qht = Xht
var Zht = (function () {
  function r() {
    ;(this._storage = []), (this._elExistsMap = {})
  }
  return (
    (r.prototype.add = function (t, e, n, i, a) {
      return this._elExistsMap[t.id]
        ? !1
        : ((this._elExistsMap[t.id] = !0),
          this._storage.push({
            el: t,
            target: e,
            duration: n,
            delay: i,
            easing: a,
          }),
          !0)
    }),
    (r.prototype.finished = function (t) {
      return (this._finishedCallback = t), this
    }),
    (r.prototype.start = function () {
      for (
        var t = this,
          e = this._storage.length,
          n = function () {
            e--,
              e <= 0 &&
                ((t._storage.length = 0),
                (t._elExistsMap = {}),
                t._finishedCallback && t._finishedCallback())
          },
          i = 0,
          a = this._storage.length;
        i < a;
        i++
      ) {
        var o = this._storage[i]
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: n,
          aborted: n,
        })
      }
      return this
    }),
    r
  )
})()
function Kht() {
  return new Zht()
}
var Fw = Ht,
  kO = ge,
  BO = 3,
  FO = 'label',
  zO = 'upperLabel',
  jht = _f * 10,
  Jht = _f * 2,
  Qht = _f * 3,
  au = $u([
    ['fill', 'color'],
    ['stroke', 'strokeColor'],
    ['lineWidth', 'strokeWidth'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
  ]),
  UO = function (r) {
    var t = au(r)
    return (t.stroke = t.fill = t.lineWidth = null), t
  },
  p0 = ve(),
  tft = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._state = 'ready'), (e._storage = md()), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = n.findComponents({
          mainType: 'series',
          subType: 'treemap',
          query: a,
        })
        if (!(re(o, e) < 0)) {
          ;(this.seriesModel = e), (this.api = i), (this.ecModel = n)
          var s = ['treemapZoomToNode', 'treemapRootToNode'],
            l = nv(a, s, e),
            u = a && a.type,
            c = e.layoutInfo,
            h = !this._oldTree,
            f = this._storage,
            d =
              u === 'treemapRootToNode' && l && f
                ? {
                    rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
                    direction: a.direction,
                  }
                : null,
            p = this._giveContainerGroup(c),
            g = e.get('animation'),
            v = this._doRender(p, e, d)
          g &&
          !h &&
          (!u || u === 'treemapZoomToNode' || u === 'treemapRootToNode')
            ? this._doAnimation(p, v, e, d)
            : v.renderFinally(),
            this._resetController(i),
            this._renderBreadcrumb(e, i, l)
        }
      }),
      (t.prototype._giveContainerGroup = function (e) {
        var n = this._containerGroup
        return (
          n ||
            ((n = this._containerGroup = new Fw()),
            this._initEvents(n),
            this.group.add(n)),
          (n.x = e.x),
          (n.y = e.y),
          n
        )
      }),
      (t.prototype._doRender = function (e, n, i) {
        var a = n.getData().tree,
          o = this._oldTree,
          s = md(),
          l = md(),
          u = this._storage,
          c = []
        function h(y, _, x, A) {
          return eft(n, l, u, i, s, c, y, _, x, A)
        }
        g(
          a.root ? [a.root] : [],
          o && o.root ? [o.root] : [],
          e,
          a === o || !o,
          0,
        )
        var f = v(u)
        if (((this._oldTree = a), (this._storage = l), this._controllerHost)) {
          var d = this.seriesModel.layoutInfo,
            p = a.root.getLayout()
          p.width === d.width &&
            p.height === d.height &&
            (this._controllerHost.zoom = 1)
        }
        return {
          lastsForAnimation: s,
          willDeleteEls: f,
          renderFinally: m,
        }
        function g(y, _, x, A, S) {
          A
            ? ((_ = y),
              R(y, function (w, M) {
                !w.isRemoved() && T(M, M)
              }))
            : new es(_, y, b, b).add(T).update(T).remove(Zt(T, null)).execute()
          function b(w) {
            return w.getId()
          }
          function T(w, M) {
            var C = w != null ? y[w] : null,
              E = M != null ? _[M] : null,
              D = h(C, E, x, S)
            D &&
              g(
                (C && C.viewChildren) || [],
                (E && E.viewChildren) || [],
                D,
                A,
                S + 1,
              )
          }
        }
        function v(y) {
          var _ = md()
          return (
            y &&
              R(y, function (x, A) {
                var S = _[A]
                R(x, function (b) {
                  b && (S.push(b), (p0(b).willDelete = !0))
                })
              }),
            _
          )
        }
        function m() {
          R(f, function (y) {
            R(y, function (_) {
              _.parent && _.parent.remove(_)
            })
          }),
            R(c, function (y) {
              ;(y.invisible = !0), y.dirty()
            })
        }
      }),
      (t.prototype._doAnimation = function (e, n, i, a) {
        var o = i.get('animationDurationUpdate'),
          s = i.get('animationEasing'),
          l = (Nt(o) ? 0 : o) || 0,
          u = (Nt(s) ? null : s) || 'cubicOut',
          c = Kht()
        R(n.willDeleteEls, function (h, f) {
          R(h, function (d, p) {
            if (!d.invisible) {
              var g = d.parent,
                v,
                m = p0(g)
              if (a && a.direction === 'drillDown')
                v =
                  g === a.rootNodeGroup
                    ? {
                        shape: {
                          x: 0,
                          y: 0,
                          width: m.nodeWidth,
                          height: m.nodeHeight,
                        },
                        style: {
                          opacity: 0,
                        },
                      }
                    : {
                        style: {
                          opacity: 0,
                        },
                      }
              else {
                var y = 0,
                  _ = 0
                m.willDelete || ((y = m.nodeWidth / 2), (_ = m.nodeHeight / 2)),
                  (v =
                    f === 'nodeGroup'
                      ? {
                          x: y,
                          y: _,
                          style: {
                            opacity: 0,
                          },
                        }
                      : {
                          shape: {
                            x: y,
                            y: _,
                            width: 0,
                            height: 0,
                          },
                          style: {
                            opacity: 0,
                          },
                        })
              }
              v && c.add(d, v, l, 0, u)
            }
          })
        }),
          R(
            this._storage,
            function (h, f) {
              R(h, function (d, p) {
                var g = n.lastsForAnimation[f][p],
                  v = {}
                g &&
                  (d instanceof Ht
                    ? g.oldX != null &&
                      ((v.x = d.x), (v.y = d.y), (d.x = g.oldX), (d.y = g.oldY))
                    : (g.oldShape &&
                        ((v.shape = Q({}, d.shape)), d.setShape(g.oldShape)),
                      g.fadein
                        ? (d.setStyle('opacity', 0),
                          (v.style = {
                            opacity: 1,
                          }))
                        : d.style.opacity !== 1 &&
                          (v.style = {
                            opacity: 1,
                          })),
                  c.add(d, v, l, 0, u))
              })
            },
            this,
          ),
          (this._state = 'animating'),
          c
            .finished(
              Tt(function () {
                ;(this._state = 'ready'), n.renderFinally()
              }, this),
            )
            .start()
      }),
      (t.prototype._resetController = function (e) {
        var n = this._controller,
          i = this._controllerHost
        i ||
          ((this._controllerHost = {
            target: this.group,
          }),
          (i = this._controllerHost)),
          n ||
            ((n = this._controller = new Rv(e.getZr())),
            n.enable(this.seriesModel.get('roam')),
            (i.zoomLimit = this.seriesModel.get('scaleLimit')),
            (i.zoom = this.seriesModel.get('zoom')),
            n.on('pan', Tt(this._onPan, this)),
            n.on('zoom', Tt(this._onZoom, this)))
        var a = new ee(0, 0, e.getWidth(), e.getHeight())
        n.setPointerChecker(function (o, s, l) {
          return a.contain(s, l)
        })
      }),
      (t.prototype._clearController = function () {
        var e = this._controller
        ;(this._controllerHost = null), e && (e.dispose(), (e = null))
      }),
      (t.prototype._onPan = function (e) {
        if (
          this._state !== 'animating' &&
          (Math.abs(e.dx) > BO || Math.abs(e.dy) > BO)
        ) {
          var n = this.seriesModel.getData().tree.root
          if (!n) return
          var i = n.getLayout()
          if (!i) return
          this.api.dispatchAction({
            type: 'treemapMove',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: i.x + e.dx,
              y: i.y + e.dy,
              width: i.width,
              height: i.height,
            },
          })
        }
      }),
      (t.prototype._onZoom = function (e) {
        var n = e.originX,
          i = e.originY,
          a = e.scale
        if (this._state !== 'animating') {
          var o = this.seriesModel.getData().tree.root
          if (!o) return
          var s = o.getLayout()
          if (!s) return
          var l = new ee(s.x, s.y, s.width, s.height),
            u = null,
            c = this._controllerHost
          u = c.zoomLimit
          var h = (c.zoom = c.zoom || 1)
          if (((h *= a), u)) {
            var f = u.min || 0,
              d = u.max || 1 / 0
            h = Math.max(Math.min(d, h), f)
          }
          var p = h / c.zoom
          c.zoom = h
          var g = this.seriesModel.layoutInfo
          ;(n -= g.x), (i -= g.y)
          var v = bi()
          ho(v, v, [-n, -i]),
            IT(v, v, [p, p]),
            ho(v, v, [n, i]),
            l.applyTransform(v),
            this.api.dispatchAction({
              type: 'treemapRender',
              from: this.uid,
              seriesId: this.seriesModel.id,
              rootRect: {
                x: l.x,
                y: l.y,
                width: l.width,
                height: l.height,
              },
            })
        }
      }),
      (t.prototype._initEvents = function (e) {
        var n = this
        e.on(
          'click',
          function (i) {
            if (n._state === 'ready') {
              var a = n.seriesModel.get('nodeClick', !0)
              if (a) {
                var o = n.findTarget(i.offsetX, i.offsetY)
                if (o) {
                  var s = o.node
                  if (s.getLayout().isLeafRoot) n._rootToNode(o)
                  else if (a === 'zoomToNode') n._zoomToNode(o)
                  else if (a === 'link') {
                    var l = s.hostTree.data.getItemModel(s.dataIndex),
                      u = l.get('link', !0),
                      c = l.get('target', !0) || 'blank'
                    u && jy(u, c)
                  }
                }
              }
            }
          },
          this,
        )
      }),
      (t.prototype._renderBreadcrumb = function (e, n, i) {
        var a = this
        i ||
          ((i =
            e.get('leafDepth', !0) != null
              ? {
                  node: e.getViewRoot(),
                }
              : this.findTarget(n.getWidth() / 2, n.getHeight() / 2)),
          i ||
            (i = {
              node: e.getData().tree.root,
            })),
          (this._breadcrumb || (this._breadcrumb = new qht(this.group))).render(
            e,
            n,
            i.node,
            function (o) {
              a._state !== 'animating' &&
                (YC(e.getViewRoot(), o)
                  ? a._rootToNode({
                      node: o,
                    })
                  : a._zoomToNode({
                      node: o,
                    }))
            },
          )
      }),
      (t.prototype.remove = function () {
        this._clearController(),
          this._containerGroup && this._containerGroup.removeAll(),
          (this._storage = md()),
          (this._state = 'ready'),
          this._breadcrumb && this._breadcrumb.remove()
      }),
      (t.prototype.dispose = function () {
        this._clearController()
      }),
      (t.prototype._zoomToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapZoomToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node,
        })
      }),
      (t.prototype._rootToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapRootToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node,
        })
      }),
      (t.prototype.findTarget = function (e, n) {
        var i,
          a = this.seriesModel.getViewRoot()
        return (
          a.eachNode(
            {
              attr: 'viewChildren',
              order: 'preorder',
            },
            function (o) {
              var s = this._storage.background[o.getRawIndex()]
              if (s) {
                var l = s.transformCoordToLocal(e, n),
                  u = s.shape
                if (
                  u.x <= l[0] &&
                  l[0] <= u.x + u.width &&
                  u.y <= l[1] &&
                  l[1] <= u.y + u.height
                )
                  i = {
                    node: o,
                    offsetX: l[0],
                    offsetY: l[1],
                  }
                else return !1
              }
            },
            this,
          ),
          i
        )
      }),
      (t.type = 'treemap'),
      t
    )
  })(Ze)
function md() {
  return {
    nodeGroup: [],
    background: [],
    content: [],
  }
}
function eft(r, t, e, n, i, a, o, s, l, u) {
  if (!o) return
  var c = o.getLayout(),
    h = r.getData(),
    f = o.getModel()
  if ((h.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)) return
  var d = c.width,
    p = c.height,
    g = c.borderWidth,
    v = c.invisible,
    m = o.getRawIndex(),
    y = s && s.getRawIndex(),
    _ = o.viewChildren,
    x = c.upperHeight,
    A = _ && _.length,
    S = f.getModel('itemStyle'),
    b = f.getModel(['emphasis', 'itemStyle']),
    T = f.getModel(['blur', 'itemStyle']),
    w = f.getModel(['select', 'itemStyle']),
    M = S.get('borderRadius') || 0,
    C = W('nodeGroup', Fw)
  if (!C) return
  if (
    (l.add(C),
    (C.x = c.x || 0),
    (C.y = c.y || 0),
    C.markRedraw(),
    (p0(C).nodeWidth = d),
    (p0(C).nodeHeight = p),
    c.isAboveViewRoot)
  )
    return C
  var E = W('background', kO, u, Jht)
  E && V(C, E, A && c.upperLabelHeight)
  var D = f.getModel('emphasis'),
    P = D.get('focus'),
    L = D.get('blurScope'),
    I = D.get('disabled'),
    F =
      P === 'ancestor'
        ? o.getAncestorsIndices()
        : P === 'descendant'
        ? o.getDescendantIndices()
        : P
  if (A)
    Wp(C) && yu(C, !1),
      E && (yu(E, !I), h.setItemGraphicEl(o.dataIndex, E), iw(E, F, L))
  else {
    var k = W('content', kO, u, Qht)
    k && H(C, k),
      (E.disableMorphing = !0),
      E && Wp(E) && yu(E, !1),
      yu(C, !I),
      h.setItemGraphicEl(o.dataIndex, C),
      iw(C, F, L)
  }
  return C
  function V(lt, ct, At) {
    var gt = Wt(ct)
    if (
      ((gt.dataIndex = o.dataIndex),
      (gt.seriesIndex = r.seriesIndex),
      ct.setShape({
        x: 0,
        y: 0,
        width: d,
        height: p,
        r: M,
      }),
      v)
    )
      Y(ct)
    else {
      ct.invisible = !1
      var dt = o.getVisual('style'),
        B = dt.stroke,
        ht = UO(S)
      ht.fill = B
      var it = au(b)
      it.fill = b.get('borderColor')
      var xt = au(T)
      xt.fill = T.get('borderColor')
      var rt = au(w)
      if (((rt.fill = w.get('borderColor')), At)) {
        var kt = d - 2 * g
        K(ct, B, dt.opacity, {
          x: g,
          y: 0,
          width: kt,
          height: x,
        })
      } else ct.removeTextContent()
      ct.setStyle(ht),
        (ct.ensureState('emphasis').style = it),
        (ct.ensureState('blur').style = xt),
        (ct.ensureState('select').style = rt),
        qu(ct)
    }
    lt.add(ct)
  }
  function H(lt, ct) {
    var At = Wt(ct)
    ;(At.dataIndex = o.dataIndex), (At.seriesIndex = r.seriesIndex)
    var gt = Math.max(d - 2 * g, 0),
      dt = Math.max(p - 2 * g, 0)
    if (
      ((ct.culling = !0),
      ct.setShape({
        x: g,
        y: g,
        width: gt,
        height: dt,
        r: M,
      }),
      v)
    )
      Y(ct)
    else {
      ct.invisible = !1
      var B = o.getVisual('style'),
        ht = B.fill,
        it = UO(S)
      ;(it.fill = ht), (it.decal = B.decal)
      var xt = au(b),
        rt = au(T),
        kt = au(w)
      K(ct, ht, B.opacity, null),
        ct.setStyle(it),
        (ct.ensureState('emphasis').style = xt),
        (ct.ensureState('blur').style = rt),
        (ct.ensureState('select').style = kt),
        qu(ct)
    }
    lt.add(ct)
  }
  function Y(lt) {
    !lt.invisible && a.push(lt)
  }
  function K(lt, ct, At, gt) {
    var dt = f.getModel(gt ? zO : FO),
      B = Un(f.get('name'), null),
      ht = dt.getShallow('show')
    mr(lt, Zn(f, gt ? zO : FO), {
      defaultText: ht ? B : null,
      inheritColor: ct,
      defaultOpacity: At,
      labelFetcher: r,
      labelDataIndex: o.dataIndex,
    })
    var it = lt.getTextContent()
    if (it) {
      var xt = it.style,
        rt = LT(xt.padding || 0)
      gt &&
        (lt.setTextConfig({
          layoutRect: gt,
        }),
        (it.disableLabelLayout = !0)),
        (it.beforeUpdate = function () {
          var Ct = Math.max(
              (gt ? gt.width : lt.shape.width) - rt[1] - rt[3],
              0,
            ),
            Lt = Math.max((gt ? gt.height : lt.shape.height) - rt[0] - rt[2], 0)
          ;(xt.width !== Ct || xt.height !== Lt) &&
            it.setStyle({
              width: Ct,
              height: Lt,
            })
        }),
        (xt.truncateMinChar = 2),
        (xt.lineOverflow = 'truncate'),
        ut(xt, gt, c)
      var kt = it.getState('emphasis')
      ut(kt ? kt.style : null, gt, c)
    }
  }
  function ut(lt, ct, At) {
    var gt = lt ? lt.text : null
    if (!ct && At.isLeafRoot && gt != null) {
      var dt = r.get('drillDownIcon', !0)
      lt.text = dt ? dt + ' ' + gt : gt
    }
  }
  function W(lt, ct, At, gt) {
    var dt = y != null && e[lt][y],
      B = i[lt]
    return (
      dt
        ? ((e[lt][y] = null), Z(B, dt))
        : v ||
          ((dt = new ct()),
          dt instanceof ea && (dt.z2 = nft(At, gt)),
          ft(B, dt)),
      (t[lt][m] = dt)
    )
  }
  function Z(lt, ct) {
    var At = (lt[m] = {})
    ct instanceof Fw
      ? ((At.oldX = ct.x), (At.oldY = ct.y))
      : (At.oldShape = Q({}, ct.shape))
  }
  function ft(lt, ct) {
    var At = (lt[m] = {}),
      gt = o.parentNode,
      dt = ct instanceof Ht
    if (gt && (!n || n.direction === 'drillDown')) {
      var B = 0,
        ht = 0,
        it = i.background[gt.getRawIndex()]
      !n &&
        it &&
        it.oldShape &&
        ((B = it.oldShape.width), (ht = it.oldShape.height)),
        dt
          ? ((At.oldX = 0), (At.oldY = ht))
          : (At.oldShape = {
              x: B,
              y: ht,
              width: 0,
              height: 0,
            })
    }
    At.fadein = !dt
  }
}
function nft(r, t) {
  return r * jht + t
}
const rft = tft
var rv = R,
  ift = Ut,
  v0 = -1,
  $C = (function () {
    function r(t) {
      var e = t.mappingMethod,
        n = t.type,
        i = (this.option = Vt(t))
      ;(this.type = n), (this.mappingMethod = e), (this._normalizeData = sft[e])
      var a = r.visualHandlers[n]
      ;(this.applyVisual = a.applyVisual),
        (this.getColorMapper = a.getColorMapper),
        (this._normalizedToVisual = a._normalizedToVisual[e]),
        e === 'piecewise'
          ? (vS(i), aft(i))
          : e === 'category'
          ? i.categories
            ? oft(i)
            : vS(i, !0)
          : (Gr(e !== 'linear' || i.dataExtent), vS(i))
    }
    return (
      (r.prototype.mapValueToVisual = function (t) {
        var e = this._normalizeData(t)
        return this._normalizedToVisual(e, t)
      }),
      (r.prototype.getNormalizer = function () {
        return Tt(this._normalizeData, this)
      }),
      (r.listVisualTypes = function () {
        return pe(r.visualHandlers)
      }),
      (r.isValidType = function (t) {
        return r.visualHandlers.hasOwnProperty(t)
      }),
      (r.eachVisual = function (t, e, n) {
        Ut(t) ? R(t, e, n) : e.call(n, t)
      }),
      (r.mapVisual = function (t, e, n) {
        var i,
          a = at(t) ? [] : Ut(t) ? {} : ((i = !0), null)
        return (
          r.eachVisual(t, function (o, s) {
            var l = e.call(n, o, s)
            i ? (a = l) : (a[s] = l)
          }),
          a
        )
      }),
      (r.retrieveVisuals = function (t) {
        var e = {},
          n
        return (
          t &&
            rv(r.visualHandlers, function (i, a) {
              t.hasOwnProperty(a) && ((e[a] = t[a]), (n = !0))
            }),
          n ? e : null
        )
      }),
      (r.prepareVisualTypes = function (t) {
        if (at(t)) t = t.slice()
        else if (ift(t)) {
          var e = []
          rv(t, function (n, i) {
            e.push(i)
          }),
            (t = e)
        } else return []
        return (
          t.sort(function (n, i) {
            return i === 'color' && n !== 'color' && n.indexOf('color') === 0
              ? 1
              : -1
          }),
          t
        )
      }),
      (r.dependsOn = function (t, e) {
        return e === 'color' ? !!(t && t.indexOf(e) === 0) : t === e
      }),
      (r.findPieceIndex = function (t, e, n) {
        for (var i, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
          var l = e[o].value
          if (l != null) {
            if (l === t || (bt(l) && l === t + '')) return o
            n && f(l, o)
          }
        }
        for (var o = 0, s = e.length; o < s; o++) {
          var u = e[o],
            c = u.interval,
            h = u.close
          if (c) {
            if (c[0] === -1 / 0) {
              if (mm(h[1], t, c[1])) return o
            } else if (c[1] === 1 / 0) {
              if (mm(h[0], c[0], t)) return o
            } else if (mm(h[0], c[0], t) && mm(h[1], t, c[1])) return o
            n && f(c[0], o), n && f(c[1], o)
          }
        }
        if (n) return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : i
        function f(d, p) {
          var g = Math.abs(d - t)
          g < a && ((a = g), (i = p))
        }
      }),
      (r.visualHandlers = {
        color: {
          applyVisual: yd('color'),
          getColorMapper: function () {
            var t = this.option
            return Tt(
              t.mappingMethod === 'category'
                ? function (e, n) {
                    return !n && (e = this._normalizeData(e)), Hd.call(this, e)
                  }
                : function (e, n, i) {
                    var a = !!i
                    return (
                      !n && (e = this._normalizeData(e)),
                      (i = Zx(e, t.parsedVisual, i)),
                      a ? i : Wo(i, 'rgba')
                    )
                  },
              this,
            )
          },
          _normalizedToVisual: {
            linear: function (t) {
              return Wo(Zx(t, this.option.parsedVisual), 'rgba')
            },
            category: Hd,
            piecewise: function (t, e) {
              var n = Uw.call(this, e)
              return (
                n == null && (n = Wo(Zx(t, this.option.parsedVisual), 'rgba')),
                n
              )
            },
            fixed: ou,
          },
        },
        colorHue: gm(function (t, e) {
          return ep(t, e)
        }),
        colorSaturation: gm(function (t, e) {
          return ep(t, null, e)
        }),
        colorLightness: gm(function (t, e) {
          return ep(t, null, null, e)
        }),
        colorAlpha: gm(function (t, e) {
          return zy(t, e)
        }),
        decal: {
          applyVisual: yd('decal'),
          _normalizedToVisual: {
            linear: null,
            category: Hd,
            piecewise: null,
            fixed: null,
          },
        },
        opacity: {
          applyVisual: yd('opacity'),
          _normalizedToVisual: zw([0, 1]),
        },
        liftZ: {
          applyVisual: yd('liftZ'),
          _normalizedToVisual: {
            linear: ou,
            category: ou,
            piecewise: ou,
            fixed: ou,
          },
        },
        symbol: {
          applyVisual: function (t, e, n) {
            var i = this.mapValueToVisual(t)
            n('symbol', i)
          },
          _normalizedToVisual: {
            linear: VO,
            category: Hd,
            piecewise: function (t, e) {
              var n = Uw.call(this, e)
              return n == null && (n = VO.call(this, t)), n
            },
            fixed: ou,
          },
        },
        symbolSize: {
          applyVisual: yd('symbolSize'),
          _normalizedToVisual: zw([0, 1]),
        },
      }),
      r
    )
  })()
function aft(r) {
  var t = r.pieceList
  ;(r.hasSpecialVisual = !1),
    R(t, function (e, n) {
      ;(e.originIndex = n), e.visual != null && (r.hasSpecialVisual = !0)
    })
}
function oft(r) {
  var t = r.categories,
    e = (r.categoryMap = {}),
    n = r.visual
  if (
    (rv(t, function (o, s) {
      e[o] = s
    }),
    !at(n))
  ) {
    var i = []
    Ut(n)
      ? rv(n, function (o, s) {
          var l = e[s]
          i[l ?? v0] = o
        })
      : (i[v0] = n),
      (n = l4(r, i))
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete e[t[a]], t.pop())
}
function vS(r, t) {
  var e = r.visual,
    n = []
  Ut(e)
    ? rv(e, function (a) {
        n.push(a)
      })
    : e != null && n.push(e)
  var i = {
    color: 1,
    symbol: 1,
  }
  !t && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), l4(r, n)
}
function gm(r) {
  return {
    applyVisual: function (t, e, n) {
      var i = this.mapValueToVisual(t)
      n('color', r(e('color'), i))
    },
    _normalizedToVisual: zw([0, 1]),
  }
}
function VO(r) {
  var t = this.option.visual
  return t[Math.round(Re(r, [0, 1], [0, t.length - 1], !0))] || {}
}
function yd(r) {
  return function (t, e, n) {
    n(r, this.mapValueToVisual(t))
  }
}
function Hd(r) {
  var t = this.option.visual
  return t[this.option.loop && r !== v0 ? r % t.length : r]
}
function ou() {
  return this.option.visual[0]
}
function zw(r) {
  return {
    linear: function (t) {
      return Re(t, r, this.option.visual, !0)
    },
    category: Hd,
    piecewise: function (t, e) {
      var n = Uw.call(this, e)
      return n == null && (n = Re(t, r, this.option.visual, !0)), n
    },
    fixed: ou,
  }
}
function Uw(r) {
  var t = this.option,
    e = t.pieceList
  if (t.hasSpecialVisual) {
    var n = $C.findPieceIndex(r, e),
      i = e[n]
    if (i && i.visual) return i.visual[this.type]
  }
}
function l4(r, t) {
  return (
    (r.visual = t),
    r.type === 'color' &&
      (r.parsedVisual = st(t, function (e) {
        var n = wi(e)
        return n || [0, 0, 0, 1]
      })),
    t
  )
}
var sft = {
  linear: function (r) {
    return Re(r, this.option.dataExtent, [0, 1], !0)
  },
  piecewise: function (r) {
    var t = this.option.pieceList,
      e = $C.findPieceIndex(r, t, !0)
    if (e != null) return Re(e, [0, t.length - 1], [0, 1], !0)
  },
  category: function (r) {
    var t = this.option.categories ? this.option.categoryMap[r] : r
    return t ?? v0
  },
  fixed: wn,
}
function mm(r, t, e) {
  return r ? t <= e : t < e
}
const vr = $C
var lft = 'itemStyle',
  u4 = ve()
const uft = {
  seriesType: 'treemap',
  reset: function (r) {
    var t = r.getData().tree,
      e = t.root
    e.isRemoved() || c4(e, {}, r.getViewRoot().getAncestors(), r)
  },
}
function c4(r, t, e, n) {
  var i = r.getModel(),
    a = r.getLayout(),
    o = r.hostTree.data
  if (!(!a || a.invisible || !a.isInView)) {
    var s = i.getModel(lft),
      l = cft(s, t, n),
      u = o.ensureUniqueItemVisual(r.dataIndex, 'style'),
      c = s.get('borderColor'),
      h = s.get('borderColorSaturation'),
      f
    h != null && ((f = GO(l)), (c = hft(h, f))), (u.stroke = c)
    var d = r.viewChildren
    if (!d || !d.length) (f = GO(l)), (u.fill = f)
    else {
      var p = fft(r, i, a, s, l, d)
      R(d, function (g, v) {
        if (g.depth >= e.length || g === e[g.depth]) {
          var m = dft(i, l, g, v, p, n)
          c4(g, m, e, n)
        }
      })
    }
  }
}
function cft(r, t, e) {
  var n = Q({}, t),
    i = e.designatedVisualItemStyle
  return (
    R(['color', 'colorAlpha', 'colorSaturation'], function (a) {
      i[a] = t[a]
      var o = r.get(a)
      ;(i[a] = null), o != null && (n[a] = o)
    }),
    n
  )
}
function GO(r) {
  var t = gS(r, 'color')
  if (t) {
    var e = gS(r, 'colorAlpha'),
      n = gS(r, 'colorSaturation')
    return n && (t = ep(t, null, null, n)), e && (t = zy(t, e)), t
  }
}
function hft(r, t) {
  return t != null ? ep(t, null, null, r) : null
}
function gS(r, t) {
  var e = r[t]
  if (e != null && e !== 'none') return e
}
function fft(r, t, e, n, i, a) {
  if (!(!a || !a.length)) {
    var o =
      mS(t, 'color') ||
      (i.color != null &&
        i.color !== 'none' &&
        (mS(t, 'colorAlpha') || mS(t, 'colorSaturation')))
    if (o) {
      var s = t.get('visualMin'),
        l = t.get('visualMax'),
        u = e.dataExtent.slice()
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l)
      var c = t.get('colorMappingBy'),
        h = {
          type: o.name,
          dataExtent: u,
          visual: o.range,
        }
      h.type === 'color' && (c === 'index' || c === 'id')
        ? ((h.mappingMethod = 'category'), (h.loop = !0))
        : (h.mappingMethod = 'linear')
      var f = new vr(h)
      return (u4(f).drColorMappingBy = c), f
    }
  }
}
function mS(r, t) {
  var e = r.get(t)
  return at(e) && e.length
    ? {
        name: t,
        range: e,
      }
    : null
}
function dft(r, t, e, n, i, a) {
  var o = Q({}, t)
  if (i) {
    var s = i.type,
      l = s === 'color' && u4(i).drColorMappingBy,
      u =
        l === 'index'
          ? n
          : l === 'id'
          ? a.mapIdToIndex(e.getId())
          : e.getValue(r.get('visualDimension'))
    o[s] = i.mapValueToVisual(u)
  }
  return o
}
var iv = Math.max,
  g0 = Math.min,
  HO = nr,
  qC = R,
  h4 = ['itemStyle', 'borderWidth'],
  pft = ['itemStyle', 'gapWidth'],
  vft = ['upperLabel', 'show'],
  gft = ['upperLabel', 'height']
const mft = {
  seriesType: 'treemap',
  reset: function (r, t, e, n) {
    var i = e.getWidth(),
      a = e.getHeight(),
      o = r.option,
      s = Vn(r.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight(),
      }),
      l = o.size || [],
      u = _t(HO(s.width, l[0]), i),
      c = _t(HO(s.height, l[1]), a),
      h = n && n.type,
      f = ['treemapZoomToNode', 'treemapRootToNode'],
      d = nv(n, f, r),
      p = h === 'treemapRender' || h === 'treemapMove' ? n.rootRect : null,
      g = r.getViewRoot(),
      v = a4(g)
    if (h !== 'treemapMove') {
      var m =
          h === 'treemapZoomToNode'
            ? bft(r, d, g, u, c)
            : p
            ? [p.width, p.height]
            : [u, c],
        y = o.sort
      y && y !== 'asc' && y !== 'desc' && (y = 'desc')
      var _ = {
        squareRatio: o.squareRatio,
        sort: y,
        leafDepth: o.leafDepth,
      }
      g.hostTree.clearLayouts()
      var x = {
        x: 0,
        y: 0,
        width: m[0],
        height: m[1],
        area: m[0] * m[1],
      }
      g.setLayout(x),
        f4(g, _, !1, 0),
        (x = g.getLayout()),
        qC(v, function (S, b) {
          var T = (v[b + 1] || g).getValue()
          S.setLayout(
            Q(
              {
                dataExtent: [T, T],
                borderWidth: 0,
                upperHeight: 0,
              },
              x,
            ),
          )
        })
    }
    var A = r.getData().tree.root
    A.setLayout(wft(s, p, d), !0),
      r.setLayoutInfo(s),
      d4(A, new ee(-s.x, -s.y, i, a), v, g, 0)
  },
}
function f4(r, t, e, n) {
  var i, a
  if (!r.isRemoved()) {
    var o = r.getLayout()
    ;(i = o.width), (a = o.height)
    var s = r.getModel(),
      l = s.get(h4),
      u = s.get(pft) / 2,
      c = p4(s),
      h = Math.max(l, c),
      f = l - u,
      d = h - u
    r.setLayout(
      {
        borderWidth: l,
        upperHeight: h,
        upperLabelHeight: c,
      },
      !0,
    ),
      (i = iv(i - 2 * f, 0)),
      (a = iv(a - f - d, 0))
    var p = i * a,
      g = yft(r, s, p, t, e, n)
    if (g.length) {
      var v = {
          x: f,
          y: d,
          width: i,
          height: a,
        },
        m = g0(i, a),
        y = 1 / 0,
        _ = []
      _.area = 0
      for (var x = 0, A = g.length; x < A; ) {
        var S = g[x]
        _.push(S), (_.area += S.getLayout().area)
        var b = Aft(_, m, t.squareRatio)
        b <= y
          ? (x++, (y = b))
          : ((_.area -= _.pop().getLayout().area),
            WO(_, m, v, u, !1),
            (m = g0(v.width, v.height)),
            (_.length = _.area = 0),
            (y = 1 / 0))
      }
      if ((_.length && WO(_, m, v, u, !0), !e)) {
        var T = s.get('childrenVisibleMin')
        T != null && p < T && (e = !0)
      }
      for (var x = 0, A = g.length; x < A; x++) f4(g[x], t, e, n + 1)
    }
  }
}
function yft(r, t, e, n, i, a) {
  var o = r.children || [],
    s = n.sort
  s !== 'asc' && s !== 'desc' && (s = null)
  var l = n.leafDepth != null && n.leafDepth <= a
  if (i && !l) return (r.viewChildren = [])
  ;(o = Ne(o, function (d) {
    return !d.isRemoved()
  })),
    xft(o, s)
  var u = Sft(t, o, s)
  if (u.sum === 0) return (r.viewChildren = [])
  if (((u.sum = _ft(t, e, u.sum, s, o)), u.sum === 0))
    return (r.viewChildren = [])
  for (var c = 0, h = o.length; c < h; c++) {
    var f = (o[c].getValue() / u.sum) * e
    o[c].setLayout({
      area: f,
    })
  }
  return (
    l &&
      (o.length &&
        r.setLayout(
          {
            isLeafRoot: !0,
          },
          !0,
        ),
      (o.length = 0)),
    (r.viewChildren = o),
    r.setLayout(
      {
        dataExtent: u.dataExtent,
      },
      !0,
    ),
    o
  )
}
function _ft(r, t, e, n, i) {
  if (!n) return e
  for (
    var a = r.get('visibleMin'), o = i.length, s = o, l = o - 1;
    l >= 0;
    l--
  ) {
    var u = i[n === 'asc' ? o - l - 1 : l].getValue()
    ;(u / e) * t < a && ((s = l), (e -= u))
  }
  return n === 'asc' ? i.splice(0, o - s) : i.splice(s, o - s), e
}
function xft(r, t) {
  return (
    t &&
      r.sort(function (e, n) {
        var i =
          t === 'asc'
            ? e.getValue() - n.getValue()
            : n.getValue() - e.getValue()
        return i === 0
          ? t === 'asc'
            ? e.dataIndex - n.dataIndex
            : n.dataIndex - e.dataIndex
          : i
      }),
    r
  )
}
function Sft(r, t, e) {
  for (var n = 0, i = 0, a = t.length; i < a; i++) n += t[i].getValue()
  var o = r.get('visualDimension'),
    s
  return (
    !t || !t.length
      ? (s = [NaN, NaN])
      : o === 'value' && e
      ? ((s = [t[t.length - 1].getValue(), t[0].getValue()]),
        e === 'asc' && s.reverse())
      : ((s = [1 / 0, -1 / 0]),
        qC(t, function (l) {
          var u = l.getValue(o)
          u < s[0] && (s[0] = u), u > s[1] && (s[1] = u)
        })),
    {
      sum: n,
      dataExtent: s,
    }
  )
}
function Aft(r, t, e) {
  for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    (o = r[a].getLayout().area), o && (o < i && (i = o), o > n && (n = o))
  var l = r.area * r.area,
    u = t * t * e
  return l ? iv((u * n) / l, l / (u * i)) : 1 / 0
}
function WO(r, t, e, n, i) {
  var a = t === e.width ? 0 : 1,
    o = 1 - a,
    s = ['x', 'y'],
    l = ['width', 'height'],
    u = e[s[a]],
    c = t ? r.area / t : 0
  ;(i || c > e[l[o]]) && (c = e[l[o]])
  for (var h = 0, f = r.length; h < f; h++) {
    var d = r[h],
      p = {},
      g = c ? d.getLayout().area / c : 0,
      v = (p[l[o]] = iv(c - 2 * n, 0)),
      m = e[s[a]] + e[l[a]] - u,
      y = h === f - 1 || m < g ? m : g,
      _ = (p[l[a]] = iv(y - 2 * n, 0))
    ;(p[s[o]] = e[s[o]] + g0(n, v / 2)),
      (p[s[a]] = u + g0(n, _ / 2)),
      (u += y),
      d.setLayout(p, !0)
  }
  ;(e[s[o]] += c), (e[l[o]] -= c)
}
function bft(r, t, e, n, i) {
  var a = (t || {}).node,
    o = [n, i]
  if (!a || a === e) return o
  for (
    var s, l = n * i, u = l * r.option.zoomToNodeRatio;
    (s = a.parentNode);

  ) {
    for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++)
      c += h[f].getValue()
    var p = a.getValue()
    if (p === 0) return o
    u *= c / p
    var g = s.getModel(),
      v = g.get(h4),
      m = Math.max(v, p4(g))
    ;(u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5)),
      u > nP && (u = nP),
      (a = s)
  }
  u < l && (u = l)
  var y = Math.pow(u / l, 0.5)
  return [n * y, i * y]
}
function wft(r, t, e) {
  if (t)
    return {
      x: t.x,
      y: t.y,
    }
  var n = {
    x: 0,
    y: 0,
  }
  if (!e) return n
  var i = e.node,
    a = i.getLayout()
  if (!a) return n
  for (var o = [a.width / 2, a.height / 2], s = i; s; ) {
    var l = s.getLayout()
    ;(o[0] += l.x), (o[1] += l.y), (s = s.parentNode)
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1],
  }
}
function d4(r, t, e, n, i) {
  var a = r.getLayout(),
    o = e[i],
    s = o && o === r
  if (!((o && !s) || (i === e.length && r !== n))) {
    r.setLayout(
      {
        isInView: !0,
        invisible: !s && !t.intersect(a),
        isAboveViewRoot: s,
      },
      !0,
    )
    var l = new ee(t.x - a.x, t.y - a.y, t.width, t.height)
    qC(r.viewChildren || [], function (u) {
      d4(u, l, e, n, i + 1)
    })
  }
}
function p4(r) {
  return r.get(vft) ? r.get(gft) : 0
}
function Mft(r) {
  r.registerSeriesModel(Hht),
    r.registerChartView(rft),
    r.registerVisual(uft),
    r.registerLayout(mft),
    Uht(r)
}
function Tft(r) {
  var t = r.findComponents({
    mainType: 'legend',
  })
  !t ||
    !t.length ||
    r.eachSeriesByType('graph', function (e) {
      var n = e.getCategoriesData(),
        i = e.getGraph(),
        a = i.data,
        o = n.mapArray(n.getName)
      a.filterSelf(function (s) {
        var l = a.getItemModel(s),
          u = l.getShallow('category')
        if (u != null) {
          be(u) && (u = o[u])
          for (var c = 0; c < t.length; c++) if (!t[c].isSelected(u)) return !1
        }
        return !0
      })
    })
}
function Cft(r) {
  var t = {}
  r.eachSeriesByType('graph', function (e) {
    var n = e.getCategoriesData(),
      i = e.getData(),
      a = {}
    n.each(function (o) {
      var s = n.getName(o)
      a['ec-' + s] = o
      var l = n.getItemModel(o),
        u = l.getModel('itemStyle').getItemStyle()
      u.fill || (u.fill = e.getColorFromPalette(s, t)),
        n.setItemVisual(o, 'style', u)
      for (
        var c = ['symbol', 'symbolSize', 'symbolKeepAspect'], h = 0;
        h < c.length;
        h++
      ) {
        var f = l.getShallow(c[h], !0)
        f != null && n.setItemVisual(o, c[h], f)
      }
    }),
      n.count() &&
        i.each(function (o) {
          var s = i.getItemModel(o),
            l = s.getShallow('category')
          if (l != null) {
            bt(l) && (l = a['ec-' + l])
            var u = n.getItemVisual(l, 'style'),
              c = i.ensureUniqueItemVisual(o, 'style')
            Q(c, u)
            for (
              var h = ['symbol', 'symbolSize', 'symbolKeepAspect'], f = 0;
              f < h.length;
              f++
            )
              i.setItemVisual(o, h[f], n.getItemVisual(l, h[f]))
          }
        })
  })
}
function ym(r) {
  return r instanceof Array || (r = [r, r]), r
}
function Eft(r) {
  r.eachSeriesByType('graph', function (t) {
    var e = t.getGraph(),
      n = t.getEdgeData(),
      i = ym(t.get('edgeSymbol')),
      a = ym(t.get('edgeSymbolSize'))
    n.setVisual('fromSymbol', i && i[0]),
      n.setVisual('toSymbol', i && i[1]),
      n.setVisual('fromSymbolSize', a && a[0]),
      n.setVisual('toSymbolSize', a && a[1]),
      n.setVisual('style', t.getModel('lineStyle').getLineStyle()),
      n.each(function (o) {
        var s = n.getItemModel(o),
          l = e.getEdgeByIndex(o),
          u = ym(s.getShallow('symbol', !0)),
          c = ym(s.getShallow('symbolSize', !0)),
          h = s.getModel('lineStyle').getLineStyle(),
          f = n.ensureUniqueItemVisual(o, 'style')
        switch ((Q(f, h), f.stroke)) {
          case 'source': {
            var d = l.node1.getVisual('style')
            f.stroke = d && d.fill
            break
          }
          case 'target': {
            var d = l.node2.getVisual('style')
            f.stroke = d && d.fill
            break
          }
        }
        u[0] && l.setVisual('fromSymbol', u[0]),
          u[1] && l.setVisual('toSymbol', u[1]),
          c[0] && l.setVisual('fromSymbolSize', c[0]),
          c[1] && l.setVisual('toSymbolSize', c[1])
      })
  })
}
var Vw = '-->',
  D_ = function (r) {
    return r.get('autoCurveness') || null
  },
  v4 = function (r, t) {
    var e = D_(r),
      n = 20,
      i = []
    if (be(e)) n = e
    else if (at(e)) {
      r.__curvenessList = e
      return
    }
    t > n && (n = t)
    var a = n % 2 ? n + 2 : n + 3
    i = []
    for (var o = 0; o < a; o++)
      i.push(((o % 2 ? o + 1 : o) / 10) * (o % 2 ? -1 : 1))
    r.__curvenessList = i
  },
  av = function (r, t, e) {
    var n = [r.id, r.dataIndex].join('.'),
      i = [t.id, t.dataIndex].join('.')
    return [e.uid, n, i].join(Vw)
  },
  g4 = function (r) {
    var t = r.split(Vw)
    return [t[0], t[2], t[1]].join(Vw)
  },
  Dft = function (r, t) {
    var e = av(r.node1, r.node2, t)
    return t.__edgeMap[e]
  },
  Lft = function (r, t) {
    var e = Gw(av(r.node1, r.node2, t), t),
      n = Gw(av(r.node2, r.node1, t), t)
    return e + n
  },
  Gw = function (r, t) {
    var e = t.__edgeMap
    return e[r] ? e[r].length : 0
  }
function Pft(r) {
  D_(r) && ((r.__curvenessList = []), (r.__edgeMap = {}), v4(r))
}
function Rft(r, t, e, n) {
  if (D_(e)) {
    var i = av(r, t, e),
      a = e.__edgeMap,
      o = a[g4(i)]
    a[i] && !o
      ? (a[i].isForward = !0)
      : o && a[i] && ((o.isForward = !0), (a[i].isForward = !1)),
      (a[i] = a[i] || []),
      a[i].push(n)
  }
}
function ZC(r, t, e, n) {
  var i = D_(t),
    a = at(i)
  if (!i) return null
  var o = Dft(r, t)
  if (!o) return null
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === e) {
      s = l
      break
    }
  var u = Lft(r, t)
  v4(t, u), (r.lineStyle = r.lineStyle || {})
  var c = av(r.node1, r.node2, t),
    h = t.__curvenessList,
    f = a || u % 2 ? 0 : 1
  if (o.isForward) return h[f + s]
  var d = g4(c),
    p = Gw(d, t),
    g = h[s + p + f]
  return n
    ? a
      ? i && i[0] === 0
        ? (p + f) % 2
          ? g
          : -g
        : ((p % 2 ? 0 : 1) + f) % 2
        ? g
        : -g
      : (p + f) % 2
      ? g
      : -g
    : h[s + p + f]
}
function m4(r) {
  var t = r.coordinateSystem
  if (!(t && t.type !== 'view')) {
    var e = r.getGraph()
    e.eachNode(function (n) {
      var i = n.getModel()
      n.setLayout([+i.get('x'), +i.get('y')])
    }),
      KC(e, r)
  }
}
function KC(r, t) {
  r.eachEdge(function (e, n) {
    var i = ao(
        e.getModel().get(['lineStyle', 'curveness']),
        -ZC(e, t, n, !0),
        0,
      ),
      a = Go(e.node1.getLayout()),
      o = Go(e.node2.getLayout()),
      s = [a, o]
    ;+i &&
      s.push([
        (a[0] + o[0]) / 2 - (a[1] - o[1]) * i,
        (a[1] + o[1]) / 2 - (o[0] - a[0]) * i,
      ]),
      e.setLayout(s)
  })
}
function Ift(r, t) {
  r.eachSeriesByType('graph', function (e) {
    var n = e.get('layout'),
      i = e.coordinateSystem
    if (i && i.type !== 'view') {
      var a = e.getData(),
        o = []
      R(i.dimensions, function (f) {
        o = o.concat(a.mapDimensionsAll(f))
      })
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var h = a.get(o[c], s)
          isNaN(h) || (u = !0), l.push(h)
        }
        u
          ? a.setItemLayout(s, i.dataToPoint(l))
          : a.setItemLayout(s, [NaN, NaN])
      }
      KC(a.graph, e)
    } else (!n || n === 'none') && m4(e)
  })
}
function Wd(r) {
  var t = r.coordinateSystem
  if (t.type !== 'view') return 1
  var e = r.option.nodeScaleRatio,
    n = t.scaleX,
    i = t.getZoom(),
    a = (i - 1) * e + 1
  return a / n
}
function Xd(r) {
  var t = r.getVisual('symbolSize')
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t
}
var XO = Math.PI,
  yS = []
function jC(r, t, e, n) {
  var i = r.coordinateSystem
  if (!(i && i.type !== 'view')) {
    var a = i.getBoundingRect(),
      o = r.getData(),
      s = o.graph,
      l = a.width / 2 + a.x,
      u = a.height / 2 + a.y,
      c = Math.min(a.width, a.height) / 2,
      h = o.count()
    if (
      (o.setLayout({
        cx: l,
        cy: u,
      }),
      !!h)
    ) {
      if (e) {
        var f = i.pointToData(n),
          d = f[0],
          p = f[1],
          g = [d - l, p - u]
        gf(g, g), Xm(g, g, c), e.setLayout([l + g[0], u + g[1]], !0)
        var v = r.get(['circular', 'rotateLabel'])
        y4(e, v, l, u)
      }
      Oft[t](r, s, o, c, l, u, h),
        s.eachEdge(function (m, y) {
          var _ = ao(
              m.getModel().get(['lineStyle', 'curveness']),
              ZC(m, r, y),
              0,
            ),
            x = Go(m.node1.getLayout()),
            A = Go(m.node2.getLayout()),
            S,
            b = (x[0] + A[0]) / 2,
            T = (x[1] + A[1]) / 2
          ;+_ && ((_ *= 3), (S = [l * _ + b * (1 - _), u * _ + T * (1 - _)])),
            m.setLayout([x, A, S])
        })
    }
  }
}
var Oft = {
  value: function (r, t, e, n, i, a, o) {
    var s = 0,
      l = e.getSum('value'),
      u = (Math.PI * 2) / (l || o)
    t.eachNode(function (c) {
      var h = c.getValue('value'),
        f = (u * (l ? h : 1)) / 2
      ;(s += f),
        c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + a]),
        (s += f)
    })
  },
  symbolSize: function (r, t, e, n, i, a, o) {
    var s = 0
    yS.length = o
    var l = Wd(r)
    t.eachNode(function (h) {
      var f = Xd(h)
      isNaN(f) && (f = 2), f < 0 && (f = 0), (f *= l)
      var d = Math.asin(f / 2 / n)
      isNaN(d) && (d = XO / 2), (yS[h.dataIndex] = d), (s += d * 2)
    })
    var u = (2 * XO - s) / o / 2,
      c = 0
    t.eachNode(function (h) {
      var f = u + yS[h.dataIndex]
      ;(c += f),
        (!h.getLayout() || !h.getLayout().fixed) &&
          h.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + a]),
        (c += f)
    })
  },
}
function y4(r, t, e, n) {
  var i = r.getGraphicEl()
  if (i) {
    var a = r.getModel(),
      o = a.get(['label', 'rotate']) || 0,
      s = i.getSymbolPath()
    if (t) {
      var l = r.getLayout(),
        u = Math.atan2(l[1] - n, l[0] - e)
      u < 0 && (u = Math.PI * 2 + u)
      var c = l[0] < e
      c && (u = u - Math.PI)
      var h = c ? 'left' : 'right'
      s.setTextConfig({
        rotation: -u,
        position: h,
        origin: 'center',
      })
      var f = s.ensureState('emphasis')
      Q(f.textConfig || (f.textConfig = {}), {
        position: h,
      })
    } else
      s.setTextConfig({
        rotation: (o *= Math.PI / 180),
      })
  }
}
function Nft(r) {
  r.eachSeriesByType('graph', function (t) {
    t.get('layout') === 'circular' && jC(t, 'symbolSize')
  })
}
var jc = Eb
function kft(r, t, e) {
  for (
    var n = r,
      i = t,
      a = e.rect,
      o = a.width,
      s = a.height,
      l = [a.x + o / 2, a.y + s / 2],
      u = e.gravity == null ? 0.1 : e.gravity,
      c = 0;
    c < n.length;
    c++
  ) {
    var h = n[c]
    h.p ||
      (h.p = tc(
        o * (Math.random() - 0.5) + l[0],
        s * (Math.random() - 0.5) + l[1],
      )),
      (h.pp = Go(h.p)),
      (h.edges = null)
  }
  var f = e.friction == null ? 0.6 : e.friction,
    d = f,
    p,
    g
  return {
    warmUp: function () {
      d = f * 0.8
    },
    setFixed: function (v) {
      n[v].fixed = !0
    },
    setUnfixed: function (v) {
      n[v].fixed = !1
    },
    beforeStep: function (v) {
      p = v
    },
    afterStep: function (v) {
      g = v
    },
    step: function (v) {
      p && p(n, i)
      for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
        var x = i[_]
        if (!x.ignoreForceLayout) {
          var A = x.n1,
            S = x.n2
          gu(m, S.p, A.p)
          var b = Db(m) - x.d,
            T = S.w / (A.w + S.w)
          isNaN(T) && (T = 0),
            gf(m, m),
            !A.fixed && jc(A.p, A.p, m, T * b * d),
            !S.fixed && jc(S.p, S.p, m, -(1 - T) * b * d)
        }
      }
      for (var _ = 0; _ < y; _++) {
        var w = n[_]
        w.fixed || (gu(m, l, w.p), jc(w.p, w.p, m, u * d))
      }
      for (var _ = 0; _ < y; _++)
        for (var A = n[_], M = _ + 1; M < y; M++) {
          var S = n[M]
          gu(m, S.p, A.p)
          var b = Db(m)
          b === 0 && (VJ(m, Math.random() - 0.5, Math.random() - 0.5), (b = 1))
          var C = (A.rep + S.rep) / b / b
          !A.fixed && jc(A.pp, A.pp, m, C), !S.fixed && jc(S.pp, S.pp, m, -C)
        }
      for (var E = [], _ = 0; _ < y; _++) {
        var w = n[_]
        w.fixed || (gu(E, w.p, w.pp), jc(w.p, w.p, E, d), Nr(w.pp, w.p))
      }
      d = d * 0.992
      var D = d < 0.01
      g && g(n, i, D), v && v(D)
    },
  }
}
function Bft(r) {
  r.eachSeriesByType('graph', function (t) {
    var e = t.coordinateSystem
    if (!(e && e.type !== 'view'))
      if (t.get('layout') === 'force') {
        var n = t.preservedPoints || {},
          i = t.getGraph(),
          a = i.data,
          o = i.edgeData,
          s = t.getModel('force'),
          l = s.get('initLayout')
        t.preservedPoints
          ? a.each(function (_) {
              var x = a.getId(_)
              a.setItemLayout(_, n[x] || [NaN, NaN])
            })
          : !l || l === 'none'
          ? m4(t)
          : l === 'circular' && jC(t, 'value')
        var u = a.getDataExtent('value'),
          c = o.getDataExtent('value'),
          h = s.get('repulsion'),
          f = s.get('edgeLength'),
          d = at(h) ? h : [h, h],
          p = at(f) ? f : [f, f]
        p = [p[1], p[0]]
        var g = a.mapArray('value', function (_, x) {
            var A = a.getItemLayout(x),
              S = Re(_, u, d)
            return (
              isNaN(S) && (S = (d[0] + d[1]) / 2),
              {
                w: S,
                rep: S,
                fixed: a.getItemModel(x).get('fixed'),
                p: !A || isNaN(A[0]) || isNaN(A[1]) ? null : A,
              }
            )
          }),
          v = o.mapArray('value', function (_, x) {
            var A = i.getEdgeByIndex(x),
              S = Re(_, c, p)
            isNaN(S) && (S = (p[0] + p[1]) / 2)
            var b = A.getModel(),
              T = ao(
                A.getModel().get(['lineStyle', 'curveness']),
                -ZC(A, t, x, !0),
                0,
              )
            return {
              n1: g[A.node1.dataIndex],
              n2: g[A.node2.dataIndex],
              d: S,
              curveness: T,
              ignoreForceLayout: b.get('ignoreForceLayout'),
            }
          }),
          m = e.getBoundingRect(),
          y = kft(g, v, {
            rect: m,
            gravity: s.get('gravity'),
            friction: s.get('friction'),
          })
        y.beforeStep(function (_, x) {
          for (var A = 0, S = _.length; A < S; A++)
            _[A].fixed && Nr(_[A].p, i.getNodeByIndex(A).getLayout())
        }),
          y.afterStep(function (_, x, A) {
            for (var S = 0, b = _.length; S < b; S++)
              _[S].fixed || i.getNodeByIndex(S).setLayout(_[S].p),
                (n[a.getId(S)] = _[S].p)
            for (var S = 0, b = x.length; S < b; S++) {
              var T = x[S],
                w = i.getEdgeByIndex(S),
                M = T.n1.p,
                C = T.n2.p,
                E = w.getLayout()
              ;(E = E ? E.slice() : []),
                (E[0] = E[0] || []),
                (E[1] = E[1] || []),
                Nr(E[0], M),
                Nr(E[1], C),
                +T.curveness &&
                  (E[2] = [
                    (M[0] + C[0]) / 2 - (M[1] - C[1]) * T.curveness,
                    (M[1] + C[1]) / 2 - (C[0] - M[0]) * T.curveness,
                  ]),
                w.setLayout(E)
            }
          }),
          (t.forceLayout = y),
          (t.preservedPoints = n),
          y.step()
      } else t.forceLayout = null
  })
}
function Fft(r, t, e) {
  var n = Q(r.getBoxLayoutParams(), {
    aspect: e,
  })
  return Vn(n, {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function zft(r, t) {
  var e = []
  return (
    r.eachSeriesByType('graph', function (n) {
      var i = n.get('coordinateSystem')
      if (!i || i === 'view') {
        var a = n.getData(),
          o = a.mapArray(function (v) {
            var m = a.getItemModel(v)
            return [+m.get('x'), +m.get('y')]
          }),
          s = [],
          l = []
        e_(o, s, l),
          l[0] - s[0] === 0 && ((l[0] += 1), (s[0] -= 1)),
          l[1] - s[1] === 0 && ((l[1] += 1), (s[1] -= 1))
        var u = (l[0] - s[0]) / (l[1] - s[1]),
          c = Fft(n, t, u)
        isNaN(u) && ((s = [c.x, c.y]), (l = [c.x + c.width, c.y + c.height]))
        var h = l[0] - s[0],
          f = l[1] - s[1],
          d = c.width,
          p = c.height,
          g = (n.coordinateSystem = new Iv())
        ;(g.zoomLimit = n.get('scaleLimit')),
          g.setBoundingRect(s[0], s[1], h, f),
          g.setViewRect(c.x, c.y, d, p),
          g.setCenter(n.get('center'), t),
          g.setZoom(n.get('zoom')),
          e.push(g)
      }
    }),
    e
  )
}
var YO = rr.prototype,
  _S = a_.prototype,
  _4 = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.percent = 1)
    }
    return r
  })()
;(function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return t
})(_4)
function xS(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1)
}
var Uft = (function (r) {
  X(t, r)
  function t(e) {
    var n = r.call(this, e) || this
    return (n.type = 'ec-line'), n
  }
  return (
    (t.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null,
      }
    }),
    (t.prototype.getDefaultShape = function () {
      return new _4()
    }),
    (t.prototype.buildPath = function (e, n) {
      xS(n) ? YO.buildPath.call(this, e, n) : _S.buildPath.call(this, e, n)
    }),
    (t.prototype.pointAt = function (e) {
      return xS(this.shape)
        ? YO.pointAt.call(this, e)
        : _S.pointAt.call(this, e)
    }),
    (t.prototype.tangentAt = function (e) {
      var n = this.shape,
        i = xS(n) ? [n.x2 - n.x1, n.y2 - n.y1] : _S.tangentAt.call(this, e)
      return gf(i, i)
    }),
    t
  )
})(oe)
const Vft = Uft
var SS = ['fromSymbol', 'toSymbol']
function $O(r) {
  return '_' + r + 'Type'
}
function qO(r, t, e) {
  var n = t.getItemVisual(e, r)
  if (!n || n === 'none') return n
  var i = t.getItemVisual(e, r + 'Size'),
    a = t.getItemVisual(e, r + 'Rotate'),
    o = t.getItemVisual(e, r + 'Offset'),
    s = t.getItemVisual(e, r + 'KeepAspect'),
    l = Lf(i),
    u = ic(o || 0, l)
  return n + l + u + (a || '') + (s || '')
}
function ZO(r, t, e) {
  var n = t.getItemVisual(e, r)
  if (!(!n || n === 'none')) {
    var i = t.getItemVisual(e, r + 'Size'),
      a = t.getItemVisual(e, r + 'Rotate'),
      o = t.getItemVisual(e, r + 'Offset'),
      s = t.getItemVisual(e, r + 'KeepAspect'),
      l = Lf(i),
      u = ic(o || 0, l),
      c = Rn(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s)
    return (
      (c.__specifiedRotation =
        a == null || isNaN(a) ? void 0 : (+a * Math.PI) / 180 || 0),
      (c.name = r),
      c
    )
  }
}
function Gft(r) {
  var t = new Vft({
    name: 'line',
    subPixelOptimize: !0,
  })
  return Hw(t.shape, r), t
}
function Hw(r, t) {
  ;(r.x1 = t[0][0]),
    (r.y1 = t[0][1]),
    (r.x2 = t[1][0]),
    (r.y2 = t[1][1]),
    (r.percent = 1)
  var e = t[2]
  e ? ((r.cpx1 = e[0]), (r.cpy1 = e[1])) : ((r.cpx1 = NaN), (r.cpy1 = NaN))
}
var Hft = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a._createLine(e, n, i), a
  }
  return (
    (t.prototype._createLine = function (e, n, i) {
      var a = e.hostModel,
        o = e.getItemLayout(n),
        s = Gft(o)
      ;(s.shape.percent = 0),
        Je(
          s,
          {
            shape: {
              percent: 1,
            },
          },
          a,
          n,
        ),
        this.add(s),
        R(
          SS,
          function (l) {
            var u = ZO(l, e, n)
            this.add(u), (this[$O(l)] = qO(l, e, n))
          },
          this,
        ),
        this._updateCommonStl(e, n, i)
    }),
    (t.prototype.updateData = function (e, n, i) {
      var a = e.hostModel,
        o = this.childOfName('line'),
        s = e.getItemLayout(n),
        l = {
          shape: {},
        }
      Hw(l.shape, s),
        we(o, l, a, n),
        R(
          SS,
          function (u) {
            var c = qO(u, e, n),
              h = $O(u)
            if (this[h] !== c) {
              this.remove(this.childOfName(u))
              var f = ZO(u, e, n)
              this.add(f)
            }
            this[h] = c
          },
          this,
        ),
        this._updateCommonStl(e, n, i)
    }),
    (t.prototype.getLinePath = function () {
      return this.childAt(0)
    }),
    (t.prototype._updateCommonStl = function (e, n, i) {
      var a = e.hostModel,
        o = this.childOfName('line'),
        s = i && i.emphasisLineStyle,
        l = i && i.blurLineStyle,
        u = i && i.selectLineStyle,
        c = i && i.labelStatesModels,
        h = i && i.emphasisDisabled,
        f = i && i.focus,
        d = i && i.blurScope
      if (!i || e.hasItemOption) {
        var p = e.getItemModel(n),
          g = p.getModel('emphasis')
        ;(s = g.getModel('lineStyle').getLineStyle()),
          (l = p.getModel(['blur', 'lineStyle']).getLineStyle()),
          (u = p.getModel(['select', 'lineStyle']).getLineStyle()),
          (h = g.get('disabled')),
          (f = g.get('focus')),
          (d = g.get('blurScope')),
          (c = Zn(p))
      }
      var v = e.getItemVisual(n, 'style'),
        m = v.stroke
      o.useStyle(v),
        (o.style.fill = null),
        (o.style.strokeNoScale = !0),
        (o.ensureState('emphasis').style = s),
        (o.ensureState('blur').style = l),
        (o.ensureState('select').style = u),
        R(
          SS,
          function (S) {
            var b = this.childOfName(S)
            if (b) {
              b.setColor(m), (b.style.opacity = v.opacity)
              for (var T = 0; T < Hr.length; T++) {
                var w = Hr[T],
                  M = o.getState(w)
                if (M) {
                  var C = M.style || {},
                    E = b.ensureState(w),
                    D = E.style || (E.style = {})
                  C.stroke != null &&
                    (D[b.__isEmptyBrush ? 'stroke' : 'fill'] = C.stroke),
                    C.opacity != null && (D.opacity = C.opacity)
                }
              }
              b.markRedraw()
            }
          },
          this,
        )
      var y = a.getRawValue(n)
      mr(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function (S, b) {
            return a.getFormattedLabel(S, b, e.dataType)
          },
        },
        inheritColor: m || '#000',
        defaultOpacity: v.opacity,
        defaultText: (y == null ? e.getName(n) : isFinite(y) ? mn(y) : y) + '',
      })
      var _ = this.getTextContent()
      if (_) {
        var x = c.normal
        ;(_.__align = _.style.align),
          (_.__verticalAlign = _.style.verticalAlign),
          (_.__position = x.get('position') || 'middle')
        var A = x.get('distance')
        at(A) || (A = [A, A]), (_.__labelDistance = A)
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1,
      }),
        fn(this, f, d, h)
    }),
    (t.prototype.highlight = function () {
      Qo(this)
    }),
    (t.prototype.downplay = function () {
      ts(this)
    }),
    (t.prototype.updateLayout = function (e, n) {
      this.setLinePoints(e.getItemLayout(n))
    }),
    (t.prototype.setLinePoints = function (e) {
      var n = this.childOfName('line')
      Hw(n.shape, e), n.dirty()
    }),
    (t.prototype.beforeUpdate = function () {
      var e = this,
        n = e.childOfName('fromSymbol'),
        i = e.childOfName('toSymbol'),
        a = e.getTextContent()
      if (!n && !i && (!a || a.ignore)) return
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), (s = s.parent)
      var l = e.childOfName('line')
      if (!this.__dirty && !l.__dirty) return
      var u = l.shape.percent,
        c = l.pointAt(0),
        h = l.pointAt(u),
        f = gu([], h, c)
      gf(f, f)
      function d(M, C) {
        var E = M.__specifiedRotation
        if (E == null) {
          var D = l.tangentAt(C)
          M.attr(
            'rotation',
            ((C === 1 ? -1 : 1) * Math.PI) / 2 - Math.atan2(D[1], D[0]),
          )
        } else M.attr('rotation', E)
      }
      if (
        (n &&
          (n.setPosition(c),
          d(n, 0),
          (n.scaleX = n.scaleY = o * u),
          n.markRedraw()),
        i &&
          (i.setPosition(h),
          d(i, 1),
          (i.scaleX = i.scaleY = o * u),
          i.markRedraw()),
        a && !a.ignore)
      ) {
        ;(a.x = a.y = 0), (a.originX = a.originY = 0)
        var p = void 0,
          g = void 0,
          v = a.__labelDistance,
          m = v[0] * o,
          y = v[1] * o,
          _ = u / 2,
          x = l.tangentAt(_),
          A = [x[1], -x[0]],
          S = l.pointAt(_)
        A[1] > 0 && ((A[0] = -A[0]), (A[1] = -A[1]))
        var b = x[0] < 0 ? -1 : 1
        if (a.__position !== 'start' && a.__position !== 'end') {
          var T = -Math.atan2(x[1], x[0])
          h[0] < c[0] && (T = Math.PI + T), (a.rotation = T)
        }
        var w = void 0
        switch (a.__position) {
          case 'insideStartTop':
          case 'insideMiddleTop':
          case 'insideEndTop':
          case 'middle':
            ;(w = -y), (g = 'bottom')
            break
          case 'insideStartBottom':
          case 'insideMiddleBottom':
          case 'insideEndBottom':
            ;(w = y), (g = 'top')
            break
          default:
            ;(w = 0), (g = 'middle')
        }
        switch (a.__position) {
          case 'end':
            ;(a.x = f[0] * m + h[0]),
              (a.y = f[1] * y + h[1]),
              (p = f[0] > 0.8 ? 'left' : f[0] < -0.8 ? 'right' : 'center'),
              (g = f[1] > 0.8 ? 'top' : f[1] < -0.8 ? 'bottom' : 'middle')
            break
          case 'start':
            ;(a.x = -f[0] * m + c[0]),
              (a.y = -f[1] * y + c[1]),
              (p = f[0] > 0.8 ? 'right' : f[0] < -0.8 ? 'left' : 'center'),
              (g = f[1] > 0.8 ? 'bottom' : f[1] < -0.8 ? 'top' : 'middle')
            break
          case 'insideStartTop':
          case 'insideStart':
          case 'insideStartBottom':
            ;(a.x = m * b + c[0]),
              (a.y = c[1] + w),
              (p = x[0] < 0 ? 'right' : 'left'),
              (a.originX = -m * b),
              (a.originY = -w)
            break
          case 'insideMiddleTop':
          case 'insideMiddle':
          case 'insideMiddleBottom':
          case 'middle':
            ;(a.x = S[0]), (a.y = S[1] + w), (p = 'center'), (a.originY = -w)
            break
          case 'insideEndTop':
          case 'insideEnd':
          case 'insideEndBottom':
            ;(a.x = -m * b + h[0]),
              (a.y = h[1] + w),
              (p = x[0] >= 0 ? 'right' : 'left'),
              (a.originX = m * b),
              (a.originY = -w)
            break
        }
        ;(a.scaleX = a.scaleY = o),
          a.setStyle({
            verticalAlign: a.__verticalAlign || g,
            align: a.__align || p,
          })
      }
    }),
    t
  )
})(Ht)
const JC = Hft
var Wft = (function () {
  function r(t) {
    ;(this.group = new Ht()), (this._LineCtor = t || JC)
  }
  return (
    (r.prototype.updateData = function (t) {
      var e = this
      this._progressiveEls = null
      var n = this,
        i = n.group,
        a = n._lineData
      ;(n._lineData = t), a || i.removeAll()
      var o = KO(t)
      t.diff(a)
        .add(function (s) {
          e._doAdd(t, s, o)
        })
        .update(function (s, l) {
          e._doUpdate(a, t, l, s, o)
        })
        .remove(function (s) {
          i.remove(a.getItemGraphicEl(s))
        })
        .execute()
    }),
    (r.prototype.updateLayout = function () {
      var t = this._lineData
      t &&
        t.eachItemGraphicEl(function (e, n) {
          e.updateLayout(t, n)
        }, this)
    }),
    (r.prototype.incrementalPrepareUpdate = function (t) {
      ;(this._seriesScope = KO(t)),
        (this._lineData = null),
        this.group.removeAll()
    }),
    (r.prototype.incrementalUpdate = function (t, e) {
      this._progressiveEls = []
      function n(s) {
        !s.isGroup &&
          !Xft(s) &&
          ((s.incremental = !0), (s.ensureState('emphasis').hoverLayer = !0))
      }
      for (var i = t.start; i < t.end; i++) {
        var a = e.getItemLayout(i)
        if (AS(a)) {
          var o = new this._LineCtor(e, i, this._seriesScope)
          o.traverse(n),
            this.group.add(o),
            e.setItemGraphicEl(i, o),
            this._progressiveEls.push(o)
        }
      }
    }),
    (r.prototype.remove = function () {
      this.group.removeAll()
    }),
    (r.prototype.eachRendered = function (t) {
      vl(this._progressiveEls || this.group, t)
    }),
    (r.prototype._doAdd = function (t, e, n) {
      var i = t.getItemLayout(e)
      if (AS(i)) {
        var a = new this._LineCtor(t, e, n)
        t.setItemGraphicEl(e, a), this.group.add(a)
      }
    }),
    (r.prototype._doUpdate = function (t, e, n, i, a) {
      var o = t.getItemGraphicEl(n)
      if (!AS(e.getItemLayout(i))) {
        this.group.remove(o)
        return
      }
      o ? o.updateData(e, i, a) : (o = new this._LineCtor(e, i, a)),
        e.setItemGraphicEl(i, o),
        this.group.add(o)
    }),
    r
  )
})()
function Xft(r) {
  return r.animators && r.animators.length > 0
}
function KO(r) {
  var t = r.hostModel,
    e = t.getModel('emphasis')
  return {
    lineStyle: t.getModel('lineStyle').getLineStyle(),
    emphasisLineStyle: e.getModel(['lineStyle']).getLineStyle(),
    blurLineStyle: t.getModel(['blur', 'lineStyle']).getLineStyle(),
    selectLineStyle: t.getModel(['select', 'lineStyle']).getLineStyle(),
    emphasisDisabled: e.get('disabled'),
    blurScope: e.get('blurScope'),
    focus: e.get('focus'),
    labelStatesModels: Zn(t),
  }
}
function jO(r) {
  return isNaN(r[0]) || isNaN(r[1])
}
function AS(r) {
  return r && !jO(r[0]) && !jO(r[1])
}
const QC = Wft
var bS = [],
  wS = [],
  MS = [],
  Jc = tr,
  TS = Lu,
  JO = Math.abs
function QO(r, t, e) {
  for (
    var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = e * e, u = 0.1, c = 0.1;
    c <= 0.9;
    c += 0.1
  ) {
    ;(bS[0] = Jc(n[0], i[0], a[0], c)), (bS[1] = Jc(n[1], i[1], a[1], c))
    var h = JO(TS(bS, t) - l)
    h < o && ((o = h), (s = c))
  }
  for (var f = 0; f < 32; f++) {
    var d = s + u
    ;(wS[0] = Jc(n[0], i[0], a[0], s)),
      (wS[1] = Jc(n[1], i[1], a[1], s)),
      (MS[0] = Jc(n[0], i[0], a[0], d)),
      (MS[1] = Jc(n[1], i[1], a[1], d))
    var h = TS(wS, t) - l
    if (JO(h) < 0.01) break
    var p = TS(MS, t) - l
    ;(u /= 2),
      h < 0
        ? p >= 0
          ? (s = s + u)
          : (s = s - u)
        : p >= 0
        ? (s = s - u)
        : (s = s + u)
  }
  return s
}
function CS(r, t) {
  var e = [],
    n = Bp,
    i = [[], [], []],
    a = [[], []],
    o = []
  ;(t /= 2),
    r.eachEdge(function (s, l) {
      var u = s.getLayout(),
        c = s.getVisual('fromSymbol'),
        h = s.getVisual('toSymbol')
      u.__original ||
        ((u.__original = [Go(u[0]), Go(u[1])]),
        u[2] && u.__original.push(Go(u[2])))
      var f = u.__original
      if (u[2] != null) {
        if (
          (Nr(i[0], f[0]), Nr(i[1], f[2]), Nr(i[2], f[1]), c && c !== 'none')
        ) {
          var d = Xd(s.node1),
            p = QO(i, f[0], d * t)
          n(i[0][0], i[1][0], i[2][0], p, e),
            (i[0][0] = e[3]),
            (i[1][0] = e[4]),
            n(i[0][1], i[1][1], i[2][1], p, e),
            (i[0][1] = e[3]),
            (i[1][1] = e[4])
        }
        if (h && h !== 'none') {
          var d = Xd(s.node2),
            p = QO(i, f[1], d * t)
          n(i[0][0], i[1][0], i[2][0], p, e),
            (i[1][0] = e[1]),
            (i[2][0] = e[2]),
            n(i[0][1], i[1][1], i[2][1], p, e),
            (i[1][1] = e[1]),
            (i[2][1] = e[2])
        }
        Nr(u[0], i[0]), Nr(u[1], i[2]), Nr(u[2], i[1])
      } else {
        if (
          (Nr(a[0], f[0]),
          Nr(a[1], f[1]),
          gu(o, a[1], a[0]),
          gf(o, o),
          c && c !== 'none')
        ) {
          var d = Xd(s.node1)
          Eb(a[0], a[0], o, d * t)
        }
        if (h && h !== 'none') {
          var d = Xd(s.node2)
          Eb(a[1], a[1], o, -d * t)
        }
        Nr(u[0], a[0]), Nr(u[1], a[1])
      }
    })
}
function tN(r) {
  return r.type === 'view'
}
var Yft = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n) {
      var i = new Cv(),
        a = new QC(),
        o = this.group
      ;(this._controller = new Rv(n.getZr())),
        (this._controllerHost = {
          target: o,
        }),
        o.add(i.group),
        o.add(a.group),
        (this._symbolDraw = i),
        (this._lineDraw = a),
        (this._firstRender = !0)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = this,
        o = e.coordinateSystem
      this._model = e
      var s = this._symbolDraw,
        l = this._lineDraw,
        u = this.group
      if (tN(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY,
        }
        this._firstRender ? u.attr(c) : we(u, c, e)
      }
      CS(e.getGraph(), Wd(e))
      var h = e.getData()
      s.updateData(h)
      var f = e.getEdgeData()
      l.updateData(f),
        this._updateNodeAndLinkScale(),
        this._updateController(e, n, i),
        clearTimeout(this._layoutTimeout)
      var d = e.forceLayout,
        p = e.get(['force', 'layoutAnimation'])
      d && this._startForceLayoutIteration(d, p)
      var g = e.get('layout')
      h.graph.eachNode(function (_) {
        var x = _.dataIndex,
          A = _.getGraphicEl(),
          S = _.getModel()
        if (A) {
          A.off('drag').off('dragend')
          var b = S.get('draggable')
          b &&
            A.on('drag', function (w) {
              switch (g) {
                case 'force':
                  d.warmUp(),
                    !a._layouting && a._startForceLayoutIteration(d, p),
                    d.setFixed(x),
                    h.setItemLayout(x, [A.x, A.y])
                  break
                case 'circular':
                  h.setItemLayout(x, [A.x, A.y]),
                    _.setLayout(
                      {
                        fixed: !0,
                      },
                      !0,
                    ),
                    jC(e, 'symbolSize', _, [w.offsetX, w.offsetY]),
                    a.updateLayout(e)
                  break
                case 'none':
                default:
                  h.setItemLayout(x, [A.x, A.y]),
                    KC(e.getGraph(), e),
                    a.updateLayout(e)
                  break
              }
            }).on('dragend', function () {
              d && d.setUnfixed(x)
            }),
            A.setDraggable(b, !!S.get('cursor'))
          var T = S.get(['emphasis', 'focus'])
          T === 'adjacency' && (Wt(A).focus = _.getAdjacentDataIndices())
        }
      }),
        h.graph.eachEdge(function (_) {
          var x = _.getGraphicEl(),
            A = _.getModel().get(['emphasis', 'focus'])
          x &&
            A === 'adjacency' &&
            (Wt(x).focus = {
              edge: [_.dataIndex],
              node: [_.node1.dataIndex, _.node2.dataIndex],
            })
        })
      var v =
          e.get('layout') === 'circular' && e.get(['circular', 'rotateLabel']),
        m = h.getLayout('cx'),
        y = h.getLayout('cy')
      h.graph.eachNode(function (_) {
        y4(_, v, m, y)
      }),
        (this._firstRender = !1)
    }),
    (t.prototype.dispose = function () {
      this.remove(),
        this._controller && this._controller.dispose(),
        (this._controllerHost = null)
    }),
    (t.prototype._startForceLayoutIteration = function (e, n) {
      var i = this
      ;(function a() {
        e.step(function (o) {
          i.updateLayout(i._model),
            (i._layouting = !o) &&
              (n ? (i._layoutTimeout = setTimeout(a, 16)) : a())
        })
      })()
    }),
    (t.prototype._updateController = function (e, n, i) {
      var a = this,
        o = this._controller,
        s = this._controllerHost,
        l = this.group
      if (
        (o.setPointerChecker(function (u, c, h) {
          var f = l.getBoundingRect()
          return f.applyTransform(l.transform), f.contain(c, h) && !T_(u, i, e)
        }),
        !tN(e.coordinateSystem))
      ) {
        o.disable()
        return
      }
      o.enable(e.get('roam')),
        (s.zoomLimit = e.get('scaleLimit')),
        (s.zoom = e.coordinateSystem.getZoom()),
        o
          .off('pan')
          .off('zoom')
          .on('pan', function (u) {
            UC(s, u.dx, u.dy),
              i.dispatchAction({
                seriesId: e.id,
                type: 'graphRoam',
                dx: u.dx,
                dy: u.dy,
              })
          })
          .on('zoom', function (u) {
            VC(s, u.scale, u.originX, u.originY),
              i.dispatchAction({
                seriesId: e.id,
                type: 'graphRoam',
                zoom: u.scale,
                originX: u.originX,
                originY: u.originY,
              }),
              a._updateNodeAndLinkScale(),
              CS(e.getGraph(), Wd(e)),
              a._lineDraw.updateLayout(),
              i.updateLabelLayout()
          })
    }),
    (t.prototype._updateNodeAndLinkScale = function () {
      var e = this._model,
        n = e.getData(),
        i = Wd(e)
      n.eachItemGraphicEl(function (a, o) {
        a && a.setSymbolScale(i)
      })
    }),
    (t.prototype.updateLayout = function (e) {
      CS(e.getGraph(), Wd(e)),
        this._symbolDraw.updateLayout(),
        this._lineDraw.updateLayout()
    }),
    (t.prototype.remove = function () {
      clearTimeout(this._layoutTimeout),
        (this._layouting = !1),
        (this._layoutTimeout = null),
        this._symbolDraw && this._symbolDraw.remove(),
        this._lineDraw && this._lineDraw.remove()
    }),
    (t.type = 'graph'),
    t
  )
})(Ze)
const $ft = Yft
function Qc(r) {
  return '_EC_' + r
}
var qft = (function () {
    function r(t) {
      ;(this.type = 'graph'),
        (this.nodes = []),
        (this.edges = []),
        (this._nodesMap = {}),
        (this._edgesMap = {}),
        (this._directed = t || !1)
    }
    return (
      (r.prototype.isDirected = function () {
        return this._directed
      }),
      (r.prototype.addNode = function (t, e) {
        t = t == null ? '' + e : '' + t
        var n = this._nodesMap
        if (!n[Qc(t)]) {
          var i = new su(t, e)
          return (i.hostGraph = this), this.nodes.push(i), (n[Qc(t)] = i), i
        }
      }),
      (r.prototype.getNodeByIndex = function (t) {
        var e = this.data.getRawIndex(t)
        return this.nodes[e]
      }),
      (r.prototype.getNodeById = function (t) {
        return this._nodesMap[Qc(t)]
      }),
      (r.prototype.addEdge = function (t, e, n) {
        var i = this._nodesMap,
          a = this._edgesMap
        if (
          (be(t) && (t = this.nodes[t]),
          be(e) && (e = this.nodes[e]),
          t instanceof su || (t = i[Qc(t)]),
          e instanceof su || (e = i[Qc(e)]),
          !(!t || !e))
        ) {
          var o = t.id + '-' + e.id,
            s = new x4(t, e, n)
          return (
            (s.hostGraph = this),
            this._directed && (t.outEdges.push(s), e.inEdges.push(s)),
            t.edges.push(s),
            t !== e && e.edges.push(s),
            this.edges.push(s),
            (a[o] = s),
            s
          )
        }
      }),
      (r.prototype.getEdgeByIndex = function (t) {
        var e = this.edgeData.getRawIndex(t)
        return this.edges[e]
      }),
      (r.prototype.getEdge = function (t, e) {
        t instanceof su && (t = t.id), e instanceof su && (e = e.id)
        var n = this._edgesMap
        return this._directed
          ? n[t + '-' + e]
          : n[t + '-' + e] || n[e + '-' + t]
      }),
      (r.prototype.eachNode = function (t, e) {
        for (var n = this.nodes, i = n.length, a = 0; a < i; a++)
          n[a].dataIndex >= 0 && t.call(e, n[a], a)
      }),
      (r.prototype.eachEdge = function (t, e) {
        for (var n = this.edges, i = n.length, a = 0; a < i; a++)
          n[a].dataIndex >= 0 &&
            n[a].node1.dataIndex >= 0 &&
            n[a].node2.dataIndex >= 0 &&
            t.call(e, n[a], a)
      }),
      (r.prototype.breadthFirstTraverse = function (t, e, n, i) {
        if ((e instanceof su || (e = this._nodesMap[Qc(e)]), !!e)) {
          for (
            var a = n === 'out' ? 'outEdges' : n === 'in' ? 'inEdges' : 'edges',
              o = 0;
            o < this.nodes.length;
            o++
          )
            this.nodes[o].__visited = !1
          if (!t.call(i, e, null))
            for (var s = [e]; s.length; )
              for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
                var c = u[o],
                  h = c.node1 === l ? c.node2 : c.node1
                if (!h.__visited) {
                  if (t.call(i, h, l)) return
                  s.push(h), (h.__visited = !0)
                }
              }
        }
      }),
      (r.prototype.update = function () {
        for (
          var t = this.data,
            e = this.edgeData,
            n = this.nodes,
            i = this.edges,
            a = 0,
            o = n.length;
          a < o;
          a++
        )
          n[a].dataIndex = -1
        for (var a = 0, o = t.count(); a < o; a++)
          n[t.getRawIndex(a)].dataIndex = a
        e.filterSelf(function (s) {
          var l = i[e.getRawIndex(s)]
          return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0
        })
        for (var a = 0, o = i.length; a < o; a++) i[a].dataIndex = -1
        for (var a = 0, o = e.count(); a < o; a++)
          i[e.getRawIndex(a)].dataIndex = a
      }),
      (r.prototype.clone = function () {
        for (
          var t = new r(this._directed), e = this.nodes, n = this.edges, i = 0;
          i < e.length;
          i++
        )
          t.addNode(e[i].id, e[i].dataIndex)
        for (var i = 0; i < n.length; i++) {
          var a = n[i]
          t.addEdge(a.node1.id, a.node2.id, a.dataIndex)
        }
        return t
      }),
      r
    )
  })(),
  su = (function () {
    function r(t, e) {
      ;(this.inEdges = []),
        (this.outEdges = []),
        (this.edges = []),
        (this.dataIndex = -1),
        (this.id = t ?? ''),
        (this.dataIndex = e ?? -1)
    }
    return (
      (r.prototype.degree = function () {
        return this.edges.length
      }),
      (r.prototype.inDegree = function () {
        return this.inEdges.length
      }),
      (r.prototype.outDegree = function () {
        return this.outEdges.length
      }),
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostGraph,
            n = e.data.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getAdjacentDataIndices = function () {
        for (
          var t = {
              edge: [],
              node: [],
            },
            e = 0;
          e < this.edges.length;
          e++
        ) {
          var n = this.edges[e]
          n.dataIndex < 0 ||
            (t.edge.push(n.dataIndex),
            t.node.push(n.node1.dataIndex, n.node2.dataIndex))
        }
        return t
      }),
      (r.prototype.getTrajectoryDataIndices = function () {
        for (var t = Pt(), e = Pt(), n = 0; n < this.edges.length; n++) {
          var i = this.edges[n]
          if (!(i.dataIndex < 0)) {
            t.set(i.dataIndex, !0)
            for (var a = [i.node1], o = [i.node2], s = 0; s < a.length; ) {
              var l = a[s]
              s++, e.set(l.dataIndex, !0)
              for (var u = 0; u < l.inEdges.length; u++)
                t.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1)
            }
            for (s = 0; s < o.length; ) {
              var c = o[s]
              s++, e.set(c.dataIndex, !0)
              for (var u = 0; u < c.outEdges.length; u++)
                t.set(c.outEdges[u].dataIndex, !0), o.push(c.outEdges[u].node2)
            }
          }
        }
        return {
          edge: t.keys(),
          node: e.keys(),
        }
      }),
      r
    )
  })(),
  x4 = (function () {
    function r(t, e, n) {
      ;(this.dataIndex = -1),
        (this.node1 = t),
        (this.node2 = e),
        (this.dataIndex = n ?? -1)
    }
    return (
      (r.prototype.getModel = function (t) {
        if (!(this.dataIndex < 0)) {
          var e = this.hostGraph,
            n = e.edgeData.getItemModel(this.dataIndex)
          return n.getModel(t)
        }
      }),
      (r.prototype.getAdjacentDataIndices = function () {
        return {
          edge: [this.dataIndex],
          node: [this.node1.dataIndex, this.node2.dataIndex],
        }
      }),
      (r.prototype.getTrajectoryDataIndices = function () {
        var t = Pt(),
          e = Pt()
        t.set(this.dataIndex, !0)
        for (var n = [this.node1], i = [this.node2], a = 0; a < n.length; ) {
          var o = n[a]
          a++, e.set(o.dataIndex, !0)
          for (var s = 0; s < o.inEdges.length; s++)
            t.set(o.inEdges[s].dataIndex, !0), n.push(o.inEdges[s].node1)
        }
        for (a = 0; a < i.length; ) {
          var l = i[a]
          a++, e.set(l.dataIndex, !0)
          for (var s = 0; s < l.outEdges.length; s++)
            t.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2)
        }
        return {
          edge: t.keys(),
          node: e.keys(),
        }
      }),
      r
    )
  })()
function S4(r, t) {
  return {
    getValue: function (e) {
      var n = this[r][t]
      return n.getStore().get(n.getDimensionIndex(e || 'value'), this.dataIndex)
    },
    setVisual: function (e, n) {
      this.dataIndex >= 0 && this[r][t].setItemVisual(this.dataIndex, e, n)
    },
    getVisual: function (e) {
      return this[r][t].getItemVisual(this.dataIndex, e)
    },
    setLayout: function (e, n) {
      this.dataIndex >= 0 && this[r][t].setItemLayout(this.dataIndex, e, n)
    },
    getLayout: function () {
      return this[r][t].getItemLayout(this.dataIndex)
    },
    getGraphicEl: function () {
      return this[r][t].getItemGraphicEl(this.dataIndex)
    },
    getRawIndex: function () {
      return this[r][t].getRawIndex(this.dataIndex)
    },
  }
}
In(su, S4('hostGraph', 'data'))
In(x4, S4('hostGraph', 'edgeData'))
const Zft = qft
function A4(r, t, e, n, i) {
  for (var a = new Zft(n), o = 0; o < r.length; o++)
    a.addNode(nr(r[o].id, r[o].name, o), o)
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o],
      h = c.source,
      f = c.target
    a.addEdge(h, f, u) &&
      (l.push(c), s.push(nr(Un(c.id, null), h + ' > ' + f)), u++)
  }
  var d = e.get('coordinateSystem'),
    p
  if (d === 'cartesian2d' || d === 'polar') p = as(r, e)
  else {
    var g = Av.get(d),
      v = g ? g.dimensions || [] : []
    re(v, 'value') < 0 && v.concat(['value'])
    var m = wv(r, {
      coordDimensions: v,
      encodeDefine: e.getEncode(),
    }).dimensions
    ;(p = new Vr(m, e)), p.initData(r)
  }
  var y = new Vr(['value'], e)
  return (
    y.initData(l, s),
    i && i(p, y),
    r4({
      mainData: p,
      struct: a,
      structAttr: 'graph',
      datas: {
        node: p,
        edge: y,
      },
      datasAttr: {
        node: 'data',
        edge: 'edgeData',
      },
    }),
    a.update(),
    a
  )
}
var Kft = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments)
      var n = this
      function i() {
        return n._categoriesData
      }
      ;(this.legendVisualProvider = new Pv(i, i)),
        this.fillDataTextStyle(e.edges || e.links),
        this._updateCategoriesData()
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments),
        this.fillDataTextStyle(e.edges || e.links),
        this._updateCategoriesData()
    }),
    (t.prototype.mergeDefaultAndTheme = function (e) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments),
        Xu(e, 'edgeLabel', ['show'])
    }),
    (t.prototype.getInitialData = function (e, n) {
      var i = e.edges || e.links || [],
        a = e.data || e.nodes || [],
        o = this
      if (a && i) {
        Pft(this)
        var s = A4(a, i, this, !0, l)
        return (
          R(
            s.edges,
            function (u) {
              Rft(u.node1, u.node2, this, u.dataIndex)
            },
            this,
          ),
          s.data
        )
      }
      function l(u, c) {
        u.wrapMethod('getItemModel', function (p) {
          var g = o._categoriesModels,
            v = p.getShallow('category'),
            m = g[v]
          return m && ((m.parentModel = p.parentModel), (p.parentModel = m)), p
        })
        var h = qe.prototype.getModel
        function f(p, g) {
          var v = h.call(this, p, g)
          return (v.resolveParentPath = d), v
        }
        c.wrapMethod('getItemModel', function (p) {
          return (p.resolveParentPath = d), (p.getModel = f), p
        })
        function d(p) {
          if (p && (p[0] === 'label' || p[1] === 'label')) {
            var g = p.slice()
            return (
              p[0] === 'label'
                ? (g[0] = 'edgeLabel')
                : p[1] === 'label' && (g[1] = 'edgeLabel'),
              g
            )
          }
          return p
        }
      }
    }),
    (t.prototype.getGraph = function () {
      return this.getData().graph
    }),
    (t.prototype.getEdgeData = function () {
      return this.getGraph().edgeData
    }),
    (t.prototype.getCategoriesData = function () {
      return this._categoriesData
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      if (i === 'edge') {
        var a = this.getData(),
          o = this.getDataParams(e, i),
          s = a.graph.getEdgeByIndex(e),
          l = a.getName(s.node1.dataIndex),
          u = a.getName(s.node2.dataIndex),
          c = []
        return (
          l != null && c.push(l),
          u != null && c.push(u),
          Kn('nameValue', {
            name: c.join(' > '),
            value: o.value,
            noValue: o.value == null,
          })
        )
      }
      var h = U5({
        series: this,
        dataIndex: e,
        multipleSeries: n,
      })
      return h
    }),
    (t.prototype._updateCategoriesData = function () {
      var e = st(this.option.categories || [], function (i) {
          return i.value != null
            ? i
            : Q(
                {
                  value: 0,
                },
                i,
              )
        }),
        n = new Vr(['value'], this)
      n.initData(e),
        (this._categoriesData = n),
        (this._categoriesModels = n.mapArray(function (i) {
          return n.getItemModel(i)
        }))
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.isAnimationEnabled = function () {
      return (
        r.prototype.isAnimationEnabled.call(this) &&
        !(
          this.get('layout') === 'force' &&
          this.get(['force', 'layoutAnimation'])
        )
      )
    }),
    (t.type = 'series.graph'),
    (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      legendHoverLink: !0,
      layout: null,
      circular: {
        rotateLabel: !1,
      },
      force: {
        initLayout: null,
        repulsion: [0, 50],
        gravity: 0.1,
        friction: 0.6,
        edgeLength: 30,
        layoutAnimation: !0,
      },
      left: 'center',
      top: 'center',
      symbol: 'circle',
      symbolSize: 10,
      edgeSymbol: ['none', 'none'],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: 'middle',
        distance: 5,
      },
      draggable: !1,
      roam: !1,
      center: null,
      zoom: 1,
      nodeScaleRatio: 0.6,
      label: {
        show: !1,
        formatter: '{b}',
      },
      itemStyle: {},
      lineStyle: {
        color: '#aaa',
        width: 1,
        opacity: 0.5,
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const jft = Kft
var Jft = {
  type: 'graphRoam',
  event: 'graphRoam',
  update: 'none',
}
function Qft(r) {
  r.registerChartView($ft),
    r.registerSeriesModel(jft),
    r.registerProcessor(Tft),
    r.registerVisual(Cft),
    r.registerVisual(Eft),
    r.registerLayout(Ift),
    r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, Nft),
    r.registerLayout(Bft),
    r.registerCoordinateSystem('graphView', {
      dimensions: Iv.dimensions,
      create: zft,
    }),
    r.registerAction(
      {
        type: 'focusNodeAdjacency',
        event: 'focusNodeAdjacency',
        update: 'series:focusNodeAdjacency',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'unfocusNodeAdjacency',
        event: 'unfocusNodeAdjacency',
        update: 'series:unfocusNodeAdjacency',
      },
      wn,
    ),
    r.registerAction(Jft, function (t, e, n) {
      e.eachComponent(
        {
          mainType: 'series',
          query: t,
        },
        function (i) {
          var a = i.coordinateSystem,
            o = HC(a, t, void 0, n)
          i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom)
        },
      )
    })
}
var tdt = (function () {
    function r() {
      ;(this.angle = 0),
        (this.width = 10),
        (this.r = 10),
        (this.x = 0),
        (this.y = 0)
    }
    return r
  })(),
  edt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'pointer'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new tdt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = Math.cos,
          a = Math.sin,
          o = n.r,
          s = n.width,
          l = n.angle,
          u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2),
          c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2)
        ;(l = n.angle - Math.PI / 2),
          e.moveTo(u, c),
          e.lineTo(n.x + i(l) * s, n.y + a(l) * s),
          e.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o),
          e.lineTo(n.x - i(l) * s, n.y - a(l) * s),
          e.lineTo(u, c)
      }),
      t
    )
  })(oe)
const ndt = edt
function rdt(r, t) {
  var e = r.get('center'),
    n = t.getWidth(),
    i = t.getHeight(),
    a = Math.min(n, i),
    o = _t(e[0], t.getWidth()),
    s = _t(e[1], t.getHeight()),
    l = _t(r.get('radius'), a / 2)
  return {
    cx: o,
    cy: s,
    r: l,
  }
}
function _m(r, t) {
  var e = r == null ? '' : r + ''
  return t && (bt(t) ? (e = t.replace('{value}', e)) : Nt(t) && (e = t(r))), e
}
var idt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      this.group.removeAll()
      var a = e.get(['axisLine', 'lineStyle', 'color']),
        o = rdt(e, i)
      this._renderMain(e, n, i, a, o), (this._data = e.getData())
    }),
    (t.prototype.dispose = function () {}),
    (t.prototype._renderMain = function (e, n, i, a, o) {
      var s = this.group,
        l = e.get('clockwise'),
        u = (-e.get('startAngle') / 180) * Math.PI,
        c = (-e.get('endAngle') / 180) * Math.PI,
        h = e.getModel('axisLine'),
        f = h.get('roundCap'),
        d = f ? h0 : oi,
        p = h.get('show'),
        g = h.getModel('lineStyle'),
        v = g.get('width'),
        m = [u, c]
      HT(m, !l), (u = m[0]), (c = m[1])
      for (var y = c - u, _ = u, x = [], A = 0; p && A < a.length; A++) {
        var S = Math.min(Math.max(a[A][0], 0), 1)
        c = u + y * S
        var b = new d({
          shape: {
            startAngle: _,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r,
          },
          silent: !0,
        })
        b.setStyle({
          fill: a[A][1],
        }),
          b.setStyle(g.getLineStyle(['color', 'width'])),
          x.push(b),
          (_ = c)
      }
      x.reverse(),
        R(x, function (w) {
          return s.add(w)
        })
      var T = function (w) {
        if (w <= 0) return a[0][1]
        var M
        for (M = 0; M < a.length; M++)
          if (a[M][0] >= w && (M === 0 ? 0 : a[M - 1][0]) < w) return a[M][1]
        return a[M - 1][1]
      }
      this._renderTicks(e, n, i, T, o, u, c, l, v),
        this._renderTitleAndDetail(e, n, i, T, o),
        this._renderAnchor(e, o),
        this._renderPointer(e, n, i, T, o, u, c, l, v)
    }),
    (t.prototype._renderTicks = function (e, n, i, a, o, s, l, u, c) {
      for (
        var h = this.group,
          f = o.cx,
          d = o.cy,
          p = o.r,
          g = +e.get('min'),
          v = +e.get('max'),
          m = e.getModel('splitLine'),
          y = e.getModel('axisTick'),
          _ = e.getModel('axisLabel'),
          x = e.get('splitNumber'),
          A = y.get('splitNumber'),
          S = _t(m.get('length'), p),
          b = _t(y.get('length'), p),
          T = s,
          w = (l - s) / x,
          M = w / A,
          C = m.getModel('lineStyle').getLineStyle(),
          E = y.getModel('lineStyle').getLineStyle(),
          D = m.get('distance'),
          P,
          L,
          I = 0;
        I <= x;
        I++
      ) {
        if (((P = Math.cos(T)), (L = Math.sin(T)), m.get('show'))) {
          var F = D ? D + c : c,
            k = new rr({
              shape: {
                x1: P * (p - F) + f,
                y1: L * (p - F) + d,
                x2: P * (p - S - F) + f,
                y2: L * (p - S - F) + d,
              },
              style: C,
              silent: !0,
            })
          C.stroke === 'auto' &&
            k.setStyle({
              stroke: a(I / x),
            }),
            h.add(k)
        }
        if (_.get('show')) {
          var F = _.get('distance') + D,
            V = _m(mn((I / x) * (v - g) + g), _.get('formatter')),
            H = a(I / x),
            Y = P * (p - S - F) + f,
            K = L * (p - S - F) + d,
            ut = _.get('rotate'),
            W = 0
          ut === 'radial'
            ? ((W = -T + 2 * Math.PI), W > Math.PI / 2 && (W += Math.PI))
            : ut === 'tangential'
            ? (W = -T - Math.PI / 2)
            : be(ut) && (W = (ut * Math.PI) / 180),
            W === 0
              ? h.add(
                  new Ae({
                    style: $e(
                      _,
                      {
                        text: V,
                        x: Y,
                        y: K,
                        verticalAlign:
                          L < -0.8 ? 'top' : L > 0.8 ? 'bottom' : 'middle',
                        align: P < -0.4 ? 'left' : P > 0.4 ? 'right' : 'center',
                      },
                      {
                        inheritColor: H,
                      },
                    ),
                    silent: !0,
                  }),
                )
              : h.add(
                  new Ae({
                    style: $e(
                      _,
                      {
                        text: V,
                        x: Y,
                        y: K,
                        verticalAlign: 'middle',
                        align: 'center',
                      },
                      {
                        inheritColor: H,
                      },
                    ),
                    silent: !0,
                    originX: Y,
                    originY: K,
                    rotation: W,
                  }),
                )
        }
        if (y.get('show') && I !== x) {
          var F = y.get('distance')
          F = F ? F + c : c
          for (var Z = 0; Z <= A; Z++) {
            ;(P = Math.cos(T)), (L = Math.sin(T))
            var ft = new rr({
              shape: {
                x1: P * (p - F) + f,
                y1: L * (p - F) + d,
                x2: P * (p - b - F) + f,
                y2: L * (p - b - F) + d,
              },
              silent: !0,
              style: E,
            })
            E.stroke === 'auto' &&
              ft.setStyle({
                stroke: a((I + Z / A) / x),
              }),
              h.add(ft),
              (T += M)
          }
          T -= M
        } else T += w
      }
    }),
    (t.prototype._renderPointer = function (e, n, i, a, o, s, l, u, c) {
      var h = this.group,
        f = this._data,
        d = this._progressEls,
        p = [],
        g = e.get(['pointer', 'show']),
        v = e.getModel('progress'),
        m = v.get('show'),
        y = e.getData(),
        _ = y.mapDimension('value'),
        x = +e.get('min'),
        A = +e.get('max'),
        S = [x, A],
        b = [s, l]
      function T(M, C) {
        var E = y.getItemModel(M),
          D = E.getModel('pointer'),
          P = _t(D.get('width'), o.r),
          L = _t(D.get('length'), o.r),
          I = e.get(['pointer', 'icon']),
          F = D.get('offsetCenter'),
          k = _t(F[0], o.r),
          V = _t(F[1], o.r),
          H = D.get('keepAspect'),
          Y
        return (
          I
            ? (Y = Rn(I, k - P / 2, V - L, P, L, null, H))
            : (Y = new ndt({
                shape: {
                  angle: -Math.PI / 2,
                  width: P,
                  r: L,
                  x: k,
                  y: V,
                },
              })),
          (Y.rotation = -(C + Math.PI / 2)),
          (Y.x = o.cx),
          (Y.y = o.cy),
          Y
        )
      }
      function w(M, C) {
        var E = v.get('roundCap'),
          D = E ? h0 : oi,
          P = v.get('overlap'),
          L = P ? v.get('width') : c / y.count(),
          I = P ? o.r - L : o.r - (M + 1) * L,
          F = P ? o.r : o.r - M * L,
          k = new D({
            shape: {
              startAngle: s,
              endAngle: C,
              cx: o.cx,
              cy: o.cy,
              clockwise: u,
              r0: I,
              r: F,
            },
          })
        return P && (k.z2 = A - (y.get(_, M) % A)), k
      }
      ;(m || g) &&
        (y
          .diff(f)
          .add(function (M) {
            var C = y.get(_, M)
            if (g) {
              var E = T(M, s)
              Je(
                E,
                {
                  rotation: -(
                    (isNaN(+C) ? b[0] : Re(C, S, b, !0)) +
                    Math.PI / 2
                  ),
                },
                e,
              ),
                h.add(E),
                y.setItemGraphicEl(M, E)
            }
            if (m) {
              var D = w(M, s),
                P = v.get('clip')
              Je(
                D,
                {
                  shape: {
                    endAngle: Re(C, S, b, P),
                  },
                },
                e,
              ),
                h.add(D),
                ew(e.seriesIndex, y.dataType, M, D),
                (p[M] = D)
            }
          })
          .update(function (M, C) {
            var E = y.get(_, M)
            if (g) {
              var D = f.getItemGraphicEl(C),
                P = D ? D.rotation : s,
                L = T(M, P)
              ;(L.rotation = P),
                we(
                  L,
                  {
                    rotation: -(
                      (isNaN(+E) ? b[0] : Re(E, S, b, !0)) +
                      Math.PI / 2
                    ),
                  },
                  e,
                ),
                h.add(L),
                y.setItemGraphicEl(M, L)
            }
            if (m) {
              var I = d[C],
                F = I ? I.shape.endAngle : s,
                k = w(M, F),
                V = v.get('clip')
              we(
                k,
                {
                  shape: {
                    endAngle: Re(E, S, b, V),
                  },
                },
                e,
              ),
                h.add(k),
                ew(e.seriesIndex, y.dataType, M, k),
                (p[M] = k)
            }
          })
          .execute(),
        y.each(function (M) {
          var C = y.getItemModel(M),
            E = C.getModel('emphasis'),
            D = E.get('focus'),
            P = E.get('blurScope'),
            L = E.get('disabled')
          if (g) {
            var I = y.getItemGraphicEl(M),
              F = y.getItemVisual(M, 'style'),
              k = F.fill
            if (I instanceof yr) {
              var V = I.style
              I.useStyle(
                Q(
                  {
                    image: V.image,
                    x: V.x,
                    y: V.y,
                    width: V.width,
                    height: V.height,
                  },
                  F,
                ),
              )
            } else I.useStyle(F), I.type !== 'pointer' && I.setColor(k)
            I.setStyle(C.getModel(['pointer', 'itemStyle']).getItemStyle()),
              I.style.fill === 'auto' &&
                I.setStyle('fill', a(Re(y.get(_, M), S, [0, 1], !0))),
              (I.z2EmphasisLift = 0),
              gr(I, C),
              fn(I, D, P, L)
          }
          if (m) {
            var H = p[M]
            H.useStyle(y.getItemVisual(M, 'style')),
              H.setStyle(C.getModel(['progress', 'itemStyle']).getItemStyle()),
              (H.z2EmphasisLift = 0),
              gr(H, C),
              fn(H, D, P, L)
          }
        }),
        (this._progressEls = p))
    }),
    (t.prototype._renderAnchor = function (e, n) {
      var i = e.getModel('anchor'),
        a = i.get('show')
      if (a) {
        var o = i.get('size'),
          s = i.get('icon'),
          l = i.get('offsetCenter'),
          u = i.get('keepAspect'),
          c = Rn(
            s,
            n.cx - o / 2 + _t(l[0], n.r),
            n.cy - o / 2 + _t(l[1], n.r),
            o,
            o,
            null,
            u,
          )
        ;(c.z2 = i.get('showAbove') ? 1 : 0),
          c.setStyle(i.getModel('itemStyle').getItemStyle()),
          this.group.add(c)
      }
    }),
    (t.prototype._renderTitleAndDetail = function (e, n, i, a, o) {
      var s = this,
        l = e.getData(),
        u = l.mapDimension('value'),
        c = +e.get('min'),
        h = +e.get('max'),
        f = new Ht(),
        d = [],
        p = [],
        g = e.isAnimationEnabled(),
        v = e.get(['pointer', 'showAbove'])
      l
        .diff(this._data)
        .add(function (m) {
          ;(d[m] = new Ae({
            silent: !0,
          })),
            (p[m] = new Ae({
              silent: !0,
            }))
        })
        .update(function (m, y) {
          ;(d[m] = s._titleEls[y]), (p[m] = s._detailEls[y])
        })
        .execute(),
        l.each(function (m) {
          var y = l.getItemModel(m),
            _ = l.get(u, m),
            x = new Ht(),
            A = a(Re(_, [c, h], [0, 1], !0)),
            S = y.getModel('title')
          if (S.get('show')) {
            var b = S.get('offsetCenter'),
              T = o.cx + _t(b[0], o.r),
              w = o.cy + _t(b[1], o.r),
              M = d[m]
            M.attr({
              z2: v ? 0 : 2,
              style: $e(
                S,
                {
                  x: T,
                  y: w,
                  text: l.getName(m),
                  align: 'center',
                  verticalAlign: 'middle',
                },
                {
                  inheritColor: A,
                },
              ),
            }),
              x.add(M)
          }
          var C = y.getModel('detail')
          if (C.get('show')) {
            var E = C.get('offsetCenter'),
              D = o.cx + _t(E[0], o.r),
              P = o.cy + _t(E[1], o.r),
              L = _t(C.get('width'), o.r),
              I = _t(C.get('height'), o.r),
              F = e.get(['progress', 'show'])
                ? l.getItemVisual(m, 'style').fill
                : A,
              M = p[m],
              k = C.get('formatter')
            M.attr({
              z2: v ? 0 : 2,
              style: $e(
                C,
                {
                  x: D,
                  y: P,
                  text: _m(_, k),
                  width: isNaN(L) ? null : L,
                  height: isNaN(I) ? null : I,
                  align: 'center',
                  verticalAlign: 'middle',
                },
                {
                  inheritColor: F,
                },
              ),
            }),
              GU(
                M,
                {
                  normal: C,
                },
                _,
                function (H) {
                  return _m(H, k)
                },
              ),
              g &&
                HU(M, m, l, e, {
                  getFormattedLabel: function (H, Y, K, ut, W, Z) {
                    return _m(Z ? Z.interpolatedValue : _, k)
                  },
                }),
              x.add(M)
          }
          f.add(x)
        }),
        this.group.add(f),
        (this._titleEls = d),
        (this._detailEls = p)
    }),
    (t.type = 'gauge'),
    t
  )
})(Ze)
const adt = idt
var odt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.visualStyleAccessPath = 'itemStyle'), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, ['value'])
    }),
    (t.type = 'series.gauge'),
    (t.defaultOption = {
      z: 2,
      colorBy: 'data',
      center: ['50%', '50%'],
      legendHoverLink: !0,
      radius: '75%',
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      min: 0,
      max: 100,
      splitNumber: 10,
      axisLine: {
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, '#E6EBF8']],
          width: 10,
        },
      },
      progress: {
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0,
      },
      splitLine: {
        show: !0,
        length: 10,
        distance: 10,
        lineStyle: {
          color: '#63677A',
          width: 3,
          type: 'solid',
        },
      },
      axisTick: {
        show: !0,
        splitNumber: 5,
        length: 6,
        distance: 10,
        lineStyle: {
          color: '#63677A',
          width: 1,
          type: 'solid',
        },
      },
      axisLabel: {
        show: !0,
        distance: 15,
        color: '#464646',
        fontSize: 12,
        rotate: 0,
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: '60%',
        width: 6,
        keepAspect: !1,
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: 'circle',
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: '#fff',
          borderWidth: 0,
          borderColor: '#5470c6',
        },
      },
      title: {
        show: !0,
        offsetCenter: [0, '20%'],
        color: '#464646',
        fontSize: 16,
        valueAnimation: !1,
      },
      detail: {
        show: !0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        borderColor: '#ccc',
        width: 100,
        height: null,
        padding: [5, 10],
        offsetCenter: [0, '40%'],
        color: '#464646',
        fontSize: 30,
        fontWeight: 'bold',
        lineHeight: 30,
        valueAnimation: !1,
      },
    }),
    t
  )
})(rn)
const sdt = odt
function ldt(r) {
  r.registerChartView(adt), r.registerSeriesModel(sdt)
}
var udt = ['itemStyle', 'opacity'],
  cdt = (function (r) {
    X(t, r)
    function t(e, n) {
      var i = r.call(this) || this,
        a = i,
        o = new li(),
        s = new Ae()
      return (
        a.setTextContent(s), i.setTextGuideLine(o), i.updateData(e, n, !0), i
      )
    }
    return (
      (t.prototype.updateData = function (e, n, i) {
        var a = this,
          o = e.hostModel,
          s = e.getItemModel(n),
          l = e.getItemLayout(n),
          u = s.getModel('emphasis'),
          c = s.get(udt)
        ;(c = c ?? 1),
          i || Ca(a),
          a.useStyle(e.getItemVisual(n, 'style')),
          (a.style.lineJoin = 'round'),
          i
            ? (a.setShape({
                points: l.points,
              }),
              (a.style.opacity = 0),
              Je(
                a,
                {
                  style: {
                    opacity: c,
                  },
                },
                o,
                n,
              ))
            : we(
                a,
                {
                  style: {
                    opacity: c,
                  },
                  shape: {
                    points: l.points,
                  },
                },
                o,
                n,
              ),
          gr(a, s),
          this._updateLabel(e, n),
          fn(this, u.get('focus'), u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e, n) {
        var i = this,
          a = this.getTextGuideLine(),
          o = i.getTextContent(),
          s = e.hostModel,
          l = e.getItemModel(n),
          u = e.getItemLayout(n),
          c = u.label,
          h = e.getItemVisual(n, 'style'),
          f = h.fill
        mr(
          o,
          Zn(l),
          {
            labelFetcher: e.hostModel,
            labelDataIndex: n,
            defaultOpacity: h.opacity,
            defaultText: e.getName(n),
          },
          {
            normal: {
              align: c.textAlign,
              verticalAlign: c.verticalAlign,
            },
          },
        ),
          i.setTextConfig({
            local: !0,
            inside: !!c.inside,
            insideStroke: f,
            outsideFill: f,
          })
        var d = c.linePoints
        a.setShape({
          points: d,
        }),
          (i.textGuideLineConfig = {
            anchor: d ? new Qt(d[0][0], d[0][1]) : null,
          }),
          we(
            o,
            {
              style: {
                x: c.x,
                y: c.y,
              },
            },
            s,
            n,
          ),
          o.attr({
            rotation: c.rotation,
            originX: c.x,
            originY: c.y,
            z2: 10,
          }),
          LC(i, PC(l), {
            stroke: f,
          })
      }),
      t
    )
  })(si),
  hdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.ignoreLabelLineUpdate = !0), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = this._data,
          s = this.group
        a
          .diff(o)
          .add(function (l) {
            var u = new cdt(a, l)
            a.setItemGraphicEl(l, u), s.add(u)
          })
          .update(function (l, u) {
            var c = o.getItemGraphicEl(u)
            c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c)
          })
          .remove(function (l) {
            var u = o.getItemGraphicEl(l)
            Xp(u, e, l)
          })
          .execute(),
          (this._data = a)
      }),
      (t.prototype.remove = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'funnel'),
      t
    )
  })(Ze)
const fdt = hdt
var ddt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e) {
      r.prototype.init.apply(this, arguments),
        (this.legendVisualProvider = new Pv(
          Tt(this.getData, this),
          Tt(this.getRawData, this),
        )),
        this._defaultLabelLine(e)
    }),
    (t.prototype.getInitialData = function (e, n) {
      return Rf(this, {
        coordDimensions: ['value'],
        encodeDefaulter: Zt(lC, this),
      })
    }),
    (t.prototype._defaultLabelLine = function (e) {
      Xu(e, 'labelLine', ['show'])
      var n = e.labelLine,
        i = e.emphasis.labelLine
      ;(n.show = n.show && e.label.show),
        (i.show = i.show && e.emphasis.label.show)
    }),
    (t.prototype.getDataParams = function (e) {
      var n = this.getData(),
        i = r.prototype.getDataParams.call(this, e),
        a = n.mapDimension('value'),
        o = n.getSum(a)
      return (
        (i.percent = o ? +((n.get(a, e) / o) * 100).toFixed(2) : 0),
        i.$vars.push('percent'),
        i
      )
    }),
    (t.type = 'series.funnel'),
    (t.defaultOption = {
      z: 2,
      legendHoverLink: !0,
      colorBy: 'data',
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      minSize: '0%',
      maxSize: '100%',
      sort: 'descending',
      orient: 'vertical',
      gap: 0,
      funnelAlign: 'center',
      label: {
        show: !0,
        position: 'outer',
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          width: 1,
        },
      },
      itemStyle: {
        borderColor: '#fff',
        borderWidth: 1,
      },
      emphasis: {
        label: {
          show: !0,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const pdt = ddt
function vdt(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function gdt(r, t) {
  for (
    var e = r.mapDimension('value'),
      n = r.mapArray(e, function (l) {
        return l
      }),
      i = [],
      a = t === 'ascending',
      o = 0,
      s = r.count();
    o < s;
    o++
  )
    i[o] = o
  return (
    Nt(t)
      ? i.sort(t)
      : t !== 'none' &&
        i.sort(function (l, u) {
          return a ? n[l] - n[u] : n[u] - n[l]
        }),
    i
  )
}
function mdt(r) {
  var t = r.hostModel,
    e = t.get('orient')
  r.each(function (n) {
    var i = r.getItemModel(n),
      a = i.getModel('label'),
      o = a.get('position'),
      s = i.getModel('labelLine'),
      l = r.getItemLayout(n),
      u = l.points,
      c =
        o === 'inner' ||
        o === 'inside' ||
        o === 'center' ||
        o === 'insideLeft' ||
        o === 'insideRight',
      h,
      f,
      d,
      p
    if (c)
      o === 'insideLeft'
        ? ((f = (u[0][0] + u[3][0]) / 2 + 5),
          (d = (u[0][1] + u[3][1]) / 2),
          (h = 'left'))
        : o === 'insideRight'
        ? ((f = (u[1][0] + u[2][0]) / 2 - 5),
          (d = (u[1][1] + u[2][1]) / 2),
          (h = 'right'))
        : ((f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4),
          (d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4),
          (h = 'center')),
        (p = [
          [f, d],
          [f, d],
        ])
    else {
      var g = void 0,
        v = void 0,
        m = void 0,
        y = void 0,
        _ = s.get('length')
      o === 'left'
        ? ((g = (u[3][0] + u[0][0]) / 2),
          (v = (u[3][1] + u[0][1]) / 2),
          (m = g - _),
          (f = m - 5),
          (h = 'right'))
        : o === 'right'
        ? ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          (m = g + _),
          (f = m + 5),
          (h = 'left'))
        : o === 'top'
        ? ((g = (u[3][0] + u[0][0]) / 2),
          (v = (u[3][1] + u[0][1]) / 2),
          (y = v - _),
          (d = y - 5),
          (h = 'center'))
        : o === 'bottom'
        ? ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          (y = v + _),
          (d = y + 5),
          (h = 'center'))
        : o === 'rightTop'
        ? ((g = e === 'horizontal' ? u[3][0] : u[1][0]),
          (v = e === 'horizontal' ? u[3][1] : u[1][1]),
          e === 'horizontal'
            ? ((y = v - _), (d = y - 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'top')))
        : o === 'rightBottom'
        ? ((g = u[2][0]),
          (v = u[2][1]),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'bottom')))
        : o === 'leftTop'
        ? ((g = u[0][0]),
          (v = e === 'horizontal' ? u[0][1] : u[1][1]),
          e === 'horizontal'
            ? ((y = v - _), (d = y - 5), (h = 'center'))
            : ((m = g - _), (f = m - 5), (h = 'right')))
        : o === 'leftBottom'
        ? ((g = e === 'horizontal' ? u[1][0] : u[3][0]),
          (v = e === 'horizontal' ? u[1][1] : u[2][1]),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g - _), (f = m - 5), (h = 'right')))
        : ((g = (u[1][0] + u[2][0]) / 2),
          (v = (u[1][1] + u[2][1]) / 2),
          e === 'horizontal'
            ? ((y = v + _), (d = y + 5), (h = 'center'))
            : ((m = g + _), (f = m + 5), (h = 'left'))),
        e === 'horizontal' ? ((m = g), (f = m)) : ((y = v), (d = y)),
        (p = [
          [g, v],
          [m, y],
        ])
    }
    l.label = {
      linePoints: p,
      x: f,
      y: d,
      verticalAlign: 'middle',
      textAlign: h,
      inside: c,
    }
  })
}
function ydt(r, t) {
  r.eachSeriesByType('funnel', function (e) {
    var n = e.getData(),
      i = n.mapDimension('value'),
      a = e.get('sort'),
      o = vdt(e, t),
      s = e.get('orient'),
      l = o.width,
      u = o.height,
      c = gdt(n, a),
      h = o.x,
      f = o.y,
      d =
        s === 'horizontal'
          ? [_t(e.get('minSize'), u), _t(e.get('maxSize'), u)]
          : [_t(e.get('minSize'), l), _t(e.get('maxSize'), l)],
      p = n.getDataExtent(i),
      g = e.get('min'),
      v = e.get('max')
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1])
    var m = e.get('funnelAlign'),
      y = e.get('gap'),
      _ = s === 'horizontal' ? l : u,
      x = (_ - y * (n.count() - 1)) / n.count(),
      A = function (P, L) {
        if (s === 'horizontal') {
          var I = n.get(i, P) || 0,
            F = Re(I, [g, v], d, !0),
            k = void 0
          switch (m) {
            case 'top':
              k = f
              break
            case 'center':
              k = f + (u - F) / 2
              break
            case 'bottom':
              k = f + (u - F)
              break
          }
          return [
            [L, k],
            [L, k + F],
          ]
        }
        var V = n.get(i, P) || 0,
          H = Re(V, [g, v], d, !0),
          Y
        switch (m) {
          case 'left':
            Y = h
            break
          case 'center':
            Y = h + (l - H) / 2
            break
          case 'right':
            Y = h + l - H
            break
        }
        return [
          [Y, L],
          [Y + H, L],
        ]
      }
    a === 'ascending' &&
      ((x = -x),
      (y = -y),
      s === 'horizontal' ? (h += l) : (f += u),
      (c = c.reverse()))
    for (var S = 0; S < c.length; S++) {
      var b = c[S],
        T = c[S + 1],
        w = n.getItemModel(b)
      if (s === 'horizontal') {
        var M = w.get(['itemStyle', 'width'])
        M == null ? (M = x) : ((M = _t(M, l)), a === 'ascending' && (M = -M))
        var C = A(b, h),
          E = A(T, h + M)
        ;(h += M + y),
          n.setItemLayout(b, {
            points: C.concat(E.slice().reverse()),
          })
      } else {
        var D = w.get(['itemStyle', 'height'])
        D == null ? (D = x) : ((D = _t(D, u)), a === 'ascending' && (D = -D))
        var C = A(b, f),
          E = A(T, f + D)
        ;(f += D + y),
          n.setItemLayout(b, {
            points: C.concat(E.slice().reverse()),
          })
      }
    }
    mdt(n)
  })
}
function _dt(r) {
  r.registerChartView(fdt),
    r.registerSeriesModel(pdt),
    r.registerLayout(ydt),
    r.registerProcessor(Lv('funnel'))
}
var xdt = 0.3,
  Sdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type), (e._dataGroup = new Ht()), (e._initialized = !1), e
      )
    }
    return (
      (t.prototype.init = function () {
        this.group.add(this._dataGroup)
      }),
      (t.prototype.render = function (e, n, i, a) {
        this._progressiveEls = null
        var o = this._dataGroup,
          s = e.getData(),
          l = this._data,
          u = e.coordinateSystem,
          c = u.dimensions,
          h = nN(e)
        s.diff(l).add(f).update(d).remove(p).execute()
        function f(v) {
          var m = eN(s, o, v, c, u)
          ES(m, s, v, h)
        }
        function d(v, m) {
          var y = l.getItemGraphicEl(m),
            _ = b4(s, v, c, u)
          s.setItemGraphicEl(v, y),
            we(
              y,
              {
                shape: {
                  points: _,
                },
              },
              e,
              v,
            ),
            Ca(y),
            ES(y, s, v, h)
        }
        function p(v) {
          var m = l.getItemGraphicEl(v)
          o.remove(m)
        }
        if (!this._initialized) {
          this._initialized = !0
          var g = Adt(u, e, function () {
            setTimeout(function () {
              o.removeClipPath()
            })
          })
          o.setClipPath(g)
        }
        this._data = s
      }),
      (t.prototype.incrementalPrepareRender = function (e, n, i) {
        ;(this._initialized = !0),
          (this._data = null),
          this._dataGroup.removeAll()
      }),
      (t.prototype.incrementalRender = function (e, n, i) {
        for (
          var a = n.getData(),
            o = n.coordinateSystem,
            s = o.dimensions,
            l = nN(n),
            u = (this._progressiveEls = []),
            c = e.start;
          c < e.end;
          c++
        ) {
          var h = eN(a, this._dataGroup, c, s, o)
          ;(h.incremental = !0), ES(h, a, c, l), u.push(h)
        }
      }),
      (t.prototype.remove = function () {
        this._dataGroup && this._dataGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'parallel'),
      t
    )
  })(Ze)
function Adt(r, t, e) {
  var n = r.model,
    i = r.getRect(),
    a = new ge({
      shape: {
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height,
      },
    }),
    o = n.get('layout') === 'horizontal' ? 'width' : 'height'
  return (
    a.setShape(o, 0),
    Je(
      a,
      {
        shape: {
          width: i.width,
          height: i.height,
        },
      },
      t,
      e,
    ),
    a
  )
}
function b4(r, t, e, n) {
  for (var i = [], a = 0; a < e.length; a++) {
    var o = e[a],
      s = r.get(r.mapDimension(o), t)
    bdt(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o))
  }
  return i
}
function eN(r, t, e, n, i) {
  var a = b4(r, e, n, i),
    o = new li({
      shape: {
        points: a,
      },
      z2: 10,
    })
  return t.add(o), r.setItemGraphicEl(e, o), o
}
function nN(r) {
  var t = r.get('smooth', !0)
  return (
    t === !0 && (t = xdt),
    (t = Jo(t)),
    kp(t) && (t = 0),
    {
      smooth: t,
    }
  )
}
function ES(r, t, e, n) {
  r.useStyle(t.getItemVisual(e, 'style')),
    (r.style.fill = null),
    r.setShape('smooth', n.smooth)
  var i = t.getItemModel(e),
    a = i.getModel('emphasis')
  gr(r, i, 'lineStyle'),
    fn(r, a.get('focus'), a.get('blurScope'), a.get('disabled'))
}
function bdt(r, t) {
  return t === 'category' ? r == null : r == null || isNaN(r)
}
const wdt = Sdt
var Mdt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.visualStyleAccessPath = 'lineStyle'),
      (e.visualDrawType = 'stroke'),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: Tt(Tdt, null, this),
      })
    }),
    (t.prototype.getRawIndicesByActiveState = function (e) {
      var n = this.coordinateSystem,
        i = this.getData(),
        a = []
      return (
        n.eachActiveState(i, function (o, s) {
          e === o && a.push(i.getRawIndex(s))
        }),
        a
      )
    }),
    (t.type = 'series.parallel'),
    (t.dependencies = ['parallel']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'parallel',
      parallelIndex: 0,
      label: {
        show: !1,
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: 'solid',
      },
      emphasis: {
        label: {
          show: !1,
        },
      },
      progressive: 500,
      smooth: !1,
      animationEasing: 'linear',
    }),
    t
  )
})(rn)
function Tdt(r) {
  var t = r.ecModel.getComponent('parallel', r.get('parallelIndex'))
  if (t) {
    var e = {}
    return (
      R(t.dimensions, function (n) {
        var i = Cdt(n)
        e[n] = i
      }),
      e
    )
  }
}
function Cdt(r) {
  return +r.replace('dim', '')
}
const Edt = Mdt
var Ddt = ['lineStyle', 'opacity'],
  Ldt = {
    seriesType: 'parallel',
    reset: function (r, t) {
      var e = r.coordinateSystem,
        n = {
          normal: r.get(['lineStyle', 'opacity']),
          active: r.get('activeOpacity'),
          inactive: r.get('inactiveOpacity'),
        }
      return {
        progress: function (i, a) {
          e.eachActiveState(
            a,
            function (o, s) {
              var l = n[o]
              if (o === 'normal' && a.hasItemOption) {
                var u = a.getItemModel(s).get(Ddt, !0)
                u != null && (l = u)
              }
              var c = a.ensureUniqueItemVisual(s, 'style')
              c.opacity = l
            },
            i.start,
            i.end,
          )
        },
      }
    },
  }
const Pdt = Ldt
function Rdt(r) {
  Idt(r), Odt(r)
}
function Idt(r) {
  if (!r.parallel) {
    var t = !1
    R(r.series, function (e) {
      e && e.type === 'parallel' && (t = !0)
    }),
      t && (r.parallel = [{}])
  }
}
function Odt(r) {
  var t = ke(r.parallelAxis)
  R(t, function (e) {
    if (Ut(e)) {
      var n = e.parallelIndex || 0,
        i = ke(r.parallel)[n]
      i && i.parallelAxisDefault && te(e, i.parallelAxisDefault, !1)
    }
  })
}
var Ndt = 5,
  kdt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        ;(this._model = e),
          (this._api = i),
          this._handlers ||
            ((this._handlers = {}),
            R(
              Bdt,
              function (a, o) {
                i.getZr().on(o, (this._handlers[o] = Tt(a, this)))
              },
              this,
            )),
          Df(
            this,
            '_throttledDispatchExpand',
            e.get('axisExpandRate'),
            'fixRate',
          )
      }),
      (t.prototype.dispose = function (e, n) {
        Zp(this, '_throttledDispatchExpand'),
          R(this._handlers, function (i, a) {
            n.getZr().off(a, i)
          }),
          (this._handlers = null)
      }),
      (t.prototype._throttledDispatchExpand = function (e) {
        this._dispatchExpand(e)
      }),
      (t.prototype._dispatchExpand = function (e) {
        e &&
          this._api.dispatchAction(
            Q(
              {
                type: 'parallelAxisExpand',
              },
              e,
            ),
          )
      }),
      (t.type = 'parallel'),
      t
    )
  })(dn),
  Bdt = {
    mousedown: function (r) {
      DS(this, 'click') && (this._mouseDownPoint = [r.offsetX, r.offsetY])
    },
    mouseup: function (r) {
      var t = this._mouseDownPoint
      if (DS(this, 'click') && t) {
        var e = [r.offsetX, r.offsetY],
          n = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2)
        if (n > Ndt) return
        var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([
          r.offsetX,
          r.offsetY,
        ])
        i.behavior !== 'none' &&
          this._dispatchExpand({
            axisExpandWindow: i.axisExpandWindow,
          })
      }
      this._mouseDownPoint = null
    },
    mousemove: function (r) {
      if (!(this._mouseDownPoint || !DS(this, 'mousemove'))) {
        var t = this._model,
          e = t.coordinateSystem.getSlidedAxisExpandWindow([
            r.offsetX,
            r.offsetY,
          ]),
          n = e.behavior
        n === 'jump' &&
          this._throttledDispatchExpand.debounceNextCall(
            t.get('axisExpandDebounce'),
          ),
          this._throttledDispatchExpand(
            n === 'none'
              ? null
              : {
                  axisExpandWindow: e.axisExpandWindow,
                  animation:
                    n === 'jump'
                      ? null
                      : {
                          duration: 0,
                        },
                },
          )
      }
    },
  }
function DS(r, t) {
  var e = r._model
  return e.get('axisExpandable') && e.get('axisExpandTriggerOn') === t
}
const Fdt = kdt
var zdt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function () {
      r.prototype.init.apply(this, arguments), this.mergeOption({})
    }),
    (t.prototype.mergeOption = function (e) {
      var n = this.option
      e && te(n, e, !0), this._initDimensions()
    }),
    (t.prototype.contains = function (e, n) {
      var i = e.get('parallelIndex')
      return i != null && n.getComponent('parallel', i) === this
    }),
    (t.prototype.setAxisExpand = function (e) {
      R(
        [
          'axisExpandable',
          'axisExpandCenter',
          'axisExpandCount',
          'axisExpandWidth',
          'axisExpandWindow',
        ],
        function (n) {
          e.hasOwnProperty(n) && (this.option[n] = e[n])
        },
        this,
      )
    }),
    (t.prototype._initDimensions = function () {
      var e = (this.dimensions = []),
        n = (this.parallelAxisIndex = []),
        i = Ne(
          this.ecModel.queryComponents({
            mainType: 'parallelAxis',
          }),
          function (a) {
            return (a.get('parallelIndex') || 0) === this.componentIndex
          },
          this,
        )
      R(i, function (a) {
        e.push('dim' + a.get('dim')), n.push(a.componentIndex)
      })
    }),
    (t.type = 'parallel'),
    (t.dependencies = ['parallelAxis']),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      layout: 'horizontal',
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: 'click',
      parallelAxisDefault: null,
    }),
    t
  )
})(xe)
const Udt = zdt
var Vdt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o) {
    var s = r.call(this, e, n, i) || this
    return (s.type = a || 'value'), (s.axisIndex = o), s
  }
  return (
    (t.prototype.isHorizontal = function () {
      return this.coordinateSystem.getModel().get('layout') !== 'horizontal'
    }),
    t
  )
})(Ra)
const Gdt = Vdt
function lc(r, t, e, n, i, a) {
  r = r || 0
  var o = e[1] - e[0]
  if (
    (i != null && (i = th(i, [0, o])),
    a != null && (a = Math.max(a, i ?? 0)),
    n === 'all')
  ) {
    var s = Math.abs(t[1] - t[0])
    ;(s = th(s, [0, o])), (i = a = th(s, [i, a])), (n = 0)
  }
  ;(t[0] = th(t[0], e)), (t[1] = th(t[1], e))
  var l = LS(t, n)
  t[n] += r
  var u = i || 0,
    c = e.slice()
  l.sign < 0 ? (c[0] += u) : (c[1] -= u), (t[n] = th(t[n], c))
  var h
  return (
    (h = LS(t, n)),
    i != null &&
      (h.sign !== l.sign || h.span < i) &&
      (t[1 - n] = t[n] + l.sign * i),
    (h = LS(t, n)),
    a != null && h.span > a && (t[1 - n] = t[n] + h.sign * a),
    t
  )
}
function LS(r, t) {
  var e = r[t] - r[1 - t]
  return {
    span: Math.abs(e),
    sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1,
  }
}
function th(r, t) {
  return Math.min(
    t[1] != null ? t[1] : 1 / 0,
    Math.max(t[0] != null ? t[0] : -1 / 0, r),
  )
}
var PS = R,
  w4 = Math.min,
  M4 = Math.max,
  rN = Math.floor,
  Hdt = Math.ceil,
  iN = mn,
  Wdt = Math.PI,
  Xdt = (function () {
    function r(t, e, n) {
      ;(this.type = 'parallel'),
        (this._axesMap = Pt()),
        (this._axesLayout = {}),
        (this.dimensions = t.dimensions),
        (this._model = t),
        this._init(t, e, n)
    }
    return (
      (r.prototype._init = function (t, e, n) {
        var i = t.dimensions,
          a = t.parallelAxisIndex
        PS(
          i,
          function (o, s) {
            var l = a[s],
              u = e.getComponent('parallelAxis', l),
              c = this._axesMap.set(
                o,
                new Gdt(o, w_(u), [0, 0], u.get('type'), l),
              ),
              h = c.type === 'category'
            ;(c.onBand = h && u.get('boundaryGap')),
              (c.inverse = u.get('inverse')),
              (u.axis = c),
              (c.model = u),
              (c.coordinateSystem = u.coordinateSystem = this)
          },
          this,
        )
      }),
      (r.prototype.update = function (t, e) {
        this._updateAxesFromSeries(this._model, t)
      }),
      (r.prototype.containPoint = function (t) {
        var e = this._makeLayoutInfo(),
          n = e.axisBase,
          i = e.layoutBase,
          a = e.pixelDimIndex,
          o = t[1 - a],
          s = t[a]
        return (
          o >= n && o <= n + e.axisLength && s >= i && s <= i + e.layoutLength
        )
      }),
      (r.prototype.getModel = function () {
        return this._model
      }),
      (r.prototype._updateAxesFromSeries = function (t, e) {
        e.eachSeries(function (n) {
          if (t.contains(n, e)) {
            var i = n.getData()
            PS(
              this.dimensions,
              function (a) {
                var o = this._axesMap.get(a)
                o.scale.unionExtentFromData(i, i.mapDimension(a)),
                  af(o.scale, o.model)
              },
              this,
            )
          }
        }, this)
      }),
      (r.prototype.resize = function (t, e) {
        ;(this._rect = Vn(t.getBoxLayoutParams(), {
          width: e.getWidth(),
          height: e.getHeight(),
        })),
          this._layoutAxes()
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype._makeLayoutInfo = function () {
        var t = this._model,
          e = this._rect,
          n = ['x', 'y'],
          i = ['width', 'height'],
          a = t.get('layout'),
          o = a === 'horizontal' ? 0 : 1,
          s = e[i[o]],
          l = [0, s],
          u = this.dimensions.length,
          c = xm(t.get('axisExpandWidth'), l),
          h = xm(t.get('axisExpandCount') || 0, [0, u]),
          f =
            t.get('axisExpandable') &&
            u > 3 &&
            u > h &&
            h > 1 &&
            c > 0 &&
            s > 0,
          d = t.get('axisExpandWindow'),
          p
        if (d) (p = xm(d[1] - d[0], l)), (d[1] = d[0] + p)
        else {
          p = xm(c * (h - 1), l)
          var g = t.get('axisExpandCenter') || rN(u / 2)
          ;(d = [c * g - p / 2]), (d[1] = d[0] + p)
        }
        var v = (s - p) / (u - h)
        v < 3 && (v = 0)
        var m = [rN(iN(d[0] / c, 1)) + 1, Hdt(iN(d[1] / c, 1)) - 1],
          y = (v / c) * d[0]
        return {
          layout: a,
          pixelDimIndex: o,
          layoutBase: e[n[o]],
          layoutLength: s,
          axisBase: e[n[1 - o]],
          axisLength: e[i[1 - o]],
          axisExpandable: f,
          axisExpandWidth: c,
          axisCollapseWidth: v,
          axisExpandWindow: d,
          axisCount: u,
          winInnerIndices: m,
          axisExpandWindow0Pos: y,
        }
      }),
      (r.prototype._layoutAxes = function () {
        var t = this._rect,
          e = this._axesMap,
          n = this.dimensions,
          i = this._makeLayoutInfo(),
          a = i.layout
        e.each(function (o) {
          var s = [0, i.axisLength],
            l = o.inverse ? 1 : 0
          o.setExtent(s[l], s[1 - l])
        }),
          PS(
            n,
            function (o, s) {
              var l = (i.axisExpandable ? $dt : Ydt)(s, i),
                u = {
                  horizontal: {
                    x: l.position,
                    y: i.axisLength,
                  },
                  vertical: {
                    x: 0,
                    y: l.position,
                  },
                },
                c = {
                  horizontal: Wdt / 2,
                  vertical: 0,
                },
                h = [u[a].x + t.x, u[a].y + t.y],
                f = c[a],
                d = bi()
              ec(d, d, f),
                ho(d, d, h),
                (this._axesLayout[o] = {
                  position: h,
                  rotation: f,
                  transform: d,
                  axisNameAvailableWidth: l.axisNameAvailableWidth,
                  axisLabelShow: l.axisLabelShow,
                  nameTruncateMaxWidth: l.nameTruncateMaxWidth,
                  tickDirection: 1,
                  labelDirection: 1,
                })
            },
            this,
          )
      }),
      (r.prototype.getAxis = function (t) {
        return this._axesMap.get(t)
      }),
      (r.prototype.dataToPoint = function (t, e) {
        return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e)
      }),
      (r.prototype.eachActiveState = function (t, e, n, i) {
        n == null && (n = 0), i == null && (i = t.count())
        var a = this._axesMap,
          o = this.dimensions,
          s = [],
          l = []
        R(o, function (v) {
          s.push(t.mapDimension(v)), l.push(a.get(v).model)
        })
        for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
          var h = void 0
          if (!u) h = 'normal'
          else {
            h = 'active'
            for (var f = t.getValues(s, c), d = 0, p = o.length; d < p; d++) {
              var g = l[d].getActiveState(f[d])
              if (g === 'inactive') {
                h = 'inactive'
                break
              }
            }
          }
          e(h, c)
        }
      }),
      (r.prototype.hasAxisBrushed = function () {
        for (
          var t = this.dimensions,
            e = this._axesMap,
            n = !1,
            i = 0,
            a = t.length;
          i < a;
          i++
        )
          e.get(t[i]).model.getActiveState() !== 'normal' && (n = !0)
        return n
      }),
      (r.prototype.axisCoordToPoint = function (t, e) {
        var n = this._axesLayout[e]
        return ba([t, 0], n.transform)
      }),
      (r.prototype.getAxisLayout = function (t) {
        return Vt(this._axesLayout[t])
      }),
      (r.prototype.getSlidedAxisExpandWindow = function (t) {
        var e = this._makeLayoutInfo(),
          n = e.pixelDimIndex,
          i = e.axisExpandWindow.slice(),
          a = i[1] - i[0],
          o = [0, e.axisExpandWidth * (e.axisCount - 1)]
        if (!this.containPoint(t))
          return {
            behavior: 'none',
            axisExpandWindow: i,
          }
        var s = t[n] - e.layoutBase - e.axisExpandWindow0Pos,
          l,
          u = 'slide',
          c = e.axisCollapseWidth,
          h = this._model.get('axisExpandSlideTriggerArea'),
          f = h[0] != null
        if (c)
          f && c && s < a * h[0]
            ? ((u = 'jump'), (l = s - a * h[2]))
            : f && c && s > a * (1 - h[0])
            ? ((u = 'jump'), (l = s - a * (1 - h[2])))
            : (l = s - a * h[1]) >= 0 &&
              (l = s - a * (1 - h[1])) <= 0 &&
              (l = 0),
            (l *= e.axisExpandWidth / c),
            l ? lc(l, i, o, 'all') : (u = 'none')
        else {
          var d = i[1] - i[0],
            p = (o[1] * s) / d
          ;(i = [M4(0, p - d / 2)]),
            (i[1] = w4(o[1], i[0] + d)),
            (i[0] = i[1] - d)
        }
        return {
          axisExpandWindow: i,
          behavior: u,
        }
      }),
      r
    )
  })()
function xm(r, t) {
  return w4(M4(r, t[0]), t[1])
}
function Ydt(r, t) {
  var e = t.layoutLength / (t.axisCount - 1)
  return {
    position: e * r,
    axisNameAvailableWidth: e,
    axisLabelShow: !0,
  }
}
function $dt(r, t) {
  var e = t.layoutLength,
    n = t.axisExpandWidth,
    i = t.axisCount,
    a = t.axisCollapseWidth,
    o = t.winInnerIndices,
    s,
    l = a,
    u = !1,
    c
  return (
    r < o[0]
      ? ((s = r * a), (c = a))
      : r <= o[1]
      ? ((s = t.axisExpandWindow0Pos + r * n - t.axisExpandWindow[0]),
        (l = n),
        (u = !0))
      : ((s = e - (i - 1 - r) * a), (c = a)),
    {
      position: s,
      axisNameAvailableWidth: l,
      axisLabelShow: u,
      nameTruncateMaxWidth: c,
    }
  )
}
const qdt = Xdt
function Zdt(r, t) {
  var e = []
  return (
    r.eachComponent('parallel', function (n, i) {
      var a = new qdt(n, r, t)
      ;(a.name = 'parallel_' + i),
        a.resize(n, t),
        (n.coordinateSystem = a),
        (a.model = n),
        e.push(a)
    }),
    r.eachSeries(function (n) {
      if (n.get('coordinateSystem') === 'parallel') {
        var i = n.getReferringComponents('parallel', Pn).models[0]
        n.coordinateSystem = i.coordinateSystem
      }
    }),
    e
  )
}
var Kdt = {
  create: Zdt,
}
const jdt = Kdt
var T4 = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.activeIntervals = []), e
  }
  return (
    (t.prototype.getAreaSelectStyle = function () {
      return $u([
        ['fill', 'color'],
        ['lineWidth', 'borderWidth'],
        ['stroke', 'borderColor'],
        ['width', 'width'],
        ['opacity', 'opacity'],
      ])(this.getModel('areaSelectStyle'))
    }),
    (t.prototype.setActiveIntervals = function (e) {
      var n = (this.activeIntervals = Vt(e))
      if (n) for (var i = n.length - 1; i >= 0; i--) Zi(n[i])
    }),
    (t.prototype.getActiveState = function (e) {
      var n = this.activeIntervals
      if (!n.length) return 'normal'
      if (e == null || isNaN(+e)) return 'inactive'
      if (n.length === 1) {
        var i = n[0]
        if (i[0] <= e && e <= i[1]) return 'active'
      } else
        for (var a = 0, o = n.length; a < o; a++)
          if (n[a][0] <= e && e <= n[a][1]) return 'active'
      return 'inactive'
    }),
    t
  )
})(xe)
In(T4, Mv)
const aN = T4
var Ku = !0,
  ov = Math.min,
  lf = Math.max,
  Jdt = Math.pow,
  Qdt = 1e4,
  tpt = 6,
  ept = 6,
  oN = 'globalPan',
  npt = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1],
  },
  rpt = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse',
  },
  sN = {
    brushStyle: {
      lineWidth: 2,
      stroke: 'rgba(210,219,238,0.3)',
      fill: '#D2DBEE',
    },
    transformable: !0,
    brushMode: 'single',
    removeOnClick: !1,
  },
  ipt = 0,
  apt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this) || this
      return (
        (n._track = []),
        (n._covers = []),
        (n._handlers = {}),
        (n._zr = e),
        (n.group = new Ht()),
        (n._uid = 'brushController_' + ipt++),
        R(
          fpt,
          function (i, a) {
            this._handlers[a] = Tt(i, this)
          },
          n,
        ),
        n
      )
    }
    return (
      (t.prototype.enableBrush = function (e) {
        return (
          this._brushType && this._doDisableBrush(),
          e.brushType && this._doEnableBrush(e),
          this
        )
      }),
      (t.prototype._doEnableBrush = function (e) {
        var n = this._zr
        this._enableGlobalPan || vct(n, oN, this._uid),
          R(this._handlers, function (i, a) {
            n.on(a, i)
          }),
          (this._brushType = e.brushType),
          (this._brushOption = te(Vt(sN), e, !0))
      }),
      (t.prototype._doDisableBrush = function () {
        var e = this._zr
        gct(e, oN, this._uid),
          R(this._handlers, function (n, i) {
            e.off(i, n)
          }),
          (this._brushType = this._brushOption = null)
      }),
      (t.prototype.setPanels = function (e) {
        if (e && e.length) {
          var n = (this._panels = {})
          R(e, function (i) {
            n[i.panelId] = Vt(i)
          })
        } else this._panels = null
        return this
      }),
      (t.prototype.mount = function (e) {
        ;(e = e || {}), (this._enableGlobalPan = e.enableGlobalPan)
        var n = this.group
        return (
          this._zr.add(n),
          n.attr({
            x: e.x || 0,
            y: e.y || 0,
            rotation: e.rotation || 0,
            scaleX: e.scaleX || 1,
            scaleY: e.scaleY || 1,
          }),
          (this._transform = n.getLocalTransform()),
          this
        )
      }),
      (t.prototype.updateCovers = function (e) {
        e = st(e, function (f) {
          return te(Vt(sN), f, !0)
        })
        var n = '\0-brush-index-',
          i = this._covers,
          a = (this._covers = []),
          o = this,
          s = this._creatingCover
        return new es(i, e, u, l).add(c).update(c).remove(h).execute(), this
        function l(f, d) {
          return (f.id != null ? f.id : n + d) + '-' + f.brushType
        }
        function u(f, d) {
          return l(f.__brushOption, d)
        }
        function c(f, d) {
          var p = e[f]
          if (d != null && i[d] === s) a[f] = i[d]
          else {
            var g = (a[f] =
              d != null ? ((i[d].__brushOption = p), i[d]) : E4(o, C4(o, p)))
            tE(o, g)
          }
        }
        function h(f) {
          i[f] !== s && o.group.remove(i[f])
        }
      }),
      (t.prototype.unmount = function () {
        return this.enableBrush(!1), Ww(this), this._zr.remove(this.group), this
      }),
      (t.prototype.dispose = function () {
        this.unmount(), this.off()
      }),
      t
    )
  })(ra)
function C4(r, t) {
  var e = L_[t.brushType].createCover(r, t)
  return (e.__brushOption = t), L4(e, t), r.group.add(e), e
}
function E4(r, t) {
  var e = eE(t)
  return e.endCreating && (e.endCreating(r, t), L4(t, t.__brushOption)), t
}
function D4(r, t) {
  var e = t.__brushOption
  eE(t).updateCoverShape(r, t, e.range, e)
}
function L4(r, t) {
  var e = t.z
  e == null && (e = Qdt),
    r.traverse(function (n) {
      ;(n.z = e), (n.z2 = e)
    })
}
function tE(r, t) {
  eE(t).updateCommon(r, t), D4(r, t)
}
function eE(r) {
  return L_[r.__brushOption.brushType]
}
function nE(r, t, e) {
  var n = r._panels
  if (!n) return Ku
  var i,
    a = r._transform
  return (
    R(n, function (o) {
      o.isTargetByCursor(t, e, a) && (i = o)
    }),
    i
  )
}
function P4(r, t) {
  var e = r._panels
  if (!e) return Ku
  var n = t.__brushOption.panelId
  return n != null ? e[n] : Ku
}
function Ww(r) {
  var t = r._covers,
    e = t.length
  return (
    R(
      t,
      function (n) {
        r.group.remove(n)
      },
      r,
    ),
    (t.length = 0),
    !!e
  )
}
function ju(r, t) {
  var e = st(r._covers, function (n) {
    var i = n.__brushOption,
      a = Vt(i.range)
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: a,
    }
  })
  r.trigger('brush', {
    areas: e,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick,
  })
}
function opt(r) {
  var t = r._track
  if (!t.length) return !1
  var e = t[t.length - 1],
    n = t[0],
    i = e[0] - n[0],
    a = e[1] - n[1],
    o = Jdt(i * i + a * a, 0.5)
  return o > tpt
}
function R4(r) {
  var t = r.length - 1
  return t < 0 && (t = 0), [r[0], r[t]]
}
function I4(r, t, e, n) {
  var i = new Ht()
  return (
    i.add(
      new ge({
        name: 'main',
        style: rE(e),
        silent: !0,
        draggable: !0,
        cursor: 'move',
        drift: Zt(lN, r, t, i, ['n', 's', 'w', 'e']),
        ondragend: Zt(ju, t, {
          isEnd: !0,
        }),
      }),
    ),
    R(n, function (a) {
      i.add(
        new ge({
          name: a.join(''),
          style: {
            opacity: 0,
          },
          draggable: !0,
          silent: !0,
          invisible: !0,
          drift: Zt(lN, r, t, i, a),
          ondragend: Zt(ju, t, {
            isEnd: !0,
          }),
        }),
      )
    }),
    i
  )
}
function O4(r, t, e, n) {
  var i = n.brushStyle.lineWidth || 0,
    a = lf(i, ept),
    o = e[0][0],
    s = e[1][0],
    l = o - i / 2,
    u = s - i / 2,
    c = e[0][1],
    h = e[1][1],
    f = c - a + i / 2,
    d = h - a + i / 2,
    p = c - o,
    g = h - s,
    v = p + i,
    m = g + i
  Lo(r, t, 'main', o, s, p, g),
    n.transformable &&
      (Lo(r, t, 'w', l, u, a, m),
      Lo(r, t, 'e', f, u, a, m),
      Lo(r, t, 'n', l, u, v, a),
      Lo(r, t, 's', l, d, v, a),
      Lo(r, t, 'nw', l, u, a, a),
      Lo(r, t, 'ne', f, u, a, a),
      Lo(r, t, 'sw', l, d, a, a),
      Lo(r, t, 'se', f, d, a, a))
}
function Xw(r, t) {
  var e = t.__brushOption,
    n = e.transformable,
    i = t.childAt(0)
  i.useStyle(rE(e)),
    i.attr({
      silent: !n,
      cursor: n ? 'move' : 'default',
    }),
    R(
      [
        ['w'],
        ['e'],
        ['n'],
        ['s'],
        ['s', 'e'],
        ['s', 'w'],
        ['n', 'e'],
        ['n', 'w'],
      ],
      function (a) {
        var o = t.childOfName(a.join('')),
          s = a.length === 1 ? Yw(r, a[0]) : lpt(r, a)
        o &&
          o.attr({
            silent: !n,
            invisible: !n,
            cursor: n ? rpt[s] + '-resize' : null,
          })
      },
    )
}
function Lo(r, t, e, n, i, a, o) {
  var s = t.childOfName(e)
  s &&
    s.setShape(
      cpt(
        iE(r, t, [
          [n, i],
          [n + a, i + o],
        ]),
      ),
    )
}
function rE(r) {
  return zt(
    {
      strokeNoScale: !0,
    },
    r.brushStyle,
  )
}
function N4(r, t, e, n) {
  var i = [ov(r, e), ov(t, n)],
    a = [lf(r, e), lf(t, n)]
  return [
    [i[0], a[0]],
    [i[1], a[1]],
  ]
}
function spt(r) {
  return Nu(r.group)
}
function Yw(r, t) {
  var e = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom',
    },
    n = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's',
    },
    i = s_(e[t], spt(r))
  return n[i]
}
function lpt(r, t) {
  var e = [Yw(r, t[0]), Yw(r, t[1])]
  return (e[0] === 'e' || e[0] === 'w') && e.reverse(), e.join('')
}
function lN(r, t, e, n, i, a) {
  var o = e.__brushOption,
    s = r.toRectRange(o.range),
    l = k4(t, i, a)
  R(n, function (u) {
    var c = npt[u]
    s[c[0]][c[1]] += l[c[0]]
  }),
    (o.range = r.fromRectRange(N4(s[0][0], s[1][0], s[0][1], s[1][1]))),
    tE(t, e),
    ju(t, {
      isEnd: !1,
    })
}
function upt(r, t, e, n) {
  var i = t.__brushOption.range,
    a = k4(r, e, n)
  R(i, function (o) {
    ;(o[0] += a[0]), (o[1] += a[1])
  }),
    tE(r, t),
    ju(r, {
      isEnd: !1,
    })
}
function k4(r, t, e) {
  var n = r.group,
    i = n.transformCoordToLocal(t, e),
    a = n.transformCoordToLocal(0, 0)
  return [i[0] - a[0], i[1] - a[1]]
}
function iE(r, t, e) {
  var n = P4(r, t)
  return n && n !== Ku ? n.clipPath(e, r._transform) : Vt(e)
}
function cpt(r) {
  var t = ov(r[0][0], r[1][0]),
    e = ov(r[0][1], r[1][1]),
    n = lf(r[0][0], r[1][0]),
    i = lf(r[0][1], r[1][1])
  return {
    x: t,
    y: e,
    width: n - t,
    height: i - e,
  }
}
function hpt(r, t, e) {
  if (!(!r._brushType || dpt(r, t.offsetX, t.offsetY))) {
    var n = r._zr,
      i = r._covers,
      a = nE(r, t, e)
    if (!r._dragging)
      for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption
        if (
          a &&
          (a === Ku || s.panelId === a.panelId) &&
          L_[s.brushType].contain(i[o], e[0], e[1])
        )
          return
      }
    a && n.setCursorStyle('crosshair')
  }
}
function $w(r) {
  var t = r.event
  t.preventDefault && t.preventDefault()
}
function qw(r, t, e) {
  return r.childOfName('main').contain(t, e)
}
function B4(r, t, e, n) {
  var i = r._creatingCover,
    a = r._creatingPanel,
    o = r._brushOption,
    s
  if ((r._track.push(e.slice()), opt(r) || i)) {
    if (a && !i) {
      o.brushMode === 'single' && Ww(r)
      var l = Vt(o)
      ;(l.brushType = uN(l.brushType, a)),
        (l.panelId = a === Ku ? null : a.panelId),
        (i = r._creatingCover = C4(r, l)),
        r._covers.push(i)
    }
    if (i) {
      var u = L_[uN(r._brushType, a)],
        c = i.__brushOption
      ;(c.range = u.getCreatingRange(iE(r, i, r._track))),
        n && (E4(r, i), u.updateCommon(r, i)),
        D4(r, i),
        (s = {
          isEnd: n,
        })
    }
  } else
    n &&
      o.brushMode === 'single' &&
      o.removeOnClick &&
      nE(r, t, e) &&
      Ww(r) &&
      (s = {
        isEnd: n,
        removeOnClick: !0,
      })
  return s
}
function uN(r, t) {
  return r === 'auto' ? t.defaultBrushType : r
}
var fpt = {
  mousedown: function (r) {
    if (this._dragging) cN(this, r)
    else if (!r.target || !r.target.draggable) {
      $w(r)
      var t = this.group.transformCoordToLocal(r.offsetX, r.offsetY)
      this._creatingCover = null
      var e = (this._creatingPanel = nE(this, r, t))
      e && ((this._dragging = !0), (this._track = [t.slice()]))
    }
  },
  mousemove: function (r) {
    var t = r.offsetX,
      e = r.offsetY,
      n = this.group.transformCoordToLocal(t, e)
    if ((hpt(this, r, n), this._dragging)) {
      $w(r)
      var i = B4(this, r, n, !1)
      i && ju(this, i)
    }
  },
  mouseup: function (r) {
    cN(this, r)
  },
}
function cN(r, t) {
  if (r._dragging) {
    $w(t)
    var e = t.offsetX,
      n = t.offsetY,
      i = r.group.transformCoordToLocal(e, n),
      a = B4(r, t, i, !0)
    ;(r._dragging = !1),
      (r._track = []),
      (r._creatingCover = null),
      a && ju(r, a)
  }
}
function dpt(r, t, e) {
  var n = r._zr
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight()
}
var L_ = {
  lineX: hN(0),
  lineY: hN(1),
  rect: {
    createCover: function (r, t) {
      function e(n) {
        return n
      }
      return I4(
        {
          toRectRange: e,
          fromRectRange: e,
        },
        r,
        t,
        [
          ['w'],
          ['e'],
          ['n'],
          ['s'],
          ['s', 'e'],
          ['s', 'w'],
          ['n', 'e'],
          ['n', 'w'],
        ],
      )
    },
    getCreatingRange: function (r) {
      var t = R4(r)
      return N4(t[1][0], t[1][1], t[0][0], t[0][1])
    },
    updateCoverShape: function (r, t, e, n) {
      O4(r, t, e, n)
    },
    updateCommon: Xw,
    contain: qw,
  },
  polygon: {
    createCover: function (r, t) {
      var e = new Ht()
      return (
        e.add(
          new li({
            name: 'main',
            style: rE(t),
            silent: !0,
          }),
        ),
        e
      )
    },
    getCreatingRange: function (r) {
      return r
    },
    endCreating: function (r, t) {
      t.remove(t.childAt(0)),
        t.add(
          new si({
            name: 'main',
            draggable: !0,
            drift: Zt(upt, r, t),
            ondragend: Zt(ju, r, {
              isEnd: !0,
            }),
          }),
        )
    },
    updateCoverShape: function (r, t, e, n) {
      t.childAt(0).setShape({
        points: iE(r, t, e),
      })
    },
    updateCommon: Xw,
    contain: qw,
  },
}
function hN(r) {
  return {
    createCover: function (t, e) {
      return I4(
        {
          toRectRange: function (n) {
            var i = [n, [0, 100]]
            return r && i.reverse(), i
          },
          fromRectRange: function (n) {
            return n[r]
          },
        },
        t,
        e,
        [
          [['w'], ['e']],
          [['n'], ['s']],
        ][r],
      )
    },
    getCreatingRange: function (t) {
      var e = R4(t),
        n = ov(e[0][r], e[1][r]),
        i = lf(e[0][r], e[1][r])
      return [n, i]
    },
    updateCoverShape: function (t, e, n, i) {
      var a,
        o = P4(t, e)
      if (o !== Ku && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r)
      else {
        var s = t._zr
        a = [0, [s.getWidth(), s.getHeight()][1 - r]]
      }
      var l = [n, a]
      r && l.reverse(), O4(t, e, l, i)
    },
    updateCommon: Xw,
    contain: qw,
  }
}
const aE = apt
function F4(r) {
  return (
    (r = oE(r)),
    function (t) {
      return zU(t, r)
    }
  )
}
function z4(r, t) {
  return (
    (r = oE(r)),
    function (e) {
      var n = t ?? e,
        i = n ? r.width : r.height,
        a = n ? r.x : r.y
      return [a, a + (i || 0)]
    }
  )
}
function U4(r, t, e) {
  var n = oE(r)
  return function (i, a) {
    return n.contain(a[0], a[1]) && !T_(i, t, e)
  }
}
function oE(r) {
  return ee.create(r)
}
var ppt = ['axisLine', 'axisTickLabel', 'axisName'],
  vpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        r.prototype.init.apply(this, arguments),
          (this._brushController = new aE(n.getZr())).on(
            'brush',
            Tt(this._onBrush, this),
          )
      }),
      (t.prototype.render = function (e, n, i, a) {
        if (!gpt(e, n, a)) {
          ;(this.axisModel = e), (this.api = i), this.group.removeAll()
          var o = this._axisGroup
          if (
            ((this._axisGroup = new Ht()),
            this.group.add(this._axisGroup),
            !!e.get('show'))
          ) {
            var s = ypt(e, n),
              l = s.coordinateSystem,
              u = e.getAreaSelectStyle(),
              c = u.width,
              h = e.axis.dim,
              f = l.getAxisLayout(h),
              d = Q(
                {
                  strokeContainThreshold: c,
                },
                f,
              ),
              p = new ns(e, d)
            R(ppt, p.add, p),
              this._axisGroup.add(p.getGroup()),
              this._refreshBrushController(d, u, e, s, c, i),
              xv(o, this._axisGroup, e)
          }
        }
      }),
      (t.prototype._refreshBrushController = function (e, n, i, a, o, s) {
        var l = i.axis.getExtent(),
          u = l[1] - l[0],
          c = Math.min(30, Math.abs(u) * 0.1),
          h = ee.create({
            x: l[0],
            y: -o / 2,
            width: u,
            height: o,
          })
        ;(h.x -= c),
          (h.width += 2 * c),
          this._brushController
            .mount({
              enableGlobalPan: !0,
              rotation: e.rotation,
              x: e.position[0],
              y: e.position[1],
            })
            .setPanels([
              {
                panelId: 'pl',
                clipPath: F4(h),
                isTargetByCursor: U4(h, s, a),
                getLinearBrushOtherExtent: z4(h, 0),
              },
            ])
            .enableBrush({
              brushType: 'lineX',
              brushStyle: n,
              removeOnClick: !0,
            })
            .updateCovers(mpt(i))
      }),
      (t.prototype._onBrush = function (e) {
        var n = e.areas,
          i = this.axisModel,
          a = i.axis,
          o = st(n, function (s) {
            return [
              a.coordToData(s.range[0], !0),
              a.coordToData(s.range[1], !0),
            ]
          })
        ;(!i.option.realtime === e.isEnd || e.removeOnClick) &&
          this.api.dispatchAction({
            type: 'axisAreaSelect',
            parallelAxisId: i.id,
            intervals: o,
          })
      }),
      (t.prototype.dispose = function () {
        this._brushController.dispose()
      }),
      (t.type = 'parallelAxis'),
      t
    )
  })(dn)
function gpt(r, t, e) {
  return (
    e &&
    e.type === 'axisAreaSelect' &&
    t.findComponents({
      mainType: 'parallelAxis',
      query: e,
    })[0] === r
  )
}
function mpt(r) {
  var t = r.axis
  return st(r.activeIntervals, function (e) {
    return {
      brushType: 'lineX',
      panelId: 'pl',
      range: [t.dataToCoord(e[0], !0), t.dataToCoord(e[1], !0)],
    }
  })
}
function ypt(r, t) {
  return t.getComponent('parallel', r.get('parallelIndex'))
}
const _pt = vpt
var xpt = {
  type: 'axisAreaSelect',
  event: 'axisAreaSelected',
}
function Spt(r) {
  r.registerAction(xpt, function (t, e) {
    e.eachComponent(
      {
        mainType: 'parallelAxis',
        query: t,
      },
      function (n) {
        n.axis.model.setActiveIntervals(t.intervals)
      },
    )
  }),
    r.registerAction('parallelAxisExpand', function (t, e) {
      e.eachComponent(
        {
          mainType: 'parallel',
          query: t,
        },
        function (n) {
          n.setAxisExpand(t)
        },
      )
    })
}
var Apt = {
  type: 'value',
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: 'rgba(160,197,232)',
    color: 'rgba(160,197,232)',
    opacity: 0.3,
  },
  realtime: !0,
  z: 10,
}
function V4(r) {
  r.registerComponentView(Fdt),
    r.registerComponentModel(Udt),
    r.registerCoordinateSystem('parallel', jdt),
    r.registerPreprocessor(Rdt),
    r.registerComponentModel(aN),
    r.registerComponentView(_pt),
    sf(r, 'parallel', aN, Apt),
    Spt(r)
}
function bpt(r) {
  ie(V4),
    r.registerChartView(wdt),
    r.registerSeriesModel(Edt),
    r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Pdt)
}
var wpt = (function () {
    function r() {
      ;(this.x1 = 0),
        (this.y1 = 0),
        (this.x2 = 0),
        (this.y2 = 0),
        (this.cpx1 = 0),
        (this.cpy1 = 0),
        (this.cpx2 = 0),
        (this.cpy2 = 0),
        (this.extent = 0)
    }
    return r
  })(),
  Mpt = (function (r) {
    X(t, r)
    function t(e) {
      return r.call(this, e) || this
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new wpt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.extent
        e.moveTo(n.x1, n.y1),
          e.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2),
          n.orient === 'vertical'
            ? (e.lineTo(n.x2 + i, n.y2),
              e.bezierCurveTo(
                n.cpx2 + i,
                n.cpy2,
                n.cpx1 + i,
                n.cpy1,
                n.x1 + i,
                n.y1,
              ))
            : (e.lineTo(n.x2, n.y2 + i),
              e.bezierCurveTo(
                n.cpx2,
                n.cpy2 + i,
                n.cpx1,
                n.cpy1 + i,
                n.x1,
                n.y1 + i,
              )),
          e.closePath()
      }),
      (t.prototype.highlight = function () {
        Qo(this)
      }),
      (t.prototype.downplay = function () {
        ts(this)
      }),
      t
    )
  })(oe),
  Tpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._focusAdjacencyDisabled = !1), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this,
          o = e.getGraph(),
          s = this.group,
          l = e.layoutInfo,
          u = l.width,
          c = l.height,
          h = e.getData(),
          f = e.getData('edge'),
          d = e.get('orient')
        ;(this._model = e),
          s.removeAll(),
          (s.x = l.x),
          (s.y = l.y),
          o.eachEdge(function (p) {
            var g = new Mpt(),
              v = Wt(g)
            ;(v.dataIndex = p.dataIndex),
              (v.seriesIndex = e.seriesIndex),
              (v.dataType = 'edge')
            var m = p.getModel(),
              y = m.getModel('lineStyle'),
              _ = y.get('curveness'),
              x = p.node1.getLayout(),
              A = p.node1.getModel(),
              S = A.get('localX'),
              b = A.get('localY'),
              T = p.node2.getLayout(),
              w = p.node2.getModel(),
              M = w.get('localX'),
              C = w.get('localY'),
              E = p.getLayout(),
              D,
              P,
              L,
              I,
              F,
              k,
              V,
              H
            ;(g.shape.extent = Math.max(1, E.dy)),
              (g.shape.orient = d),
              d === 'vertical'
                ? ((D = (S != null ? S * u : x.x) + E.sy),
                  (P = (b != null ? b * c : x.y) + x.dy),
                  (L = (M != null ? M * u : T.x) + E.ty),
                  (I = C != null ? C * c : T.y),
                  (F = D),
                  (k = P * (1 - _) + I * _),
                  (V = L),
                  (H = P * _ + I * (1 - _)))
                : ((D = (S != null ? S * u : x.x) + x.dx),
                  (P = (b != null ? b * c : x.y) + E.sy),
                  (L = M != null ? M * u : T.x),
                  (I = (C != null ? C * c : T.y) + E.ty),
                  (F = D * (1 - _) + L * _),
                  (k = P),
                  (V = D * _ + L * (1 - _)),
                  (H = I)),
              g.setShape({
                x1: D,
                y1: P,
                x2: L,
                y2: I,
                cpx1: F,
                cpy1: k,
                cpx2: V,
                cpy2: H,
              }),
              g.useStyle(y.getItemStyle()),
              fN(g.style, d, p)
            var Y = '' + m.get('value'),
              K = Zn(m, 'edgeLabel')
            mr(g, K, {
              labelFetcher: {
                getFormattedLabel: function (Z, ft, lt, ct, At, gt) {
                  return e.getFormattedLabel(
                    Z,
                    ft,
                    'edge',
                    ct,
                    ao(At, K.normal && K.normal.get('formatter'), Y),
                    gt,
                  )
                },
              },
              labelDataIndex: p.dataIndex,
              defaultText: Y,
            }),
              g.setTextConfig({
                position: 'inside',
              })
            var ut = m.getModel('emphasis')
            gr(g, m, 'lineStyle', function (Z) {
              var ft = Z.getItemStyle()
              return fN(ft, d, p), ft
            }),
              s.add(g),
              f.setItemGraphicEl(p.dataIndex, g)
            var W = ut.get('focus')
            fn(
              g,
              W === 'adjacency'
                ? p.getAdjacentDataIndices()
                : W === 'trajectory'
                ? p.getTrajectoryDataIndices()
                : W,
              ut.get('blurScope'),
              ut.get('disabled'),
            )
          }),
          o.eachNode(function (p) {
            var g = p.getLayout(),
              v = p.getModel(),
              m = v.get('localX'),
              y = v.get('localY'),
              _ = v.getModel('emphasis'),
              x = v.get(['itemStyle', 'borderRadius']) || 0,
              A = new ge({
                shape: {
                  x: m != null ? m * u : g.x,
                  y: y != null ? y * c : g.y,
                  width: g.dx,
                  height: g.dy,
                  r: x,
                },
                style: v.getModel('itemStyle').getItemStyle(),
                z2: 10,
              })
            mr(A, Zn(v), {
              labelFetcher: {
                getFormattedLabel: function (b, T) {
                  return e.getFormattedLabel(b, T, 'node')
                },
              },
              labelDataIndex: p.dataIndex,
              defaultText: p.id,
            }),
              (A.disableLabelAnimation = !0),
              A.setStyle('fill', p.getVisual('color')),
              A.setStyle('decal', p.getVisual('style').decal),
              gr(A, v),
              s.add(A),
              h.setItemGraphicEl(p.dataIndex, A),
              (Wt(A).dataType = 'node')
            var S = _.get('focus')
            fn(
              A,
              S === 'adjacency'
                ? p.getAdjacentDataIndices()
                : S === 'trajectory'
                ? p.getTrajectoryDataIndices()
                : S,
              _.get('blurScope'),
              _.get('disabled'),
            )
          }),
          h.eachItemGraphicEl(function (p, g) {
            var v = h.getItemModel(g)
            v.get('draggable') &&
              ((p.drift = function (m, y) {
                ;(a._focusAdjacencyDisabled = !0),
                  (this.shape.x += m),
                  (this.shape.y += y),
                  this.dirty(),
                  i.dispatchAction({
                    type: 'dragNode',
                    seriesId: e.id,
                    dataIndex: h.getRawIndex(g),
                    localX: this.shape.x / u,
                    localY: this.shape.y / c,
                  })
              }),
              (p.ondragend = function () {
                a._focusAdjacencyDisabled = !1
              }),
              (p.draggable = !0),
              (p.cursor = 'move'))
          }),
          !this._data &&
            e.isAnimationEnabled() &&
            s.setClipPath(
              Cpt(s.getBoundingRect(), e, function () {
                s.removeClipPath()
              }),
            ),
          (this._data = e.getData())
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'sankey'),
      t
    )
  })(Ze)
function fN(r, t, e) {
  switch (r.fill) {
    case 'source':
      ;(r.fill = e.node1.getVisual('color')),
        (r.decal = e.node1.getVisual('style').decal)
      break
    case 'target':
      ;(r.fill = e.node2.getVisual('color')),
        (r.decal = e.node2.getVisual('style').decal)
      break
    case 'gradient':
      var n = e.node1.getVisual('color'),
        i = e.node2.getVisual('color')
      bt(n) &&
        bt(i) &&
        (r.fill = new He(0, 0, +(t === 'horizontal'), +(t === 'vertical'), [
          {
            color: n,
            offset: 0,
          },
          {
            color: i,
            offset: 1,
          },
        ]))
  }
}
function Cpt(r, t, e) {
  var n = new ge({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20,
    },
  })
  return (
    Je(
      n,
      {
        shape: {
          width: r.width + 20,
        },
      },
      t,
      e,
    ),
    n
  )
}
const Ept = Tpt
var Dpt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = e.edges || e.links,
        a = e.data || e.nodes,
        o = e.levels
      this.levelModels = []
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        o[l].depth != null &&
          o[l].depth >= 0 &&
          (s[o[l].depth] = new qe(o[l], this, n))
      if (a && i) {
        var u = A4(a, i, this, !0, c)
        return u.data
      }
      function c(h, f) {
        h.wrapMethod('getItemModel', function (d, p) {
          var g = d.parentModel,
            v = g.getData().getItemLayout(p)
          if (v) {
            var m = v.depth,
              y = g.levelModels[m]
            y && (d.parentModel = y)
          }
          return d
        }),
          f.wrapMethod('getItemModel', function (d, p) {
            var g = d.parentModel,
              v = g.getGraph().getEdgeByIndex(p),
              m = v.node1.getLayout()
            if (m) {
              var y = m.depth,
                _ = g.levelModels[y]
              _ && (d.parentModel = _)
            }
            return d
          })
      }
    }),
    (t.prototype.setNodePosition = function (e, n) {
      var i = this.option.data || this.option.nodes,
        a = i[e]
      ;(a.localX = n[0]), (a.localY = n[1])
    }),
    (t.prototype.getGraph = function () {
      return this.getData().graph
    }),
    (t.prototype.getEdgeData = function () {
      return this.getGraph().edgeData
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      function a(d) {
        return isNaN(d) || d == null
      }
      if (i === 'edge') {
        var o = this.getDataParams(e, i),
          s = o.data,
          l = o.value,
          u = s.source + ' -- ' + s.target
        return Kn('nameValue', {
          name: u,
          value: l,
          noValue: a(l),
        })
      } else {
        var c = this.getGraph().getNodeByIndex(e),
          h = c.getLayout().value,
          f = this.getDataParams(e, i).data.name
        return Kn('nameValue', {
          name: f != null ? f + '' : null,
          value: h,
          noValue: a(h),
        })
      }
    }),
    (t.prototype.optionUpdated = function () {}),
    (t.prototype.getDataParams = function (e, n) {
      var i = r.prototype.getDataParams.call(this, e, n)
      if (i.value == null && n === 'node') {
        var a = this.getGraph().getNodeByIndex(e),
          o = a.getLayout().value
        i.value = o
      }
      return i
    }),
    (t.type = 'series.sankey'),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'view',
      left: '5%',
      top: '5%',
      right: '20%',
      bottom: '5%',
      orient: 'horizontal',
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: 'right',
        fontSize: 12,
      },
      edgeLabel: {
        show: !1,
        fontSize: 12,
      },
      levels: [],
      nodeAlign: 'justify',
      lineStyle: {
        color: '#314656',
        opacity: 0.2,
        curveness: 0.5,
      },
      emphasis: {
        label: {
          show: !0,
        },
        lineStyle: {
          opacity: 0.5,
        },
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
      animationEasing: 'linear',
      animationDuration: 1e3,
    }),
    t
  )
})(rn)
const Lpt = Dpt
function Ppt(r, t) {
  r.eachSeriesByType('sankey', function (e) {
    var n = e.get('nodeWidth'),
      i = e.get('nodeGap'),
      a = Rpt(e, t)
    e.layoutInfo = a
    var o = a.width,
      s = a.height,
      l = e.getGraph(),
      u = l.nodes,
      c = l.edges
    Opt(u)
    var h = Ne(u, function (g) {
        return g.getLayout().value === 0
      }),
      f = h.length !== 0 ? 0 : e.get('layoutIterations'),
      d = e.get('orient'),
      p = e.get('nodeAlign')
    Ipt(u, c, n, i, o, s, f, d, p)
  })
}
function Rpt(r, t) {
  return Vn(r.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight(),
  })
}
function Ipt(r, t, e, n, i, a, o, s, l) {
  Npt(r, t, e, i, a, s, l), zpt(r, t, a, i, n, o, s), qpt(r, s)
}
function Opt(r) {
  R(r, function (t) {
    var e = Qs(t.outEdges, m0),
      n = Qs(t.inEdges, m0),
      i = t.getValue() || 0,
      a = Math.max(e, n, i)
    t.setLayout(
      {
        value: a,
      },
      !0,
    )
  })
}
function Npt(r, t, e, n, i, a, o) {
  for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < t.length; f++)
    s[f] = 1
  for (var f = 0; f < r.length; f++)
    (l[f] = r[f].inEdges.length), l[f] === 0 && u.push(r[f])
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p],
        v = g.hostGraph.data.getRawDataItem(g.dataIndex),
        m = v.depth != null && v.depth >= 0
      m && v.depth > d && (d = v.depth),
        g.setLayout(
          {
            depth: m ? v.depth : h,
          },
          !0,
        ),
        a === 'vertical'
          ? g.setLayout(
              {
                dy: e,
              },
              !0,
            )
          : g.setLayout(
              {
                dx: e,
              },
              !0,
            )
      for (var y = 0; y < g.outEdges.length; y++) {
        var _ = g.outEdges[y],
          x = t.indexOf(_)
        s[x] = 0
        var A = _.node2,
          S = r.indexOf(A)
        --l[S] === 0 && c.indexOf(A) < 0 && c.push(A)
      }
    }
    ++h, (u = c), (c = [])
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error('Sankey is a DAG, the original data has cycle!')
  var b = d > h - 1 ? d : h - 1
  o && o !== 'left' && kpt(r, o, a, b)
  var T = a === 'vertical' ? (i - e) / b : (n - e) / b
  Fpt(r, T, a)
}
function G4(r) {
  var t = r.hostGraph.data.getRawDataItem(r.dataIndex)
  return t.depth != null && t.depth >= 0
}
function kpt(r, t, e, n) {
  if (t === 'right') {
    for (var i = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s]
        l.setLayout(
          {
            skNodeHeight: o,
          },
          !0,
        )
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u]
          i.indexOf(c.node1) < 0 && i.push(c.node1)
        }
      }
      ;(a = i), (i = []), ++o
    }
    R(r, function (h) {
      G4(h) ||
        h.setLayout(
          {
            depth: Math.max(0, n - h.getLayout().skNodeHeight),
          },
          !0,
        )
    })
  } else t === 'justify' && Bpt(r, n)
}
function Bpt(r, t) {
  R(r, function (e) {
    !G4(e) &&
      !e.outEdges.length &&
      e.setLayout(
        {
          depth: t,
        },
        !0,
      )
  })
}
function Fpt(r, t, e) {
  R(r, function (n) {
    var i = n.getLayout().depth * t
    e === 'vertical'
      ? n.setLayout(
          {
            y: i,
          },
          !0,
        )
      : n.setLayout(
          {
            x: i,
          },
          !0,
        )
  })
}
function zpt(r, t, e, n, i, a, o) {
  var s = Upt(r, o)
  Vpt(s, t, e, n, i, o), RS(s, i, e, n, o)
  for (var l = 1; a > 0; a--)
    (l *= 0.99),
      Gpt(s, l, o),
      RS(s, i, e, n, o),
      $pt(s, l, o),
      RS(s, i, e, n, o)
}
function Upt(r, t) {
  var e = [],
    n = t === 'vertical' ? 'y' : 'x',
    i = jb(r, function (a) {
      return a.getLayout()[n]
    })
  return (
    i.keys.sort(function (a, o) {
      return a - o
    }),
    R(i.keys, function (a) {
      e.push(i.buckets.get(a))
    }),
    e
  )
}
function Vpt(r, t, e, n, i, a) {
  var o = 1 / 0
  R(r, function (s) {
    var l = s.length,
      u = 0
    R(s, function (h) {
      u += h.getLayout().value
    })
    var c = a === 'vertical' ? (n - (l - 1) * i) / u : (e - (l - 1) * i) / u
    c < o && (o = c)
  }),
    R(r, function (s) {
      R(s, function (l, u) {
        var c = l.getLayout().value * o
        a === 'vertical'
          ? (l.setLayout(
              {
                x: u,
              },
              !0,
            ),
            l.setLayout(
              {
                dx: c,
              },
              !0,
            ))
          : (l.setLayout(
              {
                y: u,
              },
              !0,
            ),
            l.setLayout(
              {
                dy: c,
              },
              !0,
            ))
      })
    }),
    R(t, function (s) {
      var l = +s.getValue() * o
      s.setLayout(
        {
          dy: l,
        },
        !0,
      )
    })
}
function RS(r, t, e, n, i) {
  var a = i === 'vertical' ? 'x' : 'y'
  R(r, function (o) {
    o.sort(function (g, v) {
      return g.getLayout()[a] - v.getLayout()[a]
    })
    for (
      var s,
        l,
        u,
        c = 0,
        h = o.length,
        f = i === 'vertical' ? 'dx' : 'dy',
        d = 0;
      d < h;
      d++
    )
      (l = o[d]),
        (u = c - l.getLayout()[a]),
        u > 0 &&
          ((s = l.getLayout()[a] + u),
          i === 'vertical'
            ? l.setLayout(
                {
                  x: s,
                },
                !0,
              )
            : l.setLayout(
                {
                  y: s,
                },
                !0,
              )),
        (c = l.getLayout()[a] + l.getLayout()[f] + t)
    var p = i === 'vertical' ? n : e
    if (((u = c - t - p), u > 0)) {
      ;(s = l.getLayout()[a] - u),
        i === 'vertical'
          ? l.setLayout(
              {
                x: s,
              },
              !0,
            )
          : l.setLayout(
              {
                y: s,
              },
              !0,
            ),
        (c = s)
      for (var d = h - 2; d >= 0; --d)
        (l = o[d]),
          (u = l.getLayout()[a] + l.getLayout()[f] + t - c),
          u > 0 &&
            ((s = l.getLayout()[a] - u),
            i === 'vertical'
              ? l.setLayout(
                  {
                    x: s,
                  },
                  !0,
                )
              : l.setLayout(
                  {
                    y: s,
                  },
                  !0,
                )),
          (c = l.getLayout()[a])
    }
  })
}
function Gpt(r, t, e) {
  R(r.slice().reverse(), function (n) {
    R(n, function (i) {
      if (i.outEdges.length) {
        var a = Qs(i.outEdges, Hpt, e) / Qs(i.outEdges, m0)
        if (isNaN(a)) {
          var o = i.outEdges.length
          a = o ? Qs(i.outEdges, Wpt, e) / o : 0
        }
        if (e === 'vertical') {
          var s = i.getLayout().x + (a - ul(i, e)) * t
          i.setLayout(
            {
              x: s,
            },
            !0,
          )
        } else {
          var l = i.getLayout().y + (a - ul(i, e)) * t
          i.setLayout(
            {
              y: l,
            },
            !0,
          )
        }
      }
    })
  })
}
function Hpt(r, t) {
  return ul(r.node2, t) * r.getValue()
}
function Wpt(r, t) {
  return ul(r.node2, t)
}
function Xpt(r, t) {
  return ul(r.node1, t) * r.getValue()
}
function Ypt(r, t) {
  return ul(r.node1, t)
}
function ul(r, t) {
  return t === 'vertical'
    ? r.getLayout().x + r.getLayout().dx / 2
    : r.getLayout().y + r.getLayout().dy / 2
}
function m0(r) {
  return r.getValue()
}
function Qs(r, t, e) {
  for (var n = 0, i = r.length, a = -1; ++a < i; ) {
    var o = +t(r[a], e)
    isNaN(o) || (n += o)
  }
  return n
}
function $pt(r, t, e) {
  R(r, function (n) {
    R(n, function (i) {
      if (i.inEdges.length) {
        var a = Qs(i.inEdges, Xpt, e) / Qs(i.inEdges, m0)
        if (isNaN(a)) {
          var o = i.inEdges.length
          a = o ? Qs(i.inEdges, Ypt, e) / o : 0
        }
        if (e === 'vertical') {
          var s = i.getLayout().x + (a - ul(i, e)) * t
          i.setLayout(
            {
              x: s,
            },
            !0,
          )
        } else {
          var l = i.getLayout().y + (a - ul(i, e)) * t
          i.setLayout(
            {
              y: l,
            },
            !0,
          )
        }
      }
    })
  })
}
function qpt(r, t) {
  var e = t === 'vertical' ? 'x' : 'y'
  R(r, function (n) {
    n.outEdges.sort(function (i, a) {
      return i.node2.getLayout()[e] - a.node2.getLayout()[e]
    }),
      n.inEdges.sort(function (i, a) {
        return i.node1.getLayout()[e] - a.node1.getLayout()[e]
      })
  }),
    R(r, function (n) {
      var i = 0,
        a = 0
      R(n.outEdges, function (o) {
        o.setLayout(
          {
            sy: i,
          },
          !0,
        ),
          (i += o.getLayout().dy)
      }),
        R(n.inEdges, function (o) {
          o.setLayout(
            {
              ty: a,
            },
            !0,
          ),
            (a += o.getLayout().dy)
        })
    })
}
function Zpt(r) {
  r.eachSeriesByType('sankey', function (t) {
    var e = t.getGraph(),
      n = e.nodes,
      i = e.edges
    if (n.length) {
      var a = 1 / 0,
        o = -1 / 0
      R(n, function (s) {
        var l = s.getLayout().value
        l < a && (a = l), l > o && (o = l)
      }),
        R(n, function (s) {
          var l = new vr({
              type: 'color',
              mappingMethod: 'linear',
              dataExtent: [a, o],
              visual: t.get('color'),
            }),
            u = l.mapValueToVisual(s.getLayout().value),
            c = s.getModel().get(['itemStyle', 'color'])
          c != null
            ? (s.setVisual('color', c),
              s.setVisual('style', {
                fill: c,
              }))
            : (s.setVisual('color', u),
              s.setVisual('style', {
                fill: u,
              }))
        })
    }
    i.length &&
      R(i, function (s) {
        var l = s.getModel().get('lineStyle')
        s.setVisual('style', l)
      })
  })
}
function Kpt(r) {
  r.registerChartView(Ept),
    r.registerSeriesModel(Lpt),
    r.registerLayout(Ppt),
    r.registerVisual(Zpt),
    r.registerAction(
      {
        type: 'dragNode',
        event: 'dragnode',
        update: 'update',
      },
      function (t, e) {
        e.eachComponent(
          {
            mainType: 'series',
            subType: 'sankey',
            query: t,
          },
          function (n) {
            n.setNodePosition(t.dataIndex, [t.localX, t.localY])
          },
        )
      },
    )
}
var H4 = (function () {
    function r() {}
    return (
      (r.prototype.getInitialData = function (t, e) {
        var n,
          i = e.getComponent('xAxis', this.get('xAxisIndex')),
          a = e.getComponent('yAxis', this.get('yAxisIndex')),
          o = i.get('type'),
          s = a.get('type'),
          l
        o === 'category'
          ? ((t.layout = 'horizontal'), (n = i.getOrdinalMeta()), (l = !0))
          : s === 'category'
          ? ((t.layout = 'vertical'), (n = a.getOrdinalMeta()), (l = !0))
          : (t.layout = t.layout || 'horizontal')
        var u = ['x', 'y'],
          c = t.layout === 'horizontal' ? 0 : 1,
          h = (this._baseAxisDim = u[c]),
          f = u[1 - c],
          d = [i, a],
          p = d[c].get('type'),
          g = d[1 - c].get('type'),
          v = t.data
        if (v && l) {
          var m = []
          R(v, function (x, A) {
            var S
            at(x)
              ? ((S = x.slice()), x.unshift(A))
              : at(x.value)
              ? ((S = Q({}, x)),
                (S.value = S.value.slice()),
                x.value.unshift(A))
              : (S = x),
              m.push(S)
          }),
            (t.data = m)
        }
        var y = this.defaultValueDimensions,
          _ = [
            {
              name: h,
              type: a0(p),
              ordinalMeta: n,
              otherDims: {
                tooltip: !1,
                itemName: 0,
              },
              dimsDef: ['base'],
            },
            {
              name: f,
              type: a0(g),
              dimsDef: y.slice(),
            },
          ]
        return Rf(this, {
          coordDimensions: _,
          dimensionsCount: y.length + 1,
          encodeDefaulter: Zt(h5, _, this),
        })
      }),
      (r.prototype.getBaseAxis = function () {
        var t = this._baseAxisDim
        return this.ecModel.getComponent(t + 'Axis', this.get(t + 'AxisIndex'))
          .axis
      }),
      r
    )
  })(),
  W4 = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.defaultValueDimensions = [
          {
            name: 'min',
            defaultTooltip: !0,
          },
          {
            name: 'Q1',
            defaultTooltip: !0,
          },
          {
            name: 'median',
            defaultTooltip: !0,
          },
          {
            name: 'Q3',
            defaultTooltip: !0,
          },
          {
            name: 'max',
            defaultTooltip: !0,
          },
        ]),
        (e.visualDrawType = 'stroke'),
        e
      )
    }
    return (
      (t.type = 'series.boxplot'),
      (t.dependencies = ['xAxis', 'yAxis', 'grid']),
      (t.defaultOption = {
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: !0,
        layout: null,
        boxWidth: [7, 50],
        itemStyle: {
          color: '#fff',
          borderWidth: 1,
        },
        emphasis: {
          scale: !0,
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            shadowColor: 'rgba(0,0,0,0.2)',
          },
        },
        animationDuration: 800,
      }),
      t
    )
  })(rn)
In(W4, H4, !0)
const jpt = W4
var Jpt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = e.getData(),
          o = this.group,
          s = this._data
        this._data || o.removeAll()
        var l = e.get('layout') === 'horizontal' ? 1 : 0
        a
          .diff(s)
          .add(function (u) {
            if (a.hasValue(u)) {
              var c = a.getItemLayout(u),
                h = dN(c, a, u, l, !0)
              a.setItemGraphicEl(u, h), o.add(h)
            }
          })
          .update(function (u, c) {
            var h = s.getItemGraphicEl(c)
            if (!a.hasValue(u)) {
              o.remove(h)
              return
            }
            var f = a.getItemLayout(u)
            h ? (Ca(h), X4(f, h, a, u)) : (h = dN(f, a, u, l)),
              o.add(h),
              a.setItemGraphicEl(u, h)
          })
          .remove(function (u) {
            var c = s.getItemGraphicEl(u)
            c && o.remove(c)
          })
          .execute(),
          (this._data = a)
      }),
      (t.prototype.remove = function (e) {
        var n = this.group,
          i = this._data
        ;(this._data = null),
          i &&
            i.eachItemGraphicEl(function (a) {
              a && n.remove(a)
            })
      }),
      (t.type = 'boxplot'),
      t
    )
  })(Ze),
  Qpt = (function () {
    function r() {}
    return r
  })(),
  tvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'boxplotBoxPath'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new Qpt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points,
          a = 0
        for (e.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)
          e.lineTo(i[a][0], i[a][1])
        for (e.closePath(); a < i.length; a++)
          e.moveTo(i[a][0], i[a][1]), a++, e.lineTo(i[a][0], i[a][1])
      }),
      t
    )
  })(oe)
function dN(r, t, e, n, i) {
  var a = r.ends,
    o = new tvt({
      shape: {
        points: i ? evt(a, n, r) : a,
      },
    })
  return X4(r, o, t, e, i), o
}
function X4(r, t, e, n, i) {
  var a = e.hostModel,
    o = nc[i ? 'initProps' : 'updateProps']
  o(
    t,
    {
      shape: {
        points: r.ends,
      },
    },
    a,
    n,
  ),
    t.useStyle(e.getItemVisual(n, 'style')),
    (t.style.strokeNoScale = !0),
    (t.z2 = 100)
  var s = e.getItemModel(n),
    l = s.getModel('emphasis')
  gr(t, s), fn(t, l.get('focus'), l.get('blurScope'), l.get('disabled'))
}
function evt(r, t, e) {
  return st(r, function (n) {
    return (n = n.slice()), (n[t] = e.initBaseline), n
  })
}
const nvt = Jpt
var pp = R
function rvt(r) {
  var t = ivt(r)
  pp(t, function (e) {
    var n = e.seriesModels
    n.length &&
      (avt(e),
      pp(n, function (i, a) {
        ovt(i, e.boxOffsetList[a], e.boxWidthList[a])
      }))
  })
}
function ivt(r) {
  var t = [],
    e = []
  return (
    r.eachSeriesByType('boxplot', function (n) {
      var i = n.getBaseAxis(),
        a = re(e, i)
      a < 0 &&
        ((a = e.length),
        (e[a] = i),
        (t[a] = {
          axis: i,
          seriesModels: [],
        })),
        t[a].seriesModels.push(n)
    }),
    t
  )
}
function avt(r) {
  var t = r.axis,
    e = r.seriesModels,
    n = e.length,
    i = (r.boxWidthList = []),
    a = (r.boxOffsetList = []),
    o = [],
    s
  if (t.type === 'category') s = t.getBandWidth()
  else {
    var l = 0
    pp(e, function (p) {
      l = Math.max(l, p.getData().count())
    })
    var u = t.getExtent()
    s = Math.abs(u[1] - u[0]) / l
  }
  pp(e, function (p) {
    var g = p.get('boxWidth')
    at(g) || (g = [g, g]), o.push([_t(g[0], s) || 0, _t(g[1], s) || 0])
  })
  var c = s * 0.8 - 2,
    h = (c / n) * 0.3,
    f = (c - h * (n - 1)) / n,
    d = f / 2 - c / 2
  pp(e, function (p, g) {
    a.push(d), (d += h + f), i.push(Math.min(Math.max(f, o[g][0]), o[g][1]))
  })
}
function ovt(r, t, e) {
  var n = r.coordinateSystem,
    i = r.getData(),
    a = e / 2,
    o = r.get('layout') === 'horizontal' ? 0 : 1,
    s = 1 - o,
    l = ['x', 'y'],
    u = i.mapDimension(l[o]),
    c = i.mapDimensionsAll(l[s])
  if (u == null || c.length < 5) return
  for (var h = 0; h < i.count(); h++) {
    var f = i.get(u, h),
      d = _(f, c[2], h),
      p = _(f, c[0], h),
      g = _(f, c[1], h),
      v = _(f, c[3], h),
      m = _(f, c[4], h),
      y = []
    x(y, g, !1),
      x(y, v, !0),
      y.push(p, g, m, v),
      A(y, p),
      A(y, m),
      A(y, d),
      i.setItemLayout(h, {
        initBaseline: d[s],
        ends: y,
      })
  }
  function _(S, b, T) {
    var w = i.get(b, T),
      M = []
    ;(M[o] = S), (M[s] = w)
    var C
    return (
      isNaN(S) || isNaN(w)
        ? (C = [NaN, NaN])
        : ((C = n.dataToPoint(M)), (C[o] += t)),
      C
    )
  }
  function x(S, b, T) {
    var w = b.slice(),
      M = b.slice()
    ;(w[o] += a), (M[o] -= a), T ? S.push(w, M) : S.push(M, w)
  }
  function A(S, b) {
    var T = b.slice(),
      w = b.slice()
    ;(T[o] -= a), (w[o] += a), S.push(T, w)
  }
}
function svt(r, t) {
  t = t || {}
  for (
    var e = [], n = [], i = t.boundIQR, a = i === 'none' || i === 0, o = 0;
    o < r.length;
    o++
  ) {
    var s = Zi(r[o].slice()),
      l = s1(s, 0.25),
      u = s1(s, 0.5),
      c = s1(s, 0.75),
      h = s[0],
      f = s[s.length - 1],
      d = (i ?? 1.5) * (c - l),
      p = a ? h : Math.max(h, l - d),
      g = a ? f : Math.min(f, c + d),
      v = t.itemNameFormatter,
      m = Nt(v)
        ? v({
            value: o,
          })
        : bt(v)
        ? v.replace('{value}', o + '')
        : o + ''
    e.push([m, p, l, u, c, g])
    for (var y = 0; y < s.length; y++) {
      var _ = s[y]
      if (_ < p || _ > g) {
        var x = [m, _]
        n.push(x)
      }
    }
  }
  return {
    boxData: e,
    outliers: n,
  }
}
var lvt = {
  type: 'echarts:boxplot',
  transform: function (t) {
    var e = t.upstream
    if (e.sourceFormat !== Dr) {
      var n = ''
      Ce(n)
    }
    var i = svt(e.getRawData(), t.config)
    return [
      {
        dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],
        data: i.boxData,
      },
      {
        data: i.outliers,
      },
    ]
  },
}
function uvt(r) {
  r.registerSeriesModel(jpt),
    r.registerChartView(nvt),
    r.registerLayout(rvt),
    r.registerTransform(lvt)
}
var cvt = ['color', 'borderColor'],
  hvt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        this.group.removeClipPath(),
          (this._progressiveEls = null),
          this._updateDrawMode(e),
          this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e)
      }),
      (t.prototype.incrementalPrepareRender = function (e, n, i) {
        this._clear(), this._updateDrawMode(e)
      }),
      (t.prototype.incrementalRender = function (e, n, i, a) {
        ;(this._progressiveEls = []),
          this._isLargeDraw
            ? this._incrementalRenderLarge(e, n)
            : this._incrementalRenderNormal(e, n)
      }),
      (t.prototype.eachRendered = function (e) {
        vl(this._progressiveEls || this.group, e)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var n = e.pipelineContext.large
        ;(this._isLargeDraw == null || n !== this._isLargeDraw) &&
          ((this._isLargeDraw = n), this._clear())
      }),
      (t.prototype._renderNormal = function (e) {
        var n = e.getData(),
          i = this._data,
          a = this.group,
          o = n.getLayout('isSimpleBox'),
          s = e.get('clip', !0),
          l = e.coordinateSystem,
          u = l.getArea && l.getArea()
        this._data || a.removeAll(),
          n
            .diff(i)
            .add(function (c) {
              if (n.hasValue(c)) {
                var h = n.getItemLayout(c)
                if (s && pN(u, h)) return
                var f = IS(h, c, !0)
                Je(
                  f,
                  {
                    shape: {
                      points: h.ends,
                    },
                  },
                  e,
                  c,
                ),
                  OS(f, n, c, o),
                  a.add(f),
                  n.setItemGraphicEl(c, f)
              }
            })
            .update(function (c, h) {
              var f = i.getItemGraphicEl(h)
              if (!n.hasValue(c)) {
                a.remove(f)
                return
              }
              var d = n.getItemLayout(c)
              if (s && pN(u, d)) {
                a.remove(f)
                return
              }
              f
                ? (we(
                    f,
                    {
                      shape: {
                        points: d.ends,
                      },
                    },
                    e,
                    c,
                  ),
                  Ca(f))
                : (f = IS(d)),
                OS(f, n, c, o),
                a.add(f),
                n.setItemGraphicEl(c, f)
            })
            .remove(function (c) {
              var h = i.getItemGraphicEl(c)
              h && a.remove(h)
            })
            .execute(),
          (this._data = n)
      }),
      (t.prototype._renderLarge = function (e) {
        this._clear(), vN(e, this.group)
        var n = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
        n ? this.group.setClipPath(n) : this.group.removeClipPath()
      }),
      (t.prototype._incrementalRenderNormal = function (e, n) {
        for (
          var i = n.getData(), a = i.getLayout('isSimpleBox'), o;
          (o = e.next()) != null;

        ) {
          var s = i.getItemLayout(o),
            l = IS(s)
          OS(l, i, o, a),
            (l.incremental = !0),
            this.group.add(l),
            this._progressiveEls.push(l)
        }
      }),
      (t.prototype._incrementalRenderLarge = function (e, n) {
        vN(n, this.group, this._progressiveEls, !0)
      }),
      (t.prototype.remove = function (e) {
        this._clear()
      }),
      (t.prototype._clear = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.type = 'candlestick'),
      t
    )
  })(Ze),
  fvt = (function () {
    function r() {}
    return r
  })(),
  dvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'normalCandlestickBox'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new fvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.points
        this.__simpleBox
          ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1]))
          : (e.moveTo(i[0][0], i[0][1]),
            e.lineTo(i[1][0], i[1][1]),
            e.lineTo(i[2][0], i[2][1]),
            e.lineTo(i[3][0], i[3][1]),
            e.closePath(),
            e.moveTo(i[4][0], i[4][1]),
            e.lineTo(i[5][0], i[5][1]),
            e.moveTo(i[6][0], i[6][1]),
            e.lineTo(i[7][0], i[7][1]))
      }),
      t
    )
  })(oe)
function IS(r, t, e) {
  var n = r.ends
  return new dvt({
    shape: {
      points: e ? pvt(n, r) : n,
    },
    z2: 100,
  })
}
function pN(r, t) {
  for (var e = !0, n = 0; n < t.ends.length; n++)
    if (r.contain(t.ends[n][0], t.ends[n][1])) {
      e = !1
      break
    }
  return e
}
function OS(r, t, e, n) {
  var i = t.getItemModel(e)
  r.useStyle(t.getItemVisual(e, 'style')),
    (r.style.strokeNoScale = !0),
    (r.__simpleBox = n),
    gr(r, i)
}
function pvt(r, t) {
  return st(r, function (e) {
    return (e = e.slice()), (e[1] = t.initBaseline), e
  })
}
var vvt = (function () {
    function r() {}
    return r
  })(),
  NS = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n.type = 'largeCandlestickBox'), n
    }
    return (
      (t.prototype.getDefaultShape = function () {
        return new vvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        for (var i = n.points, a = 0; a < i.length; )
          if (this.__sign === i[a++]) {
            var o = i[a++]
            e.moveTo(o, i[a++]), e.lineTo(o, i[a++])
          } else a += 3
      }),
      t
    )
  })(oe)
function vN(r, t, e, n) {
  var i = r.getData(),
    a = i.getLayout('largePoints'),
    o = new NS({
      shape: {
        points: a,
      },
      __sign: 1,
      ignoreCoarsePointer: !0,
    })
  t.add(o)
  var s = new NS({
    shape: {
      points: a,
    },
    __sign: -1,
    ignoreCoarsePointer: !0,
  })
  t.add(s)
  var l = new NS({
    shape: {
      points: a,
    },
    __sign: 0,
    ignoreCoarsePointer: !0,
  })
  t.add(l),
    kS(1, o, r),
    kS(-1, s, r),
    kS(0, l, r),
    n && ((o.incremental = !0), (s.incremental = !0)),
    e && e.push(o, s)
}
function kS(r, t, e, n) {
  var i =
    e.get(['itemStyle', r > 0 ? 'borderColor' : 'borderColor0']) ||
    e.get(['itemStyle', r > 0 ? 'color' : 'color0'])
  r === 0 && (i = e.get(['itemStyle', 'borderColorDoji']))
  var a = e.getModel('itemStyle').getItemStyle(cvt)
  t.useStyle(a), (t.style.fill = null), (t.style.stroke = i)
}
const gvt = hvt
var Y4 = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.defaultValueDimensions = [
        {
          name: 'open',
          defaultTooltip: !0,
        },
        {
          name: 'close',
          defaultTooltip: !0,
        },
        {
          name: 'lowest',
          defaultTooltip: !0,
        },
        {
          name: 'highest',
          defaultTooltip: !0,
        },
      ]),
      e
    )
  }
  return (
    (t.prototype.getShadowDim = function () {
      return 'open'
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      var a = n.getItemLayout(e)
      return a && i.rect(a.brushRect)
    }),
    (t.type = 'series.candlestick'),
    (t.dependencies = ['xAxis', 'yAxis', 'grid']),
    (t.defaultOption = {
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: '#eb5454',
        color0: '#47b262',
        borderColor: '#eb5454',
        borderColor0: '#47b262',
        borderColorDoji: null,
        borderWidth: 1,
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
        },
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: 'mod',
      animationEasing: 'linear',
      animationDuration: 300,
    }),
    t
  )
})(rn)
In(Y4, H4, !0)
const mvt = Y4
function yvt(r) {
  !r ||
    !at(r.series) ||
    R(r.series, function (t) {
      Ut(t) && t.type === 'k' && (t.type = 'candlestick')
    })
}
var _vt = ['itemStyle', 'borderColor'],
  xvt = ['itemStyle', 'borderColor0'],
  Svt = ['itemStyle', 'borderColorDoji'],
  Avt = ['itemStyle', 'color'],
  bvt = ['itemStyle', 'color0'],
  wvt = {
    seriesType: 'candlestick',
    plan: Ef(),
    performRawSeries: !0,
    reset: function (r, t) {
      function e(a, o) {
        return o.get(a > 0 ? Avt : bvt)
      }
      function n(a, o) {
        return o.get(a === 0 ? Svt : a > 0 ? _vt : xvt)
      }
      if (!t.isSeriesFiltered(r)) {
        var i = r.pipelineContext.large
        return (
          !i && {
            progress: function (a, o) {
              for (var s; (s = a.next()) != null; ) {
                var l = o.getItemModel(s),
                  u = o.getItemLayout(s).sign,
                  c = l.getItemStyle()
                ;(c.fill = e(u, l)), (c.stroke = n(u, l) || c.fill)
                var h = o.ensureUniqueItemVisual(s, 'style')
                Q(h, c)
              }
            },
          }
        )
      }
    },
  }
const Mvt = wvt
var Tvt = {
  seriesType: 'candlestick',
  plan: Ef(),
  reset: function (r) {
    var t = r.coordinateSystem,
      e = r.getData(),
      n = Cvt(r, e),
      i = 0,
      a = 1,
      o = ['x', 'y'],
      s = e.getDimensionIndex(e.mapDimension(o[i])),
      l = st(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e),
      u = l[0],
      c = l[1],
      h = l[2],
      f = l[3]
    if (
      (e.setLayout({
        candleWidth: n,
        isSimpleBox: n <= 1.3,
      }),
      s < 0 || l.length < 4)
    )
      return
    return {
      progress: r.pipelineContext.large ? p : d,
    }
    function d(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var _ = y.get(s, m),
          x = y.get(u, m),
          A = y.get(c, m),
          S = y.get(h, m),
          b = y.get(f, m),
          T = Math.min(x, A),
          w = Math.max(x, A),
          M = F(T, _),
          C = F(w, _),
          E = F(S, _),
          D = F(b, _),
          P = []
        k(P, C, 0), k(P, M, 1), P.push(H(D), H(C), H(E), H(M))
        var L = v.getItemModel(m),
          I = !!L.get(['itemStyle', 'borderColorDoji'])
        v.setItemLayout(m, {
          sign: gN(y, m, x, A, c, I),
          initBaseline: x > A ? C[a] : M[a],
          ends: P,
          brushRect: V(S, b, _),
        })
      }
      function F(Y, K) {
        var ut = []
        return (
          (ut[i] = K),
          (ut[a] = Y),
          isNaN(K) || isNaN(Y) ? [NaN, NaN] : t.dataToPoint(ut)
        )
      }
      function k(Y, K, ut) {
        var W = K.slice(),
          Z = K.slice()
        ;(W[i] = ey(W[i] + n / 2, 1, !1)),
          (Z[i] = ey(Z[i] - n / 2, 1, !0)),
          ut ? Y.push(W, Z) : Y.push(Z, W)
      }
      function V(Y, K, ut) {
        var W = F(Y, ut),
          Z = F(K, ut)
        return (
          (W[i] -= n / 2),
          (Z[i] -= n / 2),
          {
            x: W[0],
            y: W[1],
            width: n,
            height: Z[1] - W[1],
          }
        )
      }
      function H(Y) {
        return (Y[i] = ey(Y[i], 1)), Y
      }
    }
    function p(g, v) {
      for (
        var m = eo(g.count * 4),
          y = 0,
          _,
          x = [],
          A = [],
          S,
          b = v.getStore(),
          T = !!r.get(['itemStyle', 'borderColorDoji']);
        (S = g.next()) != null;

      ) {
        var w = b.get(s, S),
          M = b.get(u, S),
          C = b.get(c, S),
          E = b.get(h, S),
          D = b.get(f, S)
        if (isNaN(w) || isNaN(E) || isNaN(D)) {
          ;(m[y++] = NaN), (y += 3)
          continue
        }
        ;(m[y++] = gN(b, S, M, C, c, T)),
          (x[i] = w),
          (x[a] = E),
          (_ = t.dataToPoint(x, null, A)),
          (m[y++] = _ ? _[0] : NaN),
          (m[y++] = _ ? _[1] : NaN),
          (x[a] = D),
          (_ = t.dataToPoint(x, null, A)),
          (m[y++] = _ ? _[1] : NaN)
      }
      v.setLayout('largePoints', m)
    }
  },
}
function gN(r, t, e, n, i, a) {
  var o
  return (
    e > n
      ? (o = -1)
      : e < n
      ? (o = 1)
      : (o = a ? 0 : t > 0 ? (r.get(i, t - 1) <= n ? 1 : -1) : 1),
    o
  )
}
function Cvt(r, t) {
  var e = r.getBaseAxis(),
    n,
    i =
      e.type === 'category'
        ? e.getBandWidth()
        : ((n = e.getExtent()), Math.abs(n[1] - n[0]) / t.count()),
    a = _t($t(r.get('barMaxWidth'), i), i),
    o = _t($t(r.get('barMinWidth'), 1), i),
    s = r.get('barWidth')
  return s != null ? _t(s, i) : Math.max(Math.min(i / 2, a), o)
}
const Evt = Tvt
function Dvt(r) {
  r.registerChartView(gvt),
    r.registerSeriesModel(mvt),
    r.registerPreprocessor(yvt),
    r.registerVisual(Mvt),
    r.registerLayout(Evt)
}
function mN(r, t) {
  var e = t.rippleEffectColor || t.color
  r.eachChild(function (n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === 'stroke' ? e : null,
        fill: t.brushType === 'fill' ? e : null,
      },
    })
  })
}
var Lvt = (function (r) {
  X(t, r)
  function t(e, n) {
    var i = r.call(this) || this,
      a = new Tv(e, n),
      o = new Ht()
    return i.add(a), i.add(o), i.updateData(e, n), i
  }
  return (
    (t.prototype.stopEffectAnimation = function () {
      this.childAt(1).removeAll()
    }),
    (t.prototype.startEffectAnimation = function (e) {
      for (
        var n = e.symbolType,
          i = e.color,
          a = e.rippleNumber,
          o = this.childAt(1),
          s = 0;
        s < a;
        s++
      ) {
        var l = Rn(n, -1, -1, 2, 2, i)
        l.attr({
          style: {
            strokeNoScale: !0,
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5,
        })
        var u = (-s / a) * e.period + e.effectOffset
        l
          .animate('', !0)
          .when(e.period, {
            scaleX: e.rippleScale / 2,
            scaleY: e.rippleScale / 2,
          })
          .delay(u)
          .start(),
          l
            .animateStyle(!0)
            .when(e.period, {
              opacity: 0,
            })
            .delay(u)
            .start(),
          o.add(l)
      }
      mN(o, e)
    }),
    (t.prototype.updateEffectAnimation = function (e) {
      for (
        var n = this._effectCfg,
          i = this.childAt(1),
          a = ['symbolType', 'period', 'rippleScale', 'rippleNumber'],
          o = 0;
        o < a.length;
        o++
      ) {
        var s = a[o]
        if (n[s] !== e[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(e)
          return
        }
      }
      mN(i, e)
    }),
    (t.prototype.highlight = function () {
      Qo(this)
    }),
    (t.prototype.downplay = function () {
      ts(this)
    }),
    (t.prototype.getSymbolType = function () {
      var e = this.childAt(0)
      return e && e.getSymbolType()
    }),
    (t.prototype.updateData = function (e, n) {
      var i = this,
        a = e.hostModel
      this.childAt(0).updateData(e, n)
      var o = this.childAt(1),
        s = e.getItemModel(n),
        l = e.getItemVisual(n, 'symbol'),
        u = Lf(e.getItemVisual(n, 'symbolSize')),
        c = e.getItemVisual(n, 'style'),
        h = c && c.fill,
        f = s.getModel('emphasis')
      o.setScale(u),
        o.traverse(function (v) {
          v.setStyle('fill', h)
        })
      var d = ic(e.getItemVisual(n, 'symbolOffset'), u)
      d && ((o.x = d[0]), (o.y = d[1]))
      var p = e.getItemVisual(n, 'symbolRotate')
      o.rotation = ((p || 0) * Math.PI) / 180 || 0
      var g = {}
      ;(g.showEffectOn = a.get('showEffectOn')),
        (g.rippleScale = s.get(['rippleEffect', 'scale'])),
        (g.brushType = s.get(['rippleEffect', 'brushType'])),
        (g.period = s.get(['rippleEffect', 'period']) * 1e3),
        (g.effectOffset = n / e.count()),
        (g.z = a.getShallow('z') || 0),
        (g.zlevel = a.getShallow('zlevel') || 0),
        (g.symbolType = l),
        (g.color = h),
        (g.rippleEffectColor = s.get(['rippleEffect', 'color'])),
        (g.rippleNumber = s.get(['rippleEffect', 'number'])),
        g.showEffectOn === 'render'
          ? (this._effectCfg
              ? this.updateEffectAnimation(g)
              : this.startEffectAnimation(g),
            (this._effectCfg = g))
          : ((this._effectCfg = null),
            this.stopEffectAnimation(),
            (this.onHoverStateChange = function (v) {
              v === 'emphasis'
                ? g.showEffectOn !== 'render' && i.startEffectAnimation(g)
                : v === 'normal' &&
                  g.showEffectOn !== 'render' &&
                  i.stopEffectAnimation()
            })),
        (this._effectCfg = g),
        fn(this, f.get('focus'), f.get('blurScope'), f.get('disabled'))
    }),
    (t.prototype.fadeOut = function (e) {
      e && e()
    }),
    t
  )
})(Ht)
const Pvt = Lvt
var Rvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function () {
      this._symbolDraw = new Cv(Pvt)
    }),
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._symbolDraw
      o.updateData(a, {
        clipShape: this._getClipShape(e),
      }),
        this.group.add(o.group)
    }),
    (t.prototype._getClipShape = function (e) {
      var n = e.coordinateSystem,
        i = n && n.getArea && n.getArea()
      return e.get('clip', !0) ? i : null
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData()
      this.group.dirty()
      var o = Dv('').reset(e, n, i)
      o.progress &&
        o.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._symbolDraw.updateLayout()
    }),
    (t.prototype._updateGroupTransform = function (e) {
      var n = e.coordinateSystem
      n &&
        n.getRoamTransform &&
        ((this.group.transform = aQ(n.getRoamTransform())),
        this.group.decomposeTransform())
    }),
    (t.prototype.remove = function (e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0)
    }),
    (t.type = 'effectScatter'),
    t
  )
})(Ze)
const Ivt = Rvt
var Ovt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.hasSymbolVisual = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        useEncodeDefaulter: !0,
      })
    }),
    (t.prototype.brushSelector = function (e, n, i) {
      return i.point(n.getItemLayout(e))
    }),
    (t.type = 'series.effectScatter'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      legendHoverLink: !0,
      effectType: 'ripple',
      progressive: 0,
      showEffectOn: 'render',
      clip: !0,
      rippleEffect: {
        period: 4,
        scale: 2.5,
        brushType: 'fill',
        number: 3,
      },
      universalTransition: {
        divideShape: 'clone',
      },
      symbolSize: 10,
    }),
    t
  )
})(rn)
const Nvt = Ovt
function kvt(r) {
  r.registerChartView(Ivt),
    r.registerSeriesModel(Nvt),
    r.registerLayout(Dv('effectScatter'))
}
var Bvt = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a.add(a.createLine(e, n, i)), a._updateEffectSymbol(e, n), a
  }
  return (
    (t.prototype.createLine = function (e, n, i) {
      return new JC(e, n, i)
    }),
    (t.prototype._updateEffectSymbol = function (e, n) {
      var i = e.getItemModel(n),
        a = i.getModel('effect'),
        o = a.get('symbolSize'),
        s = a.get('symbol')
      at(o) || (o = [o, o])
      var l = e.getItemVisual(n, 'style'),
        u = a.get('color') || (l && l.stroke),
        c = this.childAt(1)
      this._symbolType !== s &&
        (this.remove(c),
        (c = Rn(s, -0.5, -0.5, 1, 1, u)),
        (c.z2 = 100),
        (c.culling = !0),
        this.add(c)),
        c &&
          (c.setStyle('shadowColor', u),
          c.setStyle(a.getItemStyle(['color'])),
          (c.scaleX = o[0]),
          (c.scaleY = o[1]),
          c.setColor(u),
          (this._symbolType = s),
          (this._symbolScale = o),
          this._updateEffectAnimation(e, a, n))
    }),
    (t.prototype._updateEffectAnimation = function (e, n, i) {
      var a = this.childAt(1)
      if (a) {
        var o = e.getItemLayout(i),
          s = n.get('period') * 1e3,
          l = n.get('loop'),
          u = n.get('roundTrip'),
          c = n.get('constantSpeed'),
          h = nr(n.get('delay'), function (d) {
            return ((d / e.count()) * s) / 3
          })
        if (
          ((a.ignore = !0),
          this._updateAnimationPoints(a, o),
          c > 0 && (s = (this._getLineLength(a) / c) * 1e3),
          s !== this._period || l !== this._loop || u !== this._roundTrip)
        ) {
          a.stopAnimation()
          var f = void 0
          Nt(h) ? (f = h(i)) : (f = h),
            a.__t > 0 && (f = -s * a.__t),
            this._animateSymbol(a, s, f, l, u)
        }
        ;(this._period = s), (this._loop = l), (this._roundTrip = u)
      }
    }),
    (t.prototype._animateSymbol = function (e, n, i, a, o) {
      if (n > 0) {
        e.__t = 0
        var s = this,
          l = e
            .animate('', a)
            .when(o ? n * 2 : n, {
              __t: o ? 2 : 1,
            })
            .delay(i)
            .during(function () {
              s._updateSymbolPosition(e)
            })
        a ||
          l.done(function () {
            s.remove(e)
          }),
          l.start()
      }
    }),
    (t.prototype._getLineLength = function (e) {
      return ks(e.__p1, e.__cp1) + ks(e.__cp1, e.__p2)
    }),
    (t.prototype._updateAnimationPoints = function (e, n) {
      ;(e.__p1 = n[0]),
        (e.__p2 = n[1]),
        (e.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2])
    }),
    (t.prototype.updateData = function (e, n, i) {
      this.childAt(0).updateData(e, n, i), this._updateEffectSymbol(e, n)
    }),
    (t.prototype._updateSymbolPosition = function (e) {
      var n = e.__p1,
        i = e.__p2,
        a = e.__cp1,
        o = e.__t < 1 ? e.__t : 2 - e.__t,
        s = [e.x, e.y],
        l = s.slice(),
        u = tr,
        c = kb
      ;(s[0] = u(n[0], a[0], i[0], o)), (s[1] = u(n[1], a[1], i[1], o))
      var h = e.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o),
        f = e.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o)
      ;(e.rotation = -Math.atan2(f, h) - Math.PI / 2),
        (this._symbolType === 'line' ||
          this._symbolType === 'rect' ||
          this._symbolType === 'roundRect') &&
          (e.__lastT !== void 0 && e.__lastT < e.__t
            ? ((e.scaleY = ks(l, s) * 1.05),
              o === 1 &&
                ((s[0] = l[0] + (s[0] - l[0]) / 2),
                (s[1] = l[1] + (s[1] - l[1]) / 2)))
            : e.__lastT === 1
            ? (e.scaleY = 2 * ks(n, s))
            : (e.scaleY = this._symbolScale[1])),
        (e.__lastT = e.__t),
        (e.ignore = !1),
        (e.x = s[0]),
        (e.y = s[1])
    }),
    (t.prototype.updateLayout = function (e, n) {
      this.childAt(0).updateLayout(e, n)
      var i = e.getItemModel(n).getModel('effect')
      this._updateEffectAnimation(e, i, n)
    }),
    t
  )
})(Ht)
const $4 = Bvt
var Fvt = (function (r) {
  X(t, r)
  function t(e, n, i) {
    var a = r.call(this) || this
    return a._createPolyline(e, n, i), a
  }
  return (
    (t.prototype._createPolyline = function (e, n, i) {
      var a = e.getItemLayout(n),
        o = new li({
          shape: {
            points: a,
          },
        })
      this.add(o), this._updateCommonStl(e, n, i)
    }),
    (t.prototype.updateData = function (e, n, i) {
      var a = e.hostModel,
        o = this.childAt(0),
        s = {
          shape: {
            points: e.getItemLayout(n),
          },
        }
      we(o, s, a, n), this._updateCommonStl(e, n, i)
    }),
    (t.prototype._updateCommonStl = function (e, n, i) {
      var a = this.childAt(0),
        o = e.getItemModel(n),
        s = i && i.emphasisLineStyle,
        l = i && i.focus,
        u = i && i.blurScope,
        c = i && i.emphasisDisabled
      if (!i || e.hasItemOption) {
        var h = o.getModel('emphasis')
        ;(s = h.getModel('lineStyle').getLineStyle()),
          (c = h.get('disabled')),
          (l = h.get('focus')),
          (u = h.get('blurScope'))
      }
      a.useStyle(e.getItemVisual(n, 'style')),
        (a.style.fill = null),
        (a.style.strokeNoScale = !0)
      var f = a.ensureState('emphasis')
      ;(f.style = s), fn(this, l, u, c)
    }),
    (t.prototype.updateLayout = function (e, n) {
      var i = this.childAt(0)
      i.setShape('points', e.getItemLayout(n))
    }),
    t
  )
})(Ht)
const q4 = Fvt
var zvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e._lastFrame = 0), (e._lastFramePercent = 0), e
  }
  return (
    (t.prototype.createLine = function (e, n, i) {
      return new q4(e, n, i)
    }),
    (t.prototype._updateAnimationPoints = function (e, n) {
      this._points = n
      for (var i = [0], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1],
          l = n[o]
        ;(a += ks(s, l)), i.push(a)
      }
      if (a === 0) {
        this._length = 0
        return
      }
      for (var o = 0; o < i.length; o++) i[o] /= a
      ;(this._offsets = i), (this._length = a)
    }),
    (t.prototype._getLineLength = function () {
      return this._length
    }),
    (t.prototype._updateSymbolPosition = function (e) {
      var n = e.__t < 1 ? e.__t : 2 - e.__t,
        i = this._points,
        a = this._offsets,
        o = i.length
      if (a) {
        var s = this._lastFrame,
          l
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1)
          for (l = u; l >= 0 && !(a[l] <= n); l--);
          l = Math.min(l, o - 2)
        } else {
          for (l = s; l < o && !(a[l] > n); l++);
          l = Math.min(l - 1, o - 2)
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]),
          h = i[l],
          f = i[l + 1]
        ;(e.x = h[0] * (1 - c) + c * f[0]), (e.y = h[1] * (1 - c) + c * f[1])
        var d = e.__t < 1 ? f[0] - h[0] : h[0] - f[0],
          p = e.__t < 1 ? f[1] - h[1] : h[1] - f[1]
        ;(e.rotation = -Math.atan2(p, d) - Math.PI / 2),
          (this._lastFrame = l),
          (this._lastFramePercent = n),
          (e.ignore = !1)
      }
    }),
    t
  )
})($4)
const Uvt = zvt
var Vvt = (function () {
    function r() {
      ;(this.polyline = !1), (this.curveness = 0), (this.segs = [])
    }
    return r
  })(),
  Gvt = (function (r) {
    X(t, r)
    function t(e) {
      var n = r.call(this, e) || this
      return (n._off = 0), (n.hoverDataIdx = -1), n
    }
    return (
      (t.prototype.reset = function () {
        ;(this.notClear = !1), (this._off = 0)
      }),
      (t.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null,
        }
      }),
      (t.prototype.getDefaultShape = function () {
        return new Vvt()
      }),
      (t.prototype.buildPath = function (e, n) {
        var i = n.segs,
          a = n.curveness,
          o
        if (n.polyline)
          for (o = this._off; o < i.length; ) {
            var s = i[o++]
            if (s > 0) {
              e.moveTo(i[o++], i[o++])
              for (var l = 1; l < s; l++) e.lineTo(i[o++], i[o++])
            }
          }
        else
          for (o = this._off; o < i.length; ) {
            var u = i[o++],
              c = i[o++],
              h = i[o++],
              f = i[o++]
            if ((e.moveTo(u, c), a > 0)) {
              var d = (u + h) / 2 - (c - f) * a,
                p = (c + f) / 2 - (h - u) * a
              e.quadraticCurveTo(d, p, h, f)
            } else e.lineTo(h, f)
          }
        this.incremental && ((this._off = o), (this.notClear = !0))
      }),
      (t.prototype.findDataIndex = function (e, n) {
        var i = this.shape,
          a = i.segs,
          o = i.curveness,
          s = this.style.lineWidth
        if (i.polyline)
          for (var l = 0, u = 0; u < a.length; ) {
            var c = a[u++]
            if (c > 0)
              for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
                var p = a[u++],
                  g = a[u++]
                if (Es(h, f, p, g, s, e, n)) return l
              }
            l++
          }
        else
          for (var l = 0, u = 0; u < a.length; ) {
            var h = a[u++],
              f = a[u++],
              p = a[u++],
              g = a[u++]
            if (o > 0) {
              var v = (h + p) / 2 - (f - g) * o,
                m = (f + g) / 2 - (p - h) * o
              if (Jz(h, f, v, m, p, g, s, e, n)) return l
            } else if (Es(h, f, p, g, s, e, n)) return l
            l++
          }
        return -1
      }),
      (t.prototype.contain = function (e, n) {
        var i = this.transformCoordToLocal(e, n),
          a = this.getBoundingRect()
        if (((e = i[0]), (n = i[1]), a.contain(e, n))) {
          var o = (this.hoverDataIdx = this.findDataIndex(e, n))
          return o >= 0
        }
        return (this.hoverDataIdx = -1), !1
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect
        if (!e) {
          for (
            var n = this.shape,
              i = n.segs,
              a = 1 / 0,
              o = 1 / 0,
              s = -1 / 0,
              l = -1 / 0,
              u = 0;
            u < i.length;

          ) {
            var c = i[u++],
              h = i[u++]
            ;(a = Math.min(c, a)),
              (s = Math.max(c, s)),
              (o = Math.min(h, o)),
              (l = Math.max(h, l))
          }
          e = this._rect = new ee(a, o, s, l)
        }
        return e
      }),
      t
    )
  })(oe),
  Hvt = (function () {
    function r() {
      this.group = new Ht()
    }
    return (
      (r.prototype.updateData = function (t) {
        this._clear()
        var e = this._create()
        e.setShape({
          segs: t.getLayout('linesPoints'),
        }),
          this._setCommon(e, t)
      }),
      (r.prototype.incrementalPrepareUpdate = function (t) {
        this.group.removeAll(), this._clear()
      }),
      (r.prototype.incrementalUpdate = function (t, e) {
        var n = this._newAdded[0],
          i = e.getLayout('linesPoints'),
          a = n && n.shape.segs
        if (a && a.length < 2e4) {
          var o = a.length,
            s = new Float32Array(o + i.length)
          s.set(a),
            s.set(i, o),
            n.setShape({
              segs: s,
            })
        } else {
          this._newAdded = []
          var l = this._create()
          ;(l.incremental = !0),
            l.setShape({
              segs: i,
            }),
            this._setCommon(l, e),
            (l.__startIndex = t.start)
        }
      }),
      (r.prototype.remove = function () {
        this._clear()
      }),
      (r.prototype.eachRendered = function (t) {
        this._newAdded[0] && t(this._newAdded[0])
      }),
      (r.prototype._create = function () {
        var t = new Gvt({
          cursor: 'default',
          ignoreCoarsePointer: !0,
        })
        return this._newAdded.push(t), this.group.add(t), t
      }),
      (r.prototype._setCommon = function (t, e, n) {
        var i = e.hostModel
        t.setShape({
          polyline: i.get('polyline'),
          curveness: i.get(['lineStyle', 'curveness']),
        }),
          t.useStyle(i.getModel('lineStyle').getLineStyle()),
          (t.style.strokeNoScale = !0)
        var a = e.getVisual('style')
        a && a.stroke && t.setStyle('stroke', a.stroke),
          t.setStyle('fill', null)
        var o = Wt(t)
        ;(o.seriesIndex = i.seriesIndex),
          t.on('mousemove', function (s) {
            o.dataIndex = null
            var l = t.hoverDataIdx
            l > 0 && (o.dataIndex = l + t.__startIndex)
          })
      }),
      (r.prototype._clear = function () {
        ;(this._newAdded = []), this.group.removeAll()
      }),
      r
    )
  })()
const Wvt = Hvt
var Xvt = {
  seriesType: 'lines',
  plan: Ef(),
  reset: function (r) {
    var t = r.coordinateSystem
    if (t) {
      var e = r.get('polyline'),
        n = r.pipelineContext.large
      return {
        progress: function (i, a) {
          var o = []
          if (n) {
            var s = void 0,
              l = i.end - i.start
            if (e) {
              for (var u = 0, c = i.start; c < i.end; c++)
                u += r.getLineCoordsCount(c)
              s = new Float32Array(l + u * 2)
            } else s = new Float32Array(l * 4)
            for (var h = 0, f = [], c = i.start; c < i.end; c++) {
              var d = r.getLineCoords(c, o)
              e && (s[h++] = d)
              for (var p = 0; p < d; p++)
                (f = t.dataToPoint(o[p], !1, f)),
                  (s[h++] = f[0]),
                  (s[h++] = f[1])
            }
            a.setLayout('linesPoints', s)
          } else
            for (var c = i.start; c < i.end; c++) {
              var g = a.getItemModel(c),
                d = r.getLineCoords(c, o),
                v = []
              if (e) for (var m = 0; m < d; m++) v.push(t.dataToPoint(o[m]))
              else {
                ;(v[0] = t.dataToPoint(o[0])), (v[1] = t.dataToPoint(o[1]))
                var y = g.get(['lineStyle', 'curveness'])
                ;+y &&
                  (v[2] = [
                    (v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y,
                    (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y,
                  ])
              }
              a.setItemLayout(c, v)
            }
        },
      }
    }
  },
}
const Z4 = Xvt
var Yvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this._updateLineDraw(a, e),
        s = e.get('zlevel'),
        l = e.get(['effect', 'trailLength']),
        u = i.getZr(),
        c = u.painter.getType() === 'svg'
      c || u.painter.getLayer(s).clear(!0),
        this._lastZlevel != null &&
          !c &&
          u.configLayer(this._lastZlevel, {
            motionBlur: !1,
          }),
        this._showEffect(e) &&
          l > 0 &&
          (c ||
            u.configLayer(s, {
              motionBlur: !0,
              lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0),
            })),
        o.updateData(a)
      var h = e.get('clip', !0) && Ev(e.coordinateSystem, !1, e)
      h ? this.group.setClipPath(h) : this.group.removeClipPath(),
        (this._lastZlevel = s),
        (this._finished = !0)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      var a = e.getData(),
        o = this._updateLineDraw(a, e)
      o.incrementalPrepareUpdate(a), this._clearLayer(i), (this._finished = !1)
    }),
    (t.prototype.incrementalRender = function (e, n, i) {
      this._lineDraw.incrementalUpdate(e, n.getData()),
        (this._finished = e.end === n.getData().count())
    }),
    (t.prototype.eachRendered = function (e) {
      this._lineDraw && this._lineDraw.eachRendered(e)
    }),
    (t.prototype.updateTransform = function (e, n, i) {
      var a = e.getData(),
        o = e.pipelineContext
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0,
        }
      var s = Z4.reset(e, n, i)
      s.progress &&
        s.progress(
          {
            start: 0,
            end: a.count(),
            count: a.count(),
          },
          a,
        ),
        this._lineDraw.updateLayout(),
        this._clearLayer(i)
    }),
    (t.prototype._updateLineDraw = function (e, n) {
      var i = this._lineDraw,
        a = this._showEffect(n),
        o = !!n.get('polyline'),
        s = n.pipelineContext,
        l = s.large
      return (
        (!i ||
          a !== this._hasEffet ||
          o !== this._isPolyline ||
          l !== this._isLargeDraw) &&
          (i && i.remove(),
          (i = this._lineDraw =
            l ? new Wvt() : new QC(o ? (a ? Uvt : q4) : a ? $4 : JC)),
          (this._hasEffet = a),
          (this._isPolyline = o),
          (this._isLargeDraw = l)),
        this.group.add(i.group),
        i
      )
    }),
    (t.prototype._showEffect = function (e) {
      return !!e.get(['effect', 'show'])
    }),
    (t.prototype._clearLayer = function (e) {
      var n = e.getZr(),
        i = n.painter.getType() === 'svg'
      !i &&
        this._lastZlevel != null &&
        n.painter.getLayer(this._lastZlevel).clear(!0)
    }),
    (t.prototype.remove = function (e, n) {
      this._lineDraw && this._lineDraw.remove(),
        (this._lineDraw = null),
        this._clearLayer(n)
    }),
    (t.prototype.dispose = function (e, n) {
      this.remove(e, n)
    }),
    (t.type = 'lines'),
    t
  )
})(Ze)
const $vt = Yvt
var qvt = typeof Uint32Array > 'u' ? Array : Uint32Array,
  Zvt = typeof Float64Array > 'u' ? Array : Float64Array
function yN(r) {
  var t = r.data
  t &&
    t[0] &&
    t[0][0] &&
    t[0][0].coord &&
    (r.data = st(t, function (e) {
      var n = [e[0].coord, e[1].coord],
        i = {
          coords: n,
        }
      return (
        e[0].name && (i.fromName = e[0].name),
        e[1].name && (i.toName = e[1].name),
        ET([i, e[0], e[1]])
      )
    }))
}
var Kvt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.visualStyleAccessPath = 'lineStyle'),
      (e.visualDrawType = 'stroke'),
      e
    )
  }
  return (
    (t.prototype.init = function (e) {
      ;(e.data = e.data || []), yN(e)
      var n = this._processFlatCoordsArray(e.data)
      ;(this._flatCoords = n.flatCoords),
        (this._flatCoordsOffset = n.flatCoordsOffset),
        n.flatCoords && (e.data = new Float32Array(n.count)),
        r.prototype.init.apply(this, arguments)
    }),
    (t.prototype.mergeOption = function (e) {
      if ((yN(e), e.data)) {
        var n = this._processFlatCoordsArray(e.data)
        ;(this._flatCoords = n.flatCoords),
          (this._flatCoordsOffset = n.flatCoordsOffset),
          n.flatCoords && (e.data = new Float32Array(n.count))
      }
      r.prototype.mergeOption.apply(this, arguments)
    }),
    (t.prototype.appendData = function (e) {
      var n = this._processFlatCoordsArray(e.data)
      n.flatCoords &&
        (this._flatCoords
          ? ((this._flatCoords = ky(this._flatCoords, n.flatCoords)),
            (this._flatCoordsOffset = ky(
              this._flatCoordsOffset,
              n.flatCoordsOffset,
            )))
          : ((this._flatCoords = n.flatCoords),
            (this._flatCoordsOffset = n.flatCoordsOffset)),
        (e.data = new Float32Array(n.count))),
        this.getRawData().appendData(e.data)
    }),
    (t.prototype._getCoordsFromItemModel = function (e) {
      var n = this.getData().getItemModel(e),
        i = n.option instanceof Array ? n.option : n.getShallow('coords')
      return i
    }),
    (t.prototype.getLineCoordsCount = function (e) {
      return this._flatCoordsOffset
        ? this._flatCoordsOffset[e * 2 + 1]
        : this._getCoordsFromItemModel(e).length
    }),
    (t.prototype.getLineCoords = function (e, n) {
      if (this._flatCoordsOffset) {
        for (
          var i = this._flatCoordsOffset[e * 2],
            a = this._flatCoordsOffset[e * 2 + 1],
            o = 0;
          o < a;
          o++
        )
          (n[o] = n[o] || []),
            (n[o][0] = this._flatCoords[i + o * 2]),
            (n[o][1] = this._flatCoords[i + o * 2 + 1])
        return a
      } else {
        for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++)
          (n[o] = n[o] || []), (n[o][0] = s[o][0]), (n[o][1] = s[o][1])
        return s.length
      }
    }),
    (t.prototype._processFlatCoordsArray = function (e) {
      var n = 0
      if ((this._flatCoords && (n = this._flatCoords.length), be(e[0]))) {
        for (
          var i = e.length,
            a = new qvt(i),
            o = new Zvt(i),
            s = 0,
            l = 0,
            u = 0,
            c = 0;
          c < i;

        ) {
          u++
          var h = e[c++]
          ;(a[l++] = s + n), (a[l++] = h)
          for (var f = 0; f < h; f++) {
            var d = e[c++],
              p = e[c++]
            ;(o[s++] = d), (o[s++] = p)
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u,
        }
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: e.length,
      }
    }),
    (t.prototype.getInitialData = function (e, n) {
      var i = new Vr(['value'], this)
      return (
        (i.hasItemOption = !1),
        i.initData(e.data, [], function (a, o, s, l) {
          if (a instanceof Array) return NaN
          i.hasItemOption = !0
          var u = a.value
          if (u != null) return u instanceof Array ? u[l] : u
        }),
        i
      )
    }),
    (t.prototype.formatTooltip = function (e, n, i) {
      var a = this.getData(),
        o = a.getItemModel(e),
        s = o.get('name')
      if (s) return s
      var l = o.get('fromName'),
        u = o.get('toName'),
        c = []
      return (
        l != null && c.push(l),
        u != null && c.push(u),
        Kn('nameValue', {
          name: c.join(' > '),
        })
      )
    }),
    (t.prototype.preventIncremental = function () {
      return !!this.get(['effect', 'show'])
    }),
    (t.prototype.getProgressive = function () {
      var e = this.option.progressive
      return e ?? (this.option.large ? 1e4 : this.get('progressive'))
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.option.progressiveThreshold
      return e ?? (this.option.large ? 2e4 : this.get('progressiveThreshold'))
    }),
    (t.prototype.getZLevelKey = function () {
      var e = this.getModel('effect'),
        n = e.get('trailLength')
      return this.getData().count() > this.getProgressiveThreshold()
        ? this.id
        : e.get('show') && n > 0
        ? n + ''
        : ''
    }),
    (t.type = 'series.lines'),
    (t.dependencies = ['grid', 'polar', 'geo', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'geo',
      z: 2,
      legendHoverLink: !0,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ['none', 'none'],
      symbolSize: [10, 10],
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: 'circle',
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2,
      },
      large: !1,
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: 'end',
      },
      lineStyle: {
        opacity: 0.5,
      },
    }),
    t
  )
})(rn)
const jvt = Kvt
function Sm(r) {
  return r instanceof Array || (r = [r, r]), r
}
var Jvt = {
  seriesType: 'lines',
  reset: function (r) {
    var t = Sm(r.get('symbol')),
      e = Sm(r.get('symbolSize')),
      n = r.getData()
    n.setVisual('fromSymbol', t && t[0]),
      n.setVisual('toSymbol', t && t[1]),
      n.setVisual('fromSymbolSize', e && e[0]),
      n.setVisual('toSymbolSize', e && e[1])
    function i(a, o) {
      var s = a.getItemModel(o),
        l = Sm(s.getShallow('symbol', !0)),
        u = Sm(s.getShallow('symbolSize', !0))
      l[0] && a.setItemVisual(o, 'fromSymbol', l[0]),
        l[1] && a.setItemVisual(o, 'toSymbol', l[1]),
        u[0] && a.setItemVisual(o, 'fromSymbolSize', u[0]),
        u[1] && a.setItemVisual(o, 'toSymbolSize', u[1])
    }
    return {
      dataEach: n.hasItemOption ? i : null,
    }
  },
}
const Qvt = Jvt
function tgt(r) {
  r.registerChartView($vt),
    r.registerSeriesModel(jvt),
    r.registerLayout(Z4),
    r.registerVisual(Qvt)
}
var egt = 256,
  ngt = (function () {
    function r() {
      ;(this.blurSize = 30),
        (this.pointSize = 20),
        (this.maxOpacity = 1),
        (this.minOpacity = 0),
        (this._gradientPixels = {
          inRange: null,
          outOfRange: null,
        })
      var t = rl.createCanvas()
      this.canvas = t
    }
    return (
      (r.prototype.update = function (t, e, n, i, a, o) {
        var s = this._getBrush(),
          l = this._getGradient(a, 'inRange'),
          u = this._getGradient(a, 'outOfRange'),
          c = this.pointSize + this.blurSize,
          h = this.canvas,
          f = h.getContext('2d'),
          d = t.length
        ;(h.width = e), (h.height = n)
        for (var p = 0; p < d; ++p) {
          var g = t[p],
            v = g[0],
            m = g[1],
            y = g[2],
            _ = i(y)
          ;(f.globalAlpha = _), f.drawImage(s, v - c, m - c)
        }
        if (!h.width || !h.height) return h
        for (
          var x = f.getImageData(0, 0, h.width, h.height),
            A = x.data,
            S = 0,
            b = A.length,
            T = this.minOpacity,
            w = this.maxOpacity,
            M = w - T;
          S < b;

        ) {
          var _ = A[S + 3] / 256,
            C = Math.floor(_ * (egt - 1)) * 4
          if (_ > 0) {
            var E = o(_) ? l : u
            _ > 0 && (_ = _ * M + T),
              (A[S++] = E[C]),
              (A[S++] = E[C + 1]),
              (A[S++] = E[C + 2]),
              (A[S++] = E[C + 3] * _ * 256)
          } else S += 4
        }
        return f.putImageData(x, 0, 0), h
      }),
      (r.prototype._getBrush = function () {
        var t = this._brushCanvas || (this._brushCanvas = rl.createCanvas()),
          e = this.pointSize + this.blurSize,
          n = e * 2
        ;(t.width = n), (t.height = n)
        var i = t.getContext('2d')
        return (
          i.clearRect(0, 0, n, n),
          (i.shadowOffsetX = n),
          (i.shadowBlur = this.blurSize),
          (i.shadowColor = '#000'),
          i.beginPath(),
          i.arc(-e, e, this.pointSize, 0, Math.PI * 2, !0),
          i.closePath(),
          i.fill(),
          t
        )
      }),
      (r.prototype._getGradient = function (t, e) {
        for (
          var n = this._gradientPixels,
            i = n[e] || (n[e] = new Uint8ClampedArray(256 * 4)),
            a = [0, 0, 0, 0],
            o = 0,
            s = 0;
          s < 256;
          s++
        )
          t[e](s / 255, !0, a),
            (i[o++] = a[0]),
            (i[o++] = a[1]),
            (i[o++] = a[2]),
            (i[o++] = a[3])
        return i
      }),
      r
    )
  })()
const rgt = ngt
function igt(r, t, e) {
  var n = r[1] - r[0]
  t = st(t, function (o) {
    return {
      interval: [(o.interval[0] - r[0]) / n, (o.interval[1] - r[0]) / n],
    }
  })
  var i = t.length,
    a = 0
  return function (o) {
    var s
    for (s = a; s < i; s++) {
      var l = t[s].interval
      if (l[0] <= o && o <= l[1]) {
        a = s
        break
      }
    }
    if (s === i)
      for (s = a - 1; s >= 0; s--) {
        var l = t[s].interval
        if (l[0] <= o && o <= l[1]) {
          a = s
          break
        }
      }
    return s >= 0 && s < i && e[s]
  }
}
function agt(r, t) {
  var e = r[1] - r[0]
  return (
    (t = [(t[0] - r[0]) / e, (t[1] - r[0]) / e]),
    function (n) {
      return n >= t[0] && n <= t[1]
    }
  )
}
function _N(r) {
  var t = r.dimensions
  return t[0] === 'lng' && t[1] === 'lat'
}
var ogt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a
      n.eachComponent('visualMap', function (s) {
        s.eachTargetSeries(function (l) {
          l === e && (a = s)
        })
      }),
        (this._progressiveEls = null),
        this.group.removeAll()
      var o = e.coordinateSystem
      o.type === 'cartesian2d' || o.type === 'calendar'
        ? this._renderOnCartesianAndCalendar(e, i, 0, e.getData().count())
        : _N(o) && this._renderOnGeo(o, e, a, i)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      this.group.removeAll()
    }),
    (t.prototype.incrementalRender = function (e, n, i, a) {
      var o = n.coordinateSystem
      o &&
        (_N(o)
          ? this.render(n, i, a)
          : ((this._progressiveEls = []),
            this._renderOnCartesianAndCalendar(n, a, e.start, e.end, !0)))
    }),
    (t.prototype.eachRendered = function (e) {
      vl(this._progressiveEls || this.group, e)
    }),
    (t.prototype._renderOnCartesianAndCalendar = function (e, n, i, a, o) {
      var s = e.coordinateSystem,
        l = oc(s, 'cartesian2d'),
        u,
        c,
        h,
        f
      if (l) {
        var d = s.getAxis('x'),
          p = s.getAxis('y')
        ;(u = d.getBandWidth() + 0.5),
          (c = p.getBandWidth() + 0.5),
          (h = d.scale.getExtent()),
          (f = p.scale.getExtent())
      }
      for (
        var g = this.group,
          v = e.getData(),
          m = e.getModel(['emphasis', 'itemStyle']).getItemStyle(),
          y = e.getModel(['blur', 'itemStyle']).getItemStyle(),
          _ = e.getModel(['select', 'itemStyle']).getItemStyle(),
          x = e.get(['itemStyle', 'borderRadius']),
          A = Zn(e),
          S = e.getModel('emphasis'),
          b = S.get('focus'),
          T = S.get('blurScope'),
          w = S.get('disabled'),
          M = l
            ? [
                v.mapDimension('x'),
                v.mapDimension('y'),
                v.mapDimension('value'),
              ]
            : [v.mapDimension('time'), v.mapDimension('value')],
          C = i;
        C < a;
        C++
      ) {
        var E = void 0,
          D = v.getItemVisual(C, 'style')
        if (l) {
          var P = v.get(M[0], C),
            L = v.get(M[1], C)
          if (
            isNaN(v.get(M[2], C)) ||
            isNaN(P) ||
            isNaN(L) ||
            P < h[0] ||
            P > h[1] ||
            L < f[0] ||
            L > f[1]
          )
            continue
          var I = s.dataToPoint([P, L])
          E = new ge({
            shape: {
              x: I[0] - u / 2,
              y: I[1] - c / 2,
              width: u,
              height: c,
            },
            style: D,
          })
        } else {
          if (isNaN(v.get(M[1], C))) continue
          E = new ge({
            z2: 1,
            shape: s.dataToRect([v.get(M[0], C)]).contentShape,
            style: D,
          })
        }
        if (v.hasItemOption) {
          var F = v.getItemModel(C),
            k = F.getModel('emphasis')
          ;(m = k.getModel('itemStyle').getItemStyle()),
            (y = F.getModel(['blur', 'itemStyle']).getItemStyle()),
            (_ = F.getModel(['select', 'itemStyle']).getItemStyle()),
            (x = F.get(['itemStyle', 'borderRadius'])),
            (b = k.get('focus')),
            (T = k.get('blurScope')),
            (w = k.get('disabled')),
            (A = Zn(F))
        }
        E.shape.r = x
        var V = e.getRawValue(C),
          H = '-'
        V && V[2] != null && (H = V[2] + ''),
          mr(E, A, {
            labelFetcher: e,
            labelDataIndex: C,
            defaultOpacity: D.opacity,
            defaultText: H,
          }),
          (E.ensureState('emphasis').style = m),
          (E.ensureState('blur').style = y),
          (E.ensureState('select').style = _),
          fn(E, b, T, w),
          (E.incremental = o),
          o && (E.states.emphasis.hoverLayer = !0),
          g.add(E),
          v.setItemGraphicEl(C, E),
          this._progressiveEls && this._progressiveEls.push(E)
      }
    }),
    (t.prototype._renderOnGeo = function (e, n, i, a) {
      var o = i.targetVisuals.inRange,
        s = i.targetVisuals.outOfRange,
        l = n.getData(),
        u = this._hmLayer || this._hmLayer || new rgt()
      ;(u.blurSize = n.get('blurSize')),
        (u.pointSize = n.get('pointSize')),
        (u.minOpacity = n.get('minOpacity')),
        (u.maxOpacity = n.get('maxOpacity'))
      var c = e.getViewRect().clone(),
        h = e.getRoamTransform()
      c.applyTransform(h)
      var f = Math.max(c.x, 0),
        d = Math.max(c.y, 0),
        p = Math.min(c.width + c.x, a.getWidth()),
        g = Math.min(c.height + c.y, a.getHeight()),
        v = p - f,
        m = g - d,
        y = [
          l.mapDimension('lng'),
          l.mapDimension('lat'),
          l.mapDimension('value'),
        ],
        _ = l.mapArray(y, function (b, T, w) {
          var M = e.dataToPoint([b, T])
          return (M[0] -= f), (M[1] -= d), M.push(w), M
        }),
        x = i.getExtent(),
        A =
          i.type === 'visualMap.continuous'
            ? agt(x, i.option.range)
            : igt(x, i.getPieceList(), i.option.selected)
      u.update(
        _,
        v,
        m,
        o.color.getNormalizer(),
        {
          inRange: o.color.getColorMapper(),
          outOfRange: s.color.getColorMapper(),
        },
        A,
      )
      var S = new yr({
        style: {
          width: v,
          height: m,
          x: f,
          y: d,
          image: u.canvas,
        },
        silent: !0,
      })
      this.group.add(S)
    }),
    (t.type = 'heatmap'),
    t
  )
})(Ze)
const sgt = ogt
var lgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      return as(null, this, {
        generateCoord: 'value',
      })
    }),
    (t.prototype.preventIncremental = function () {
      var e = Av.get(this.get('coordinateSystem'))
      if (e && e.dimensions)
        return e.dimensions[0] === 'lng' && e.dimensions[1] === 'lat'
    }),
    (t.type = 'series.heatmap'),
    (t.dependencies = ['grid', 'geo', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'cartesian2d',
      z: 2,
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    }),
    t
  )
})(rn)
const ugt = lgt
function cgt(r) {
  r.registerChartView(sgt), r.registerSeriesModel(ugt)
}
var hgt = ['itemStyle', 'borderWidth'],
  xN = [
    {
      xy: 'x',
      wh: 'width',
      index: 0,
      posDesc: ['left', 'right'],
    },
    {
      xy: 'y',
      wh: 'height',
      index: 1,
      posDesc: ['top', 'bottom'],
    },
  ],
  BS = new pl(),
  fgt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a = this.group,
          o = e.getData(),
          s = this._data,
          l = e.coordinateSystem,
          u = l.getBaseAxis(),
          c = u.isHorizontal(),
          h = l.master.getRect(),
          f = {
            ecSize: {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            seriesModel: e,
            coordSys: l,
            coordSysExtent: [
              [h.x, h.x + h.width],
              [h.y, h.y + h.height],
            ],
            isHorizontal: c,
            valueDim: xN[+c],
            categoryDim: xN[1 - +c],
          }
        o.diff(s)
          .add(function (p) {
            if (o.hasValue(p)) {
              var g = AN(o, p),
                v = SN(o, p, g, f),
                m = bN(o, f, v)
              o.setItemGraphicEl(p, m), a.add(m), MN(m, f, v)
            }
          })
          .update(function (p, g) {
            var v = s.getItemGraphicEl(g)
            if (!o.hasValue(p)) {
              a.remove(v)
              return
            }
            var m = AN(o, p),
              y = SN(o, p, m, f),
              _ = eH(o, y)
            v &&
              _ !== v.__pictorialShapeStr &&
              (a.remove(v), o.setItemGraphicEl(p, null), (v = null)),
              v ? _gt(v, f, y) : (v = bN(o, f, y, !0)),
              o.setItemGraphicEl(p, v),
              (v.__pictorialSymbolMeta = y),
              a.add(v),
              MN(v, f, y)
          })
          .remove(function (p) {
            var g = s.getItemGraphicEl(p)
            g && wN(s, p, g.__pictorialSymbolMeta.animationModel, g)
          })
          .execute()
        var d = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
        return (
          d ? a.setClipPath(d) : a.removeClipPath(),
          (this._data = o),
          this.group
        )
      }),
      (t.prototype.remove = function (e, n) {
        var i = this.group,
          a = this._data
        e.get('animation')
          ? a &&
            a.eachItemGraphicEl(function (o) {
              wN(a, Wt(o).dataIndex, e, o)
            })
          : i.removeAll()
      }),
      (t.type = 'pictorialBar'),
      t
    )
  })(Ze)
function SN(r, t, e, n) {
  var i = r.getItemLayout(t),
    a = e.get('symbolRepeat'),
    o = e.get('symbolClip'),
    s = e.get('symbolPosition') || 'start',
    l = e.get('symbolRotate'),
    u = ((l || 0) * Math.PI) / 180 || 0,
    c = e.get('symbolPatternSize') || 2,
    h = e.isAnimationEnabled(),
    f = {
      dataIndex: t,
      layout: i,
      itemModel: e,
      symbolType: r.getItemVisual(t, 'symbol') || 'circle',
      style: r.getItemVisual(t, 'style'),
      symbolClip: o,
      symbolRepeat: a,
      symbolRepeatDirection: e.get('symbolRepeatDirection'),
      symbolPatternSize: c,
      rotation: u,
      animationModel: h ? e : null,
      hoverScale: h && e.get(['emphasis', 'scale']),
      z2: e.getShallow('z', !0) || 0,
    }
  dgt(e, a, i, n, f),
    pgt(r, t, i, a, o, f.boundingLength, f.pxSign, c, n, f),
    vgt(e, f.symbolScale, u, n, f)
  var d = f.symbolSize,
    p = ic(e.get('symbolOffset'), d)
  return (
    ggt(
      e,
      d,
      i,
      a,
      o,
      p,
      s,
      f.valueLineWidth,
      f.boundingLength,
      f.repeatCutLength,
      n,
      f,
    ),
    f
  )
}
function dgt(r, t, e, n, i) {
  var a = n.valueDim,
    o = r.get('symbolBoundingData'),
    s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()),
    l = s.toGlobalCoord(s.dataToCoord(0)),
    u = 1 - +(e[a.wh] <= 0),
    c
  if (at(o)) {
    var h = [FS(s, o[0]) - l, FS(s, o[1]) - l]
    h[1] < h[0] && h.reverse(), (c = h[u])
  } else
    o != null
      ? (c = FS(s, o) - l)
      : t
      ? (c = n.coordSysExtent[a.index][u] - l)
      : (c = e[a.wh])
  ;(i.boundingLength = c),
    t && (i.repeatCutLength = e[a.wh]),
    (i.pxSign = c > 0 ? 1 : -1)
}
function FS(r, t) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(t)))
}
function pgt(r, t, e, n, i, a, o, s, l, u) {
  var c = l.valueDim,
    h = l.categoryDim,
    f = Math.abs(e[h.wh]),
    d = r.getItemVisual(t, 'symbolSize'),
    p
  at(d) ? (p = d.slice()) : d == null ? (p = ['100%', '100%']) : (p = [d, d]),
    (p[h.index] = _t(p[h.index], f)),
    (p[c.index] = _t(p[c.index], n ? f : Math.abs(a))),
    (u.symbolSize = p)
  var g = (u.symbolScale = [p[0] / s, p[1] / s])
  g[c.index] *= (l.isHorizontal ? -1 : 1) * o
}
function vgt(r, t, e, n, i) {
  var a = r.get(hgt) || 0
  a &&
    (BS.attr({
      scaleX: t[0],
      scaleY: t[1],
      rotation: e,
    }),
    BS.updateTransform(),
    (a /= BS.getLineScale()),
    (a *= t[n.valueDim.index])),
    (i.valueLineWidth = a || 0)
}
function ggt(r, t, e, n, i, a, o, s, l, u, c, h) {
  var f = c.categoryDim,
    d = c.valueDim,
    p = h.pxSign,
    g = Math.max(t[d.index] + s, 0),
    v = g
  if (n) {
    var m = Math.abs(l),
      y = nr(r.get('symbolMargin'), '15%') + '',
      _ = !1
    y.lastIndexOf('!') === y.length - 1 &&
      ((_ = !0), (y = y.slice(0, y.length - 1)))
    var x = _t(y, t[d.index]),
      A = Math.max(g + x * 2, 0),
      S = _ ? 0 : x * 2,
      b = Fz(n),
      T = b ? n : TN((m + S) / A),
      w = m - T * g
    ;(x = w / 2 / (_ ? T : Math.max(T - 1, 1))),
      (A = g + x * 2),
      (S = _ ? 0 : x * 2),
      !b && n !== 'fixed' && (T = u ? TN((Math.abs(u) + S) / A) : 0),
      (v = T * A - S),
      (h.repeatTimes = T),
      (h.symbolMargin = x)
  }
  var M = p * (v / 2),
    C = (h.pathPosition = [])
  ;(C[f.index] = e[f.wh] / 2),
    (C[d.index] = o === 'start' ? M : o === 'end' ? l - M : l / 2),
    a && ((C[0] += a[0]), (C[1] += a[1]))
  var E = (h.bundlePosition = [])
  ;(E[f.index] = e[f.xy]), (E[d.index] = e[d.xy])
  var D = (h.barRectShape = Q({}, e))
  ;(D[d.wh] = p * Math.max(Math.abs(e[d.wh]), Math.abs(C[d.index] + M))),
    (D[f.wh] = e[f.wh])
  var P = (h.clipShape = {})
  ;(P[f.xy] = -e[f.xy]),
    (P[f.wh] = c.ecSize[f.wh]),
    (P[d.xy] = 0),
    (P[d.wh] = e[d.wh])
}
function K4(r) {
  var t = r.symbolPatternSize,
    e = Rn(r.symbolType, -t / 2, -t / 2, t, t)
  return (
    e.attr({
      culling: !0,
    }),
    e.type !== 'image' &&
      e.setStyle({
        strokeNoScale: !0,
      }),
    e
  )
}
function j4(r, t, e, n) {
  var i = r.__pictorialBundle,
    a = e.symbolSize,
    o = e.valueLineWidth,
    s = e.pathPosition,
    l = t.valueDim,
    u = e.repeatTimes || 0,
    c = 0,
    h = a[t.valueDim.index] + o + e.symbolMargin * 2
  for (
    sE(r, function (g) {
      ;(g.__pictorialAnimationIndex = c),
        (g.__pictorialRepeatTimes = u),
        c < u
          ? kh(g, null, p(c), e, n)
          : kh(
              g,
              null,
              {
                scaleX: 0,
                scaleY: 0,
              },
              e,
              n,
              function () {
                i.remove(g)
              },
            ),
        c++
    });
    c < u;
    c++
  ) {
    var f = K4(e)
    ;(f.__pictorialAnimationIndex = c), (f.__pictorialRepeatTimes = u), i.add(f)
    var d = p(c)
    kh(
      f,
      {
        x: d.x,
        y: d.y,
        scaleX: 0,
        scaleY: 0,
      },
      {
        scaleX: d.scaleX,
        scaleY: d.scaleY,
        rotation: d.rotation,
      },
      e,
      n,
    )
  }
  function p(g) {
    var v = s.slice(),
      m = e.pxSign,
      y = g
    return (
      (e.symbolRepeatDirection === 'start' ? m > 0 : m < 0) && (y = u - 1 - g),
      (v[l.index] = h * (y - u / 2 + 0.5) + s[l.index]),
      {
        x: v[0],
        y: v[1],
        scaleX: e.symbolScale[0],
        scaleY: e.symbolScale[1],
        rotation: e.rotation,
      }
    )
  }
}
function J4(r, t, e, n) {
  var i = r.__pictorialBundle,
    a = r.__pictorialMainPath
  a
    ? kh(
        a,
        null,
        {
          x: e.pathPosition[0],
          y: e.pathPosition[1],
          scaleX: e.symbolScale[0],
          scaleY: e.symbolScale[1],
          rotation: e.rotation,
        },
        e,
        n,
      )
    : ((a = r.__pictorialMainPath = K4(e)),
      i.add(a),
      kh(
        a,
        {
          x: e.pathPosition[0],
          y: e.pathPosition[1],
          scaleX: 0,
          scaleY: 0,
          rotation: e.rotation,
        },
        {
          scaleX: e.symbolScale[0],
          scaleY: e.symbolScale[1],
        },
        e,
        n,
      ))
}
function Q4(r, t, e) {
  var n = Q({}, t.barRectShape),
    i = r.__pictorialBarRect
  i
    ? kh(
        i,
        null,
        {
          shape: n,
        },
        t,
        e,
      )
    : ((i = r.__pictorialBarRect =
        new ge({
          z2: 2,
          shape: n,
          silent: !0,
          style: {
            stroke: 'transparent',
            fill: 'transparent',
            lineWidth: 0,
          },
        })),
      (i.disableMorphing = !0),
      r.add(i))
}
function tH(r, t, e, n) {
  if (e.symbolClip) {
    var i = r.__pictorialClipPath,
      a = Q({}, e.clipShape),
      o = t.valueDim,
      s = e.animationModel,
      l = e.dataIndex
    if (i)
      we(
        i,
        {
          shape: a,
        },
        s,
        l,
      )
    else {
      ;(a[o.wh] = 0),
        (i = new ge({
          shape: a,
        })),
        r.__pictorialBundle.setClipPath(i),
        (r.__pictorialClipPath = i)
      var u = {}
      ;(u[o.wh] = e.clipShape[o.wh]),
        nc[n ? 'updateProps' : 'initProps'](
          i,
          {
            shape: u,
          },
          s,
          l,
        )
    }
  }
}
function AN(r, t) {
  var e = r.getItemModel(t)
  return (e.getAnimationDelayParams = mgt), (e.isAnimationEnabled = ygt), e
}
function mgt(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes,
  }
}
function ygt() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation')
}
function bN(r, t, e, n) {
  var i = new Ht(),
    a = new Ht()
  return (
    i.add(a),
    (i.__pictorialBundle = a),
    (a.x = e.bundlePosition[0]),
    (a.y = e.bundlePosition[1]),
    e.symbolRepeat ? j4(i, t, e) : J4(i, t, e),
    Q4(i, e, n),
    tH(i, t, e, n),
    (i.__pictorialShapeStr = eH(r, e)),
    (i.__pictorialSymbolMeta = e),
    i
  )
}
function _gt(r, t, e) {
  var n = e.animationModel,
    i = e.dataIndex,
    a = r.__pictorialBundle
  we(
    a,
    {
      x: e.bundlePosition[0],
      y: e.bundlePosition[1],
    },
    n,
    i,
  ),
    e.symbolRepeat ? j4(r, t, e, !0) : J4(r, t, e, !0),
    Q4(r, e, !0),
    tH(r, t, e, !0)
}
function wN(r, t, e, n) {
  var i = n.__pictorialBarRect
  i && i.removeTextContent()
  var a = []
  sE(n, function (o) {
    a.push(o)
  }),
    n.__pictorialMainPath && a.push(n.__pictorialMainPath),
    n.__pictorialClipPath && (e = null),
    R(a, function (o) {
      al(
        o,
        {
          scaleX: 0,
          scaleY: 0,
        },
        e,
        t,
        function () {
          n.parent && n.parent.remove(n)
        },
      )
    }),
    r.setItemGraphicEl(t, null)
}
function eH(r, t) {
  return [
    r.getItemVisual(t.dataIndex, 'symbol') || 'none',
    !!t.symbolRepeat,
    !!t.symbolClip,
  ].join(':')
}
function sE(r, t, e) {
  R(r.__pictorialBundle.children(), function (n) {
    n !== r.__pictorialBarRect && t.call(e, n)
  })
}
function kh(r, t, e, n, i, a) {
  t && r.attr(t),
    n.symbolClip && !i
      ? e && r.attr(e)
      : e &&
        nc[i ? 'updateProps' : 'initProps'](
          r,
          e,
          n.animationModel,
          n.dataIndex,
          a,
        )
}
function MN(r, t, e) {
  var n = e.dataIndex,
    i = e.itemModel,
    a = i.getModel('emphasis'),
    o = a.getModel('itemStyle').getItemStyle(),
    s = i.getModel(['blur', 'itemStyle']).getItemStyle(),
    l = i.getModel(['select', 'itemStyle']).getItemStyle(),
    u = i.getShallow('cursor'),
    c = a.get('focus'),
    h = a.get('blurScope'),
    f = a.get('scale')
  sE(r, function (g) {
    if (g instanceof yr) {
      var v = g.style
      g.useStyle(
        Q(
          {
            image: v.image,
            x: v.x,
            y: v.y,
            width: v.width,
            height: v.height,
          },
          e.style,
        ),
      )
    } else g.useStyle(e.style)
    var m = g.ensureState('emphasis')
    ;(m.style = o),
      f && ((m.scaleX = g.scaleX * 1.1), (m.scaleY = g.scaleY * 1.1)),
      (g.ensureState('blur').style = s),
      (g.ensureState('select').style = l),
      u && (g.cursor = u),
      (g.z2 = e.z2)
  })
  var d = t.valueDim.posDesc[+(e.boundingLength > 0)],
    p = r.__pictorialBarRect
  ;(p.ignoreClip = !0),
    mr(p, Zn(i), {
      labelFetcher: t.seriesModel,
      labelDataIndex: n,
      defaultText: of(t.seriesModel.getData(), n),
      inheritColor: e.style.fill,
      defaultOpacity: e.style.opacity,
      defaultOutsidePosition: d,
    }),
    fn(r, c, h, a.get('disabled'))
}
function TN(r) {
  var t = Math.round(r)
  return Math.abs(r - t) < 1e-4 ? t : Math.ceil(r)
}
const xgt = fgt
var Sgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.hasSymbolVisual = !0),
      (e.defaultSymbol = 'roundRect'),
      e
    )
  }
  return (
    (t.prototype.getInitialData = function (e) {
      return (e.stack = null), r.prototype.getInitialData.apply(this, arguments)
    }),
    (t.type = 'series.pictorialBar'),
    (t.dependencies = ['grid']),
    (t.defaultOption = gl(c0.defaultOption, {
      symbol: 'circle',
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: 'end',
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: '-100%',
      clip: !1,
      progressive: 0,
      emphasis: {
        scale: !1,
      },
      select: {
        itemStyle: {
          borderColor: '#212121',
        },
      },
    })),
    t
  )
})(c0)
const Agt = Sgt
function bgt(r) {
  r.registerChartView(xgt),
    r.registerSeriesModel(Agt),
    r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Zt(IV, 'pictorialBar')),
    r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, OV('pictorialBar'))
}
var wgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e._layers = []), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = e.getData(),
        o = this,
        s = this.group,
        l = e.getLayerSeries(),
        u = a.getLayout('layoutInfo'),
        c = u.rect,
        h = u.boundaryGap
      ;(s.x = 0), (s.y = c.y + h[0])
      function f(v) {
        return v.name
      }
      var d = new es(this._layersSeries || [], l, f, f),
        p = []
      d.add(Tt(g, this, 'add'))
        .update(Tt(g, this, 'update'))
        .remove(Tt(g, this, 'remove'))
        .execute()
      function g(v, m, y) {
        var _ = o._layers
        if (v === 'remove') {
          s.remove(_[m])
          return
        }
        for (
          var x = [], A = [], S, b = l[m].indices, T = 0;
          T < b.length;
          T++
        ) {
          var w = a.getItemLayout(b[T]),
            M = w.x,
            C = w.y0,
            E = w.y
          x.push(M, C), A.push(M, C + E), (S = a.getItemVisual(b[T], 'style'))
        }
        var D,
          P = a.getItemLayout(b[0]),
          L = e.getModel('label'),
          I = L.get('margin'),
          F = e.getModel('emphasis')
        if (v === 'add') {
          var k = (p[m] = new Ht())
          ;(D = new wG({
            shape: {
              points: x,
              stackedOnPoints: A,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1,
            },
            z2: 0,
          })),
            k.add(D),
            s.add(k),
            e.isAnimationEnabled() &&
              D.setClipPath(
                Mgt(D.getBoundingRect(), e, function () {
                  D.removeClipPath()
                }),
              )
        } else {
          var k = _[y]
          ;(D = k.childAt(0)),
            s.add(k),
            (p[m] = k),
            we(
              D,
              {
                shape: {
                  points: x,
                  stackedOnPoints: A,
                },
              },
              e,
            ),
            Ca(D)
        }
        mr(
          D,
          Zn(e),
          {
            labelDataIndex: b[T - 1],
            defaultText: a.getName(b[T - 1]),
            inheritColor: S.fill,
          },
          {
            normal: {
              verticalAlign: 'middle',
            },
          },
        ),
          D.setTextConfig({
            position: null,
            local: !0,
          })
        var V = D.getTextContent()
        V && ((V.x = P.x - I), (V.y = P.y0 + P.y / 2)),
          D.useStyle(S),
          a.setItemGraphicEl(m, D),
          gr(D, e),
          fn(D, F.get('focus'), F.get('blurScope'), F.get('disabled'))
      }
      ;(this._layersSeries = l), (this._layers = p)
    }),
    (t.type = 'themeRiver'),
    t
  )
})(Ze)
function Mgt(r, t, e) {
  var n = new ge({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20,
    },
  })
  return (
    Je(
      n,
      {
        shape: {
          x: r.x - 50,
          width: r.width + 100,
          height: r.height + 20,
        },
      },
      t,
      e,
    ),
    n
  )
}
const Tgt = wgt
var zS = 2,
  Cgt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e) {
        r.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new Pv(
            Tt(this.getData, this),
            Tt(this.getRawData, this),
          ))
      }),
      (t.prototype.fixData = function (e) {
        var n = e.length,
          i = {},
          a = jb(e, function (f) {
            return i.hasOwnProperty(f[0] + '') || (i[f[0] + ''] = -1), f[2]
          }),
          o = []
        a.buckets.each(function (f, d) {
          o.push({
            name: d,
            dataList: f,
          })
        })
        for (var s = o.length, l = 0; l < s; ++l) {
          for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
            var h = o[l].dataList[c][0] + ''
            i[h] = l
          }
          for (var h in i)
            i.hasOwnProperty(h) &&
              i[h] !== l &&
              ((i[h] = l), (e[n] = [h, 0, u]), n++)
        }
        return e
      }),
      (t.prototype.getInitialData = function (e, n) {
        for (
          var i = this.getReferringComponents('singleAxis', Pn).models[0],
            a = i.get('type'),
            o = Ne(e.data, function (p) {
              return p[2] !== void 0
            }),
            s = this.fixData(o || []),
            l = [],
            u = (this.nameMap = Pt()),
            c = 0,
            h = 0;
          h < s.length;
          ++h
        )
          l.push(s[h][zS]), u.get(s[h][zS]) || (u.set(s[h][zS], c), c++)
        var f = wv(s, {
            coordDimensions: ['single'],
            dimensionsDefine: [
              {
                name: 'time',
                type: a0(a),
              },
              {
                name: 'value',
                type: 'float',
              },
              {
                name: 'name',
                type: 'ordinal',
              },
            ],
            encodeDefine: {
              single: 0,
              value: 1,
              itemName: 2,
            },
          }).dimensions,
          d = new Vr(f, this)
        return d.initData(s), d
      }),
      (t.prototype.getLayerSeries = function () {
        for (var e = this.getData(), n = e.count(), i = [], a = 0; a < n; ++a)
          i[a] = a
        var o = e.mapDimension('single'),
          s = jb(i, function (u) {
            return e.get('name', u)
          }),
          l = []
        return (
          s.buckets.each(function (u, c) {
            u.sort(function (h, f) {
              return e.get(o, h) - e.get(o, f)
            }),
              l.push({
                name: c,
                indices: u,
              })
          }),
          l
        )
      }),
      (t.prototype.getAxisTooltipData = function (e, n, i) {
        at(e) || (e = e ? [e] : [])
        for (
          var a = this.getData(),
            o = this.getLayerSeries(),
            s = [],
            l = o.length,
            u,
            c = 0;
          c < l;
          ++c
        ) {
          for (
            var h = Number.MAX_VALUE, f = -1, d = o[c].indices.length, p = 0;
            p < d;
            ++p
          ) {
            var g = a.get(e[0], o[c].indices[p]),
              v = Math.abs(g - n)
            v <= h && ((u = g), (h = v), (f = o[c].indices[p]))
          }
          s.push(f)
        }
        return {
          dataIndices: s,
          nestestValue: u,
        }
      }),
      (t.prototype.formatTooltip = function (e, n, i) {
        var a = this.getData(),
          o = a.getName(e),
          s = a.get(a.mapDimension('value'), e)
        return Kn('nameValue', {
          name: o,
          value: s,
        })
      }),
      (t.type = 'series.themeRiver'),
      (t.dependencies = ['singleAxis']),
      (t.defaultOption = {
        z: 2,
        colorBy: 'data',
        coordinateSystem: 'singleAxis',
        boundaryGap: ['10%', '10%'],
        singleAxisIndex: 0,
        animationEasing: 'linear',
        label: {
          margin: 4,
          show: !0,
          position: 'left',
          fontSize: 11,
        },
        emphasis: {
          label: {
            show: !0,
          },
        },
      }),
      t
    )
  })(rn)
const Egt = Cgt
function Dgt(r, t) {
  r.eachSeriesByType('themeRiver', function (e) {
    var n = e.getData(),
      i = e.coordinateSystem,
      a = {},
      o = i.getRect()
    a.rect = o
    var s = e.get('boundaryGap'),
      l = i.getAxis()
    if (((a.boundaryGap = s), l.orient === 'horizontal')) {
      ;(s[0] = _t(s[0], o.height)), (s[1] = _t(s[1], o.height))
      var u = o.height - s[0] - s[1]
      CN(n, e, u)
    } else {
      ;(s[0] = _t(s[0], o.width)), (s[1] = _t(s[1], o.width))
      var c = o.width - s[0] - s[1]
      CN(n, e, c)
    }
    n.setLayout('layoutInfo', a)
  })
}
function CN(r, t, e) {
  if (r.count())
    for (
      var n = t.coordinateSystem,
        i = t.getLayerSeries(),
        a = r.mapDimension('single'),
        o = r.mapDimension('value'),
        s = st(i, function (v) {
          return st(v.indices, function (m) {
            var y = n.dataToPoint(r.get(a, m))
            return (y[1] = r.get(o, m)), y
          })
        }),
        l = Lgt(s),
        u = l.y0,
        c = e / l.max,
        h = i.length,
        f = i[0].indices.length,
        d,
        p = 0;
      p < f;
      ++p
    ) {
      ;(d = u[p] * c),
        r.setItemLayout(i[0].indices[p], {
          layerIndex: 0,
          x: s[0][p][0],
          y0: d,
          y: s[0][p][1] * c,
        })
      for (var g = 1; g < h; ++g)
        (d += s[g - 1][p][1] * c),
          r.setItemLayout(i[g].indices[p], {
            layerIndex: g,
            x: s[g][p][0],
            y0: d,
            y: s[g][p][1] * c,
          })
    }
}
function Lgt(r) {
  for (
    var t = r.length, e = r[0].length, n = [], i = [], a = 0, o = 0;
    o < e;
    ++o
  ) {
    for (var s = 0, l = 0; l < t; ++l) s += r[l][o][1]
    s > a && (a = s), n.push(s)
  }
  for (var u = 0; u < e; ++u) i[u] = (a - n[u]) / 2
  a = 0
  for (var c = 0; c < e; ++c) {
    var h = n[c] + i[c]
    h > a && (a = h)
  }
  return {
    y0: i,
    max: a,
  }
}
function Pgt(r) {
  r.registerChartView(Tgt),
    r.registerSeriesModel(Egt),
    r.registerLayout(Dgt),
    r.registerProcessor(Lv('themeRiver'))
}
var Rgt = 2,
  Igt = 4,
  Ogt = (function (r) {
    X(t, r)
    function t(e, n, i, a) {
      var o = r.call(this) || this
      ;(o.z2 = Rgt),
        (o.textConfig = {
          inside: !0,
        }),
        (Wt(o).seriesIndex = n.seriesIndex)
      var s = new Ae({
        z2: Igt,
        silent: e.getModel().get(['label', 'silent']),
      })
      return o.setTextContent(s), o.updateData(!0, e, n, i, a), o
    }
    return (
      (t.prototype.updateData = function (e, n, i, a, o) {
        ;(this.node = n),
          (n.piece = this),
          (i = i || this._seriesModel),
          (a = a || this._ecModel)
        var s = this
        Wt(s).dataIndex = n.dataIndex
        var l = n.getModel(),
          u = l.getModel('emphasis'),
          c = n.getLayout(),
          h = Q({}, c)
        h.label = null
        var f = n.getVisual('style')
        f.lineJoin = 'bevel'
        var d = n.getVisual('decal')
        d && (f.decal = rf(d, o))
        var p = bu(l.getModel('itemStyle'), h, !0)
        Q(h, p),
          R(Hr, function (y) {
            var _ = s.ensureState(y),
              x = l.getModel([y, 'itemStyle'])
            _.style = x.getItemStyle()
            var A = bu(x, h)
            A && (_.shape = A)
          }),
          e
            ? (s.setShape(h),
              (s.shape.r = c.r0),
              Je(
                s,
                {
                  shape: {
                    r: c.r,
                  },
                },
                i,
                n.dataIndex,
              ))
            : (we(
                s,
                {
                  shape: h,
                },
                i,
              ),
              Ca(s)),
          s.useStyle(f),
          this._updateLabel(i)
        var g = l.getShallow('cursor')
        g && s.attr('cursor', g),
          (this._seriesModel = i || this._seriesModel),
          (this._ecModel = a || this._ecModel)
        var v = u.get('focus'),
          m =
            v === 'ancestor'
              ? n.getAncestorsIndices()
              : v === 'descendant'
              ? n.getDescendantIndices()
              : v
        fn(this, m, u.get('blurScope'), u.get('disabled'))
      }),
      (t.prototype._updateLabel = function (e) {
        var n = this,
          i = this.node.getModel(),
          a = i.getModel('label'),
          o = this.node.getLayout(),
          s = o.endAngle - o.startAngle,
          l = (o.startAngle + o.endAngle) / 2,
          u = Math.cos(l),
          c = Math.sin(l),
          h = this,
          f = h.getTextContent(),
          d = this.node.dataIndex,
          p = (a.get('minAngle') / 180) * Math.PI,
          g = a.get('show') && !(p != null && Math.abs(s) < p)
        ;(f.ignore = !g),
          R(Hp, function (m) {
            var y =
                m === 'normal' ? i.getModel('label') : i.getModel([m, 'label']),
              _ = m === 'normal',
              x = _ ? f : f.ensureState(m),
              A = e.getFormattedLabel(d, m)
            _ && (A = A || n.node.name),
              (x.style = $e(y, {}, null, m !== 'normal', !0)),
              A && (x.style.text = A)
            var S = y.get('show')
            S != null && !_ && (x.ignore = !S)
            var b = v(y, 'position'),
              T = _ ? h : h.states[m],
              w = T.style.fill
            T.textConfig = {
              outsideFill: y.get('color') === 'inherit' ? w : null,
              inside: b !== 'outside',
            }
            var M,
              C = v(y, 'distance') || 0,
              E = v(y, 'align'),
              D = v(y, 'rotate'),
              P = Math.PI * 0.5,
              L = Math.PI * 1.5,
              I = xi(D === 'tangential' ? Math.PI / 2 - l : l),
              F = I > P && !Up(I - P) && I < L
            b === 'outside'
              ? ((M = o.r + C), (E = F ? 'right' : 'left'))
              : !E || E === 'center'
              ? (s === 2 * Math.PI && o.r0 === 0
                  ? (M = 0)
                  : (M = (o.r + o.r0) / 2),
                (E = 'center'))
              : E === 'left'
              ? ((M = o.r0 + C), (E = F ? 'right' : 'left'))
              : E === 'right' && ((M = o.r - C), (E = F ? 'left' : 'right')),
              (x.style.align = E),
              (x.style.verticalAlign = v(y, 'verticalAlign') || 'middle'),
              (x.x = M * u + o.cx),
              (x.y = M * c + o.cy)
            var k = 0
            D === 'radial'
              ? (k = xi(-l) + (F ? Math.PI : 0))
              : D === 'tangential'
              ? (k = xi(Math.PI / 2 - l) + (F ? Math.PI : 0))
              : be(D) && (k = (D * Math.PI) / 180),
              (x.rotation = xi(k))
          })
        function v(m, y) {
          var _ = m.get(y)
          return _ ?? a.get(y)
        }
        f.dirtyStyle()
      }),
      t
    )
  })(oi)
const EN = Ogt
var Zw = 'sunburstRootToNode',
  DN = 'sunburstHighlight',
  Ngt = 'sunburstUnhighlight'
function kgt(r) {
  r.registerAction(
    {
      type: Zw,
      update: 'updateView',
    },
    function (t, e) {
      e.eachComponent(
        {
          mainType: 'series',
          subType: 'sunburst',
          query: t,
        },
        n,
      )
      function n(i, a) {
        var o = nv(t, [Zw], i)
        if (o) {
          var s = i.getViewRoot()
          s && (t.direction = YC(s, o.node) ? 'rollUp' : 'drillDown'),
            i.resetViewRoot(o.node)
        }
      }
    },
  ),
    r.registerAction(
      {
        type: DN,
        update: 'none',
      },
      function (t, e, n) {
        ;(t = Q({}, t)),
          e.eachComponent(
            {
              mainType: 'series',
              subType: 'sunburst',
              query: t,
            },
            i,
          )
        function i(a) {
          var o = nv(t, [DN], a)
          o && (t.dataIndex = o.node.dataIndex)
        }
        n.dispatchAction(
          Q(t, {
            type: 'highlight',
          }),
        )
      },
    ),
    r.registerAction(
      {
        type: Ngt,
        update: 'updateView',
      },
      function (t, e, n) {
        ;(t = Q({}, t)),
          n.dispatchAction(
            Q(t, {
              type: 'downplay',
            }),
          )
      },
    )
}
var Bgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      var o = this
      ;(this.seriesModel = e), (this.api = i), (this.ecModel = n)
      var s = e.getData(),
        l = s.tree.root,
        u = e.getViewRoot(),
        c = this.group,
        h = e.get('renderLabelForZeroData'),
        f = []
      u.eachNode(function (y) {
        f.push(y)
      })
      var d = this._oldChildren || []
      p(f, d), m(l, u), this._initEvents(), (this._oldChildren = f)
      function p(y, _) {
        if (y.length === 0 && _.length === 0) return
        new es(_, y, x, x).add(A).update(A).remove(Zt(A, null)).execute()
        function x(S) {
          return S.getId()
        }
        function A(S, b) {
          var T = S == null ? null : y[S],
            w = b == null ? null : _[b]
          g(T, w)
        }
      }
      function g(y, _) {
        if ((!h && y && !y.getValue() && (y = null), y !== l && _ !== l)) {
          if (_ && _.piece)
            y
              ? (_.piece.updateData(!1, y, e, n, i),
                s.setItemGraphicEl(y.dataIndex, _.piece))
              : v(_)
          else if (y) {
            var x = new EN(y, e, n, i)
            c.add(x), s.setItemGraphicEl(y.dataIndex, x)
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), (y.piece = null))
      }
      function m(y, _) {
        _.depth > 0
          ? (o.virtualPiece
              ? o.virtualPiece.updateData(!1, y, e, n, i)
              : ((o.virtualPiece = new EN(y, e, n, i)), c.add(o.virtualPiece)),
            _.piece.off('click'),
            o.virtualPiece.on('click', function (x) {
              o._rootToNode(_.parentNode)
            }))
          : o.virtualPiece &&
            (c.remove(o.virtualPiece), (o.virtualPiece = null))
      }
    }),
    (t.prototype._initEvents = function () {
      var e = this
      this.group.off('click'),
        this.group.on('click', function (n) {
          var i = !1,
            a = e.seriesModel.getViewRoot()
          a.eachNode(function (o) {
            if (!i && o.piece && o.piece === n.target) {
              var s = o.getModel().get('nodeClick')
              if (s === 'rootToNode') e._rootToNode(o)
              else if (s === 'link') {
                var l = o.getModel(),
                  u = l.get('link')
                if (u) {
                  var c = l.get('target', !0) || '_blank'
                  jy(u, c)
                }
              }
              i = !0
            }
          })
        })
    }),
    (t.prototype._rootToNode = function (e) {
      e !== this.seriesModel.getViewRoot() &&
        this.api.dispatchAction({
          type: Zw,
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e,
        })
    }),
    (t.prototype.containPoint = function (e, n) {
      var i = n.getData(),
        a = i.getItemLayout(0)
      if (a) {
        var o = e[0] - a.cx,
          s = e[1] - a.cy,
          l = Math.sqrt(o * o + s * s)
        return l <= a.r && l >= a.r0
      }
    }),
    (t.type = 'sunburst'),
    t
  )
})(Ze)
const Fgt = Bgt
var zgt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.ignoreStyleOnData = !0), e
  }
  return (
    (t.prototype.getInitialData = function (e, n) {
      var i = {
        name: e.name,
        children: e.data,
      }
      nH(i)
      var a = (this._levelModels = st(
          e.levels || [],
          function (l) {
            return new qe(l, this, n)
          },
          this,
        )),
        o = XC.createTree(i, this, s)
      function s(l) {
        l.wrapMethod('getItemModel', function (u, c) {
          var h = o.getNodeByDataIndex(c),
            f = a[h.depth]
          return f && (u.parentModel = f), u
        })
      }
      return o.data
    }),
    (t.prototype.optionUpdated = function () {
      this.resetViewRoot()
    }),
    (t.prototype.getDataParams = function (e) {
      var n = r.prototype.getDataParams.apply(this, arguments),
        i = this.getData().tree.getNodeByDataIndex(e)
      return (n.treePathInfo = E_(i, this)), n
    }),
    (t.prototype.getLevelModel = function (e) {
      return this._levelModels && this._levelModels[e.depth]
    }),
    (t.prototype.getViewRoot = function () {
      return this._viewRoot
    }),
    (t.prototype.resetViewRoot = function (e) {
      e ? (this._viewRoot = e) : (e = this._viewRoot)
      var n = this.getRawData().tree.root
      ;(!e || (e !== n && !n.contains(e))) && (this._viewRoot = n)
    }),
    (t.prototype.enableAriaDecal = function () {
      o4(this)
    }),
    (t.type = 'series.sunburst'),
    (t.defaultOption = {
      z: 2,
      center: ['50%', '50%'],
      radius: [0, '75%'],
      clockwise: !0,
      startAngle: 90,
      minAngle: 0,
      stillShowZeroSum: !0,
      nodeClick: 'rootToNode',
      renderLabelForZeroData: !1,
      label: {
        rotate: 'radial',
        show: !0,
        opacity: 1,
        align: 'center',
        position: 'inside',
        distance: 5,
        silent: !0,
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: 'white',
        borderType: 'solid',
        shadowBlur: 0,
        shadowColor: 'rgba(0, 0, 0, 0.2)',
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1,
      },
      emphasis: {
        focus: 'descendant',
      },
      blur: {
        itemStyle: {
          opacity: 0.2,
        },
        label: {
          opacity: 0.1,
        },
      },
      animationType: 'expansion',
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      sort: 'desc',
    }),
    t
  )
})(rn)
function nH(r) {
  var t = 0
  R(r.children, function (n) {
    nH(n)
    var i = n.value
    at(i) && (i = i[0]), (t += i)
  })
  var e = r.value
  at(e) && (e = e[0]),
    (e == null || isNaN(e)) && (e = t),
    e < 0 && (e = 0),
    at(r.value) ? (r.value[0] = e) : (r.value = e)
}
const Ugt = zgt
var LN = Math.PI / 180
function Vgt(r, t, e) {
  t.eachSeriesByType(r, function (n) {
    var i = n.get('center'),
      a = n.get('radius')
    at(a) || (a = [0, a]), at(i) || (i = [i, i])
    var o = e.getWidth(),
      s = e.getHeight(),
      l = Math.min(o, s),
      u = _t(i[0], o),
      c = _t(i[1], s),
      h = _t(a[0], l / 2),
      f = _t(a[1], l / 2),
      d = -n.get('startAngle') * LN,
      p = n.get('minAngle') * LN,
      g = n.getData().tree.root,
      v = n.getViewRoot(),
      m = v.depth,
      y = n.get('sort')
    y != null && rH(v, y)
    var _ = 0
    R(v.children, function (I) {
      !isNaN(I.getValue()) && _++
    })
    var x = v.getValue(),
      A = (Math.PI / (x || _)) * 2,
      S = v.depth > 0,
      b = v.height - (S ? -1 : 1),
      T = (f - h) / (b || 1),
      w = n.get('clockwise'),
      M = n.get('stillShowZeroSum'),
      C = w ? 1 : -1,
      E = function (I, F) {
        if (I) {
          var k = F
          if (I !== g) {
            var V = I.getValue(),
              H = x === 0 && M ? A : V * A
            H < p && (H = p), (k = F + C * H)
            var Y = I.depth - m - (S ? -1 : 1),
              K = h + T * Y,
              ut = h + T * (Y + 1),
              W = n.getLevelModel(I)
            if (W) {
              var Z = W.get('r0', !0),
                ft = W.get('r', !0),
                lt = W.get('radius', !0)
              lt != null && ((Z = lt[0]), (ft = lt[1])),
                Z != null && (K = _t(Z, l / 2)),
                ft != null && (ut = _t(ft, l / 2))
            }
            I.setLayout({
              angle: H,
              startAngle: F,
              endAngle: k,
              clockwise: w,
              cx: u,
              cy: c,
              r0: K,
              r: ut,
            })
          }
          if (I.children && I.children.length) {
            var ct = 0
            R(I.children, function (At) {
              ct += E(At, F + ct)
            })
          }
          return k - F
        }
      }
    if (S) {
      var D = h,
        P = h + T,
        L = Math.PI * 2
      g.setLayout({
        angle: L,
        startAngle: d,
        endAngle: d + L,
        clockwise: w,
        cx: u,
        cy: c,
        r0: D,
        r: P,
      })
    }
    E(v, d)
  })
}
function rH(r, t) {
  var e = r.children || []
  ;(r.children = Ggt(e, t)),
    e.length &&
      R(r.children, function (n) {
        rH(n, t)
      })
}
function Ggt(r, t) {
  if (Nt(t)) {
    var e = st(r, function (i, a) {
      var o = i.getValue()
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function () {
            return o
          },
        },
        index: a,
      }
    })
    return (
      e.sort(function (i, a) {
        return t(i.params, a.params)
      }),
      st(e, function (i) {
        return r[i.index]
      })
    )
  } else {
    var n = t === 'asc'
    return r.sort(function (i, a) {
      var o = (i.getValue() - a.getValue()) * (n ? 1 : -1)
      return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o
    })
  }
}
function Hgt(r) {
  var t = {}
  function e(n, i, a) {
    for (var o = n; o && o.depth > 1; ) o = o.parentNode
    var s = i.getColorFromPalette(o.name || o.dataIndex + '', t)
    return (
      n.depth > 1 && bt(s) && (s = zb(s, ((n.depth - 1) / (a - 1)) * 0.5)), s
    )
  }
  r.eachSeriesByType('sunburst', function (n) {
    var i = n.getData(),
      a = i.tree
    a.eachNode(function (o) {
      var s = o.getModel(),
        l = s.getModel('itemStyle').getItemStyle()
      l.fill || (l.fill = e(o, n, a.root.height))
      var u = i.ensureUniqueItemVisual(o.dataIndex, 'style')
      Q(u, l)
    })
  })
}
function Wgt(r) {
  r.registerChartView(Fgt),
    r.registerSeriesModel(Ugt),
    r.registerLayout(Zt(Vgt, 'sunburst')),
    r.registerProcessor(Zt(Lv, 'sunburst')),
    r.registerVisual(Hgt),
    kgt(r)
}
var PN = {
    color: 'fill',
    borderColor: 'stroke',
  },
  Xgt = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1,
  },
  Xo = ve(),
  Ygt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.optionUpdated = function () {
        ;(this.currentZLevel = this.get('zlevel', !0)),
          (this.currentZ = this.get('z', !0))
      }),
      (t.prototype.getInitialData = function (e, n) {
        return as(null, this)
      }),
      (t.prototype.getDataParams = function (e, n, i) {
        var a = r.prototype.getDataParams.call(this, e, n)
        return i && (a.info = Xo(i).info), a
      }),
      (t.type = 'series.custom'),
      (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        z: 2,
        legendHoverLink: !0,
        clip: !1,
      }),
      t
    )
  })(rn)
const $gt = Ygt
function qgt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      ['x', 'y'],
      function (e, n) {
        var i = this.getAxis(e),
          a = t[n],
          o = r[n] / 2
        return i.type === 'category'
          ? i.getBandWidth()
          : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o))
      },
      this,
    )
  )
}
function Zgt(r) {
  var t = r.master.getRect()
  return {
    coordSys: {
      type: 'cartesian2d',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(qgt, r),
    },
  }
}
function Kgt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      [0, 1],
      function (e) {
        var n = t[e],
          i = r[e] / 2,
          a = [],
          o = []
        return (
          (a[e] = n - i),
          (o[e] = n + i),
          (a[1 - e] = o[1 - e] = t[1 - e]),
          Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e])
        )
      },
      this,
    )
  )
}
function jgt(r) {
  var t = r.getBoundingRect()
  return {
    coordSys: {
      type: 'geo',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: r.getZoom(),
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(Kgt, r),
    },
  }
}
function Jgt(r, t) {
  var e = this.getAxis(),
    n = t instanceof Array ? t[0] : t,
    i = (r instanceof Array ? r[0] : r) / 2
  return e.type === 'category'
    ? e.getBandWidth()
    : Math.abs(e.dataToCoord(n - i) - e.dataToCoord(n + i))
}
function Qgt(r) {
  var t = r.getRect()
  return {
    coordSys: {
      type: 'singleAxis',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
    },
    api: {
      coord: function (e) {
        return r.dataToPoint(e)
      },
      size: Tt(Jgt, r),
    },
  }
}
function tmt(r, t) {
  return (
    (t = t || [0, 0]),
    st(
      ['Radius', 'Angle'],
      function (e, n) {
        var i = 'get' + e + 'Axis',
          a = this[i](),
          o = t[n],
          s = r[n] / 2,
          l =
            a.type === 'category'
              ? a.getBandWidth()
              : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s))
        return e === 'Angle' && (l = (l * Math.PI) / 180), l
      },
      this,
    )
  )
}
function emt(r) {
  var t = r.getRadiusAxis(),
    e = r.getAngleAxis(),
    n = t.getExtent()
  return (
    n[0] > n[1] && n.reverse(),
    {
      coordSys: {
        type: 'polar',
        cx: r.cx,
        cy: r.cy,
        r: n[1],
        r0: n[0],
      },
      api: {
        coord: function (i) {
          var a = t.dataToRadius(i[0]),
            o = e.dataToAngle(i[1]),
            s = r.coordToPoint([a, o])
          return s.push(a, (o * Math.PI) / 180), s
        },
        size: Tt(tmt, r),
      },
    }
  )
}
function nmt(r) {
  var t = r.getRect(),
    e = r.getRangeInfo()
  return {
    coordSys: {
      type: 'calendar',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: e.start,
        end: e.end,
        weeks: e.weeks,
        dayCount: e.allDay,
      },
    },
    api: {
      coord: function (n, i) {
        return r.dataToPoint(n, i)
      },
    },
  }
}
function iH(r, t, e, n) {
  return (
    r &&
    (r.legacy ||
      (r.legacy !== !1 &&
        !e &&
        !n &&
        t !== 'tspan' &&
        (t === 'text' || Et(r, 'text'))))
  )
}
function aH(r, t, e) {
  var n = r,
    i,
    a,
    o
  if (t === 'text') o = n
  else {
    ;(o = {}),
      Et(n, 'text') && (o.text = n.text),
      Et(n, 'rich') && (o.rich = n.rich),
      Et(n, 'textFill') && (o.fill = n.textFill),
      Et(n, 'textStroke') && (o.stroke = n.textStroke),
      Et(n, 'fontFamily') && (o.fontFamily = n.fontFamily),
      Et(n, 'fontSize') && (o.fontSize = n.fontSize),
      Et(n, 'fontStyle') && (o.fontStyle = n.fontStyle),
      Et(n, 'fontWeight') && (o.fontWeight = n.fontWeight),
      (a = {
        type: 'text',
        style: o,
        silent: !0,
      }),
      (i = {})
    var s = Et(n, 'textPosition')
    e
      ? (i.position = s ? n.textPosition : 'inside')
      : s && (i.position = n.textPosition),
      Et(n, 'textPosition') && (i.position = n.textPosition),
      Et(n, 'textOffset') && (i.offset = n.textOffset),
      Et(n, 'textRotation') && (i.rotation = n.textRotation),
      Et(n, 'textDistance') && (i.distance = n.textDistance)
  }
  return (
    RN(o, r),
    R(o.rich, function (l) {
      RN(l, l)
    }),
    {
      textConfig: i,
      textContent: a,
    }
  )
}
function RN(r, t) {
  t &&
    ((t.font = t.textFont || t.font),
    Et(t, 'textStrokeWidth') && (r.lineWidth = t.textStrokeWidth),
    Et(t, 'textAlign') && (r.align = t.textAlign),
    Et(t, 'textVerticalAlign') && (r.verticalAlign = t.textVerticalAlign),
    Et(t, 'textLineHeight') && (r.lineHeight = t.textLineHeight),
    Et(t, 'textWidth') && (r.width = t.textWidth),
    Et(t, 'textHeight') && (r.height = t.textHeight),
    Et(t, 'textBackgroundColor') && (r.backgroundColor = t.textBackgroundColor),
    Et(t, 'textPadding') && (r.padding = t.textPadding),
    Et(t, 'textBorderColor') && (r.borderColor = t.textBorderColor),
    Et(t, 'textBorderWidth') && (r.borderWidth = t.textBorderWidth),
    Et(t, 'textBorderRadius') && (r.borderRadius = t.textBorderRadius),
    Et(t, 'textBoxShadowColor') && (r.shadowColor = t.textBoxShadowColor),
    Et(t, 'textBoxShadowBlur') && (r.shadowBlur = t.textBoxShadowBlur),
    Et(t, 'textBoxShadowOffsetX') && (r.shadowOffsetX = t.textBoxShadowOffsetX),
    Et(t, 'textBoxShadowOffsetY') && (r.shadowOffsetY = t.textBoxShadowOffsetY))
}
function IN(r, t, e) {
  var n = r
  ;(n.textPosition = n.textPosition || e.position || 'inside'),
    e.offset != null && (n.textOffset = e.offset),
    e.rotation != null && (n.textRotation = e.rotation),
    e.distance != null && (n.textDistance = e.distance)
  var i = n.textPosition.indexOf('inside') >= 0,
    a = r.fill || '#000'
  ON(n, t)
  var o = n.textFill == null
  return (
    i
      ? o &&
        ((n.textFill = e.insideFill || '#fff'),
        !n.textStroke && e.insideStroke && (n.textStroke = e.insideStroke),
        !n.textStroke && (n.textStroke = a),
        n.textStrokeWidth == null && (n.textStrokeWidth = 2))
      : (o && (n.textFill = r.fill || e.outsideFill || '#000'),
        !n.textStroke && e.outsideStroke && (n.textStroke = e.outsideStroke)),
    (n.text = t.text),
    (n.rich = t.rich),
    R(t.rich, function (s) {
      ON(s, s)
    }),
    n
  )
}
function ON(r, t) {
  t &&
    (Et(t, 'fill') && (r.textFill = t.fill),
    Et(t, 'stroke') && (r.textStroke = t.fill),
    Et(t, 'lineWidth') && (r.textStrokeWidth = t.lineWidth),
    Et(t, 'font') && (r.font = t.font),
    Et(t, 'fontStyle') && (r.fontStyle = t.fontStyle),
    Et(t, 'fontWeight') && (r.fontWeight = t.fontWeight),
    Et(t, 'fontSize') && (r.fontSize = t.fontSize),
    Et(t, 'fontFamily') && (r.fontFamily = t.fontFamily),
    Et(t, 'align') && (r.textAlign = t.align),
    Et(t, 'verticalAlign') && (r.textVerticalAlign = t.verticalAlign),
    Et(t, 'lineHeight') && (r.textLineHeight = t.lineHeight),
    Et(t, 'width') && (r.textWidth = t.width),
    Et(t, 'height') && (r.textHeight = t.height),
    Et(t, 'backgroundColor') && (r.textBackgroundColor = t.backgroundColor),
    Et(t, 'padding') && (r.textPadding = t.padding),
    Et(t, 'borderColor') && (r.textBorderColor = t.borderColor),
    Et(t, 'borderWidth') && (r.textBorderWidth = t.borderWidth),
    Et(t, 'borderRadius') && (r.textBorderRadius = t.borderRadius),
    Et(t, 'shadowColor') && (r.textBoxShadowColor = t.shadowColor),
    Et(t, 'shadowBlur') && (r.textBoxShadowBlur = t.shadowBlur),
    Et(t, 'shadowOffsetX') && (r.textBoxShadowOffsetX = t.shadowOffsetX),
    Et(t, 'shadowOffsetY') && (r.textBoxShadowOffsetY = t.shadowOffsetY),
    Et(t, 'textShadowColor') && (r.textShadowColor = t.textShadowColor),
    Et(t, 'textShadowBlur') && (r.textShadowBlur = t.textShadowBlur),
    Et(t, 'textShadowOffsetX') && (r.textShadowOffsetX = t.textShadowOffsetX),
    Et(t, 'textShadowOffsetY') && (r.textShadowOffsetY = t.textShadowOffsetY))
}
var oH = {
    position: ['x', 'y'],
    scale: ['scaleX', 'scaleY'],
    origin: ['originX', 'originY'],
  },
  NN = pe(oH)
co(
  fo,
  function (r, t) {
    return (r[t] = 1), r
  },
  {},
)
fo.join(', ')
var y0 = ['', 'style', 'shape', 'extra'],
  uf = ve()
function lE(r, t, e, n, i) {
  var a = r + 'Animation',
    o = xf(r, n, i) || {},
    s = uf(t).userDuring
  return (
    o.duration > 0 &&
      ((o.during = s
        ? Tt(smt, {
            el: t,
            userDuring: s,
          })
        : null),
      (o.setToFinal = !0),
      (o.scope = r)),
    Q(o, e[a]),
    o
  )
}
function sy(r, t, e, n) {
  n = n || {}
  var i = n.dataIndex,
    a = n.isInit,
    o = n.clearStyle,
    s = e.isAnimationEnabled(),
    l = uf(r),
    u = t.style
  l.userDuring = t.during
  var c = {},
    h = {}
  if (
    (umt(r, t, h),
    BN('shape', t, h),
    BN('extra', t, h),
    !a &&
      s &&
      (lmt(r, t, c),
      kN('shape', r, t, c),
      kN('extra', r, t, c),
      cmt(r, t, u, c)),
    (h.style = u),
    rmt(r, h, o),
    amt(r, t),
    s)
  )
    if (a) {
      var f = {}
      R(y0, function (p) {
        var g = p ? t[p] : t
        g &&
          g.enterFrom &&
          (p && (f[p] = f[p] || {}), Q(p ? f[p] : f, g.enterFrom))
      })
      var d = lE('enter', r, t, e, i)
      d.duration > 0 && r.animateFrom(f, d)
    } else imt(r, t, i || 0, e, c)
  sH(r, t), u ? r.dirty() : r.markRedraw()
}
function sH(r, t) {
  for (var e = uf(r).leaveToProps, n = 0; n < y0.length; n++) {
    var i = y0[n],
      a = i ? t[i] : t
    a &&
      a.leaveTo &&
      (e || (e = uf(r).leaveToProps = {}),
      i && (e[i] = e[i] || {}),
      Q(i ? e[i] : e, a.leaveTo))
  }
}
function P_(r, t, e, n) {
  if (r) {
    var i = r.parent,
      a = uf(r).leaveToProps
    if (a) {
      var o = lE('update', r, t, e, 0)
      ;(o.done = function () {
        i.remove(r), n && n()
      }),
        r.animateTo(a, o)
    } else i.remove(r), n && n()
  }
}
function zu(r) {
  return r === 'all'
}
function rmt(r, t, e) {
  var n = t.style
  if (!r.isGroup && n) {
    if (e) {
      r.useStyle({})
      for (var i = r.animators, a = 0; a < i.length; a++) {
        var o = i[a]
        o.targetName === 'style' && o.changeTarget(r.style)
      }
    }
    r.setStyle(n)
  }
  t && ((t.style = null), t && r.attr(t), (t.style = n))
}
function imt(r, t, e, n, i) {
  if (i) {
    var a = lE('update', r, t, n, e)
    a.duration > 0 && r.animateFrom(i, a)
  }
}
function amt(r, t) {
  Et(t, 'silent') && (r.silent = t.silent),
    Et(t, 'ignore') && (r.ignore = t.ignore),
    r instanceof ea && Et(t, 'invisible') && (r.invisible = t.invisible),
    r instanceof oe && Et(t, 'autoBatch') && (r.autoBatch = t.autoBatch)
}
var Va = {},
  omt = {
    setTransform: function (r, t) {
      return (Va.el[r] = t), this
    },
    getTransform: function (r) {
      return Va.el[r]
    },
    setShape: function (r, t) {
      var e = Va.el,
        n = e.shape || (e.shape = {})
      return (n[r] = t), e.dirtyShape && e.dirtyShape(), this
    },
    getShape: function (r) {
      var t = Va.el.shape
      if (t) return t[r]
    },
    setStyle: function (r, t) {
      var e = Va.el,
        n = e.style
      return n && ((n[r] = t), e.dirtyStyle && e.dirtyStyle()), this
    },
    getStyle: function (r) {
      var t = Va.el.style
      if (t) return t[r]
    },
    setExtra: function (r, t) {
      var e = Va.el.extra || (Va.el.extra = {})
      return (e[r] = t), this
    },
    getExtra: function (r) {
      var t = Va.el.extra
      if (t) return t[r]
    },
  }
function smt() {
  var r = this,
    t = r.el
  if (t) {
    var e = uf(t).userDuring,
      n = r.userDuring
    if (e !== n) {
      r.el = r.userDuring = null
      return
    }
    ;(Va.el = t), n(omt)
  }
}
function kN(r, t, e, n) {
  var i = e[r]
  if (i) {
    var a = t[r],
      o
    if (a) {
      var s = e.transition,
        l = i.transition
      if (l)
        if ((!o && (o = n[r] = {}), zu(l))) Q(o, a)
        else
          for (var u = ke(l), c = 0; c < u.length; c++) {
            var h = u[c],
              f = a[h]
            o[h] = f
          }
      else if (zu(s) || re(s, r) >= 0) {
        !o && (o = n[r] = {})
        for (var d = pe(a), c = 0; c < d.length; c++) {
          var h = d[c],
            f = a[h]
          hmt(i[h], f) && (o[h] = f)
        }
      }
    }
  }
}
function BN(r, t, e) {
  var n = t[r]
  if (n)
    for (var i = (e[r] = {}), a = pe(n), o = 0; o < a.length; o++) {
      var s = a[o]
      i[s] = np(n[s])
    }
}
function lmt(r, t, e) {
  for (
    var n = t.transition, i = zu(n) ? fo : ke(n || []), a = 0;
    a < i.length;
    a++
  ) {
    var o = i[a]
    if (!(o === 'style' || o === 'shape' || o === 'extra')) {
      var s = r[o]
      e[o] = s
    }
  }
}
function umt(r, t, e) {
  for (var n = 0; n < NN.length; n++) {
    var i = NN[n],
      a = oH[i],
      o = t[i]
    o && ((e[a[0]] = o[0]), (e[a[1]] = o[1]))
  }
  for (var n = 0; n < fo.length; n++) {
    var s = fo[n]
    t[s] != null && (e[s] = t[s])
  }
}
function cmt(r, t, e, n) {
  if (e) {
    var i = r.style,
      a
    if (i) {
      var o = e.transition,
        s = t.transition
      if (o && !zu(o)) {
        var l = ke(o)
        !a && (a = n.style = {})
        for (var u = 0; u < l.length; u++) {
          var c = l[u],
            h = i[c]
          a[c] = h
        }
      } else if (
        r.getAnimationStyleProps &&
        (zu(s) || zu(o) || re(s, 'style') >= 0)
      ) {
        var f = r.getAnimationStyleProps(),
          d = f ? f.style : null
        if (d) {
          !a && (a = n.style = {})
          for (var p = pe(e), u = 0; u < p.length; u++) {
            var c = p[u]
            if (d[c]) {
              var h = i[c]
              a[c] = h
            }
          }
        }
      }
    }
  }
}
function hmt(r, t) {
  return Er(r) ? r !== t : r != null && isFinite(r)
}
var lH = ve(),
  fmt = ['percent', 'easing', 'shape', 'style', 'extra']
function uH(r) {
  r.stopAnimation('keyframe'), r.attr(lH(r))
}
function _0(r, t, e) {
  if (!(!e.isAnimationEnabled() || !t)) {
    if (at(t)) {
      R(t, function (s) {
        _0(r, s, e)
      })
      return
    }
    var n = t.keyframes,
      i = t.duration
    if (e && i == null) {
      var a = xf('enter', e, 0)
      i = a && a.duration
    }
    if (!(!n || !i)) {
      var o = lH(r)
      R(y0, function (s) {
        if (!(s && !r[s])) {
          var l
          n.sort(function (u, c) {
            return u.percent - c.percent
          }),
            R(n, function (u) {
              var c = r.animators,
                h = s ? u[s] : u
              if (h) {
                var f = pe(h)
                if (
                  (s ||
                    (f = Ne(f, function (g) {
                      return re(fmt, g) < 0
                    })),
                  !!f.length)
                ) {
                  l || ((l = r.animate(s, t.loop, !0)), (l.scope = 'keyframe'))
                  for (var d = 0; d < c.length; d++)
                    c[d] !== l &&
                      c[d].targetName === l.targetName &&
                      c[d].stopTracks(f)
                  s && (o[s] = o[s] || {})
                  var p = s ? o[s] : o
                  R(f, function (g) {
                    p[g] = ((s ? r[s] : r) || {})[g]
                  }),
                    l.whenWithKeys(i * u.percent, h, f, u.easing)
                }
              }
            }),
            l &&
              l
                .delay(t.delay || 0)
                .duration(i)
                .start(t.easing)
        }
      })
    }
  }
}
var Yo = 'emphasis',
  Hs = 'normal',
  uE = 'blur',
  cE = 'select',
  cl = [Hs, Yo, uE, cE],
  US = {
    normal: ['itemStyle'],
    emphasis: [Yo, 'itemStyle'],
    blur: [uE, 'itemStyle'],
    select: [cE, 'itemStyle'],
  },
  VS = {
    normal: ['label'],
    emphasis: [Yo, 'label'],
    blur: [uE, 'label'],
    select: [cE, 'label'],
  },
  dmt = ['x', 'y'],
  pmt = 'e\0\0',
  Oi = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {},
  },
  vmt = {
    cartesian2d: Zgt,
    geo: jgt,
    single: Qgt,
    polar: emt,
    calendar: nmt,
  }
function Kw(r) {
  return r instanceof oe
}
function jw(r) {
  return r instanceof ea
}
function gmt(r, t) {
  t.copyTransform(r),
    jw(t) &&
      jw(r) &&
      (t.setStyle(r.style),
      (t.z = r.z),
      (t.z2 = r.z2),
      (t.zlevel = r.zlevel),
      (t.invisible = r.invisible),
      (t.ignore = r.ignore),
      Kw(t) && Kw(r) && t.setShape(r.shape))
}
var mmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      this._progressiveEls = null
      var o = this._data,
        s = e.getData(),
        l = this.group,
        u = FN(e, s, n, i)
      o || l.removeAll(),
        s
          .diff(o)
          .add(function (h) {
            GS(i, null, h, u(h, a), e, l, s)
          })
          .remove(function (h) {
            var f = o.getItemGraphicEl(h)
            f && P_(f, Xo(f).option, e)
          })
          .update(function (h, f) {
            var d = o.getItemGraphicEl(f)
            GS(i, d, h, u(h, a), e, l, s)
          })
          .execute()
      var c = e.get('clip', !0) ? Ev(e.coordinateSystem, !1, e) : null
      c ? l.setClipPath(c) : l.removeClipPath(), (this._data = s)
    }),
    (t.prototype.incrementalPrepareRender = function (e, n, i) {
      this.group.removeAll(), (this._data = null)
    }),
    (t.prototype.incrementalRender = function (e, n, i, a, o) {
      var s = n.getData(),
        l = FN(n, s, i, a),
        u = (this._progressiveEls = [])
      function c(d) {
        d.isGroup ||
          ((d.incremental = !0), (d.ensureState('emphasis').hoverLayer = !0))
      }
      for (var h = e.start; h < e.end; h++) {
        var f = GS(null, null, h, l(h, o), n, this.group, s)
        f && (f.traverse(c), u.push(f))
      }
    }),
    (t.prototype.eachRendered = function (e) {
      vl(this._progressiveEls || this.group, e)
    }),
    (t.prototype.filterForExposedEvent = function (e, n, i, a) {
      var o = n.element
      if (o == null || i.name === o) return !0
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === o) return !0
      return !1
    }),
    (t.type = 'custom'),
    t
  )
})(Ze)
const ymt = mmt
function hE(r) {
  var t = r.type,
    e
  if (t === 'path') {
    var n = r.shape,
      i =
        n.width != null && n.height != null
          ? {
              x: n.x || 0,
              y: n.y || 0,
              width: n.width,
              height: n.height,
            }
          : null,
      a = fH(n)
    ;(e = o_(a, null, i, n.layout || 'center')), (Xo(e).customPathData = a)
  } else if (t === 'image')
    (e = new yr({})), (Xo(e).customImagePath = r.style.image)
  else if (t === 'text') e = new Ae({})
  else if (t === 'group') e = new Ht()
  else {
    if (t === 'compoundPath')
      throw new Error('"compoundPath" is not supported yet.')
    var o = tC(t)
    if (!o) {
      var s = ''
      Ce(s)
    }
    e = new o()
  }
  return (
    (Xo(e).customGraphicType = t),
    (e.name = r.name),
    (e.z2EmphasisLift = 1),
    (e.z2SelectLift = 1),
    e
  )
}
function fE(r, t, e, n, i, a, o) {
  uH(t)
  var s = i && i.normal.cfg
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = dmt)
  var l = n && n.style
  if (l) {
    if (t.type === 'text') {
      var u = l
      Et(u, 'textFill') && (u.fill = u.textFill),
        Et(u, 'textStroke') && (u.stroke = u.textStroke)
    }
    var c = void 0,
      h = Kw(t) ? l.decal : null
    r && h && ((h.dirty = !0), (c = rf(h, r))), (l.__decalPattern = c)
  }
  if (jw(t) && l) {
    var c = l.__decalPattern
    c && (l.decal = c)
  }
  sy(t, n, a, {
    dataIndex: e,
    isInit: o,
    clearStyle: !0,
  }),
    _0(t, n.keyframeAnimation, a)
}
function cH(r, t, e, n, i) {
  var a = t.isGroup ? null : t,
    o = i && i[r].cfg
  if (a) {
    var s = a.ensureState(r)
    if (n === !1) {
      var l = a.getState(r)
      l && (l.style = null)
    } else s.style = n || null
    o && (s.textConfig = o), qu(a)
  }
}
function _mt(r, t, e) {
  if (!r.isGroup) {
    var n = r,
      i = e.currentZ,
      a = e.currentZLevel
    ;(n.z = i), (n.zlevel = a)
    var o = t.z2
    o != null && (n.z2 = o || 0)
    for (var s = 0; s < cl.length; s++) xmt(n, t, cl[s])
  }
}
function xmt(r, t, e) {
  var n = e === Hs,
    i = n ? t : x0(t, e),
    a = i ? i.z2 : null,
    o
  a != null && ((o = n ? r : r.ensureState(e)), (o.z2 = a || 0))
}
function FN(r, t, e, n) {
  var i = r.get('renderItem'),
    a = r.coordinateSystem,
    o = {}
  a && (o = a.prepareCustoms ? a.prepareCustoms(a) : vmt[a.type](a))
  for (
    var s = zt(
        {
          getWidth: n.getWidth,
          getHeight: n.getHeight,
          getZr: n.getZr,
          getDevicePixelRatio: n.getDevicePixelRatio,
          value: x,
          style: S,
          ordinalRawValue: A,
          styleEmphasis: b,
          visual: M,
          barLayout: C,
          currentSeriesIndices: E,
          font: D,
        },
        o.api || {},
      ),
      l = {
        context: {},
        seriesId: r.id,
        seriesName: r.name,
        seriesIndex: r.seriesIndex,
        coordSys: o.coordSys,
        dataInsideLength: t.count(),
        encode: Smt(r.getData()),
      },
      u,
      c,
      h = {},
      f = {},
      d = {},
      p = {},
      g = 0;
    g < cl.length;
    g++
  ) {
    var v = cl[g]
    ;(d[v] = r.getModel(US[v])), (p[v] = r.getModel(VS[v]))
  }
  function m(P) {
    return P === u ? c || (c = t.getItemModel(P)) : t.getItemModel(P)
  }
  function y(P, L) {
    return t.hasItemOption
      ? P === u
        ? h[L] || (h[L] = m(P).getModel(US[L]))
        : m(P).getModel(US[L])
      : d[L]
  }
  function _(P, L) {
    return t.hasItemOption
      ? P === u
        ? f[L] || (f[L] = m(P).getModel(VS[L]))
        : m(P).getModel(VS[L])
      : p[L]
  }
  return function (P, L) {
    return (
      (u = P),
      (c = null),
      (h = {}),
      (f = {}),
      i &&
        i(
          zt(
            {
              dataIndexInside: P,
              dataIndex: t.getRawIndex(P),
              actionType: L ? L.type : null,
            },
            l,
          ),
          s,
        )
    )
  }
  function x(P, L) {
    return (
      L == null && (L = u), t.getStore().get(t.getDimensionIndex(P || 0), L)
    )
  }
  function A(P, L) {
    L == null && (L = u), (P = P || 0)
    var I = t.getDimensionInfo(P)
    if (!I) {
      var F = t.getDimensionIndex(P)
      return F >= 0 ? t.getStore().get(F, L) : void 0
    }
    var k = t.get(I.name, L),
      V = I && I.ordinalMeta
    return V ? V.categories[k] : k
  }
  function S(P, L) {
    L == null && (L = u)
    var I = t.getItemVisual(L, 'style'),
      F = I && I.fill,
      k = I && I.opacity,
      V = y(L, Hs).getItemStyle()
    F != null && (V.fill = F), k != null && (V.opacity = k)
    var H = {
        inheritColor: bt(F) ? F : '#000',
      },
      Y = _(L, Hs),
      K = $e(Y, null, H, !1, !0)
    K.text = Y.getShallow('show')
      ? $t(r.getFormattedLabel(L, Hs), of(t, L))
      : null
    var ut = Zy(Y, H, !1)
    return w(P, V), (V = IN(V, K, ut)), P && T(V, P), (V.legacy = !0), V
  }
  function b(P, L) {
    L == null && (L = u)
    var I = y(L, Yo).getItemStyle(),
      F = _(L, Yo),
      k = $e(F, null, null, !0, !0)
    k.text = F.getShallow('show')
      ? ao(r.getFormattedLabel(L, Yo), r.getFormattedLabel(L, Hs), of(t, L))
      : null
    var V = Zy(F, null, !0)
    return w(P, I), (I = IN(I, k, V)), P && T(I, P), (I.legacy = !0), I
  }
  function T(P, L) {
    for (var I in L) Et(L, I) && (P[I] = L[I])
  }
  function w(P, L) {
    P &&
      (P.textFill && (L.textFill = P.textFill),
      P.textPosition && (L.textPosition = P.textPosition))
  }
  function M(P, L) {
    if ((L == null && (L = u), Et(PN, P))) {
      var I = t.getItemVisual(L, 'style')
      return I ? I[PN[P]] : null
    }
    if (Et(Xgt, P)) return t.getItemVisual(L, P)
  }
  function C(P) {
    if (a.type === 'cartesian2d') {
      var L = a.getBaseAxis()
      return Sot(
        zt(
          {
            axis: L,
          },
          P,
        ),
      )
    }
  }
  function E() {
    return e.getCurrentSeriesIndices()
  }
  function D(P) {
    return eC(P, e)
  }
}
function Smt(r) {
  var t = {}
  return (
    R(r.dimensions, function (e) {
      var n = r.getDimensionInfo(e)
      if (!n.isExtraCoord) {
        var i = n.coordDim,
          a = (t[i] = t[i] || [])
        a[n.coordDimIndex] = r.getDimensionIndex(e)
      }
    }),
    t
  )
}
function GS(r, t, e, n, i, a, o) {
  if (!n) {
    a.remove(t)
    return
  }
  var s = dE(r, t, e, n, i, a)
  return (
    s && o.setItemGraphicEl(e, s),
    s && fn(s, n.focus, n.blurScope, n.emphasisDisabled),
    s
  )
}
function dE(r, t, e, n, i, a) {
  var o = -1,
    s = t
  t && hH(t, n, i) && ((o = re(a.childrenRef(), t)), (t = null))
  var l = !t,
    u = t
  u ? u.clearStates() : ((u = hE(n)), s && gmt(s, u)),
    n.morph === !1
      ? (u.disableMorphing = !0)
      : u.disableMorphing && (u.disableMorphing = !1),
    (Oi.normal.cfg =
      Oi.normal.conOpt =
      Oi.emphasis.cfg =
      Oi.emphasis.conOpt =
      Oi.blur.cfg =
      Oi.blur.conOpt =
      Oi.select.cfg =
      Oi.select.conOpt =
        null),
    (Oi.isLegacy = !1),
    bmt(u, e, n, i, l, Oi),
    Amt(u, e, n, i, l),
    fE(r, u, e, n, Oi, i, l),
    Et(n, 'info') && (Xo(u).info = n.info)
  for (var c = 0; c < cl.length; c++) {
    var h = cl[c]
    if (h !== Hs) {
      var f = x0(n, h),
        d = pE(n, f, h)
      cH(h, u, f, d, Oi)
    }
  }
  return (
    _mt(u, n, i),
    n.type === 'group' && wmt(r, u, e, n, i),
    o >= 0 ? a.replaceAt(u, o) : a.add(u),
    u
  )
}
function hH(r, t, e) {
  var n = Xo(r),
    i = t.type,
    a = t.shape,
    o = t.style
  return (
    e.isUniversalTransitionEnabled() ||
    (i != null && i !== n.customGraphicType) ||
    (i === 'path' && Emt(a) && fH(a) !== n.customPathData) ||
    (i === 'image' && Et(o, 'image') && o.image !== n.customImagePath)
  )
}
function Amt(r, t, e, n, i) {
  var a = e.clipPath
  if (a === !1) r && r.getClipPath() && r.removeClipPath()
  else if (a) {
    var o = r.getClipPath()
    o && hH(o, a, n) && (o = null),
      o || ((o = hE(a)), r.setClipPath(o)),
      fE(null, o, t, a, null, n, i)
  }
}
function bmt(r, t, e, n, i, a) {
  if (!r.isGroup) {
    zN(e, null, a), zN(e, Yo, a)
    var o = a.normal.conOpt,
      s = a.emphasis.conOpt,
      l = a.blur.conOpt,
      u = a.select.conOpt
    if (o != null || s != null || u != null || l != null) {
      var c = r.getTextContent()
      if (o === !1) c && r.removeTextContent()
      else {
        ;(o = a.normal.conOpt =
          o || {
            type: 'text',
          }),
          c ? c.clearStates() : ((c = hE(o)), r.setTextContent(c)),
          fE(null, c, t, o, null, n, i)
        for (var h = o && o.style, f = 0; f < cl.length; f++) {
          var d = cl[f]
          if (d !== Hs) {
            var p = a[d].conOpt
            cH(d, c, p, pE(o, p, d), null)
          }
        }
        h ? c.dirty() : c.markRedraw()
      }
    }
  }
}
function zN(r, t, e) {
  var n = t ? x0(r, t) : r,
    i = t ? pE(r, n, Yo) : r.style,
    a = r.type,
    o = n ? n.textConfig : null,
    s = r.textContent,
    l = s ? (t ? x0(s, t) : s) : null
  if (i && (e.isLegacy || iH(i, a, !!o, !!l))) {
    e.isLegacy = !0
    var u = aH(i, a, !t)
    !o && u.textConfig && (o = u.textConfig),
      !l && u.textContent && (l = u.textContent)
  }
  if (!t && l) {
    var c = l
    !c.type && (c.type = 'text')
  }
  var h = t ? e[t] : e.normal
  ;(h.cfg = o), (h.conOpt = l)
}
function x0(r, t) {
  return t ? (r ? r[t] : null) : r
}
function pE(r, t, e) {
  var n = t && t.style
  return n == null && e === Yo && r && (n = r.styleEmphasis), n
}
function wmt(r, t, e, n, i) {
  var a = n.children,
    o = a ? a.length : 0,
    s = n.$mergeChildren,
    l = s === 'byName' || n.diffChildrenByName,
    u = s === !1
  if (!(!o && !l && !u)) {
    if (l) {
      Tmt({
        api: r,
        oldChildren: t.children() || [],
        newChildren: a || [],
        dataIndex: e,
        seriesModel: i,
        group: t,
      })
      return
    }
    u && t.removeAll()
    for (var c = 0; c < o; c++) {
      var h = a[c],
        f = t.childAt(c)
      h
        ? (h.ignore == null && (h.ignore = !1), dE(r, f, e, h, i, t))
        : (f.ignore = !0)
    }
    for (var d = t.childCount() - 1; d >= c; d--) {
      var p = t.childAt(d)
      Mmt(t, p, i)
    }
  }
}
function Mmt(r, t, e) {
  t && P_(t, Xo(r).option, e)
}
function Tmt(r) {
  new es(r.oldChildren, r.newChildren, UN, UN, r)
    .add(VN)
    .update(VN)
    .remove(Cmt)
    .execute()
}
function UN(r, t) {
  var e = r && r.name
  return e ?? pmt + t
}
function VN(r, t) {
  var e = this.context,
    n = r != null ? e.newChildren[r] : null,
    i = t != null ? e.oldChildren[t] : null
  dE(e.api, i, e.dataIndex, n, e.seriesModel, e.group)
}
function Cmt(r) {
  var t = this.context,
    e = t.oldChildren[r]
  e && P_(e, Xo(e).option, t.seriesModel)
}
function fH(r) {
  return r && (r.pathData || r.d)
}
function Emt(r) {
  return r && (Et(r, 'pathData') || Et(r, 'd'))
}
function Dmt(r) {
  r.registerChartView(ymt), r.registerSeriesModel($gt)
}
var du = ve(),
  GN = Vt,
  HS = Tt,
  Lmt = (function () {
    function r() {
      ;(this._dragging = !1), (this.animationThreshold = 15)
    }
    return (
      (r.prototype.render = function (t, e, n, i) {
        var a = e.get('value'),
          o = e.get('status')
        if (
          ((this._axisModel = t),
          (this._axisPointerModel = e),
          (this._api = n),
          !(!i && this._lastValue === a && this._lastStatus === o))
        ) {
          ;(this._lastValue = a), (this._lastStatus = o)
          var s = this._group,
            l = this._handle
          if (!o || o === 'hide') {
            s && s.hide(), l && l.hide()
            return
          }
          s && s.show(), l && l.show()
          var u = {}
          this.makeElOption(u, a, t, e, n)
          var c = u.graphicKey
          c !== this._lastGraphicKey && this.clear(n),
            (this._lastGraphicKey = c)
          var h = (this._moveAnimation = this.determineAnimation(t, e))
          if (!s)
            (s = this._group = new Ht()),
              this.createPointerEl(s, u, t, e),
              this.createLabelEl(s, u, t, e),
              n.getZr().add(s)
          else {
            var f = Zt(HN, e, h)
            this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, e)
          }
          XN(s, e, !0), this._renderHandle(a)
        }
      }),
      (r.prototype.remove = function (t) {
        this.clear(t)
      }),
      (r.prototype.dispose = function (t) {
        this.clear(t)
      }),
      (r.prototype.determineAnimation = function (t, e) {
        var n = e.get('animation'),
          i = t.axis,
          a = i.type === 'category',
          o = e.get('snap')
        if (!o && !a) return !1
        if (n === 'auto' || n == null) {
          var s = this.animationThreshold
          if (a && i.getBandWidth() > s) return !0
          if (o) {
            var l = FC(t).seriesDataCount,
              u = i.getExtent()
            return Math.abs(u[0] - u[1]) / l > s
          }
          return !1
        }
        return n === !0
      }),
      (r.prototype.makeElOption = function (t, e, n, i, a) {}),
      (r.prototype.createPointerEl = function (t, e, n, i) {
        var a = e.pointer
        if (a) {
          var o = (du(t).pointerEl = new nc[a.type](GN(e.pointer)))
          t.add(o)
        }
      }),
      (r.prototype.createLabelEl = function (t, e, n, i) {
        if (e.label) {
          var a = (du(t).labelEl = new Ae(GN(e.label)))
          t.add(a), WN(a, i)
        }
      }),
      (r.prototype.updatePointerEl = function (t, e, n) {
        var i = du(t).pointerEl
        i &&
          e.pointer &&
          (i.setStyle(e.pointer.style),
          n(i, {
            shape: e.pointer.shape,
          }))
      }),
      (r.prototype.updateLabelEl = function (t, e, n, i) {
        var a = du(t).labelEl
        a &&
          (a.setStyle(e.label.style),
          n(a, {
            x: e.label.x,
            y: e.label.y,
          }),
          WN(a, i))
      }),
      (r.prototype._renderHandle = function (t) {
        if (!(this._dragging || !this.updateHandleTransform)) {
          var e = this._axisPointerModel,
            n = this._api.getZr(),
            i = this._handle,
            a = e.getModel('handle'),
            o = e.get('status')
          if (!a.get('show') || !o || o === 'hide') {
            i && n.remove(i), (this._handle = null)
            return
          }
          var s
          this._handle ||
            ((s = !0),
            (i = this._handle =
              Sv(a.get('icon'), {
                cursor: 'move',
                draggable: !0,
                onmousemove: function (u) {
                  jo(u.event)
                },
                onmousedown: HS(this._onHandleDragMove, this, 0, 0),
                drift: HS(this._onHandleDragMove, this),
                ondragend: HS(this._onHandleDragEnd, this),
              })),
            n.add(i)),
            XN(i, e, !1),
            i.setStyle(
              a.getItemStyle(null, [
                'color',
                'borderColor',
                'borderWidth',
                'opacity',
                'shadowColor',
                'shadowBlur',
                'shadowOffsetX',
                'shadowOffsetY',
              ]),
            )
          var l = a.get('size')
          at(l) || (l = [l, l]),
            (i.scaleX = l[0] / 2),
            (i.scaleY = l[1] / 2),
            Df(
              this,
              '_doDispatchAxisPointer',
              a.get('throttle') || 0,
              'fixRate',
            ),
            this._moveHandleToValue(t, s)
        }
      }),
      (r.prototype._moveHandleToValue = function (t, e) {
        HN(
          this._axisPointerModel,
          !e && this._moveAnimation,
          this._handle,
          WS(
            this.getHandleTransform(t, this._axisModel, this._axisPointerModel),
          ),
        )
      }),
      (r.prototype._onHandleDragMove = function (t, e) {
        var n = this._handle
        if (n) {
          this._dragging = !0
          var i = this.updateHandleTransform(
            WS(n),
            [t, e],
            this._axisModel,
            this._axisPointerModel,
          )
          ;(this._payloadInfo = i),
            n.stopAnimation(),
            n.attr(WS(i)),
            (du(n).lastProp = null),
            this._doDispatchAxisPointer()
        }
      }),
      (r.prototype._doDispatchAxisPointer = function () {
        var t = this._handle
        if (t) {
          var e = this._payloadInfo,
            n = this._axisModel
          this._api.dispatchAction({
            type: 'updateAxisPointer',
            x: e.cursorPoint[0],
            y: e.cursorPoint[1],
            tooltipOption: e.tooltipOption,
            axesInfo: [
              {
                axisDim: n.axis.dim,
                axisIndex: n.componentIndex,
              },
            ],
          })
        }
      }),
      (r.prototype._onHandleDragEnd = function () {
        this._dragging = !1
        var t = this._handle
        if (t) {
          var e = this._axisPointerModel.get('value')
          this._moveHandleToValue(e),
            this._api.dispatchAction({
              type: 'hideTip',
            })
        }
      }),
      (r.prototype.clear = function (t) {
        ;(this._lastValue = null), (this._lastStatus = null)
        var e = t.getZr(),
          n = this._group,
          i = this._handle
        e &&
          n &&
          ((this._lastGraphicKey = null),
          n && e.remove(n),
          i && e.remove(i),
          (this._group = null),
          (this._handle = null),
          (this._payloadInfo = null)),
          Zp(this, '_doDispatchAxisPointer')
      }),
      (r.prototype.doClear = function () {}),
      (r.prototype.buildLabel = function (t, e, n) {
        return (
          (n = n || 0),
          {
            x: t[n],
            y: t[1 - n],
            width: e[n],
            height: e[1 - n],
          }
        )
      }),
      r
    )
  })()
function HN(r, t, e, n) {
  dH(du(e).lastProp, n) ||
    ((du(e).lastProp = n), t ? we(e, n, r) : (e.stopAnimation(), e.attr(n)))
}
function dH(r, t) {
  if (Ut(r) && Ut(t)) {
    var e = !0
    return (
      R(t, function (n, i) {
        e = e && dH(r[i], n)
      }),
      !!e
    )
  } else return r === t
}
function WN(r, t) {
  r[t.get(['label', 'show']) ? 'show' : 'hide']()
}
function WS(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0,
  }
}
function XN(r, t, e) {
  var n = t.get('z'),
    i = t.get('zlevel')
  r &&
    r.traverse(function (a) {
      a.type !== 'group' &&
        (n != null && (a.z = n), i != null && (a.zlevel = i), (a.silent = e))
    })
}
const vE = Lmt
function gE(r) {
  var t = r.get('type'),
    e = r.getModel(t + 'Style'),
    n
  return (
    t === 'line'
      ? ((n = e.getLineStyle()), (n.fill = null))
      : t === 'shadow' && ((n = e.getAreaStyle()), (n.stroke = null)),
    n
  )
}
function pH(r, t, e, n, i) {
  var a = e.get('value'),
    o = vH(a, t.axis, t.ecModel, e.get('seriesDataIndices'), {
      precision: e.get(['label', 'precision']),
      formatter: e.get(['label', 'formatter']),
    }),
    s = e.getModel('label'),
    l = wf(s.get('padding') || 0),
    u = s.getFont(),
    c = mv(o, u),
    h = i.position,
    f = c.width + l[1] + l[3],
    d = c.height + l[0] + l[2],
    p = i.align
  p === 'right' && (h[0] -= f), p === 'center' && (h[0] -= f / 2)
  var g = i.verticalAlign
  g === 'bottom' && (h[1] -= d),
    g === 'middle' && (h[1] -= d / 2),
    Pmt(h, f, d, n)
  var v = s.get('backgroundColor')
  ;(!v || v === 'auto') && (v = t.get(['axisLine', 'lineStyle', 'color'])),
    (r.label = {
      x: h[0],
      y: h[1],
      style: $e(s, {
        text: o,
        font: u,
        fill: s.getTextColor(),
        padding: l,
        backgroundColor: v,
      }),
      z2: 10,
    })
}
function Pmt(r, t, e, n) {
  var i = n.getWidth(),
    a = n.getHeight()
  ;(r[0] = Math.min(r[0] + t, i) - t),
    (r[1] = Math.min(r[1] + e, a) - e),
    (r[0] = Math.max(r[0], 0)),
    (r[1] = Math.max(r[1], 0))
}
function vH(r, t, e, n, i) {
  r = t.scale.parse(r)
  var a = t.scale.getLabel(
      {
        value: r,
      },
      {
        precision: i.precision,
      },
    ),
    o = i.formatter
  if (o) {
    var s = {
      value: EC(t, {
        value: r,
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: [],
    }
    R(n, function (l) {
      var u = e.getSeriesByIndex(l.seriesIndex),
        c = l.dataIndexInside,
        h = u && u.getDataParams(c)
      h && s.seriesData.push(h)
    }),
      bt(o) ? (a = o.replace('{value}', a)) : Nt(o) && (a = o(s))
  }
  return a
}
function mE(r, t, e) {
  var n = bi()
  return (
    ec(n, n, e.rotation),
    ho(n, n, e.position),
    ba(
      [
        r.dataToCoord(t),
        (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0),
      ],
      n,
    )
  )
}
function gH(r, t, e, n, i, a) {
  var o = ns.innerTextLayout(e.rotation, 0, e.labelDirection)
  ;(e.labelMargin = i.get(['label', 'margin'])),
    pH(t, n, i, a, {
      position: mE(n.axis, r, e),
      align: o.textAlign,
      verticalAlign: o.textVerticalAlign,
    })
}
function yE(r, t, e) {
  return (
    (e = e || 0),
    {
      x1: r[e],
      y1: r[1 - e],
      x2: t[e],
      y2: t[1 - e],
    }
  )
}
function mH(r, t, e) {
  return (
    (e = e || 0),
    {
      x: r[e],
      y: r[1 - e],
      width: t[e],
      height: t[1 - e],
    }
  )
}
function YN(r, t, e, n, i, a) {
  return {
    cx: r,
    cy: t,
    r0: e,
    r: n,
    startAngle: i,
    endAngle: a,
    clockwise: !0,
  }
}
var Rmt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.makeElOption = function (e, n, i, a, o) {
      var s = i.axis,
        l = s.grid,
        u = a.get('type'),
        c = $N(l, s).getOtherAxis(s).getGlobalExtent(),
        h = s.toGlobalCoord(s.dataToCoord(n, !0))
      if (u && u !== 'none') {
        var f = gE(a),
          d = Imt[u](s, h, c)
        ;(d.style = f), (e.graphicKey = d.type), (e.pointer = d)
      }
      var p = Iw(l.model, i)
      gH(n, e, p, i, a, o)
    }),
    (t.prototype.getHandleTransform = function (e, n, i) {
      var a = Iw(n.axis.grid.model, n, {
        labelInside: !1,
      })
      a.labelMargin = i.get(['handle', 'margin'])
      var o = mE(n.axis, e, a)
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0),
      }
    }),
    (t.prototype.updateHandleTransform = function (e, n, i, a) {
      var o = i.axis,
        s = o.grid,
        l = o.getGlobalExtent(!0),
        u = $N(s, o).getOtherAxis(o).getGlobalExtent(),
        c = o.dim === 'x' ? 0 : 1,
        h = [e.x, e.y]
      ;(h[c] += n[c]),
        (h[c] = Math.min(l[1], h[c])),
        (h[c] = Math.max(l[0], h[c]))
      var f = (u[1] + u[0]) / 2,
        d = [f, f]
      d[c] = h[c]
      var p = [
        {
          verticalAlign: 'middle',
        },
        {
          align: 'center',
        },
      ]
      return {
        x: h[0],
        y: h[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: p[c],
      }
    }),
    t
  )
})(vE)
function $N(r, t) {
  var e = {}
  return (e[t.dim + 'AxisIndex'] = t.index), r.getCartesian(e)
}
var Imt = {
  line: function (r, t, e) {
    var n = yE([t, e[0]], [t, e[1]], qN(r))
    return {
      type: 'Line',
      subPixelOptimize: !0,
      shape: n,
    }
  },
  shadow: function (r, t, e) {
    var n = Math.max(1, r.getBandWidth()),
      i = e[1] - e[0]
    return {
      type: 'Rect',
      shape: mH([t - n / 2, e[0]], [n, i], qN(r)),
    }
  },
}
function qN(r) {
  return r.dim === 'x' ? 0 : 1
}
const Omt = Rmt
var Nmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'axisPointer'),
    (t.defaultOption = {
      show: 'auto',
      z: 50,
      type: 'line',
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: '#B9BEC9',
        width: 1,
        type: 'dashed',
      },
      shadowStyle: {
        color: 'rgba(210,219,238,0.2)',
      },
      label: {
        show: !0,
        formatter: null,
        precision: 'auto',
        margin: 3,
        color: '#fff',
        padding: [5, 7, 5, 7],
        backgroundColor: 'auto',
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3,
      },
      handle: {
        show: !1,
        icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
        size: 45,
        margin: 50,
        color: '#333',
        shadowBlur: 3,
        shadowColor: '#aaa',
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        throttle: 40,
      },
    }),
    t
  )
})(xe)
const kmt = Nmt
var Vo = ve(),
  Bmt = R
function yH(r, t, e) {
  if (!Se.node) {
    var n = t.getZr()
    Vo(n).records || (Vo(n).records = {}), Fmt(n, t)
    var i = Vo(n).records[r] || (Vo(n).records[r] = {})
    i.handler = e
  }
}
function Fmt(r, t) {
  if (Vo(r).initialized) return
  ;(Vo(r).initialized = !0),
    e('click', Zt(ZN, 'click')),
    e('mousemove', Zt(ZN, 'mousemove')),
    e('globalout', Umt)
  function e(n, i) {
    r.on(n, function (a) {
      var o = Vmt(t)
      Bmt(Vo(r).records, function (s) {
        s && i(s, a, o.dispatchAction)
      }),
        zmt(o.pendings, t)
    })
  }
}
function zmt(r, t) {
  var e = r.showTip.length,
    n = r.hideTip.length,
    i
  e ? (i = r.showTip[e - 1]) : n && (i = r.hideTip[n - 1]),
    i && ((i.dispatchAction = null), t.dispatchAction(i))
}
function Umt(r, t, e) {
  r.handler('leave', null, e)
}
function ZN(r, t, e, n) {
  t.handler(r, e, n)
}
function Vmt(r) {
  var t = {
      showTip: [],
      hideTip: [],
    },
    e = function (n) {
      var i = t[n.type]
      i ? i.push(n) : ((n.dispatchAction = e), r.dispatchAction(n))
    }
  return {
    dispatchAction: e,
    pendings: t,
  }
}
function Jw(r, t) {
  if (!Se.node) {
    var e = t.getZr(),
      n = (Vo(e).records || {})[r]
    n && (Vo(e).records[r] = null)
  }
}
var Gmt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = n.getComponent('tooltip'),
        o = e.get('triggerOn') || (a && a.get('triggerOn')) || 'mousemove|click'
      yH('axisPointer', i, function (s, l, u) {
        o !== 'none' &&
          (s === 'leave' || o.indexOf(s) >= 0) &&
          u({
            type: 'updateAxisPointer',
            currTrigger: s,
            x: l && l.offsetX,
            y: l && l.offsetY,
          })
      })
    }),
    (t.prototype.remove = function (e, n) {
      Jw('axisPointer', n)
    }),
    (t.prototype.dispose = function (e, n) {
      Jw('axisPointer', n)
    }),
    (t.type = 'axisPointer'),
    t
  )
})(dn)
const Hmt = Gmt
function _H(r, t) {
  var e = [],
    n = r.seriesIndex,
    i
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: [],
    }
  var a = i.getData(),
    o = Yu(a, r)
  if (o == null || o < 0 || at(o))
    return {
      point: [],
    }
  var s = a.getItemGraphicEl(o),
    l = i.coordinateSystem
  if (i.getTooltipPosition) e = i.getTooltipPosition(o) || []
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(),
        c = l.getOtherAxis(u),
        h = c.dim,
        f = u.dim,
        d = h === 'x' || h === 'radius' ? 1 : 0,
        p = a.mapDimension(f),
        g = []
      ;(g[d] = a.get(p, o)),
        (g[1 - d] = a.get(a.getCalculationInfo('stackResultDimension'), o)),
        (e = l.dataToPoint(g) || [])
    } else
      e =
        l.dataToPoint(
          a.getValues(
            st(l.dimensions, function (m) {
              return a.mapDimension(m)
            }),
            o,
          ),
        ) || []
  else if (s) {
    var v = s.getBoundingRect().clone()
    v.applyTransform(s.transform), (e = [v.x + v.width / 2, v.y + v.height / 2])
  }
  return {
    point: e,
    el: s,
  }
}
var KN = ve()
function Wmt(r, t, e) {
  var n = r.currTrigger,
    i = [r.x, r.y],
    a = r,
    o = r.dispatchAction || Tt(e.dispatchAction, e),
    s = t.getComponent('axisPointer').coordSysAxesInfo
  if (s) {
    ly(i) &&
      (i = _H(
        {
          seriesIndex: a.seriesIndex,
          dataIndex: a.dataIndex,
        },
        t,
      ).point)
    var l = ly(i),
      u = a.axesInfo,
      c = s.axesInfo,
      h = n === 'leave' || ly(i),
      f = {},
      d = {},
      p = {
        list: [],
        map: {},
      },
      g = {
        showPointer: Zt(Ymt, d),
        showTooltip: Zt($mt, p),
      }
    R(s.coordSysMap, function (m, y) {
      var _ = l || m.containPoint(i)
      R(s.coordSysAxesInfo[y], function (x, A) {
        var S = x.axis,
          b = jmt(u, x)
        if (!h && _ && (!u || b)) {
          var T = b && b.value
          T == null && !l && (T = S.pointToData(i)),
            T != null && jN(x, T, g, !1, f)
        }
      })
    })
    var v = {}
    return (
      R(c, function (m, y) {
        var _ = m.linkGroup
        _ &&
          !d[y] &&
          R(_.axesInfo, function (x, A) {
            var S = d[A]
            if (x !== m && S) {
              var b = S.value
              _.mapper && (b = m.axis.scale.parse(_.mapper(b, JN(x), JN(m)))),
                (v[m.key] = b)
            }
          })
      }),
      R(v, function (m, y) {
        jN(c[y], m, g, !0, f)
      }),
      qmt(d, c, f),
      Zmt(p, i, r, o),
      Kmt(c, o, e),
      f
    )
  }
}
function jN(r, t, e, n, i) {
  var a = r.axis
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!r.involveSeries) {
      e.showPointer(r, t)
      return
    }
    var o = Xmt(t, r),
      s = o.payloadBatch,
      l = o.snapToValue
    s[0] && i.seriesIndex == null && Q(i, s[0]),
      !n && r.snap && a.containData(l) && l != null && (t = l),
      e.showPointer(r, t, s),
      e.showTooltip(r, o, l)
  }
}
function Xmt(r, t) {
  var e = t.axis,
    n = e.dim,
    i = r,
    a = [],
    o = Number.MAX_VALUE,
    s = -1
  return (
    R(t.seriesModels, function (l, u) {
      var c = l.getData().mapDimensionsAll(n),
        h,
        f
      if (l.getAxisTooltipData) {
        var d = l.getAxisTooltipData(c, r, e)
        ;(f = d.dataIndices), (h = d.nestestValue)
      } else {
        if (
          ((f = l
            .getData()
            .indicesOfNearest(c[0], r, e.type === 'category' ? 0.5 : null)),
          !f.length)
        )
          return
        h = l.getData().get(c[0], f[0])
      }
      if (!(h == null || !isFinite(h))) {
        var p = r - h,
          g = Math.abs(p)
        g <= o &&
          ((g < o || (p >= 0 && s < 0)) &&
            ((o = g), (s = p), (i = h), (a.length = 0)),
          R(f, function (v) {
            a.push({
              seriesIndex: l.seriesIndex,
              dataIndexInside: v,
              dataIndex: l.getData().getRawIndex(v),
            })
          }))
      }
    }),
    {
      payloadBatch: a,
      snapToValue: i,
    }
  )
}
function Ymt(r, t, e, n) {
  r[t.key] = {
    value: e,
    payloadBatch: n,
  }
}
function $mt(r, t, e, n) {
  var i = e.payloadBatch,
    a = t.axis,
    o = a.model,
    s = t.axisPointerModel
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model,
      u = ev(l),
      c = r.map[u]
    c ||
      ((c = r.map[u] =
        {
          coordSysId: l.id,
          coordSysIndex: l.componentIndex,
          coordSysType: l.type,
          coordSysMainType: l.mainType,
          dataByAxis: [],
        }),
      r.list.push(c)),
      c.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: o.componentIndex,
        axisType: o.type,
        axisId: o.id,
        value: n,
        valueLabelOpt: {
          precision: s.get(['label', 'precision']),
          formatter: s.get(['label', 'formatter']),
        },
        seriesDataIndices: i.slice(),
      })
  }
}
function qmt(r, t, e) {
  var n = (e.axesInfo = [])
  R(t, function (i, a) {
    var o = i.axisPointerModel.option,
      s = r[a]
    s
      ? (!i.useHandle && (o.status = 'show'),
        (o.value = s.value),
        (o.seriesDataIndices = (s.payloadBatch || []).slice()))
      : !i.useHandle && (o.status = 'hide'),
      o.status === 'show' &&
        n.push({
          axisDim: i.axis.dim,
          axisIndex: i.axis.model.componentIndex,
          value: o.value,
        })
  })
}
function Zmt(r, t, e, n) {
  if (ly(t) || !r.list.length) {
    n({
      type: 'hideTip',
    })
    return
  }
  var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}
  n({
    type: 'showTip',
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: e.tooltipOption,
    position: e.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: r.list,
  })
}
function Kmt(r, t, e) {
  var n = e.getZr(),
    i = 'axisPointerLastHighlights',
    a = KN(n)[i] || {},
    o = (KN(n)[i] = {})
  R(r, function (u, c) {
    var h = u.axisPointerModel.option
    h.status === 'show' &&
      u.triggerEmphasis &&
      R(h.seriesDataIndices, function (f) {
        var d = f.seriesIndex + ' | ' + f.dataIndex
        o[d] = f
      })
  })
  var s = [],
    l = []
  R(a, function (u, c) {
    !o[c] && l.push(u)
  }),
    R(o, function (u, c) {
      !a[c] && s.push(u)
    }),
    l.length &&
      e.dispatchAction({
        type: 'downplay',
        escapeConnect: !0,
        notBlur: !0,
        batch: l,
      }),
    s.length &&
      e.dispatchAction({
        type: 'highlight',
        escapeConnect: !0,
        notBlur: !0,
        batch: s,
      })
}
function jmt(r, t) {
  for (var e = 0; e < (r || []).length; e++) {
    var n = r[e]
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n
  }
}
function JN(r) {
  var t = r.axis.model,
    e = {},
    n = (e.axisDim = r.axis.dim)
  return (
    (e.axisIndex = e[n + 'AxisIndex'] = t.componentIndex),
    (e.axisName = e[n + 'AxisName'] = t.name),
    (e.axisId = e[n + 'AxisId'] = t.id),
    e
  )
}
function ly(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1])
}
function Ov(r) {
  sc.registerAxisPointerClass('CartesianAxisPointer', Omt),
    r.registerComponentModel(kmt),
    r.registerComponentView(Hmt),
    r.registerPreprocessor(function (t) {
      if (t) {
        ;(!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {})
        var e = t.axisPointer.link
        e && !at(e) && (t.axisPointer.link = [e])
      }
    }),
    r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function (t, e) {
      t.getComponent('axisPointer').coordSysAxesInfo = Fut(t, e)
    }),
    r.registerAction(
      {
        type: 'updateAxisPointer',
        event: 'updateAxisPointer',
        update: ':updateAxisPointer',
      },
      Wmt,
    )
}
function Jmt(r) {
  ie(XG), ie(Ov)
}
var Qmt = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.makeElOption = function (e, n, i, a, o) {
      var s = i.axis
      s.dim === 'angle' && (this.animationThreshold = Math.PI / 18)
      var l = s.polar,
        u = l.getOtherAxis(s),
        c = u.getExtent(),
        h = s.dataToCoord(n),
        f = a.get('type')
      if (f && f !== 'none') {
        var d = gE(a),
          p = eyt[f](s, l, h, c)
        ;(p.style = d), (e.graphicKey = p.type), (e.pointer = p)
      }
      var g = a.get(['label', 'margin']),
        v = tyt(n, i, a, l, g)
      pH(e, i, a, o, v)
    }),
    t
  )
})(vE)
function tyt(r, t, e, n, i) {
  var a = t.axis,
    o = a.dataToCoord(r),
    s = n.getAngleAxis().getExtent()[0]
  s = (s / 180) * Math.PI
  var l = n.getRadiusAxis().getExtent(),
    u,
    c,
    h
  if (a.dim === 'radius') {
    var f = bi()
    ec(f, f, s), ho(f, f, [n.cx, n.cy]), (u = ba([o, -i], f))
    var d = t.getModel('axisLabel').get('rotate') || 0,
      p = ns.innerTextLayout(s, (d * Math.PI) / 180, -1)
    ;(c = p.textAlign), (h = p.textVerticalAlign)
  } else {
    var g = l[1]
    u = n.coordToPoint([g + i, o])
    var v = n.cx,
      m = n.cy
    ;(c =
      Math.abs(u[0] - v) / g < 0.3 ? 'center' : u[0] > v ? 'left' : 'right'),
      (h =
        Math.abs(u[1] - m) / g < 0.3 ? 'middle' : u[1] > m ? 'top' : 'bottom')
  }
  return {
    position: u,
    align: c,
    verticalAlign: h,
  }
}
var eyt = {
  line: function (r, t, e, n) {
    return r.dim === 'angle'
      ? {
          type: 'Line',
          shape: yE(t.coordToPoint([n[0], e]), t.coordToPoint([n[1], e])),
        }
      : {
          type: 'Circle',
          shape: {
            cx: t.cx,
            cy: t.cy,
            r: e,
          },
        }
  },
  shadow: function (r, t, e, n) {
    var i = Math.max(1, r.getBandWidth()),
      a = Math.PI / 180
    return r.dim === 'angle'
      ? {
          type: 'Sector',
          shape: YN(t.cx, t.cy, n[0], n[1], (-e - i / 2) * a, (-e + i / 2) * a),
        }
      : {
          type: 'Sector',
          shape: YN(t.cx, t.cy, e - i / 2, e + i / 2, 0, Math.PI * 2),
        }
  },
}
const nyt = Qmt
var ryt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.findAxisModel = function (e) {
      var n,
        i = this.ecModel
      return (
        i.eachComponent(
          e,
          function (a) {
            a.getCoordSysModel() === this && (n = a)
          },
          this,
        ),
        n
      )
    }),
    (t.type = 'polar'),
    (t.dependencies = ['radiusAxis', 'angleAxis']),
    (t.defaultOption = {
      z: 0,
      center: ['50%', '50%'],
      radius: '80%',
    }),
    t
  )
})(xe)
const iyt = ryt
var _E = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this.getReferringComponents('polar', Pn).models[0]
    }),
    (t.type = 'polarAxis'),
    t
  )
})(xe)
In(_E, Mv)
var ayt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'angleAxis'), t
  })(_E),
  oyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'radiusAxis'), t
  })(_E),
  xE = (function (r) {
    X(t, r)
    function t(e, n) {
      return r.call(this, 'radius', e, n) || this
    }
    return (
      (t.prototype.pointToData = function (e, n) {
        return this.polar.pointToData(e, n)[this.dim === 'radius' ? 0 : 1]
      }),
      t
    )
  })(Ra)
xE.prototype.dataToRadius = Ra.prototype.dataToCoord
xE.prototype.radiusToData = Ra.prototype.coordToData
const syt = xE
var lyt = ve(),
  SE = (function (r) {
    X(t, r)
    function t(e, n) {
      return r.call(this, 'angle', e, n || [0, 360]) || this
    }
    return (
      (t.prototype.pointToData = function (e, n) {
        return this.polar.pointToData(e, n)[this.dim === 'radius' ? 0 : 1]
      }),
      (t.prototype.calculateCategoryInterval = function () {
        var e = this,
          n = e.getLabelModel(),
          i = e.scale,
          a = i.getExtent(),
          o = i.count()
        if (a[1] - a[0] < 1) return 0
        var s = a[0],
          l = e.dataToCoord(s + 1) - e.dataToCoord(s),
          u = Math.abs(l),
          c = mv(s == null ? '' : s + '', n.getFont(), 'center', 'top'),
          h = Math.max(c.height, 7),
          f = h / u
        isNaN(f) && (f = 1 / 0)
        var d = Math.max(0, Math.floor(f)),
          p = lyt(e.model),
          g = p.lastAutoInterval,
          v = p.lastTickCount
        return (
          g != null &&
          v != null &&
          Math.abs(g - d) <= 1 &&
          Math.abs(v - o) <= 1 &&
          g > d
            ? (d = g)
            : ((p.lastTickCount = o), (p.lastAutoInterval = d)),
          d
        )
      }),
      t
    )
  })(Ra)
SE.prototype.dataToAngle = Ra.prototype.dataToCoord
SE.prototype.angleToData = Ra.prototype.coordToData
const uyt = SE
var xH = ['radius', 'angle'],
  cyt = (function () {
    function r(t) {
      ;(this.dimensions = xH),
        (this.type = 'polar'),
        (this.cx = 0),
        (this.cy = 0),
        (this._radiusAxis = new syt()),
        (this._angleAxis = new uyt()),
        (this.axisPointerEnabled = !0),
        (this.name = t || ''),
        (this._radiusAxis.polar = this._angleAxis.polar = this)
    }
    return (
      (r.prototype.containPoint = function (t) {
        var e = this.pointToCoord(t)
        return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1])
      }),
      (r.prototype.containData = function (t) {
        return (
          this._radiusAxis.containData(t[0]) &&
          this._angleAxis.containData(t[1])
        )
      }),
      (r.prototype.getAxis = function (t) {
        var e = '_' + t + 'Axis'
        return this[e]
      }),
      (r.prototype.getAxes = function () {
        return [this._radiusAxis, this._angleAxis]
      }),
      (r.prototype.getAxesByScale = function (t) {
        var e = [],
          n = this._angleAxis,
          i = this._radiusAxis
        return (
          n.scale.type === t && e.push(n), i.scale.type === t && e.push(i), e
        )
      }),
      (r.prototype.getAngleAxis = function () {
        return this._angleAxis
      }),
      (r.prototype.getRadiusAxis = function () {
        return this._radiusAxis
      }),
      (r.prototype.getOtherAxis = function (t) {
        var e = this._angleAxis
        return t === e ? this._radiusAxis : e
      }),
      (r.prototype.getBaseAxis = function () {
        return (
          this.getAxesByScale('ordinal')[0] ||
          this.getAxesByScale('time')[0] ||
          this.getAngleAxis()
        )
      }),
      (r.prototype.getTooltipAxes = function (t) {
        var e = t != null && t !== 'auto' ? this.getAxis(t) : this.getBaseAxis()
        return {
          baseAxes: [e],
          otherAxes: [this.getOtherAxis(e)],
        }
      }),
      (r.prototype.dataToPoint = function (t, e) {
        return this.coordToPoint([
          this._radiusAxis.dataToRadius(t[0], e),
          this._angleAxis.dataToAngle(t[1], e),
        ])
      }),
      (r.prototype.pointToData = function (t, e) {
        var n = this.pointToCoord(t)
        return [
          this._radiusAxis.radiusToData(n[0], e),
          this._angleAxis.angleToData(n[1], e),
        ]
      }),
      (r.prototype.pointToCoord = function (t) {
        var e = t[0] - this.cx,
          n = t[1] - this.cy,
          i = this.getAngleAxis(),
          a = i.getExtent(),
          o = Math.min(a[0], a[1]),
          s = Math.max(a[0], a[1])
        i.inverse ? (o = s - 360) : (s = o + 360)
        var l = Math.sqrt(e * e + n * n)
        ;(e /= l), (n /= l)
        for (
          var u = (Math.atan2(-n, e) / Math.PI) * 180, c = u < o ? 1 : -1;
          u < o || u > s;

        )
          u += c * 360
        return [l, u]
      }),
      (r.prototype.coordToPoint = function (t) {
        var e = t[0],
          n = (t[1] / 180) * Math.PI,
          i = Math.cos(n) * e + this.cx,
          a = -Math.sin(n) * e + this.cy
        return [i, a]
      }),
      (r.prototype.getArea = function () {
        var t = this.getAngleAxis(),
          e = this.getRadiusAxis(),
          n = e.getExtent().slice()
        n[0] > n[1] && n.reverse()
        var i = t.getExtent(),
          a = Math.PI / 180
        return {
          cx: this.cx,
          cy: this.cy,
          r0: n[0],
          r: n[1],
          startAngle: -i[0] * a,
          endAngle: -i[1] * a,
          clockwise: t.inverse,
          contain: function (o, s) {
            var l = o - this.cx,
              u = s - this.cy,
              c = l * l + u * u - 1e-4,
              h = this.r,
              f = this.r0
            return c <= h * h && c >= f * f
          },
        }
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = QN(e)
        return i === this ? this.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = QN(e)
        return i === this ? this.pointToData(n) : null
      }),
      r
    )
  })()
function QN(r) {
  var t = r.seriesModel,
    e = r.polarModel
  return (e && e.coordinateSystem) || (t && t.coordinateSystem)
}
const hyt = cyt
function fyt(r, t, e) {
  var n = t.get('center'),
    i = e.getWidth(),
    a = e.getHeight()
  ;(r.cx = _t(n[0], i)), (r.cy = _t(n[1], a))
  var o = r.getRadiusAxis(),
    s = Math.min(i, a) / 2,
    l = t.get('radius')
  l == null ? (l = [0, '100%']) : at(l) || (l = [0, l])
  var u = [_t(l[0], s), _t(l[1], s)]
  o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1])
}
function dyt(r, t) {
  var e = this,
    n = e.getAngleAxis(),
    i = e.getRadiusAxis()
  if (
    (n.scale.setExtent(1 / 0, -1 / 0),
    i.scale.setExtent(1 / 0, -1 / 0),
    r.eachSeries(function (s) {
      if (s.coordinateSystem === e) {
        var l = s.getData()
        R(o0(l, 'radius'), function (u) {
          i.scale.unionExtentFromData(l, u)
        }),
          R(o0(l, 'angle'), function (u) {
            n.scale.unionExtentFromData(l, u)
          })
      }
    }),
    af(n.scale, n.model),
    af(i.scale, i.model),
    n.type === 'category' && !n.onBand)
  ) {
    var a = n.getExtent(),
      o = 360 / n.scale.count()
    n.inverse ? (a[1] += o) : (a[1] -= o), n.setExtent(a[0], a[1])
  }
}
function pyt(r) {
  return r.mainType === 'angleAxis'
}
function t3(r, t) {
  var e
  if (
    ((r.type = t.get('type')),
    (r.scale = w_(t)),
    (r.onBand = t.get('boundaryGap') && r.type === 'category'),
    (r.inverse = t.get('inverse')),
    pyt(t))
  ) {
    r.inverse = r.inverse !== t.get('clockwise')
    var n = t.get('startAngle'),
      i =
        (e = t.get('endAngle')) !== null && e !== void 0
          ? e
          : n + (r.inverse ? -360 : 360)
    r.setExtent(n, i)
  }
  ;(t.axis = r), (r.model = t)
}
var vyt = {
  dimensions: xH,
  create: function (r, t) {
    var e = []
    return (
      r.eachComponent('polar', function (n, i) {
        var a = new hyt(i + '')
        a.update = dyt
        var o = a.getRadiusAxis(),
          s = a.getAngleAxis(),
          l = n.findAxisModel('radiusAxis'),
          u = n.findAxisModel('angleAxis')
        t3(o, l),
          t3(s, u),
          fyt(a, n, t),
          e.push(a),
          (n.coordinateSystem = a),
          (a.model = n)
      }),
      r.eachSeries(function (n) {
        if (n.get('coordinateSystem') === 'polar') {
          var i = n.getReferringComponents('polar', Pn).models[0]
          n.coordinateSystem = i.coordinateSystem
        }
      }),
      e
    )
  },
}
const gyt = vyt
var myt = [
  'axisLine',
  'axisLabel',
  'axisTick',
  'minorTick',
  'splitLine',
  'minorSplitLine',
  'splitArea',
]
function Am(r, t, e) {
  t[1] > t[0] && (t = t.slice().reverse())
  var n = r.coordToPoint([t[0], e]),
    i = r.coordToPoint([t[1], e])
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1],
  }
}
function bm(r) {
  var t = r.getRadiusAxis()
  return t.inverse ? 0 : 1
}
function e3(r) {
  var t = r[0],
    e = r[r.length - 1]
  t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && r.pop()
}
var yyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'PolarAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var i = e.axis,
            a = i.polar,
            o = a.getRadiusAxis().getExtent(),
            s = i.getTicksCoords(),
            l = i.getMinorTicksCoords(),
            u = st(i.getViewLabels(), function (c) {
              c = Vt(c)
              var h = i.scale,
                f =
                  h.type === 'ordinal'
                    ? h.getRawOrdinalNumber(c.tickValue)
                    : c.tickValue
              return (c.coord = i.dataToCoord(f)), c
            })
          e3(u),
            e3(s),
            R(
              myt,
              function (c) {
                e.get([c, 'show']) &&
                  (!i.scale.isBlank() || c === 'axisLine') &&
                  _yt[c](this.group, e, a, s, l, o, u)
              },
              this,
            )
        }
      }),
      (t.type = 'angleAxis'),
      t
    )
  })(sc),
  _yt = {
    axisLine: function (r, t, e, n, i, a) {
      var o = t.getModel(['axisLine', 'lineStyle']),
        s = e.getAngleAxis(),
        l = Math.PI / 180,
        u = s.getExtent(),
        c = bm(e),
        h = c ? 0 : 1,
        f,
        d = Math.abs(u[1] - u[0]) === 360 ? 'Circle' : 'Arc'
      a[h] === 0
        ? (f = new nc[d]({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: a[c],
              startAngle: -u[0] * l,
              endAngle: -u[1] * l,
              clockwise: s.inverse,
            },
            style: o.getLineStyle(),
            z2: 1,
            silent: !0,
          }))
        : (f = new i_({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: a[c],
              r0: a[h],
            },
            style: o.getLineStyle(),
            z2: 1,
            silent: !0,
          })),
        (f.style.fill = null),
        r.add(f)
    },
    axisTick: function (r, t, e, n, i, a) {
      var o = t.getModel('axisTick'),
        s = (o.get('inside') ? -1 : 1) * o.get('length'),
        l = a[bm(e)],
        u = st(n, function (c) {
          return new rr({
            shape: Am(e, [l, l + s], c.coord),
          })
        })
      r.add(
        Wi(u, {
          style: zt(o.getModel('lineStyle').getLineStyle(), {
            stroke: t.get(['axisLine', 'lineStyle', 'color']),
          }),
        }),
      )
    },
    minorTick: function (r, t, e, n, i, a) {
      if (i.length) {
        for (
          var o = t.getModel('axisTick'),
            s = t.getModel('minorTick'),
            l = (o.get('inside') ? -1 : 1) * s.get('length'),
            u = a[bm(e)],
            c = [],
            h = 0;
          h < i.length;
          h++
        )
          for (var f = 0; f < i[h].length; f++)
            c.push(
              new rr({
                shape: Am(e, [u, u + l], i[h][f].coord),
              }),
            )
        r.add(
          Wi(c, {
            style: zt(
              s.getModel('lineStyle').getLineStyle(),
              zt(o.getLineStyle(), {
                stroke: t.get(['axisLine', 'lineStyle', 'color']),
              }),
            ),
          }),
        )
      }
    },
    axisLabel: function (r, t, e, n, i, a, o) {
      var s = t.getCategories(!0),
        l = t.getModel('axisLabel'),
        u = l.get('margin'),
        c = t.get('triggerEvent')
      R(
        o,
        function (h, f) {
          var d = l,
            p = h.tickValue,
            g = a[bm(e)],
            v = e.coordToPoint([g + u, h.coord]),
            m = e.cx,
            y = e.cy,
            _ =
              Math.abs(v[0] - m) / g < 0.3
                ? 'center'
                : v[0] > m
                ? 'left'
                : 'right',
            x =
              Math.abs(v[1] - y) / g < 0.3
                ? 'middle'
                : v[1] > y
                ? 'top'
                : 'bottom'
          if (s && s[p]) {
            var A = s[p]
            Ut(A) && A.textStyle && (d = new qe(A.textStyle, l, l.ecModel))
          }
          var S = new Ae({
            silent: ns.isLabelSilent(t),
            style: $e(d, {
              x: v[0],
              y: v[1],
              fill:
                d.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              text: h.formattedLabel,
              align: _,
              verticalAlign: x,
            }),
          })
          if ((r.add(S), c)) {
            var b = ns.makeAxisEventDataBase(t)
            ;(b.targetType = 'axisLabel'),
              (b.value = h.rawLabel),
              (Wt(S).eventData = b)
          }
        },
        this,
      )
    },
    splitLine: function (r, t, e, n, i, a) {
      var o = t.getModel('splitLine'),
        s = o.getModel('lineStyle'),
        l = s.get('color'),
        u = 0
      l = l instanceof Array ? l : [l]
      for (var c = [], h = 0; h < n.length; h++) {
        var f = u++ % l.length
        ;(c[f] = c[f] || []),
          c[f].push(
            new rr({
              shape: Am(e, a, n[h].coord),
            }),
          )
      }
      for (var h = 0; h < c.length; h++)
        r.add(
          Wi(c[h], {
            style: zt(
              {
                stroke: l[h % l.length],
              },
              s.getLineStyle(),
            ),
            silent: !0,
            z: t.get('z'),
          }),
        )
    },
    minorSplitLine: function (r, t, e, n, i, a) {
      if (i.length) {
        for (
          var o = t.getModel('minorSplitLine'),
            s = o.getModel('lineStyle'),
            l = [],
            u = 0;
          u < i.length;
          u++
        )
          for (var c = 0; c < i[u].length; c++)
            l.push(
              new rr({
                shape: Am(e, a, i[u][c].coord),
              }),
            )
        r.add(
          Wi(l, {
            style: s.getLineStyle(),
            silent: !0,
            z: t.get('z'),
          }),
        )
      }
    },
    splitArea: function (r, t, e, n, i, a) {
      if (n.length) {
        var o = t.getModel('splitArea'),
          s = o.getModel('areaStyle'),
          l = s.get('color'),
          u = 0
        l = l instanceof Array ? l : [l]
        for (
          var c = [],
            h = Math.PI / 180,
            f = -n[0].coord * h,
            d = Math.min(a[0], a[1]),
            p = Math.max(a[0], a[1]),
            g = t.get('clockwise'),
            v = 1,
            m = n.length;
          v <= m;
          v++
        ) {
          var y = v === m ? n[0].coord : n[v].coord,
            _ = u++ % l.length
          ;(c[_] = c[_] || []),
            c[_].push(
              new oi({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r0: d,
                  r: p,
                  startAngle: f,
                  endAngle: -y * h,
                  clockwise: g,
                },
                silent: !0,
              }),
            ),
            (f = -y * h)
        }
        for (var v = 0; v < c.length; v++)
          r.add(
            Wi(c[v], {
              style: zt(
                {
                  fill: l[v % l.length],
                },
                s.getAreaStyle(),
              ),
              silent: !0,
            }),
          )
      }
    },
  }
const xyt = yyt
var Syt = ['axisLine', 'axisTickLabel', 'axisName'],
  Ayt = ['splitLine', 'splitArea', 'minorSplitLine'],
  byt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'PolarAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var i = this._axisGroup,
            a = (this._axisGroup = new Ht())
          this.group.add(a)
          var o = e.axis,
            s = o.polar,
            l = s.getAngleAxis(),
            u = o.getTicksCoords(),
            c = o.getMinorTicksCoords(),
            h = l.getExtent()[0],
            f = o.getExtent(),
            d = Myt(s, e, h),
            p = new ns(e, d)
          R(Syt, p.add, p),
            a.add(p.getGroup()),
            xv(i, a, e),
            R(
              Ayt,
              function (g) {
                e.get([g, 'show']) &&
                  !o.scale.isBlank() &&
                  wyt[g](this.group, e, s, h, f, u, c)
              },
              this,
            )
        }
      }),
      (t.type = 'radiusAxis'),
      t
    )
  })(sc),
  wyt = {
    splitLine: function (r, t, e, n, i, a) {
      var o = t.getModel('splitLine'),
        s = o.getModel('lineStyle'),
        l = s.get('color'),
        u = 0,
        c = e.getAngleAxis(),
        h = Math.PI / 180,
        f = c.getExtent(),
        d = Math.abs(f[1] - f[0]) === 360 ? 'Circle' : 'Arc'
      l = l instanceof Array ? l : [l]
      for (var p = [], g = 0; g < a.length; g++) {
        var v = u++ % l.length
        ;(p[v] = p[v] || []),
          p[v].push(
            new nc[d]({
              shape: {
                cx: e.cx,
                cy: e.cy,
                r: Math.max(a[g].coord, 0),
                startAngle: -f[0] * h,
                endAngle: -f[1] * h,
                clockwise: c.inverse,
              },
            }),
          )
      }
      for (var g = 0; g < p.length; g++)
        r.add(
          Wi(p[g], {
            style: zt(
              {
                stroke: l[g % l.length],
                fill: null,
              },
              s.getLineStyle(),
            ),
            silent: !0,
          }),
        )
    },
    minorSplitLine: function (r, t, e, n, i, a, o) {
      if (o.length) {
        for (
          var s = t.getModel('minorSplitLine'),
            l = s.getModel('lineStyle'),
            u = [],
            c = 0;
          c < o.length;
          c++
        )
          for (var h = 0; h < o[c].length; h++)
            u.push(
              new pl({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r: o[c][h].coord,
                },
              }),
            )
        r.add(
          Wi(u, {
            style: zt(
              {
                fill: null,
              },
              l.getLineStyle(),
            ),
            silent: !0,
          }),
        )
      }
    },
    splitArea: function (r, t, e, n, i, a) {
      if (a.length) {
        var o = t.getModel('splitArea'),
          s = o.getModel('areaStyle'),
          l = s.get('color'),
          u = 0
        l = l instanceof Array ? l : [l]
        for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
          var d = u++ % l.length
          ;(c[d] = c[d] || []),
            c[d].push(
              new oi({
                shape: {
                  cx: e.cx,
                  cy: e.cy,
                  r0: h,
                  r: a[f].coord,
                  startAngle: 0,
                  endAngle: Math.PI * 2,
                },
                silent: !0,
              }),
            ),
            (h = a[f].coord)
        }
        for (var f = 0; f < c.length; f++)
          r.add(
            Wi(c[f], {
              style: zt(
                {
                  fill: l[f % l.length],
                },
                s.getAreaStyle(),
              ),
              silent: !0,
            }),
          )
      }
    },
  }
function Myt(r, t, e) {
  return {
    position: [r.cx, r.cy],
    rotation: (e / 180) * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel('axisLabel').get('rotate'),
    z2: 1,
  }
}
const Tyt = byt
function SH(r) {
  return r.get('stack') || '__ec_stack_' + r.seriesIndex
}
function AH(r, t) {
  return t.dim + r.model.componentIndex
}
function Cyt(r, t, e) {
  var n = {},
    i = Eyt(
      Ne(t.getSeriesByType(r), function (a) {
        return (
          !t.isSeriesFiltered(a) &&
          a.coordinateSystem &&
          a.coordinateSystem.type === 'polar'
        )
      }),
    )
  t.eachSeriesByType(r, function (a) {
    if (a.coordinateSystem.type === 'polar') {
      var o = a.getData(),
        s = a.coordinateSystem,
        l = s.getBaseAxis(),
        u = AH(s, l),
        c = SH(a),
        h = i[u][c],
        f = h.offset,
        d = h.width,
        p = s.getOtherAxis(l),
        g = a.coordinateSystem.cx,
        v = a.coordinateSystem.cy,
        m = a.get('barMinHeight') || 0,
        y = a.get('barMinAngle') || 0
      n[c] = n[c] || []
      for (
        var _ = o.mapDimension(p.dim),
          x = o.mapDimension(l.dim),
          A = sl(o, _),
          S = l.dim !== 'radius' || !a.get('roundCap', !0),
          b = p.model,
          T = b.get('startValue'),
          w = p.dataToCoord(T || 0),
          M = 0,
          C = o.count();
        M < C;
        M++
      ) {
        var E = o.get(_, M),
          D = o.get(x, M),
          P = E >= 0 ? 'p' : 'n',
          L = w
        A &&
          (n[c][D] ||
            (n[c][D] = {
              p: w,
              n: w,
            }),
          (L = n[c][D][P]))
        var I = void 0,
          F = void 0,
          k = void 0,
          V = void 0
        if (p.dim === 'radius') {
          var H = p.dataToCoord(E) - w,
            Y = l.dataToCoord(D)
          Math.abs(H) < m && (H = (H < 0 ? -1 : 1) * m),
            (I = L),
            (F = L + H),
            (k = Y - f),
            (V = k - d),
            A && (n[c][D][P] = F)
        } else {
          var K = p.dataToCoord(E, S) - w,
            ut = l.dataToCoord(D)
          Math.abs(K) < y && (K = (K < 0 ? -1 : 1) * y),
            (I = ut + f),
            (F = I + d),
            (k = L),
            (V = L + K),
            A && (n[c][D][P] = V)
        }
        o.setItemLayout(M, {
          cx: g,
          cy: v,
          r0: I,
          r: F,
          startAngle: (-k * Math.PI) / 180,
          endAngle: (-V * Math.PI) / 180,
          clockwise: k >= V,
        })
      }
    }
  })
}
function Eyt(r) {
  var t = {}
  R(r, function (n, i) {
    var a = n.getData(),
      o = n.coordinateSystem,
      s = o.getBaseAxis(),
      l = AH(o, s),
      u = s.getExtent(),
      c =
        s.type === 'category'
          ? s.getBandWidth()
          : Math.abs(u[1] - u[0]) / a.count(),
      h = t[l] || {
        bandWidth: c,
        remainedWidth: c,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {},
      },
      f = h.stacks
    t[l] = h
    var d = SH(n)
    f[d] || h.autoWidthCount++,
      (f[d] = f[d] || {
        width: 0,
        maxWidth: 0,
      })
    var p = _t(n.get('barWidth'), c),
      g = _t(n.get('barMaxWidth'), c),
      v = n.get('barGap'),
      m = n.get('barCategoryGap')
    p &&
      !f[d].width &&
      ((p = Math.min(h.remainedWidth, p)),
      (f[d].width = p),
      (h.remainedWidth -= p)),
      g && (f[d].maxWidth = g),
      v != null && (h.gap = v),
      m != null && (h.categoryGap = m)
  })
  var e = {}
  return (
    R(t, function (n, i) {
      e[i] = {}
      var a = n.stacks,
        o = n.bandWidth,
        s = _t(n.categoryGap, o),
        l = _t(n.gap, 1),
        u = n.remainedWidth,
        c = n.autoWidthCount,
        h = (u - s) / (c + (c - 1) * l)
      ;(h = Math.max(h, 0)),
        R(a, function (g, v) {
          var m = g.maxWidth
          m &&
            m < h &&
            ((m = Math.min(m, u)),
            g.width && (m = Math.min(m, g.width)),
            (u -= m),
            (g.width = m),
            c--)
        }),
        (h = (u - s) / (c + (c - 1) * l)),
        (h = Math.max(h, 0))
      var f = 0,
        d
      R(a, function (g, v) {
        g.width || (g.width = h), (d = g), (f += g.width * (1 + l))
      }),
        d && (f -= d.width * l)
      var p = -f / 2
      R(a, function (g, v) {
        ;(e[i][v] = e[i][v] || {
          offset: p,
          width: g.width,
        }),
          (p += g.width * (1 + l))
      })
    }),
    e
  )
}
var Dyt = {
    startAngle: 90,
    clockwise: !0,
    splitNumber: 12,
    axisLabel: {
      rotate: 0,
    },
  },
  Lyt = {
    splitNumber: 5,
  },
  Pyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (t.type = 'polar'), t
  })(dn)
function Ryt(r) {
  ie(Ov),
    sc.registerAxisPointerClass('PolarAxisPointer', nyt),
    r.registerCoordinateSystem('polar', gyt),
    r.registerComponentModel(iyt),
    r.registerComponentView(Pyt),
    sf(r, 'angle', ayt, Dyt),
    sf(r, 'radius', oyt, Lyt),
    r.registerComponentView(xyt),
    r.registerComponentView(Tyt),
    r.registerLayout(Zt(Cyt, 'bar'))
}
function Qw(r, t) {
  t = t || {}
  var e = r.coordinateSystem,
    n = r.axis,
    i = {},
    a = n.position,
    o = n.orient,
    s = e.getRect(),
    l = [s.x, s.x + s.width, s.y, s.y + s.height],
    u = {
      horizontal: {
        top: l[2],
        bottom: l[3],
      },
      vertical: {
        left: l[0],
        right: l[1],
      },
    }
  i.position = [
    o === 'vertical' ? u.vertical[a] : l[0],
    o === 'horizontal' ? u.horizontal[a] : l[3],
  ]
  var c = {
    horizontal: 0,
    vertical: 1,
  }
  i.rotation = (Math.PI / 2) * c[o]
  var h = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1,
  }
  ;(i.labelDirection = i.tickDirection = i.nameDirection = h[a]),
    r.get(['axisTick', 'inside']) && (i.tickDirection = -i.tickDirection),
    nr(t.labelInside, r.get(['axisLabel', 'inside'])) &&
      (i.labelDirection = -i.labelDirection)
  var f = t.rotate
  return (
    f == null && (f = r.get(['axisLabel', 'rotate'])),
    (i.labelRotation = a === 'top' ? -f : f),
    (i.z2 = 1),
    i
  )
}
var Iyt = ['axisLine', 'axisTickLabel', 'axisName'],
  Oyt = ['splitArea', 'splitLine'],
  Nyt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.axisPointerClass = 'SingleAxisPointer'), e
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        var o = this.group
        o.removeAll()
        var s = this._axisGroup
        this._axisGroup = new Ht()
        var l = Qw(e),
          u = new ns(e, l)
        R(Iyt, u.add, u),
          o.add(this._axisGroup),
          o.add(u.getGroup()),
          R(
            Oyt,
            function (c) {
              e.get([c, 'show']) && kyt[c](this, this.group, this._axisGroup, e)
            },
            this,
          ),
          xv(s, this._axisGroup, e),
          r.prototype.render.call(this, e, n, i, a)
      }),
      (t.prototype.remove = function () {
        GG(this)
      }),
      (t.type = 'singleAxis'),
      t
    )
  })(sc),
  kyt = {
    splitLine: function (r, t, e, n) {
      var i = n.axis
      if (!i.scale.isBlank()) {
        var a = n.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = s instanceof Array ? s : [s]
        for (
          var l = o.get('width'),
            u = n.coordinateSystem.getRect(),
            c = i.isHorizontal(),
            h = [],
            f = 0,
            d = i.getTicksCoords({
              tickModel: a,
            }),
            p = [],
            g = [],
            v = 0;
          v < d.length;
          ++v
        ) {
          var m = i.toGlobalCoord(d[v].coord)
          c
            ? ((p[0] = m), (p[1] = u.y), (g[0] = m), (g[1] = u.y + u.height))
            : ((p[0] = u.x), (p[1] = m), (g[0] = u.x + u.width), (g[1] = m))
          var y = new rr({
            shape: {
              x1: p[0],
              y1: p[1],
              x2: g[0],
              y2: g[1],
            },
            silent: !0,
          })
          ef(y.shape, l)
          var _ = f++ % s.length
          ;(h[_] = h[_] || []), h[_].push(y)
        }
        for (var x = o.getLineStyle(['color']), v = 0; v < h.length; ++v)
          t.add(
            Wi(h[v], {
              style: zt(
                {
                  stroke: s[v % s.length],
                },
                x,
              ),
              silent: !0,
            }),
          )
      }
    },
    splitArea: function (r, t, e, n) {
      VG(r, e, n, n)
    },
  }
const Byt = Nyt
var bH = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.getCoordSysModel = function () {
      return this
    }),
    (t.type = 'singleAxis'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      left: '5%',
      top: '5%',
      right: '5%',
      bottom: '5%',
      type: 'value',
      position: 'bottom',
      orient: 'horizontal',
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: 'solid',
        },
      },
      tooltip: {
        show: !0,
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1,
        },
      },
      axisLabel: {
        show: !0,
        interval: 'auto',
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: 'dashed',
          opacity: 0.2,
        },
      },
    }),
    t
  )
})(xe)
In(bH, Mv.prototype)
const XS = bH
var Fyt = (function (r) {
  X(t, r)
  function t(e, n, i, a, o) {
    var s = r.call(this, e, n, i) || this
    return (s.type = a || 'value'), (s.position = o || 'bottom'), s
  }
  return (
    (t.prototype.isHorizontal = function () {
      var e = this.position
      return e === 'top' || e === 'bottom'
    }),
    (t.prototype.pointToData = function (e, n) {
      return this.coordinateSystem.pointToData(e)[0]
    }),
    t
  )
})(Ra)
const zyt = Fyt
var wH = ['single'],
  Uyt = (function () {
    function r(t, e, n) {
      ;(this.type = 'single'),
        (this.dimension = 'single'),
        (this.dimensions = wH),
        (this.axisPointerEnabled = !0),
        (this.model = t),
        this._init(t, e, n)
    }
    return (
      (r.prototype._init = function (t, e, n) {
        var i = this.dimension,
          a = new zyt(i, w_(t), [0, 0], t.get('type'), t.get('position')),
          o = a.type === 'category'
        ;(a.onBand = o && t.get('boundaryGap')),
          (a.inverse = t.get('inverse')),
          (a.orient = t.get('orient')),
          (t.axis = a),
          (a.model = t),
          (a.coordinateSystem = this),
          (this._axis = a)
      }),
      (r.prototype.update = function (t, e) {
        t.eachSeries(function (n) {
          if (n.coordinateSystem === this) {
            var i = n.getData()
            R(
              i.mapDimensionsAll(this.dimension),
              function (a) {
                this._axis.scale.unionExtentFromData(i, a)
              },
              this,
            ),
              af(this._axis.scale, this._axis.model)
          }
        }, this)
      }),
      (r.prototype.resize = function (t, e) {
        ;(this._rect = Vn(
          {
            left: t.get('left'),
            top: t.get('top'),
            right: t.get('right'),
            bottom: t.get('bottom'),
            width: t.get('width'),
            height: t.get('height'),
          },
          {
            width: e.getWidth(),
            height: e.getHeight(),
          },
        )),
          this._adjustAxis()
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype._adjustAxis = function () {
        var t = this._rect,
          e = this._axis,
          n = e.isHorizontal(),
          i = n ? [0, t.width] : [0, t.height],
          a = e.inverse ? 1 : 0
        e.setExtent(i[a], i[1 - a]), this._updateAxisTransform(e, n ? t.x : t.y)
      }),
      (r.prototype._updateAxisTransform = function (t, e) {
        var n = t.getExtent(),
          i = n[0] + n[1],
          a = t.isHorizontal()
        ;(t.toGlobalCoord = a
          ? function (o) {
              return o + e
            }
          : function (o) {
              return i - o + e
            }),
          (t.toLocalCoord = a
            ? function (o) {
                return o - e
              }
            : function (o) {
                return i - o + e
              })
      }),
      (r.prototype.getAxis = function () {
        return this._axis
      }),
      (r.prototype.getBaseAxis = function () {
        return this._axis
      }),
      (r.prototype.getAxes = function () {
        return [this._axis]
      }),
      (r.prototype.getTooltipAxes = function () {
        return {
          baseAxes: [this.getAxis()],
          otherAxes: [],
        }
      }),
      (r.prototype.containPoint = function (t) {
        var e = this.getRect(),
          n = this.getAxis(),
          i = n.orient
        return i === 'horizontal'
          ? n.contain(n.toLocalCoord(t[0])) &&
              t[1] >= e.y &&
              t[1] <= e.y + e.height
          : n.contain(n.toLocalCoord(t[1])) &&
              t[0] >= e.y &&
              t[0] <= e.y + e.height
      }),
      (r.prototype.pointToData = function (t) {
        var e = this.getAxis()
        return [
          e.coordToData(e.toLocalCoord(t[e.orient === 'horizontal' ? 0 : 1])),
        ]
      }),
      (r.prototype.dataToPoint = function (t) {
        var e = this.getAxis(),
          n = this.getRect(),
          i = [],
          a = e.orient === 'horizontal' ? 0 : 1
        return (
          t instanceof Array && (t = t[0]),
          (i[a] = e.toGlobalCoord(e.dataToCoord(+t))),
          (i[1 - a] = a === 0 ? n.y + n.height / 2 : n.x + n.width / 2),
          i
        )
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = n3(e)
        return i === this ? this.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = n3(e)
        return i === this ? this.pointToData(n) : null
      }),
      r
    )
  })()
function n3(r) {
  var t = r.seriesModel,
    e = r.singleAxisModel
  return (e && e.coordinateSystem) || (t && t.coordinateSystem)
}
function Vyt(r, t) {
  var e = []
  return (
    r.eachComponent('singleAxis', function (n, i) {
      var a = new Uyt(n, r, t)
      ;(a.name = 'single_' + i),
        a.resize(n, t),
        (n.coordinateSystem = a),
        e.push(a)
    }),
    r.eachSeries(function (n) {
      if (n.get('coordinateSystem') === 'singleAxis') {
        var i = n.getReferringComponents('singleAxis', Pn).models[0]
        n.coordinateSystem = i && i.coordinateSystem
      }
    }),
    e
  )
}
var Gyt = {
  create: Vyt,
  dimensions: wH,
}
const Hyt = Gyt
var r3 = ['x', 'y'],
  Wyt = ['width', 'height'],
  Xyt = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.makeElOption = function (e, n, i, a, o) {
        var s = i.axis,
          l = s.coordinateSystem,
          u = YS(l, 1 - S0(s)),
          c = l.dataToPoint(n)[0],
          h = a.get('type')
        if (h && h !== 'none') {
          var f = gE(a),
            d = Yyt[h](s, c, u)
          ;(d.style = f), (e.graphicKey = d.type), (e.pointer = d)
        }
        var p = Qw(i)
        gH(n, e, p, i, a, o)
      }),
      (t.prototype.getHandleTransform = function (e, n, i) {
        var a = Qw(n, {
          labelInside: !1,
        })
        a.labelMargin = i.get(['handle', 'margin'])
        var o = mE(n.axis, e, a)
        return {
          x: o[0],
          y: o[1],
          rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0),
        }
      }),
      (t.prototype.updateHandleTransform = function (e, n, i, a) {
        var o = i.axis,
          s = o.coordinateSystem,
          l = S0(o),
          u = YS(s, l),
          c = [e.x, e.y]
        ;(c[l] += n[l]),
          (c[l] = Math.min(u[1], c[l])),
          (c[l] = Math.max(u[0], c[l]))
        var h = YS(s, 1 - l),
          f = (h[1] + h[0]) / 2,
          d = [f, f]
        return (
          (d[l] = c[l]),
          {
            x: c[0],
            y: c[1],
            rotation: e.rotation,
            cursorPoint: d,
            tooltipOption: {
              verticalAlign: 'middle',
            },
          }
        )
      }),
      t
    )
  })(vE),
  Yyt = {
    line: function (r, t, e) {
      var n = yE([t, e[0]], [t, e[1]], S0(r))
      return {
        type: 'Line',
        subPixelOptimize: !0,
        shape: n,
      }
    },
    shadow: function (r, t, e) {
      var n = r.getBandWidth(),
        i = e[1] - e[0]
      return {
        type: 'Rect',
        shape: mH([t - n / 2, e[0]], [n, i], S0(r)),
      }
    },
  }
function S0(r) {
  return r.isHorizontal() ? 0 : 1
}
function YS(r, t) {
  var e = r.getRect()
  return [e[r3[t]], e[r3[t]] + e[Wyt[t]]]
}
const $yt = Xyt
var qyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'single'), t
})(dn)
function Zyt(r) {
  ie(Ov),
    sc.registerAxisPointerClass('SingleAxisPointer', $yt),
    r.registerComponentView(qyt),
    r.registerComponentView(Byt),
    r.registerComponentModel(XS),
    sf(r, 'single', XS, XS.defaultOption),
    r.registerCoordinateSystem('single', Hyt)
}
var Kyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      var a = Mf(e)
      r.prototype.init.apply(this, arguments), i3(e, a)
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments), i3(this.option, e)
    }),
    (t.prototype.getCellSize = function () {
      return this.option.cellSize
    }),
    (t.type = 'calendar'),
    (t.defaultOption = {
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: 'horizontal',
      splitLine: {
        show: !0,
        lineStyle: {
          color: '#000',
          width: 1,
          type: 'solid',
        },
      },
      itemStyle: {
        color: '#fff',
        borderWidth: 1,
        borderColor: '#ccc',
      },
      dayLabel: {
        show: !0,
        firstDay: 0,
        position: 'start',
        margin: '50%',
        color: '#000',
      },
      monthLabel: {
        show: !0,
        position: 'start',
        margin: 5,
        align: 'center',
        formatter: null,
        color: '#000',
      },
      yearLabel: {
        show: !0,
        position: null,
        margin: 30,
        formatter: null,
        color: '#ccc',
        fontFamily: 'sans-serif',
        fontWeight: 'bolder',
        fontSize: 20,
      },
    }),
    t
  )
})(xe)
function i3(r, t) {
  var e = r.cellSize,
    n
  at(e) ? (n = e) : (n = r.cellSize = [e, e]), n.length === 1 && (n[1] = n[0])
  var i = st([0, 1], function (a) {
    return ert(t, a) && (n[a] = 'auto'), n[a] != null && n[a] !== 'auto'
  })
  ol(r, t, {
    type: 'box',
    ignoreSize: i,
  })
}
const jyt = Kyt
var Jyt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i) {
      var a = this.group
      a.removeAll()
      var o = e.coordinateSystem,
        s = o.getRangeInfo(),
        l = o.getOrient(),
        u = n.getLocaleModel()
      this._renderDayRect(e, s, a),
        this._renderLines(e, s, l, a),
        this._renderYearText(e, s, l, a),
        this._renderMonthText(e, u, l, a),
        this._renderWeekText(e, u, s, l, a)
    }),
    (t.prototype._renderDayRect = function (e, n, i) {
      for (
        var a = e.coordinateSystem,
          o = e.getModel('itemStyle').getItemStyle(),
          s = a.getCellWidth(),
          l = a.getCellHeight(),
          u = n.start.time;
        u <= n.end.time;
        u = a.getNextNDay(u, 1).time
      ) {
        var c = a.dataToRect([u], !1).tl,
          h = new ge({
            shape: {
              x: c[0],
              y: c[1],
              width: s,
              height: l,
            },
            cursor: 'default',
            style: o,
          })
        i.add(h)
      }
    }),
    (t.prototype._renderLines = function (e, n, i, a) {
      var o = this,
        s = e.coordinateSystem,
        l = e.getModel(['splitLine', 'lineStyle']).getLineStyle(),
        u = e.get(['splitLine', 'show']),
        c = l.lineWidth
      ;(this._tlpoints = []),
        (this._blpoints = []),
        (this._firstDayOfMonth = []),
        (this._firstDayPoints = [])
      for (var h = n.start, f = 0; h.time <= n.end.time; f++) {
        p(h.formatedDate),
          f === 0 && (h = s.getDateInfo(n.start.y + '-' + n.start.m))
        var d = h.date
        d.setMonth(d.getMonth() + 1), (h = s.getDateInfo(d))
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate)
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)),
          o._firstDayPoints.push(s.dataToRect([g], !1).tl)
        var v = o._getLinePointsOfOneWeek(e, g, i)
        o._tlpoints.push(v[0]),
          o._blpoints.push(v[v.length - 1]),
          u && o._drawSplitline(v, l, a)
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a),
        u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a)
    }),
    (t.prototype._getEdgesPoints = function (e, n, i) {
      var a = [e[0].slice(), e[e.length - 1].slice()],
        o = i === 'horizontal' ? 0 : 1
      return (a[0][o] = a[0][o] - n / 2), (a[1][o] = a[1][o] + n / 2), a
    }),
    (t.prototype._drawSplitline = function (e, n, i) {
      var a = new li({
        z2: 20,
        shape: {
          points: e,
        },
        style: n,
      })
      i.add(a)
    }),
    (t.prototype._getLinePointsOfOneWeek = function (e, n, i) {
      for (
        var a = e.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0;
        l < 7;
        l++
      ) {
        var u = a.getNextNDay(o.time, l),
          c = a.dataToRect([u.time], !1)
        ;(s[2 * u.day] = c.tl),
          (s[2 * u.day + 1] = c[i === 'horizontal' ? 'bl' : 'tr'])
      }
      return s
    }),
    (t.prototype._formatterLabel = function (e, n) {
      return bt(e) && e ? Jnt(e, n) : Nt(e) ? e(n) : n.nameMap
    }),
    (t.prototype._yearTextPositionControl = function (e, n, i, a, o) {
      var s = n[0],
        l = n[1],
        u = ['center', 'bottom']
      a === 'bottom'
        ? ((l += o), (u = ['center', 'top']))
        : a === 'left'
        ? (s -= o)
        : a === 'right'
        ? ((s += o), (u = ['center', 'top']))
        : (l -= o)
      var c = 0
      return (
        (a === 'left' || a === 'right') && (c = Math.PI / 2),
        {
          rotation: c,
          x: s,
          y: l,
          style: {
            align: u[0],
            verticalAlign: u[1],
          },
        }
      )
    }),
    (t.prototype._renderYearText = function (e, n, i, a) {
      var o = e.getModel('yearLabel')
      if (o.get('show')) {
        var s = o.get('margin'),
          l = o.get('position')
        l || (l = i !== 'horizontal' ? 'top' : 'left')
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
          c = (u[0][0] + u[1][0]) / 2,
          h = (u[0][1] + u[1][1]) / 2,
          f = i === 'horizontal' ? 0 : 1,
          d = {
            top: [c, u[f][1]],
            bottom: [c, u[1 - f][1]],
            left: [u[1 - f][0], h],
            right: [u[f][0], h],
          },
          p = n.start.y
        ;+n.end.y > +n.start.y && (p = p + '-' + n.end.y)
        var g = o.get('formatter'),
          v = {
            start: n.start.y,
            end: n.end.y,
            nameMap: p,
          },
          m = this._formatterLabel(g, v),
          y = new Ae({
            z2: 30,
            style: $e(o, {
              text: m,
            }),
          })
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y)
      }
    }),
    (t.prototype._monthTextPositionControl = function (e, n, i, a, o) {
      var s = 'left',
        l = 'top',
        u = e[0],
        c = e[1]
      return (
        i === 'horizontal'
          ? ((c = c + o), n && (s = 'center'), a === 'start' && (l = 'bottom'))
          : ((u = u + o), n && (l = 'middle'), a === 'start' && (s = 'right')),
        {
          x: u,
          y: c,
          align: s,
          verticalAlign: l,
        }
      )
    }),
    (t.prototype._renderMonthText = function (e, n, i, a) {
      var o = e.getModel('monthLabel')
      if (o.get('show')) {
        var s = o.get('nameMap'),
          l = o.get('margin'),
          u = o.get('position'),
          c = o.get('align'),
          h = [this._tlpoints, this._blpoints]
        ;(!s || bt(s)) &&
          (s && (n = uw(s) || n), (s = n.get(['time', 'monthAbbr']) || []))
        var f = u === 'start' ? 0 : 1,
          d = i === 'horizontal' ? 0 : 1
        l = u === 'start' ? -l : l
        for (var p = c === 'center', g = 0; g < h[f].length - 1; g++) {
          var v = h[f][g].slice(),
            m = this._firstDayOfMonth[g]
          if (p) {
            var y = this._firstDayPoints[g]
            v[d] = (y[d] + h[0][g + 1][d]) / 2
          }
          var _ = o.get('formatter'),
            x = s[+m.m - 1],
            A = {
              yyyy: m.y,
              yy: (m.y + '').slice(2),
              MM: m.m,
              M: +m.m,
              nameMap: x,
            },
            S = this._formatterLabel(_, A),
            b = new Ae({
              z2: 30,
              style: Q(
                $e(o, {
                  text: S,
                }),
                this._monthTextPositionControl(v, p, i, u, l),
              ),
            })
          a.add(b)
        }
      }
    }),
    (t.prototype._weekTextPositionControl = function (e, n, i, a, o) {
      var s = 'center',
        l = 'middle',
        u = e[0],
        c = e[1],
        h = i === 'start'
      return (
        n === 'horizontal'
          ? ((u = u + a + ((h ? 1 : -1) * o[0]) / 2),
            (s = h ? 'right' : 'left'))
          : ((c = c + a + ((h ? 1 : -1) * o[1]) / 2),
            (l = h ? 'bottom' : 'top')),
        {
          x: u,
          y: c,
          align: s,
          verticalAlign: l,
        }
      )
    }),
    (t.prototype._renderWeekText = function (e, n, i, a, o) {
      var s = e.getModel('dayLabel')
      if (s.get('show')) {
        var l = e.coordinateSystem,
          u = s.get('position'),
          c = s.get('nameMap'),
          h = s.get('margin'),
          f = l.getFirstDayOfWeek()
        if (!c || bt(c)) {
          c && (n = uw(c) || n)
          var d = n.get(['time', 'dayOfWeekShort'])
          c =
            d ||
            st(n.get(['time', 'dayOfWeekAbbr']), function (A) {
              return A[0]
            })
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time,
          g = [l.getCellWidth(), l.getCellHeight()]
        ;(h = _t(h, Math.min(g[1], g[0]))),
          u === 'start' &&
            ((p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time), (h = -h))
        for (var v = 0; v < 7; v++) {
          var m = l.getNextNDay(p, v),
            y = l.dataToRect([m.time], !1).center,
            _ = v
          _ = Math.abs((v + f) % 7)
          var x = new Ae({
            z2: 30,
            style: Q(
              $e(s, {
                text: c[_],
              }),
              this._weekTextPositionControl(y, a, u, h, g),
            ),
          })
          o.add(x)
        }
      }
    }),
    (t.type = 'calendar'),
    t
  )
})(dn)
const Qyt = Jyt
var $S = 864e5,
  t0t = (function () {
    function r(t, e, n) {
      ;(this.type = 'calendar'),
        (this.dimensions = r.dimensions),
        (this.getDimensionsInfo = r.getDimensionsInfo),
        (this._model = t)
    }
    return (
      (r.getDimensionsInfo = function () {
        return [
          {
            name: 'time',
            type: 'time',
          },
          'value',
        ]
      }),
      (r.prototype.getRangeInfo = function () {
        return this._rangeInfo
      }),
      (r.prototype.getModel = function () {
        return this._model
      }),
      (r.prototype.getRect = function () {
        return this._rect
      }),
      (r.prototype.getCellWidth = function () {
        return this._sw
      }),
      (r.prototype.getCellHeight = function () {
        return this._sh
      }),
      (r.prototype.getOrient = function () {
        return this._orient
      }),
      (r.prototype.getFirstDayOfWeek = function () {
        return this._firstDayOfWeek
      }),
      (r.prototype.getDateInfo = function (t) {
        t = po(t)
        var e = t.getFullYear(),
          n = t.getMonth() + 1,
          i = n < 10 ? '0' + n : '' + n,
          a = t.getDate(),
          o = a < 10 ? '0' + a : '' + a,
          s = t.getDay()
        return (
          (s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7)),
          {
            y: e + '',
            m: i,
            d: o,
            day: s,
            time: t.getTime(),
            formatedDate: e + '-' + i + '-' + o,
            date: t,
          }
        )
      }),
      (r.prototype.getNextNDay = function (t, e) {
        return (
          (e = e || 0),
          e === 0
            ? this.getDateInfo(t)
            : ((t = new Date(this.getDateInfo(t).time)),
              t.setDate(t.getDate() + e),
              this.getDateInfo(t))
        )
      }),
      (r.prototype.update = function (t, e) {
        ;(this._firstDayOfWeek = +this._model
          .getModel('dayLabel')
          .get('firstDay')),
          (this._orient = this._model.get('orient')),
          (this._lineWidth =
            this._model.getModel('itemStyle').getItemStyle().lineWidth || 0),
          (this._rangeInfo = this._getRangeInfo(this._initRangeOption()))
        var n = this._rangeInfo.weeks || 1,
          i = ['width', 'height'],
          a = this._model.getCellSize().slice(),
          o = this._model.getBoxLayoutParams(),
          s = this._orient === 'horizontal' ? [n, 7] : [7, n]
        R([0, 1], function (h) {
          c(a, h) && (o[i[h]] = a[h] * s[h])
        })
        var l = {
            width: e.getWidth(),
            height: e.getHeight(),
          },
          u = (this._rect = Vn(o, l))
        R([0, 1], function (h) {
          c(a, h) || (a[h] = u[i[h]] / s[h])
        })
        function c(h, f) {
          return h[f] != null && h[f] !== 'auto'
        }
        ;(this._sw = a[0]), (this._sh = a[1])
      }),
      (r.prototype.dataToPoint = function (t, e) {
        at(t) && (t = t[0]), e == null && (e = !0)
        var n = this.getDateInfo(t),
          i = this._rangeInfo,
          a = n.formatedDate
        if (e && !(n.time >= i.start.time && n.time < i.end.time + $S))
          return [NaN, NaN]
        var o = n.day,
          s = this._getRangeInfo([i.start.time, a]).nthWeek
        return this._orient === 'vertical'
          ? [
              this._rect.x + o * this._sw + this._sw / 2,
              this._rect.y + s * this._sh + this._sh / 2,
            ]
          : [
              this._rect.x + s * this._sw + this._sw / 2,
              this._rect.y + o * this._sh + this._sh / 2,
            ]
      }),
      (r.prototype.pointToData = function (t) {
        var e = this.pointToDate(t)
        return e && e.time
      }),
      (r.prototype.dataToRect = function (t, e) {
        var n = this.dataToPoint(t, e)
        return {
          contentShape: {
            x: n[0] - (this._sw - this._lineWidth) / 2,
            y: n[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth,
          },
          center: n,
          tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
          tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
          br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
          bl: [n[0] - this._sw / 2, n[1] + this._sh / 2],
        }
      }),
      (r.prototype.pointToDate = function (t) {
        var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1,
          n = Math.floor((t[1] - this._rect.y) / this._sh) + 1,
          i = this._rangeInfo.range
        return this._orient === 'vertical'
          ? this._getDateByWeeksAndDay(n, e - 1, i)
          : this._getDateByWeeksAndDay(e, n - 1, i)
      }),
      (r.prototype.convertToPixel = function (t, e, n) {
        var i = a3(e)
        return i === this ? i.dataToPoint(n) : null
      }),
      (r.prototype.convertFromPixel = function (t, e, n) {
        var i = a3(e)
        return i === this ? i.pointToData(n) : null
      }),
      (r.prototype.containPoint = function (t) {
        return console.warn('Not implemented.'), !1
      }),
      (r.prototype._initRangeOption = function () {
        var t = this._model.get('range'),
          e
        if ((at(t) && t.length === 1 && (t = t[0]), at(t))) e = t
        else {
          var n = t.toString()
          if (
            (/^\d{4}$/.test(n) && (e = [n + '-01-01', n + '-12-31']),
            /^\d{4}[\/|-]\d{1,2}$/.test(n))
          ) {
            var i = this.getDateInfo(n),
              a = i.date
            a.setMonth(a.getMonth() + 1)
            var o = this.getNextNDay(a, -1)
            e = [i.formatedDate, o.formatedDate]
          }
          ;/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (e = [n, n])
        }
        if (!e) return t
        var s = this._getRangeInfo(e)
        return s.start.time > s.end.time && e.reverse(), e
      }),
      (r.prototype._getRangeInfo = function (t) {
        var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])],
          n
        e[0].time > e[1].time && ((n = !0), e.reverse())
        var i = Math.floor(e[1].time / $S) - Math.floor(e[0].time / $S) + 1,
          a = new Date(e[0].time),
          o = a.getDate(),
          s = e[1].date.getDate()
        a.setDate(o + i - 1)
        var l = a.getDate()
        if (l !== s)
          for (
            var u = a.getTime() - e[1].time > 0 ? 1 : -1;
            (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0;

          )
            (i -= u), a.setDate(l - u)
        var c = Math.floor((i + e[0].day + 6) / 7),
          h = n ? -c + 1 : c - 1
        return (
          n && e.reverse(),
          {
            range: [e[0].formatedDate, e[1].formatedDate],
            start: e[0],
            end: e[1],
            allDay: i,
            weeks: c,
            nthWeek: h,
            fweek: e[0].day,
            lweek: e[1].day,
          }
        )
      }),
      (r.prototype._getDateByWeeksAndDay = function (t, e, n) {
        var i = this._getRangeInfo(n)
        if (
          t > i.weeks ||
          (t === 0 && e < i.fweek) ||
          (t === i.weeks && e > i.lweek)
        )
          return null
        var a = (t - 1) * 7 - i.fweek + e,
          o = new Date(i.start.time)
        return o.setDate(+i.start.d + a), this.getDateInfo(o)
      }),
      (r.create = function (t, e) {
        var n = []
        return (
          t.eachComponent('calendar', function (i) {
            var a = new r(i)
            n.push(a), (i.coordinateSystem = a)
          }),
          t.eachSeries(function (i) {
            i.get('coordinateSystem') === 'calendar' &&
              (i.coordinateSystem = n[i.get('calendarIndex') || 0])
          }),
          n
        )
      }),
      (r.dimensions = ['time', 'value']),
      r
    )
  })()
function a3(r) {
  var t = r.calendarModel,
    e = r.seriesModel,
    n = t ? t.coordinateSystem : e ? e.coordinateSystem : null
  return n
}
const e0t = t0t
function n0t(r) {
  r.registerComponentModel(jyt),
    r.registerComponentView(Qyt),
    r.registerCoordinateSystem('calendar', e0t)
}
function r0t(r, t) {
  var e = r.existing
  if (
    ((t.id = r.keyInfo.id),
    !t.type && e && (t.type = e.type),
    t.parentId == null)
  ) {
    var n = t.parentOption
    n ? (t.parentId = n.id) : e && (t.parentId = e.parentId)
  }
  t.parentOption = null
}
function o3(r, t) {
  var e
  return (
    R(t, function (n) {
      r[n] != null && r[n] !== 'auto' && (e = !0)
    }),
    e
  )
}
function i0t(r, t, e) {
  var n = Q({}, e),
    i = r[t],
    a = e.$action || 'merge'
  a === 'merge'
    ? i
      ? (te(i, n, !0),
        ol(i, n, {
          ignoreSize: !0,
        }),
        o5(e, i),
        wm(e, i),
        wm(e, i, 'shape'),
        wm(e, i, 'style'),
        wm(e, i, 'extra'),
        (e.clipPath = i.clipPath))
      : (r[t] = n)
    : a === 'replace'
    ? (r[t] = n)
    : a === 'remove' && i && (r[t] = null)
}
var MH = ['transition', 'enterFrom', 'leaveTo'],
  a0t = MH.concat(['enterAnimation', 'updateAnimation', 'leaveAnimation'])
function wm(r, t, e) {
  if (
    (e && (!r[e] && t[e] && (r[e] = {}), (r = r[e]), (t = t[e])), !(!r || !t))
  )
    for (var n = e ? MH : a0t, i = 0; i < n.length; i++) {
      var a = n[i]
      r[a] == null && t[a] != null && (r[a] = t[a])
    }
}
function o0t(r, t) {
  if (
    r &&
    ((r.hv = t.hv = [o3(t, ['left', 'right']), o3(t, ['top', 'bottom'])]),
    r.type === 'group')
  ) {
    var e = r,
      n = t
    e.width == null && (e.width = n.width = 0),
      e.height == null && (e.height = n.height = 0)
  }
}
var s0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.preventAutoZ = !0), e
    }
    return (
      (t.prototype.mergeOption = function (e, n) {
        var i = this.option.elements
        ;(this.option.elements = null),
          r.prototype.mergeOption.call(this, e, n),
          (this.option.elements = i)
      }),
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option,
          a = (n ? i : e).elements,
          o = (i.elements = n ? [] : i.elements),
          s = []
        this._flatten(a, s, null)
        var l = Hz(o, s, 'normalMerge'),
          u = (this._elOptionsToUpdate = [])
        R(
          l,
          function (c, h) {
            var f = c.newOption
            f && (u.push(f), r0t(c, f), i0t(o, h, f), o0t(o[h], f))
          },
          this,
        ),
          (i.elements = Ne(o, function (c) {
            return c && delete c.$action, c != null
          }))
      }),
      (t.prototype._flatten = function (e, n, i) {
        R(
          e,
          function (a) {
            if (a) {
              i && (a.parentOption = i), n.push(a)
              var o = a.children
              o && o.length && this._flatten(o, n, a), delete a.children
            }
          },
          this,
        )
      }),
      (t.prototype.useElOptionsToUpdate = function () {
        var e = this._elOptionsToUpdate
        return (this._elOptionsToUpdate = null), e
      }),
      (t.type = 'graphic'),
      (t.defaultOption = {
        elements: [],
      }),
      t
    )
  })(xe),
  s3 = {
    path: null,
    compoundPath: null,
    group: Ht,
    image: yr,
    text: Ae,
  },
  Vi = ve(),
  l0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function () {
        this._elMap = Pt()
      }),
      (t.prototype.render = function (e, n, i) {
        e !== this._lastGraphicModel && this._clear(),
          (this._lastGraphicModel = e),
          this._updateElements(e),
          this._relocate(e, i)
      }),
      (t.prototype._updateElements = function (e) {
        var n = e.useElOptionsToUpdate()
        if (n) {
          var i = this._elMap,
            a = this.group,
            o = e.get('z'),
            s = e.get('zlevel')
          R(n, function (l) {
            var u = Un(l.id, null),
              c = u != null ? i.get(u) : null,
              h = Un(l.parentId, null),
              f = h != null ? i.get(h) : a,
              d = l.type,
              p = l.style
            d === 'text' &&
              p &&
              l.hv &&
              l.hv[1] &&
              (p.textVerticalAlign =
                p.textBaseline =
                p.verticalAlign =
                p.align =
                  null)
            var g = l.textContent,
              v = l.textConfig
            if (p && iH(p, d, !!v, !!g)) {
              var m = aH(p, d, !0)
              !v && m.textConfig && (v = l.textConfig = m.textConfig),
                !g && m.textContent && (g = m.textContent)
            }
            var y = u0t(l),
              _ = l.$action || 'merge',
              x = _ === 'merge',
              A = _ === 'replace'
            if (x) {
              var S = !c,
                b = c
              S ? (b = l3(u, f, l.type, i)) : (b && (Vi(b).isNew = !1), uH(b)),
                b &&
                  (sy(b, y, e, {
                    isInit: S,
                  }),
                  u3(b, l, o, s))
            } else if (A) {
              uy(c, l, i, e)
              var T = l3(u, f, l.type, i)
              T &&
                (sy(T, y, e, {
                  isInit: !0,
                }),
                u3(T, l, o, s))
            } else _ === 'remove' && (sH(c, l), uy(c, l, i, e))
            var w = i.get(u)
            if (w && g)
              if (x) {
                var M = w.getTextContent()
                M ? M.attr(g) : w.setTextContent(new Ae(g))
              } else A && w.setTextContent(new Ae(g))
            if (w) {
              var C = l.clipPath
              if (C) {
                var E = C.type,
                  D = void 0,
                  S = !1
                if (x) {
                  var P = w.getClipPath()
                  ;(S = !P || Vi(P).type !== E), (D = S ? tM(E) : P)
                } else A && ((S = !0), (D = tM(E)))
                w.setClipPath(D),
                  sy(D, C, e, {
                    isInit: S,
                  }),
                  _0(D, C.keyframeAnimation, e)
              }
              var L = Vi(w)
              w.setTextConfig(v),
                (L.option = l),
                c0t(w, e, l),
                Sf({
                  el: w,
                  componentModel: e,
                  itemName: w.name,
                  itemTooltipOption: l.tooltip,
                }),
                _0(w, l.keyframeAnimation, e)
            }
          })
        }
      }),
      (t.prototype._relocate = function (e, n) {
        for (
          var i = e.option.elements,
            a = this.group,
            o = this._elMap,
            s = n.getWidth(),
            l = n.getHeight(),
            u = ['x', 'y'],
            c = 0;
          c < i.length;
          c++
        ) {
          var h = i[c],
            f = Un(h.id, null),
            d = f != null ? o.get(f) : null
          if (!(!d || !d.isGroup)) {
            var p = d.parent,
              g = p === a,
              v = Vi(d),
              m = Vi(p)
            ;(v.width = _t(v.option.width, g ? s : m.width) || 0),
              (v.height = _t(v.option.height, g ? l : m.height) || 0)
          }
        }
        for (var c = i.length - 1; c >= 0; c--) {
          var h = i[c],
            f = Un(h.id, null),
            d = f != null ? o.get(f) : null
          if (d) {
            var p = d.parent,
              m = Vi(p),
              y =
                p === a
                  ? {
                      width: s,
                      height: l,
                    }
                  : {
                      width: m.width,
                      height: m.height,
                    },
              _ = {},
              x = p_(
                d,
                h,
                y,
                null,
                {
                  hv: h.hv,
                  boundingMode: h.bounding,
                },
                _,
              )
            if (!Vi(d).isNew && x) {
              for (var A = h.transition, S = {}, b = 0; b < u.length; b++) {
                var T = u[b],
                  w = _[T]
                A && (zu(A) || re(A, T) >= 0) ? (S[T] = w) : (d[T] = w)
              }
              we(d, S, e, 0)
            } else d.attr(_)
          }
        }
      }),
      (t.prototype._clear = function () {
        var e = this,
          n = this._elMap
        n.each(function (i) {
          uy(i, Vi(i).option, n, e._lastGraphicModel)
        }),
          (this._elMap = Pt())
      }),
      (t.prototype.dispose = function () {
        this._clear()
      }),
      (t.type = 'graphic'),
      t
    )
  })(dn)
function tM(r) {
  var t = Et(s3, r) ? s3[r] : tC(r),
    e = new t({})
  return (Vi(e).type = r), e
}
function l3(r, t, e, n) {
  var i = tM(e)
  return t.add(i), n.set(r, i), (Vi(i).id = r), (Vi(i).isNew = !0), i
}
function uy(r, t, e, n) {
  var i = r && r.parent
  i &&
    (r.type === 'group' &&
      r.traverse(function (a) {
        uy(a, t, e, n)
      }),
    P_(r, t, n),
    e.removeKey(Vi(r).id))
}
function u3(r, t, e, n) {
  r.isGroup ||
    R(
      [
        ['cursor', ea.prototype.cursor],
        ['zlevel', n || 0],
        ['z', e || 0],
        ['z2', 0],
      ],
      function (i) {
        var a = i[0]
        Et(t, a) ? (r[a] = $t(t[a], i[1])) : r[a] == null && (r[a] = i[1])
      },
    ),
    R(pe(t), function (i) {
      if (i.indexOf('on') === 0) {
        var a = t[i]
        r[i] = Nt(a) ? a : null
      }
    }),
    Et(t, 'draggable') && (r.draggable = t.draggable),
    t.name != null && (r.name = t.name),
    t.id != null && (r.id = t.id)
}
function u0t(r) {
  return (
    (r = Q({}, r)),
    R(
      [
        'id',
        'parentId',
        '$action',
        'hv',
        'bounding',
        'textContent',
        'clipPath',
      ].concat(a5),
      function (t) {
        delete r[t]
      },
    ),
    r
  )
}
function c0t(r, t, e) {
  var n = Wt(r).eventData
  !r.silent &&
    !r.ignore &&
    !n &&
    (n = Wt(r).eventData =
      {
        componentType: 'graphic',
        componentIndex: t.componentIndex,
        name: r.name,
      }),
    n && (n.info = e.info)
}
function h0t(r) {
  r.registerComponentModel(s0t),
    r.registerComponentView(l0t),
    r.registerPreprocessor(function (t) {
      var e = t.graphic
      at(e)
        ? !e[0] || !e[0].elements
          ? (t.graphic = [
              {
                elements: e,
              },
            ])
          : (t.graphic = [t.graphic[0]])
        : e &&
          !e.elements &&
          (t.graphic = [
            {
              elements: [e],
            },
          ])
    })
}
var c3 = ['x', 'y', 'radius', 'angle', 'single'],
  f0t = ['cartesian2d', 'polar', 'singleAxis']
function d0t(r) {
  var t = r.get('coordinateSystem')
  return re(f0t, t) >= 0
}
function Ws(r) {
  return r + 'Axis'
}
function p0t(r, t) {
  var e = Pt(),
    n = [],
    i = Pt()
  r.eachComponent(
    {
      mainType: 'dataZoom',
      query: t,
    },
    function (c) {
      i.get(c.uid) || s(c)
    },
  )
  var a
  do (a = !1), r.eachComponent('dataZoom', o)
  while (a)
  function o(c) {
    !i.get(c.uid) && l(c) && (s(c), (a = !0))
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c)
  }
  function l(c) {
    var h = !1
    return (
      c.eachTargetAxis(function (f, d) {
        var p = e.get(f)
        p && p[d] && (h = !0)
      }),
      h
    )
  }
  function u(c) {
    c.eachTargetAxis(function (h, f) {
      ;(e.get(h) || e.set(h, []))[f] = !0
    })
  }
  return n
}
function TH(r) {
  var t = r.ecModel,
    e = {
      infoList: [],
      infoMap: Pt(),
    }
  return (
    r.eachTargetAxis(function (n, i) {
      var a = t.getComponent(Ws(n), i)
      if (a) {
        var o = a.getCoordSysModel()
        if (o) {
          var s = o.uid,
            l = e.infoMap.get(s)
          l ||
            ((l = {
              model: o,
              axisModels: [],
            }),
            e.infoList.push(l),
            e.infoMap.set(s, l)),
            l.axisModels.push(a)
        }
      }
    }),
    e
  )
}
var qS = (function () {
    function r() {
      ;(this.indexList = []), (this.indexMap = [])
    }
    return (
      (r.prototype.add = function (t) {
        this.indexMap[t] || (this.indexList.push(t), (this.indexMap[t] = !0))
      }),
      r
    )
  })(),
  v0t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e._autoThrottle = !0),
        (e._noTarget = !0),
        (e._rangePropMode = ['percent', 'percent']),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        var a = h3(e)
        ;(this.settledOption = a),
          this.mergeDefaultAndTheme(e, i),
          this._doInit(a)
      }),
      (t.prototype.mergeOption = function (e) {
        var n = h3(e)
        te(this.option, e, !0), te(this.settledOption, n, !0), this._doInit(n)
      }),
      (t.prototype._doInit = function (e) {
        var n = this.option
        this._setDefaultThrottle(e), this._updateRangeUse(e)
        var i = this.settledOption
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a, o) {
            this._rangePropMode[o] === 'value' && (n[a[0]] = i[a[0]] = null)
          },
          this,
        ),
          this._resetTarget()
      }),
      (t.prototype._resetTarget = function () {
        var e = this.get('orient', !0),
          n = (this._targetAxisInfoMap = Pt()),
          i = this._fillSpecifiedTargetAxis(n)
        i
          ? (this._orient = e || this._makeAutoOrientByTargetAxis())
          : ((this._orient = e || 'horizontal'),
            this._fillAutoTargetAxisByOrient(n, this._orient)),
          (this._noTarget = !0),
          n.each(function (a) {
            a.indexList.length && (this._noTarget = !1)
          }, this)
      }),
      (t.prototype._fillSpecifiedTargetAxis = function (e) {
        var n = !1
        return (
          R(
            c3,
            function (i) {
              var a = this.getReferringComponents(Ws(i), Ltt)
              if (a.specified) {
                n = !0
                var o = new qS()
                R(a.models, function (s) {
                  o.add(s.componentIndex)
                }),
                  e.set(i, o)
              }
            },
            this,
          ),
          n
        )
      }),
      (t.prototype._fillAutoTargetAxisByOrient = function (e, n) {
        var i = this.ecModel,
          a = !0
        if (a) {
          var o = n === 'vertical' ? 'y' : 'x',
            s = i.findComponents({
              mainType: o + 'Axis',
            })
          l(s, o)
        }
        if (a) {
          var s = i.findComponents({
            mainType: 'singleAxis',
            filter: function (c) {
              return c.get('orient', !0) === n
            },
          })
          l(s, 'single')
        }
        function l(u, c) {
          var h = u[0]
          if (h) {
            var f = new qS()
            if (
              (f.add(h.componentIndex),
              e.set(c, f),
              (a = !1),
              c === 'x' || c === 'y')
            ) {
              var d = h.getReferringComponents('grid', Pn).models[0]
              d &&
                R(u, function (p) {
                  h.componentIndex !== p.componentIndex &&
                    d === p.getReferringComponents('grid', Pn).models[0] &&
                    f.add(p.componentIndex)
                })
            }
          }
        }
        a &&
          R(
            c3,
            function (u) {
              if (a) {
                var c = i.findComponents({
                  mainType: Ws(u),
                  filter: function (f) {
                    return f.get('type', !0) === 'category'
                  },
                })
                if (c[0]) {
                  var h = new qS()
                  h.add(c[0].componentIndex), e.set(u, h), (a = !1)
                }
              }
            },
            this,
          )
      }),
      (t.prototype._makeAutoOrientByTargetAxis = function () {
        var e
        return (
          this.eachTargetAxis(function (n) {
            !e && (e = n)
          }, this),
          e === 'y' ? 'vertical' : 'horizontal'
        )
      }),
      (t.prototype._setDefaultThrottle = function (e) {
        if (
          (e.hasOwnProperty('throttle') && (this._autoThrottle = !1),
          this._autoThrottle)
        ) {
          var n = this.ecModel.option
          this.option.throttle =
            n.animation && n.animationDurationUpdate > 0 ? 100 : 20
        }
      }),
      (t.prototype._updateRangeUse = function (e) {
        var n = this._rangePropMode,
          i = this.get('rangeMode')
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a, o) {
            var s = e[a[0]] != null,
              l = e[a[1]] != null
            s && !l
              ? (n[o] = 'percent')
              : !s && l
              ? (n[o] = 'value')
              : i
              ? (n[o] = i[o])
              : s && (n[o] = 'percent')
          },
        )
      }),
      (t.prototype.noTarget = function () {
        return this._noTarget
      }),
      (t.prototype.getFirstTargetAxisModel = function () {
        var e
        return (
          this.eachTargetAxis(function (n, i) {
            e == null && (e = this.ecModel.getComponent(Ws(n), i))
          }, this),
          e
        )
      }),
      (t.prototype.eachTargetAxis = function (e, n) {
        this._targetAxisInfoMap.each(function (i, a) {
          R(i.indexList, function (o) {
            e.call(n, a, o)
          })
        })
      }),
      (t.prototype.getAxisProxy = function (e, n) {
        var i = this.getAxisModel(e, n)
        if (i) return i.__dzAxisProxy
      }),
      (t.prototype.getAxisModel = function (e, n) {
        var i = this._targetAxisInfoMap.get(e)
        if (i && i.indexMap[n]) return this.ecModel.getComponent(Ws(e), n)
      }),
      (t.prototype.setRawRange = function (e) {
        var n = this.option,
          i = this.settledOption
        R(
          [
            ['start', 'startValue'],
            ['end', 'endValue'],
          ],
          function (a) {
            ;(e[a[0]] != null || e[a[1]] != null) &&
              ((n[a[0]] = i[a[0]] = e[a[0]]), (n[a[1]] = i[a[1]] = e[a[1]]))
          },
          this,
        ),
          this._updateRangeUse(e)
      }),
      (t.prototype.setCalculatedRange = function (e) {
        var n = this.option
        R(['start', 'startValue', 'end', 'endValue'], function (i) {
          n[i] = e[i]
        })
      }),
      (t.prototype.getPercentRange = function () {
        var e = this.findRepresentativeAxisProxy()
        if (e) return e.getDataPercentWindow()
      }),
      (t.prototype.getValueRange = function (e, n) {
        if (e == null && n == null) {
          var i = this.findRepresentativeAxisProxy()
          if (i) return i.getDataValueWindow()
        } else return this.getAxisProxy(e, n).getDataValueWindow()
      }),
      (t.prototype.findRepresentativeAxisProxy = function (e) {
        if (e) return e.__dzAxisProxy
        for (
          var n, i = this._targetAxisInfoMap.keys(), a = 0;
          a < i.length;
          a++
        )
          for (
            var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0;
            l < s.indexList.length;
            l++
          ) {
            var u = this.getAxisProxy(o, s.indexList[l])
            if (u.hostedBy(this)) return u
            n || (n = u)
          }
        return n
      }),
      (t.prototype.getRangePropMode = function () {
        return this._rangePropMode.slice()
      }),
      (t.prototype.getOrient = function () {
        return this._orient
      }),
      (t.type = 'dataZoom'),
      (t.dependencies = [
        'xAxis',
        'yAxis',
        'radiusAxis',
        'angleAxis',
        'singleAxis',
        'series',
        'toolbox',
      ]),
      (t.defaultOption = {
        z: 4,
        filterMode: 'filter',
        start: 0,
        end: 100,
      }),
      t
    )
  })(xe)
function h3(r) {
  var t = {}
  return (
    R(['start', 'end', 'startValue', 'endValue', 'throttle'], function (e) {
      r.hasOwnProperty(e) && (t[e] = r[e])
    }),
    t
  )
}
const sv = v0t
var g0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'dataZoom.select'), t
})(sv)
const m0t = g0t
var y0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      ;(this.dataZoomModel = e), (this.ecModel = n), (this.api = i)
    }),
    (t.type = 'dataZoom'),
    t
  )
})(dn)
const AE = y0t
var _0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'dataZoom.select'), t
})(AE)
const x0t = _0t
var uh = R,
  f3 = Zi,
  S0t = (function () {
    function r(t, e, n, i) {
      ;(this._dimName = t),
        (this._axisIndex = e),
        (this.ecModel = i),
        (this._dataZoomModel = n)
    }
    return (
      (r.prototype.hostedBy = function (t) {
        return this._dataZoomModel === t
      }),
      (r.prototype.getDataValueWindow = function () {
        return this._valueWindow.slice()
      }),
      (r.prototype.getDataPercentWindow = function () {
        return this._percentWindow.slice()
      }),
      (r.prototype.getTargetSeriesModels = function () {
        var t = []
        return (
          this.ecModel.eachSeries(function (e) {
            if (d0t(e)) {
              var n = Ws(this._dimName),
                i = e.getReferringComponents(n, Pn).models[0]
              i && this._axisIndex === i.componentIndex && t.push(e)
            }
          }, this),
          t
        )
      }),
      (r.prototype.getAxisModel = function () {
        return this.ecModel.getComponent(
          this._dimName + 'Axis',
          this._axisIndex,
        )
      }),
      (r.prototype.getMinMaxSpan = function () {
        return Vt(this._minMaxSpan)
      }),
      (r.prototype.calculateDataWindow = function (t) {
        var e = this._dataExtent,
          n = this.getAxisModel(),
          i = n.axis.scale,
          a = this._dataZoomModel.getRangePropMode(),
          o = [0, 100],
          s = [],
          l = [],
          u
        uh(['start', 'end'], function (f, d) {
          var p = t[f],
            g = t[f + 'Value']
          a[d] === 'percent'
            ? (p == null && (p = o[d]), (g = i.parse(Re(p, o, e))))
            : ((u = !0),
              (g = g == null ? e[d] : i.parse(g)),
              (p = Re(g, e, o))),
            (l[d] = g == null || isNaN(g) ? e[d] : g),
            (s[d] = p == null || isNaN(p) ? o[d] : p)
        }),
          f3(l),
          f3(s)
        var c = this._minMaxSpan
        u ? h(l, s, e, o, !1) : h(s, l, o, e, !0)
        function h(f, d, p, g, v) {
          var m = v ? 'Span' : 'ValueSpan'
          lc(0, f, p, 'all', c['min' + m], c['max' + m])
          for (var y = 0; y < 2; y++)
            (d[y] = Re(f[y], p, g, !0)), v && (d[y] = i.parse(d[y]))
        }
        return {
          valueWindow: l,
          percentWindow: s,
        }
      }),
      (r.prototype.reset = function (t) {
        if (t === this._dataZoomModel) {
          var e = this.getTargetSeriesModels()
          ;(this._dataExtent = A0t(this, this._dimName, e)),
            this._updateMinMaxSpan()
          var n = this.calculateDataWindow(t.settledOption)
          ;(this._valueWindow = n.valueWindow),
            (this._percentWindow = n.percentWindow),
            this._setAxisModel()
        }
      }),
      (r.prototype.filterData = function (t, e) {
        if (t !== this._dataZoomModel) return
        var n = this._dimName,
          i = this.getTargetSeriesModels(),
          a = t.get('filterMode'),
          o = this._valueWindow
        if (a === 'none') return
        uh(i, function (l) {
          var u = l.getData(),
            c = u.mapDimensionsAll(n)
          if (c.length) {
            if (a === 'weakFilter') {
              var h = u.getStore(),
                f = st(
                  c,
                  function (d) {
                    return u.getDimensionIndex(d)
                  },
                  u,
                )
              u.filterSelf(function (d) {
                for (var p, g, v, m = 0; m < c.length; m++) {
                  var y = h.get(f[m], d),
                    _ = !isNaN(y),
                    x = y < o[0],
                    A = y > o[1]
                  if (_ && !x && !A) return !0
                  _ && (v = !0), x && (p = !0), A && (g = !0)
                }
                return v && p && g
              })
            } else
              uh(c, function (d) {
                if (a === 'empty')
                  l.setData(
                    (u = u.map(d, function (g) {
                      return s(g) ? g : NaN
                    })),
                  )
                else {
                  var p = {}
                  ;(p[d] = o), u.selectRange(p)
                }
              })
            uh(c, function (d) {
              u.setApproximateExtent(o, d)
            })
          }
        })
        function s(l) {
          return l >= o[0] && l <= o[1]
        }
      }),
      (r.prototype._updateMinMaxSpan = function () {
        var t = (this._minMaxSpan = {}),
          e = this._dataZoomModel,
          n = this._dataExtent
        uh(
          ['min', 'max'],
          function (i) {
            var a = e.get(i + 'Span'),
              o = e.get(i + 'ValueSpan')
            o != null && (o = this.getAxisModel().axis.scale.parse(o)),
              o != null
                ? (a = Re(n[0] + o, n, [0, 100], !0))
                : a != null && (o = Re(a, [0, 100], n, !0) - n[0]),
              (t[i + 'Span'] = a),
              (t[i + 'ValueSpan'] = o)
          },
          this,
        )
      }),
      (r.prototype._setAxisModel = function () {
        var t = this.getAxisModel(),
          e = this._percentWindow,
          n = this._valueWindow
        if (e) {
          var i = Nz(n, [0, 500])
          i = Math.min(i, 20)
          var a = t.axis.scale.rawExtentInfo
          e[0] !== 0 && a.setDeterminedMinMax('min', +n[0].toFixed(i)),
            e[1] !== 100 && a.setDeterminedMinMax('max', +n[1].toFixed(i)),
            a.freeze()
        }
      }),
      r
    )
  })()
function A0t(r, t, e) {
  var n = [1 / 0, -1 / 0]
  uh(e, function (o) {
    Wot(n, o.getData(), t)
  })
  var i = r.getAxisModel(),
    a = UV(i.axis.scale, i, n).calculate()
  return [a.min, a.max]
}
const b0t = S0t
var w0t = {
  getTargetSeries: function (r) {
    function t(i) {
      r.eachComponent('dataZoom', function (a) {
        a.eachTargetAxis(function (o, s) {
          var l = r.getComponent(Ws(o), s)
          i(o, s, l, a)
        })
      })
    }
    t(function (i, a, o, s) {
      o.__dzAxisProxy = null
    })
    var e = []
    t(function (i, a, o, s) {
      o.__dzAxisProxy ||
        ((o.__dzAxisProxy = new b0t(i, a, s, r)), e.push(o.__dzAxisProxy))
    })
    var n = Pt()
    return (
      R(e, function (i) {
        R(i.getTargetSeriesModels(), function (a) {
          n.set(a.uid, a)
        })
      }),
      n
    )
  },
  overallReset: function (r, t) {
    r.eachComponent('dataZoom', function (e) {
      e.eachTargetAxis(function (n, i) {
        e.getAxisProxy(n, i).reset(e)
      }),
        e.eachTargetAxis(function (n, i) {
          e.getAxisProxy(n, i).filterData(e, t)
        })
    }),
      r.eachComponent('dataZoom', function (e) {
        var n = e.findRepresentativeAxisProxy()
        if (n) {
          var i = n.getDataPercentWindow(),
            a = n.getDataValueWindow()
          e.setCalculatedRange({
            start: i[0],
            end: i[1],
            startValue: a[0],
            endValue: a[1],
          })
        }
      })
  },
}
const M0t = w0t
function T0t(r) {
  r.registerAction('dataZoom', function (t, e) {
    var n = p0t(e, t)
    R(n, function (i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue,
      })
    })
  })
}
var d3 = !1
function bE(r) {
  d3 ||
    ((d3 = !0),
    r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, M0t),
    T0t(r),
    r.registerSubTypeDefaulter('dataZoom', function () {
      return 'slider'
    }))
}
function C0t(r) {
  r.registerComponentModel(m0t), r.registerComponentView(x0t), bE(r)
}
var Hi = (function () {
    function r() {}
    return r
  })(),
  CH = {}
function ch(r, t) {
  CH[r] = t
}
function EH(r) {
  return CH[r]
}
var E0t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.optionUpdated = function () {
      r.prototype.optionUpdated.apply(this, arguments)
      var e = this.ecModel
      R(this.option.feature, function (n, i) {
        var a = EH(i)
        a &&
          (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)),
          te(n, a.defaultOption))
      })
    }),
    (t.type = 'toolbox'),
    (t.layoutMode = {
      type: 'box',
      ignoreSize: !0,
    }),
    (t.defaultOption = {
      show: !0,
      z: 6,
      orient: 'horizontal',
      left: 'right',
      top: 'top',
      backgroundColor: 'transparent',
      borderColor: '#ccc',
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: '#666',
        color: 'none',
      },
      emphasis: {
        iconStyle: {
          borderColor: '#3E98C5',
        },
      },
      tooltip: {
        show: !1,
        position: 'bottom',
      },
    }),
    t
  )
})(xe)
const D0t = E0t
function L0t(r, t, e) {
  var n = t.getBoxLayoutParams(),
    i = t.get('padding'),
    a = {
      width: e.getWidth(),
      height: e.getHeight(),
    },
    o = Vn(n, a, i)
  ku(t.get('orient'), r, t.get('itemGap'), o.width, o.height), p_(r, n, a, i)
}
function DH(r, t) {
  var e = wf(t.get('padding')),
    n = t.getItemStyle(['color', 'opacity'])
  return (
    (n.fill = t.get('backgroundColor')),
    (r = new ge({
      shape: {
        x: r.x - e[3],
        y: r.y - e[0],
        width: r.width + e[1] + e[3],
        height: r.height + e[0] + e[2],
        r: t.get('borderRadius'),
      },
      style: n,
      silent: !0,
      z2: -1,
    })),
    r
  )
}
var P0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.render = function (e, n, i, a) {
      var o = this.group
      if ((o.removeAll(), !e.get('show'))) return
      var s = +e.get('itemSize'),
        l = e.get('orient') === 'vertical',
        u = e.get('feature') || {},
        c = this._features || (this._features = {}),
        h = []
      R(u, function (p, g) {
        h.push(g)
      }),
        new es(this._featureNames || [], h)
          .add(f)
          .update(f)
          .remove(Zt(f, null))
          .execute(),
        (this._featureNames = h)
      function f(p, g) {
        var v = h[p],
          m = h[g],
          y = u[v],
          _ = new qe(y, e, e.ecModel),
          x
        if (
          (a &&
            a.newTitle != null &&
            a.featureName === v &&
            (y.title = a.newTitle),
          v && !m)
        ) {
          if (R0t(v))
            x = {
              onclick: _.option.onclick,
              featureName: v,
            }
          else {
            var A = EH(v)
            if (!A) return
            x = new A()
          }
          c[v] = x
        } else if (((x = c[m]), !x)) return
        ;(x.uid = bf('toolbox-feature')),
          (x.model = _),
          (x.ecModel = n),
          (x.api = i)
        var S = x instanceof Hi
        if (!v && m) {
          S && x.dispose && x.dispose(n, i)
          return
        }
        if (!_.get('show') || (S && x.unusable)) {
          S && x.remove && x.remove(n, i)
          return
        }
        d(_, x, v),
          (_.setIconStatus = function (b, T) {
            var w = this.option,
              M = this.iconPaths
            ;(w.iconStatus = w.iconStatus || {}),
              (w.iconStatus[b] = T),
              M[b] && (T === 'emphasis' ? Qo : ts)(M[b])
          }),
          x instanceof Hi && x.render && x.render(_, n, i, a)
      }
      function d(p, g, v) {
        var m = p.getModel('iconStyle'),
          y = p.getModel(['emphasis', 'iconStyle']),
          _ = g instanceof Hi && g.getIcons ? g.getIcons() : p.get('icon'),
          x = p.get('title') || {},
          A,
          S
        bt(_) ? ((A = {}), (A[v] = _)) : (A = _),
          bt(x) ? ((S = {}), (S[v] = x)) : (S = x)
        var b = (p.iconPaths = {})
        R(A, function (T, w) {
          var M = Sv(
            T,
            {},
            {
              x: -s / 2,
              y: -s / 2,
              width: s,
              height: s,
            },
          )
          M.setStyle(m.getItemStyle())
          var C = M.ensureState('emphasis')
          C.style = y.getItemStyle()
          var E = new Ae({
            style: {
              text: S[w],
              align: y.get('textAlign'),
              borderRadius: y.get('textBorderRadius'),
              padding: y.get('textPadding'),
              fill: null,
              font: eC(
                {
                  fontStyle: y.get('textFontStyle'),
                  fontFamily: y.get('textFontFamily'),
                  fontSize: y.get('textFontSize'),
                  fontWeight: y.get('textFontWeight'),
                },
                n,
              ),
            },
            ignore: !0,
          })
          M.setTextContent(E),
            Sf({
              el: M,
              componentModel: e,
              itemName: w,
              formatterParamsExtra: {
                title: S[w],
              },
            }),
            (M.__title = S[w]),
            M.on('mouseover', function () {
              var D = y.getItemStyle(),
                P = l
                  ? e.get('right') == null && e.get('left') !== 'right'
                    ? 'right'
                    : 'left'
                  : e.get('bottom') == null && e.get('top') !== 'bottom'
                  ? 'bottom'
                  : 'top'
              E.setStyle({
                fill: y.get('textFill') || D.fill || D.stroke || '#000',
                backgroundColor: y.get('textBackgroundColor'),
              }),
                M.setTextConfig({
                  position: y.get('textPosition') || P,
                }),
                (E.ignore = !e.get('showTitle')),
                i.enterEmphasis(this)
            }).on('mouseout', function () {
              p.get(['iconStatus', w]) !== 'emphasis' && i.leaveEmphasis(this),
                E.hide()
            }),
            (p.get(['iconStatus', w]) === 'emphasis' ? Qo : ts)(M),
            o.add(M),
            M.on('click', Tt(g.onclick, g, n, i, w)),
            (b[w] = M)
        })
      }
      L0t(o, e, i),
        o.add(DH(o.getBoundingRect(), e)),
        l ||
          o.eachChild(function (p) {
            var g = p.__title,
              v = p.ensureState('emphasis'),
              m = v.textConfig || (v.textConfig = {}),
              y = p.getTextContent(),
              _ = y && y.ensureState('emphasis')
            if (_ && !Nt(_) && g) {
              var x = _.style || (_.style = {}),
                A = mv(g, Ae.makeFont(x)),
                S = p.x + o.x,
                b = p.y + o.y + s,
                T = !1
              b + A.height > i.getHeight() && ((m.position = 'top'), (T = !0))
              var w = T ? -5 - A.height : s + 10
              S + A.width / 2 > i.getWidth()
                ? ((m.position = ['100%', w]), (x.align = 'right'))
                : S - A.width / 2 < 0 &&
                  ((m.position = [0, w]), (x.align = 'left'))
            }
          })
    }),
    (t.prototype.updateView = function (e, n, i, a) {
      R(this._features, function (o) {
        o instanceof Hi && o.updateView && o.updateView(o.model, n, i, a)
      })
    }),
    (t.prototype.remove = function (e, n) {
      R(this._features, function (i) {
        i instanceof Hi && i.remove && i.remove(e, n)
      }),
        this.group.removeAll()
    }),
    (t.prototype.dispose = function (e, n) {
      R(this._features, function (i) {
        i instanceof Hi && i.dispose && i.dispose(e, n)
      })
    }),
    (t.type = 'toolbox'),
    t
  )
})(dn)
function R0t(r) {
  return r.indexOf('my') === 0
}
const I0t = P0t
var O0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      var i = this.model,
        a = i.get('name') || e.get('title.0.text') || 'echarts',
        o = n.getZr().painter.getType() === 'svg',
        s = o ? 'svg' : i.get('type', !0) || 'png',
        l = n.getConnectedDataURL({
          type: s,
          backgroundColor:
            i.get('backgroundColor', !0) || e.get('backgroundColor') || '#fff',
          connectedBackgroundColor: i.get('connectedBackgroundColor'),
          excludeComponents: i.get('excludeComponents'),
          pixelRatio: i.get('pixelRatio'),
        }),
        u = Se.browser
      if (
        typeof MouseEvent == 'function' &&
        (u.newEdge || (!u.ie && !u.edge))
      ) {
        var c = document.createElement('a')
        ;(c.download = a + '.' + s), (c.target = '_blank'), (c.href = l)
        var h = new MouseEvent('click', {
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1,
        })
        c.dispatchEvent(h)
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(','),
          d = f[0].indexOf('base64') > -1,
          p = o ? decodeURIComponent(f[1]) : f[1]
        d && (p = window.atob(p))
        var g = a + '.' + s
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v)
          var y = new Blob([m])
          window.navigator.msSaveOrOpenBlob(y, g)
        } else {
          var _ = document.createElement('iframe')
          document.body.appendChild(_)
          var x = _.contentWindow,
            A = x.document
          A.open('image/svg+xml', 'replace'),
            A.write(p),
            A.close(),
            x.focus(),
            A.execCommand('SaveAs', !0, g),
            document.body.removeChild(_)
        }
      } else {
        var S = i.get('lang'),
          b =
            '<body style="margin:0;"><img src="' +
            l +
            '" style="max-width:100%;" title="' +
            ((S && S[0]) || '') +
            '" /></body>',
          T = window.open()
        T.document.write(b), (T.document.title = a)
      }
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
        title: e.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']),
        type: 'png',
        connectedBackgroundColor: '#fff',
        name: '',
        excludeComponents: ['toolbox'],
        lang: e.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang']),
      }
      return n
    }),
    t
  )
})(Hi)
const N0t = O0t
var p3 = '__ec_magicType_stack__',
  k0t = [['line', 'bar'], ['stack']],
  B0t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.getIcons = function () {
        var e = this.model,
          n = e.get('icon'),
          i = {}
        return (
          R(e.get('type'), function (a) {
            n[a] && (i[a] = n[a])
          }),
          i
        )
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          type: [],
          icon: {
            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
            stack:
              'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
          },
          title: e.getLocaleModel().get(['toolbox', 'magicType', 'title']),
          option: {},
          seriesIndex: {},
        }
        return n
      }),
      (t.prototype.onclick = function (e, n, i) {
        var a = this.model,
          o = a.get(['seriesIndex', i])
        if (v3[i]) {
          var s = {
              series: [],
            },
            l = function (h) {
              var f = h.subType,
                d = h.id,
                p = v3[i](f, d, h, a)
              p && (zt(p, h.option), s.series.push(p))
              var g = h.coordinateSystem
              if (
                g &&
                g.type === 'cartesian2d' &&
                (i === 'line' || i === 'bar')
              ) {
                var v = g.getAxesByScale('ordinal')[0]
                if (v) {
                  var m = v.dim,
                    y = m + 'Axis',
                    _ = h.getReferringComponents(y, Pn).models[0],
                    x = _.componentIndex
                  s[y] = s[y] || []
                  for (var A = 0; A <= x; A++) s[y][x] = s[y][x] || {}
                  s[y][x].boundaryGap = i === 'bar'
                }
              }
            }
          R(k0t, function (h) {
            re(h, i) >= 0 &&
              R(h, function (f) {
                a.setIconStatus(f, 'normal')
              })
          }),
            a.setIconStatus(i, 'emphasis'),
            e.eachComponent(
              {
                mainType: 'series',
                query:
                  o == null
                    ? null
                    : {
                        seriesIndex: o,
                      },
              },
              l,
            )
          var u,
            c = i
          i === 'stack' &&
            ((u = te(
              {
                stack: a.option.title.tiled,
                tiled: a.option.title.stack,
              },
              a.option.title,
            )),
            a.get(['iconStatus', i]) !== 'emphasis' && (c = 'tiled')),
            n.dispatchAction({
              type: 'changeMagicType',
              currentType: c,
              newOption: s,
              newTitle: u,
              featureName: 'magicType',
            })
        }
      }),
      t
    )
  })(Hi),
  v3 = {
    line: function (r, t, e, n) {
      if (r === 'bar')
        return te(
          {
            id: t,
            type: 'line',
            data: e.get('data'),
            stack: e.get('stack'),
            markPoint: e.get('markPoint'),
            markLine: e.get('markLine'),
          },
          n.get(['option', 'line']) || {},
          !0,
        )
    },
    bar: function (r, t, e, n) {
      if (r === 'line')
        return te(
          {
            id: t,
            type: 'bar',
            data: e.get('data'),
            stack: e.get('stack'),
            markPoint: e.get('markPoint'),
            markLine: e.get('markLine'),
          },
          n.get(['option', 'bar']) || {},
          !0,
        )
    },
    stack: function (r, t, e, n) {
      var i = e.get('stack') === p3
      if (r === 'line' || r === 'bar')
        return (
          n.setIconStatus('stack', i ? 'normal' : 'emphasis'),
          te(
            {
              id: t,
              stack: i ? '' : p3,
            },
            n.get(['option', 'stack']) || {},
            !0,
          )
        )
    },
  }
xo(
  {
    type: 'changeMagicType',
    event: 'magicTypeChanged',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    t.mergeOption(r.newOption)
  },
)
const F0t = B0t
var R_ = new Array(60).join('-'),
  cf = '	'
function z0t(r) {
  var t = {},
    e = [],
    n = []
  return (
    r.eachRawSeries(function (i) {
      var a = i.coordinateSystem
      if (a && (a.type === 'cartesian2d' || a.type === 'polar')) {
        var o = a.getBaseAxis()
        if (o.type === 'category') {
          var s = o.dim + '_' + o.index
          t[s] ||
            ((t[s] = {
              categoryAxis: o,
              valueAxis: a.getOtherAxis(o),
              series: [],
            }),
            n.push({
              axisDim: o.dim,
              axisIndex: o.index,
            })),
            t[s].series.push(i)
        } else e.push(i)
      } else e.push(i)
    }),
    {
      seriesGroupByCategoryAxis: t,
      other: e,
      meta: n,
    }
  )
}
function U0t(r) {
  var t = []
  return (
    R(r, function (e, n) {
      var i = e.categoryAxis,
        a = e.valueAxis,
        o = a.dim,
        s = [' '].concat(
          st(e.series, function (d) {
            return d.name
          }),
        ),
        l = [i.model.getCategories()]
      R(e.series, function (d) {
        var p = d.getRawData()
        l.push(
          d.getRawData().mapArray(p.mapDimension(o), function (g) {
            return g
          }),
        )
      })
      for (var u = [s.join(cf)], c = 0; c < l[0].length; c++) {
        for (var h = [], f = 0; f < l.length; f++) h.push(l[f][c])
        u.push(h.join(cf))
      }
      t.push(
        u.join(`
`),
      )
    }),
    t.join(
      `

` +
        R_ +
        `

`,
    )
  )
}
function V0t(r) {
  return st(r, function (t) {
    var e = t.getRawData(),
      n = [t.name],
      i = []
    return (
      e.each(e.dimensions, function () {
        for (
          var a = arguments.length,
            o = arguments[a - 1],
            s = e.getName(o),
            l = 0;
          l < a - 1;
          l++
        )
          i[l] = arguments[l]
        n.push((s ? s + cf : '') + i.join(cf))
      }),
      n.join(`
`)
    )
  }).join(
    `

` +
      R_ +
      `

`,
  )
}
function G0t(r) {
  var t = z0t(r)
  return {
    value: Ne([U0t(t.seriesGroupByCategoryAxis), V0t(t.other)], function (e) {
      return !!e.replace(/[\n\t\s]/g, '')
    }).join(
      `

` +
        R_ +
        `

`,
    ),
    meta: t.meta,
  }
}
function A0(r) {
  return r.replace(/^\s\s*/, '').replace(/\s\s*$/, '')
}
function H0t(r) {
  var t = r.slice(
    0,
    r.indexOf(`
`),
  )
  if (t.indexOf(cf) >= 0) return !0
}
var eM = new RegExp('[' + cf + ']+', 'g')
function W0t(r) {
  for (
    var t = r.split(/\n+/g),
      e = A0(t.shift()).split(eM),
      n = [],
      i = st(e, function (l) {
        return {
          name: l,
          data: [],
        }
      }),
      a = 0;
    a < t.length;
    a++
  ) {
    var o = A0(t[a]).split(eM)
    n.push(o.shift())
    for (var s = 0; s < o.length; s++) i[s] && (i[s].data[a] = o[s])
  }
  return {
    series: i,
    categories: n,
  }
}
function X0t(r) {
  for (
    var t = r.split(/\n+/g), e = A0(t.shift()), n = [], i = 0;
    i < t.length;
    i++
  ) {
    var a = A0(t[i])
    if (a) {
      var o = a.split(eM),
        s = '',
        l = void 0,
        u = !1
      isNaN(o[0])
        ? ((u = !0),
          (s = o[0]),
          (o = o.slice(1)),
          (n[i] = {
            name: s,
            value: [],
          }),
          (l = n[i].value))
        : (l = n[i] = [])
      for (var c = 0; c < o.length; c++) l.push(+o[c])
      l.length === 1 && (u ? (n[i].value = l[0]) : (n[i] = l[0]))
    }
  }
  return {
    name: e,
    data: n,
  }
}
function Y0t(r, t) {
  var e = r.split(
      new RegExp(
        `
*` +
          R_ +
          `
*`,
        'g',
      ),
    ),
    n = {
      series: [],
    }
  return (
    R(e, function (i, a) {
      if (H0t(i)) {
        var o = W0t(i),
          s = t[a],
          l = s.axisDim + 'Axis'
        s &&
          ((n[l] = n[l] || []),
          (n[l][s.axisIndex] = {
            data: o.categories,
          }),
          (n.series = n.series.concat(o.series)))
      } else {
        var o = X0t(i)
        n.series.push(o)
      }
    }),
    n
  )
}
var $0t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      setTimeout(function () {
        n.dispatchAction({
          type: 'hideTip',
        })
      })
      var i = n.getDom(),
        a = this.model
      this._dom && i.removeChild(this._dom)
      var o = document.createElement('div')
      ;(o.style.cssText =
        'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px'),
        (o.style.backgroundColor = a.get('backgroundColor') || '#fff')
      var s = document.createElement('h4'),
        l = a.get('lang') || []
      ;(s.innerHTML = l[0] || a.get('title')),
        (s.style.cssText = 'margin:10px 20px'),
        (s.style.color = a.get('textColor'))
      var u = document.createElement('div'),
        c = document.createElement('textarea')
      u.style.cssText = 'overflow:auto'
      var h = a.get('optionToContent'),
        f = a.get('contentToOption'),
        d = G0t(e)
      if (Nt(h)) {
        var p = h(n.getOption())
        bt(p) ? (u.innerHTML = p) : tf(p) && u.appendChild(p)
      } else {
        c.readOnly = a.get('readOnly')
        var g = c.style
        ;(g.cssText =
          'display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none'),
          (g.color = a.get('textColor')),
          (g.borderColor = a.get('textareaBorderColor')),
          (g.backgroundColor = a.get('textareaColor')),
          (c.value = d.value),
          u.appendChild(c)
      }
      var v = d.meta,
        m = document.createElement('div')
      m.style.cssText = 'position:absolute;bottom:5px;left:0;right:0'
      var y =
          'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px',
        _ = document.createElement('div'),
        x = document.createElement('div')
      ;(y += ';background-color:' + a.get('buttonColor')),
        (y += ';color:' + a.get('buttonTextColor'))
      var A = this
      function S() {
        i.removeChild(o), (A._dom = null)
      }
      Ob(_, 'click', S),
        Ob(x, 'click', function () {
          if ((f == null && h != null) || (f != null && h == null)) {
            S()
            return
          }
          var b
          try {
            Nt(f) ? (b = f(u, n.getOption())) : (b = Y0t(c.value, v))
          } catch (T) {
            throw (S(), new Error('Data view format error ' + T))
          }
          b &&
            n.dispatchAction({
              type: 'changeDataView',
              newOption: b,
            }),
            S()
        }),
        (_.innerHTML = l[1]),
        (x.innerHTML = l[2]),
        (x.style.cssText = _.style.cssText = y),
        !a.get('readOnly') && m.appendChild(x),
        m.appendChild(_),
        o.appendChild(s),
        o.appendChild(u),
        o.appendChild(m),
        (u.style.height = i.clientHeight - 80 + 'px'),
        i.appendChild(o),
        (this._dom = o)
    }),
    (t.prototype.remove = function (e, n) {
      this._dom && n.getDom().removeChild(this._dom)
    }),
    (t.prototype.dispose = function (e, n) {
      this.remove(e, n)
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
        title: e.getLocaleModel().get(['toolbox', 'dataView', 'title']),
        lang: e.getLocaleModel().get(['toolbox', 'dataView', 'lang']),
        backgroundColor: '#fff',
        textColor: '#000',
        textareaColor: '#fff',
        textareaBorderColor: '#333',
        buttonColor: '#c23531',
        buttonTextColor: '#fff',
      }
      return n
    }),
    t
  )
})(Hi)
function q0t(r, t) {
  return st(r, function (e, n) {
    var i = t && t[n]
    if (Ut(i) && !at(i)) {
      var a = Ut(e) && !at(e)
      a ||
        (e = {
          value: e,
        })
      var o = i.name != null && e.name == null
      return (e = zt(e, i)), o && delete e.name, e
    } else return e
  })
}
xo(
  {
    type: 'changeDataView',
    event: 'dataViewChanged',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    var e = []
    R(r.newOption.series, function (n) {
      var i = t.getSeriesByName(n.name)[0]
      if (!i)
        e.push(
          Q(
            {
              type: 'scatter',
            },
            n,
          ),
        )
      else {
        var a = i.get('data')
        e.push({
          name: n.name,
          data: q0t(n.data, a),
        })
      }
    }),
      t.mergeOption(
        zt(
          {
            series: e,
          },
          r.newOption,
        ),
      )
  },
)
const Z0t = $0t
var LH = R,
  PH = ve()
function K0t(r, t) {
  var e = wE(r)
  LH(t, function (n, i) {
    for (var a = e.length - 1; a >= 0; a--) {
      var o = e[a]
      if (o[i]) break
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: 'dataZoom',
        subType: 'select',
        id: i,
      })[0]
      if (s) {
        var l = s.getPercentRange()
        e[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1],
        }
      }
    }
  }),
    e.push(t)
}
function j0t(r) {
  var t = wE(r),
    e = t[t.length - 1]
  t.length > 1 && t.pop()
  var n = {}
  return (
    LH(e, function (i, a) {
      for (var o = t.length - 1; o >= 0; o--)
        if (((i = t[o][a]), i)) {
          n[a] = i
          break
        }
    }),
    n
  )
}
function J0t(r) {
  PH(r).snapshots = null
}
function Q0t(r) {
  return wE(r).length
}
function wE(r) {
  var t = PH(r)
  return t.snapshots || (t.snapshots = [{}]), t.snapshots
}
var t_t = (function (r) {
  X(t, r)
  function t() {
    return (r !== null && r.apply(this, arguments)) || this
  }
  return (
    (t.prototype.onclick = function (e, n) {
      J0t(e),
        n.dispatchAction({
          type: 'restore',
          from: this.uid,
        })
    }),
    (t.getDefaultOption = function (e) {
      var n = {
        show: !0,
        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
        title: e.getLocaleModel().get(['toolbox', 'restore', 'title']),
      }
      return n
    }),
    t
  )
})(Hi)
xo(
  {
    type: 'restore',
    event: 'restore',
    update: 'prepareAndUpdate',
  },
  function (r, t) {
    t.resetOption('recreate')
  },
)
const e_t = t_t
var n_t = [
    'grid',
    'xAxis',
    'yAxis',
    'geo',
    'graph',
    'polar',
    'radiusAxis',
    'angleAxis',
    'bmap',
  ],
  r_t = (function () {
    function r(t, e, n) {
      var i = this
      this._targetInfoList = []
      var a = g3(e, t)
      R(i_t, function (o, s) {
        ;(!n || !n.include || re(n.include, s) >= 0) && o(a, i._targetInfoList)
      })
    }
    return (
      (r.prototype.setOutputRanges = function (t, e) {
        return (
          this.matchOutputRanges(t, e, function (n, i, a) {
            if (
              ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange)
            ) {
              n.coordRange = i
              var o = ZS[n.brushType](0, a, i)
              n.__rangeOffset = {
                offset: x3[n.brushType](o.values, n.range, [1, 1]),
                xyMinMax: o.xyMinMax,
              }
            }
          }),
          t
        )
      }),
      (r.prototype.matchOutputRanges = function (t, e, n) {
        R(
          t,
          function (i) {
            var a = this.findTargetInfo(i, e)
            a &&
              a !== !0 &&
              R(a.coordSyses, function (o) {
                var s = ZS[i.brushType](1, o, i.range, !0)
                n(i, s.values, o, e)
              })
          },
          this,
        )
      }),
      (r.prototype.setInputRanges = function (t, e) {
        R(
          t,
          function (n) {
            var i = this.findTargetInfo(n, e)
            if (((n.range = n.range || []), i && i !== !0)) {
              n.panelId = i.panelId
              var a = ZS[n.brushType](0, i.coordSys, n.coordRange),
                o = n.__rangeOffset
              n.range = o
                ? x3[n.brushType](
                    a.values,
                    o.offset,
                    a_t(a.xyMinMax, o.xyMinMax),
                  )
                : a.values
            }
          },
          this,
        )
      }),
      (r.prototype.makePanelOpts = function (t, e) {
        return st(this._targetInfoList, function (n) {
          var i = n.getPanelRect()
          return {
            panelId: n.panelId,
            defaultBrushType: e ? e(n) : null,
            clipPath: F4(i),
            isTargetByCursor: U4(i, t, n.coordSysModel),
            getLinearBrushOtherExtent: z4(i),
          }
        })
      }),
      (r.prototype.controlSeries = function (t, e, n) {
        var i = this.findTargetInfo(t, n)
        return i === !0 || (i && re(i.coordSyses, e.coordinateSystem) >= 0)
      }),
      (r.prototype.findTargetInfo = function (t, e) {
        for (
          var n = this._targetInfoList, i = g3(e, t), a = 0;
          a < n.length;
          a++
        ) {
          var o = n[a],
            s = t.panelId
          if (s) {
            if (o.panelId === s) return o
          } else for (var l = 0; l < m3.length; l++) if (m3[l](i, o)) return o
        }
        return !0
      }),
      r
    )
  })()
function nM(r) {
  return r[0] > r[1] && r.reverse(), r
}
function g3(r, t) {
  return ip(r, t, {
    includeMainTypes: n_t,
  })
}
var i_t = {
    grid: function (r, t) {
      var e = r.xAxisModels,
        n = r.yAxisModels,
        i = r.gridModels,
        a = Pt(),
        o = {},
        s = {}
      ;(!e && !n && !i) ||
        (R(e, function (l) {
          var u = l.axis.grid.model
          a.set(u.id, u), (o[u.id] = !0)
        }),
        R(n, function (l) {
          var u = l.axis.grid.model
          a.set(u.id, u), (s[u.id] = !0)
        }),
        R(i, function (l) {
          a.set(l.id, l), (o[l.id] = !0), (s[l.id] = !0)
        }),
        a.each(function (l) {
          var u = l.coordinateSystem,
            c = []
          R(u.getCartesians(), function (h, f) {
            ;(re(e, h.getAxis('x').model) >= 0 ||
              re(n, h.getAxis('y').model) >= 0) &&
              c.push(h)
          }),
            t.push({
              panelId: 'grid--' + l.id,
              gridModel: l,
              coordSysModel: l,
              coordSys: c[0],
              coordSyses: c,
              getPanelRect: y3.grid,
              xAxisDeclared: o[l.id],
              yAxisDeclared: s[l.id],
            })
        }))
    },
    geo: function (r, t) {
      R(r.geoModels, function (e) {
        var n = e.coordinateSystem
        t.push({
          panelId: 'geo--' + e.id,
          geoModel: e,
          coordSysModel: e,
          coordSys: n,
          coordSyses: [n],
          getPanelRect: y3.geo,
        })
      })
    },
  },
  m3 = [
    function (r, t) {
      var e = r.xAxisModel,
        n = r.yAxisModel,
        i = r.gridModel
      return (
        !i && e && (i = e.axis.grid.model),
        !i && n && (i = n.axis.grid.model),
        i && i === t.gridModel
      )
    },
    function (r, t) {
      var e = r.geoModel
      return e && e === t.geoModel
    },
  ],
  y3 = {
    grid: function () {
      return this.coordSys.master.getRect().clone()
    },
    geo: function () {
      var r = this.coordSys,
        t = r.getBoundingRect().clone()
      return t.applyTransform(Nu(r)), t
    },
  },
  ZS = {
    lineX: Zt(_3, 0),
    lineY: Zt(_3, 1),
    rect: function (r, t, e, n) {
      var i = r
          ? t.pointToData([e[0][0], e[1][0]], n)
          : t.dataToPoint([e[0][0], e[1][0]], n),
        a = r
          ? t.pointToData([e[0][1], e[1][1]], n)
          : t.dataToPoint([e[0][1], e[1][1]], n),
        o = [nM([i[0], a[0]]), nM([i[1], a[1]])]
      return {
        values: o,
        xyMinMax: o,
      }
    },
    polygon: function (r, t, e, n) {
      var i = [
          [1 / 0, -1 / 0],
          [1 / 0, -1 / 0],
        ],
        a = st(e, function (o) {
          var s = r ? t.pointToData(o, n) : t.dataToPoint(o, n)
          return (
            (i[0][0] = Math.min(i[0][0], s[0])),
            (i[1][0] = Math.min(i[1][0], s[1])),
            (i[0][1] = Math.max(i[0][1], s[0])),
            (i[1][1] = Math.max(i[1][1], s[1])),
            s
          )
        })
      return {
        values: a,
        xyMinMax: i,
      }
    },
  }
function _3(r, t, e, n) {
  var i = e.getAxis(['x', 'y'][r]),
    a = nM(
      st([0, 1], function (s) {
        return t
          ? i.coordToData(i.toLocalCoord(n[s]), !0)
          : i.toGlobalCoord(i.dataToCoord(n[s]))
      }),
    ),
    o = []
  return (
    (o[r] = a),
    (o[1 - r] = [NaN, NaN]),
    {
      values: a,
      xyMinMax: o,
    }
  )
}
var x3 = {
  lineX: Zt(S3, 0),
  lineY: Zt(S3, 1),
  rect: function (r, t, e) {
    return [
      [r[0][0] - e[0] * t[0][0], r[0][1] - e[0] * t[0][1]],
      [r[1][0] - e[1] * t[1][0], r[1][1] - e[1] * t[1][1]],
    ]
  },
  polygon: function (r, t, e) {
    return st(r, function (n, i) {
      return [n[0] - e[0] * t[i][0], n[1] - e[1] * t[i][1]]
    })
  },
}
function S3(r, t, e, n) {
  return [t[0] - n[r] * e[0], t[1] - n[r] * e[1]]
}
function a_t(r, t) {
  var e = A3(r),
    n = A3(t),
    i = [e[0] / n[0], e[1] / n[1]]
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i
}
function A3(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN]
}
const ME = r_t
var rM = R,
  o_t = Mtt('toolbox-dataZoom_'),
  s_t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.render = function (e, n, i, a) {
        this._brushController ||
          ((this._brushController = new aE(i.getZr())),
          this._brushController.on('brush', Tt(this._onBrush, this)).mount()),
          c_t(e, n, this, a, i),
          u_t(e, n)
      }),
      (t.prototype.onclick = function (e, n, i) {
        l_t[i].call(this)
      }),
      (t.prototype.remove = function (e, n) {
        this._brushController && this._brushController.unmount()
      }),
      (t.prototype.dispose = function (e, n) {
        this._brushController && this._brushController.dispose()
      }),
      (t.prototype._onBrush = function (e) {
        var n = e.areas
        if (!e.isEnd || !n.length) return
        var i = {},
          a = this.ecModel
        this._brushController.updateCovers([])
        var o = new ME(TE(this.model), a, {
          include: ['grid'],
        })
        o.matchOutputRanges(n, a, function (u, c, h) {
          if (h.type === 'cartesian2d') {
            var f = u.brushType
            f === 'rect'
              ? (s('x', h, c[0]), s('y', h, c[1]))
              : s(
                  {
                    lineX: 'x',
                    lineY: 'y',
                  }[f],
                  h,
                  c,
                )
          }
        }),
          K0t(a, i),
          this._dispatchZoomAction(i)
        function s(u, c, h) {
          var f = c.getAxis(u),
            d = f.model,
            p = l(u, d, a),
            g = p.findRepresentativeAxisProxy(d).getMinMaxSpan()
          ;(g.minValueSpan != null || g.maxValueSpan != null) &&
            (h = lc(
              0,
              h.slice(),
              f.scale.getExtent(),
              0,
              g.minValueSpan,
              g.maxValueSpan,
            )),
            p &&
              (i[p.id] = {
                dataZoomId: p.id,
                startValue: h[0],
                endValue: h[1],
              })
        }
        function l(u, c, h) {
          var f
          return (
            h.eachComponent(
              {
                mainType: 'dataZoom',
                subType: 'select',
              },
              function (d) {
                var p = d.getAxisModel(u, c.componentIndex)
                p && (f = d)
              },
            ),
            f
          )
        }
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var n = []
        rM(e, function (i, a) {
          n.push(Vt(i))
        }),
          n.length &&
            this.api.dispatchAction({
              type: 'dataZoom',
              from: this.uid,
              batch: n,
            })
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          filterMode: 'filter',
          icon: {
            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26',
          },
          title: e.getLocaleModel().get(['toolbox', 'dataZoom', 'title']),
          brushStyle: {
            borderWidth: 0,
            color: 'rgba(210,219,238,0.2)',
          },
        }
        return n
      }),
      t
    )
  })(Hi),
  l_t = {
    zoom: function () {
      var r = !this._isZoomActive
      this.api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'dataZoomSelect',
        dataZoomSelectActive: r,
      })
    },
    back: function () {
      this._dispatchZoomAction(j0t(this.ecModel))
    },
  }
function TE(r) {
  var t = {
    xAxisIndex: r.get('xAxisIndex', !0),
    yAxisIndex: r.get('yAxisIndex', !0),
    xAxisId: r.get('xAxisId', !0),
    yAxisId: r.get('yAxisId', !0),
  }
  return (
    t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = 'all'),
    t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = 'all'),
    t
  )
}
function u_t(r, t) {
  r.setIconStatus('back', Q0t(t) > 1 ? 'emphasis' : 'normal')
}
function c_t(r, t, e, n, i) {
  var a = e._isZoomActive
  n &&
    n.type === 'takeGlobalCursor' &&
    (a = n.key === 'dataZoomSelect' ? n.dataZoomSelectActive : !1),
    (e._isZoomActive = a),
    r.setIconStatus('zoom', a ? 'emphasis' : 'normal')
  var o = new ME(TE(r), t, {
      include: ['grid'],
    }),
    s = o.makePanelOpts(i, function (l) {
      return l.xAxisDeclared && !l.yAxisDeclared
        ? 'lineX'
        : !l.xAxisDeclared && l.yAxisDeclared
        ? 'lineY'
        : 'rect'
    })
  e._brushController.setPanels(s).enableBrush(
    a && s.length
      ? {
          brushType: 'auto',
          brushStyle: r.getModel('brushStyle').getItemStyle(),
        }
      : !1,
  )
}
srt('dataZoom', function (r) {
  var t = r.getComponent('toolbox', 0),
    e = ['feature', 'dataZoom']
  if (!t || t.get(e) == null) return
  var n = t.getModel(e),
    i = [],
    a = TE(n),
    o = ip(r, a)
  rM(o.xAxisModels, function (l) {
    return s(l, 'xAxis', 'xAxisIndex')
  }),
    rM(o.yAxisModels, function (l) {
      return s(l, 'yAxis', 'yAxisIndex')
    })
  function s(l, u, c) {
    var h = l.componentIndex,
      f = {
        type: 'select',
        $fromToolbox: !0,
        filterMode: n.get('filterMode', !0) || 'filter',
        id: o_t + u + h,
      }
    ;(f[c] = h), i.push(f)
  }
  return i
})
const h_t = s_t
function f_t(r) {
  r.registerComponentModel(D0t),
    r.registerComponentView(I0t),
    ch('saveAsImage', N0t),
    ch('magicType', F0t),
    ch('dataView', Z0t),
    ch('dataZoom', h_t),
    ch('restore', e_t),
    ie(C0t)
}
var d_t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'tooltip'),
    (t.dependencies = ['axisPointer']),
    (t.defaultOption = {
      z: 60,
      show: !0,
      showContent: !0,
      trigger: 'item',
      triggerOn: 'mousemove|click',
      alwaysShowContent: !1,
      displayMode: 'single',
      renderMode: 'auto',
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: '#fff',
      shadowBlur: 10,
      shadowColor: 'rgba(0, 0, 0, .2)',
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: '',
      axisPointer: {
        type: 'line',
        axis: 'auto',
        animation: 'auto',
        animationDurationUpdate: 200,
        animationEasingUpdate: 'exponentialOut',
        crossStyle: {
          color: '#999',
          width: 1,
          type: 'dashed',
          textStyle: {},
        },
      },
      textStyle: {
        color: '#666',
        fontSize: 14,
      },
    }),
    t
  )
})(xe)
const p_t = d_t
function RH(r) {
  var t = r.get('confine')
  return t != null ? !!t : r.get('renderMode') === 'richText'
}
function IH(r) {
  if (Se.domSupported) {
    for (
      var t = document.documentElement.style, e = 0, n = r.length;
      e < n;
      e++
    )
      if (r[e] in t) return r[e]
  }
}
var OH = IH([
    'transform',
    'webkitTransform',
    'OTransform',
    'MozTransform',
    'msTransform',
  ]),
  v_t = IH([
    'webkitTransition',
    'transition',
    'OTransition',
    'MozTransition',
    'msTransition',
  ])
function NH(r, t) {
  if (!r) return t
  t = r5(t, !0)
  var e = r.indexOf(t)
  return (r = e === -1 ? t : '-' + r.slice(0, e) + '-' + t), r.toLowerCase()
}
function g_t(r, t) {
  var e =
    r.currentStyle ||
    (document.defaultView && document.defaultView.getComputedStyle(r))
  return e ? (t ? e[t] : e) : null
}
var m_t = NH(v_t, 'transition'),
  CE = NH(OH, 'transform'),
  y_t =
    'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;' +
    (Se.transform3dSupported ? 'will-change:transform;' : '')
function __t(r) {
  return (
    (r =
      r === 'left'
        ? 'right'
        : r === 'right'
        ? 'left'
        : r === 'top'
        ? 'bottom'
        : 'top'),
    r
  )
}
function x_t(r, t, e) {
  if (!bt(e) || e === 'inside') return ''
  var n = r.get('backgroundColor'),
    i = r.get('borderWidth')
  t = Zu(t)
  var a = __t(e),
    o = Math.max(Math.round(i) * 1.5, 6),
    s = '',
    l = CE + ':',
    u
  re(['left', 'right'], a) > -1
    ? ((s += 'top:50%'),
      (l +=
        'translateY(-50%) rotate(' + (u = a === 'left' ? -225 : -45) + 'deg)'))
    : ((s += 'left:50%'),
      (l += 'translateX(-50%) rotate(' + (u = a === 'top' ? 225 : 45) + 'deg)'))
  var c = (u * Math.PI) / 180,
    h = o + i,
    f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)),
    d =
      Math.round(
        ((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - h) / 2) * 100,
      ) / 100
  s += ';' + a + ':-' + d + 'px'
  var p = t + ' solid ' + i + 'px;',
    g = [
      'position:absolute;width:' + o + 'px;height:' + o + 'px;z-index:-1;',
      s + ';' + l + ';',
      'border-bottom:' + p,
      'border-right:' + p,
      'background-color:' + n + ';',
    ]
  return '<div style="' + g.join('') + '"></div>'
}
function S_t(r, t) {
  var e = 'cubic-bezier(0.23,1,0.32,1)',
    n = ' ' + r / 2 + 's ' + e,
    i = 'opacity' + n + ',visibility' + n
  return (
    t ||
      ((n = ' ' + r + 's ' + e),
      (i += Se.transformSupported ? ',' + CE + n : ',left' + n + ',top' + n)),
    m_t + ':' + i
  )
}
function b3(r, t, e) {
  var n = r.toFixed(0) + 'px',
    i = t.toFixed(0) + 'px'
  if (!Se.transformSupported)
    return e
      ? 'top:' + i + ';left:' + n + ';'
      : [
          ['top', i],
          ['left', n],
        ]
  var a = Se.transform3dSupported,
    o =
      'translate' + (a ? '3d' : '') + '(' + n + ',' + i + (a ? ',0' : '') + ')'
  return e
    ? 'top:0;left:0;' + CE + ':' + o + ';'
    : [
        ['top', 0],
        ['left', 0],
        [OH, o],
      ]
}
function A_t(r) {
  var t = [],
    e = r.get('fontSize'),
    n = r.getTextColor()
  n && t.push('color:' + n),
    t.push('font:' + r.getFont()),
    e && t.push('line-height:' + Math.round((e * 3) / 2) + 'px')
  var i = r.get('textShadowColor'),
    a = r.get('textShadowBlur') || 0,
    o = r.get('textShadowOffsetX') || 0,
    s = r.get('textShadowOffsetY') || 0
  return (
    i && a && t.push('text-shadow:' + o + 'px ' + s + 'px ' + a + 'px ' + i),
    R(['decoration', 'align'], function (l) {
      var u = r.get(l)
      u && t.push('text-' + l + ':' + u)
    }),
    t.join(';')
  )
}
function b_t(r, t, e) {
  var n = [],
    i = r.get('transitionDuration'),
    a = r.get('backgroundColor'),
    o = r.get('shadowBlur'),
    s = r.get('shadowColor'),
    l = r.get('shadowOffsetX'),
    u = r.get('shadowOffsetY'),
    c = r.getModel('textStyle'),
    h = z5(r, 'html'),
    f = l + 'px ' + u + 'px ' + o + 'px ' + s
  return (
    n.push('box-shadow:' + f),
    t && i && n.push(S_t(i, e)),
    a && n.push('background-color:' + a),
    R(['width', 'color', 'radius'], function (d) {
      var p = 'border-' + d,
        g = r5(p),
        v = r.get(g)
      v != null && n.push(p + ':' + v + (d === 'color' ? '' : 'px'))
    }),
    n.push(A_t(c)),
    h != null && n.push('padding:' + wf(h).join('px ') + 'px'),
    n.join(';') + ';'
  )
}
function w3(r, t, e, n, i) {
  var a = t && t.painter
  if (e) {
    var o = a && a.getViewportRoot()
    o && qJ(r, o, e, n, i)
  } else {
    ;(r[0] = n), (r[1] = i)
    var s = a && a.getViewportRootOffset()
    s && ((r[0] += s.offsetLeft), (r[1] += s.offsetTop))
  }
  ;(r[2] = r[0] / t.getWidth()), (r[3] = r[1] / t.getHeight())
}
var w_t = (function () {
  function r(t, e) {
    if (
      ((this._show = !1),
      (this._styleCoord = [0, 0, 0, 0]),
      (this._enterable = !0),
      (this._alwaysShowContent = !1),
      (this._firstShow = !0),
      (this._longHide = !0),
      Se.wxa)
    )
      return null
    var n = document.createElement('div')
    ;(n.domBelongToZr = !0), (this.el = n)
    var i = (this._zr = t.getZr()),
      a = e.appendTo,
      o =
        a &&
        (bt(a) ? document.querySelector(a) : tf(a) ? a : Nt(a) && a(t.getDom()))
    w3(this._styleCoord, i, o, t.getWidth() / 2, t.getHeight() / 2),
      (o || t.getDom()).appendChild(n),
      (this._api = t),
      (this._container = o)
    var s = this
    ;(n.onmouseenter = function () {
      s._enterable && (clearTimeout(s._hideTimeout), (s._show = !0)),
        (s._inContent = !0)
    }),
      (n.onmousemove = function (l) {
        if (((l = l || window.event), !s._enterable)) {
          var u = i.handler,
            c = i.painter.getViewportRoot()
          Fi(c, l, !0), u.dispatch('mousemove', l)
        }
      }),
      (n.onmouseleave = function () {
        ;(s._inContent = !1),
          s._enterable && s._show && s.hideLater(s._hideDelay)
      })
  }
  return (
    (r.prototype.update = function (t) {
      if (!this._container) {
        var e = this._api.getDom(),
          n = g_t(e, 'position'),
          i = e.style
        i.position !== 'absolute' &&
          n !== 'absolute' &&
          (i.position = 'relative')
      }
      var a = t.get('alwaysShowContent')
      a && this._moveIfResized(),
        (this._alwaysShowContent = a),
        (this.el.className = t.get('className') || '')
    }),
    (r.prototype.show = function (t, e) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout)
      var n = this.el,
        i = n.style,
        a = this._styleCoord
      n.innerHTML
        ? (i.cssText =
            y_t +
            b_t(t, !this._firstShow, this._longHide) +
            b3(a[0], a[1], !0) +
            ('border-color:' + Zu(e) + ';') +
            (t.get('extraCssText') || '') +
            (';pointer-events:' + (this._enterable ? 'auto' : 'none')))
        : (i.display = 'none'),
        (this._show = !0),
        (this._firstShow = !1),
        (this._longHide = !1)
    }),
    (r.prototype.setContent = function (t, e, n, i, a) {
      var o = this.el
      if (t == null) {
        o.innerHTML = ''
        return
      }
      var s = ''
      if (
        (bt(a) && n.get('trigger') === 'item' && !RH(n) && (s = x_t(n, i, a)),
        bt(t))
      )
        o.innerHTML = t + s
      else if (t) {
        ;(o.innerHTML = ''), at(t) || (t = [t])
        for (var l = 0; l < t.length; l++)
          tf(t[l]) && t[l].parentNode !== o && o.appendChild(t[l])
        if (s && o.childNodes.length) {
          var u = document.createElement('div')
          ;(u.innerHTML = s), o.appendChild(u)
        }
      }
    }),
    (r.prototype.setEnterable = function (t) {
      this._enterable = t
    }),
    (r.prototype.getSize = function () {
      var t = this.el
      return [t.offsetWidth, t.offsetHeight]
    }),
    (r.prototype.moveTo = function (t, e) {
      var n = this._styleCoord
      if (
        (w3(n, this._zr, this._container, t, e), n[0] != null && n[1] != null)
      ) {
        var i = this.el.style,
          a = b3(n[0], n[1])
        R(a, function (o) {
          i[o[0]] = o[1]
        })
      }
    }),
    (r.prototype._moveIfResized = function () {
      var t = this._styleCoord[2],
        e = this._styleCoord[3]
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
    }),
    (r.prototype.hide = function () {
      var t = this,
        e = this.el.style
      ;(e.visibility = 'hidden'),
        (e.opacity = '0'),
        Se.transform3dSupported && (e.willChange = ''),
        (this._show = !1),
        (this._longHideTimeout = setTimeout(function () {
          return (t._longHide = !0)
        }, 500))
    }),
    (r.prototype.hideLater = function (t) {
      this._show &&
        !(this._inContent && this._enterable) &&
        !this._alwaysShowContent &&
        (t
          ? ((this._hideDelay = t),
            (this._show = !1),
            (this._hideTimeout = setTimeout(Tt(this.hide, this), t)))
          : this.hide())
    }),
    (r.prototype.isShow = function () {
      return this._show
    }),
    (r.prototype.dispose = function () {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout)
      var t = this.el.parentNode
      t && t.removeChild(this.el), (this.el = this._container = null)
    }),
    r
  )
})()
const M_t = w_t
var T_t = (function () {
  function r(t) {
    ;(this._show = !1),
      (this._styleCoord = [0, 0, 0, 0]),
      (this._alwaysShowContent = !1),
      (this._enterable = !0),
      (this._zr = t.getZr()),
      T3(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2)
  }
  return (
    (r.prototype.update = function (t) {
      var e = t.get('alwaysShowContent')
      e && this._moveIfResized(), (this._alwaysShowContent = e)
    }),
    (r.prototype.show = function () {
      this._hideTimeout && clearTimeout(this._hideTimeout),
        this.el.show(),
        (this._show = !0)
    }),
    (r.prototype.setContent = function (t, e, n, i, a) {
      var o = this
      Ut(t) && Ce(''), this.el && this._zr.remove(this.el)
      var s = n.getModel('textStyle')
      ;(this.el = new Ae({
        style: {
          rich: e.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get('textShadowColor'),
          fill: n.get(['textStyle', 'color']),
          padding: z5(n, 'richText'),
          verticalAlign: 'top',
          align: 'left',
        },
        z: n.get('z'),
      })),
        R(
          [
            'backgroundColor',
            'borderRadius',
            'shadowColor',
            'shadowBlur',
            'shadowOffsetX',
            'shadowOffsetY',
          ],
          function (u) {
            o.el.style[u] = n.get(u)
          },
        ),
        R(
          ['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'],
          function (u) {
            o.el.style[u] = s.get(u) || 0
          },
        ),
        this._zr.add(this.el)
      var l = this
      this.el.on('mouseover', function () {
        l._enterable && (clearTimeout(l._hideTimeout), (l._show = !0)),
          (l._inContent = !0)
      }),
        this.el.on('mouseout', function () {
          l._enterable && l._show && l.hideLater(l._hideDelay),
            (l._inContent = !1)
        })
    }),
    (r.prototype.setEnterable = function (t) {
      this._enterable = t
    }),
    (r.prototype.getSize = function () {
      var t = this.el,
        e = this.el.getBoundingRect(),
        n = M3(t.style)
      return [e.width + n.left + n.right, e.height + n.top + n.bottom]
    }),
    (r.prototype.moveTo = function (t, e) {
      var n = this.el
      if (n) {
        var i = this._styleCoord
        T3(i, this._zr, t, e), (t = i[0]), (e = i[1])
        var a = n.style,
          o = Ts(a.borderWidth || 0),
          s = M3(a)
        ;(n.x = t + o + s.left), (n.y = e + o + s.top), n.markRedraw()
      }
    }),
    (r.prototype._moveIfResized = function () {
      var t = this._styleCoord[2],
        e = this._styleCoord[3]
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight())
    }),
    (r.prototype.hide = function () {
      this.el && this.el.hide(), (this._show = !1)
    }),
    (r.prototype.hideLater = function (t) {
      this._show &&
        !(this._inContent && this._enterable) &&
        !this._alwaysShowContent &&
        (t
          ? ((this._hideDelay = t),
            (this._show = !1),
            (this._hideTimeout = setTimeout(Tt(this.hide, this), t)))
          : this.hide())
    }),
    (r.prototype.isShow = function () {
      return this._show
    }),
    (r.prototype.dispose = function () {
      this._zr.remove(this.el)
    }),
    r
  )
})()
function Ts(r) {
  return Math.max(0, r)
}
function M3(r) {
  var t = Ts(r.shadowBlur || 0),
    e = Ts(r.shadowOffsetX || 0),
    n = Ts(r.shadowOffsetY || 0)
  return {
    left: Ts(t - e),
    right: Ts(t + e),
    top: Ts(t - n),
    bottom: Ts(t + n),
  }
}
function T3(r, t, e, n) {
  ;(r[0] = e),
    (r[1] = n),
    (r[2] = r[0] / t.getWidth()),
    (r[3] = r[1] / t.getHeight())
}
const C_t = T_t
var E_t = new ge({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2,
    },
  }),
  D_t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        if (!(Se.node || !n.getDom())) {
          var i = e.getComponent('tooltip'),
            a = (this._renderMode = Rtt(i.get('renderMode')))
          this._tooltipContent =
            a === 'richText'
              ? new C_t(n)
              : new M_t(n, {
                  appendTo: i.get('appendToBody', !0)
                    ? 'body'
                    : i.get('appendTo', !0),
                })
        }
      }),
      (t.prototype.render = function (e, n, i) {
        if (!(Se.node || !i.getDom())) {
          this.group.removeAll(),
            (this._tooltipModel = e),
            (this._ecModel = n),
            (this._api = i)
          var a = this._tooltipContent
          a.update(e),
            a.setEnterable(e.get('enterable')),
            this._initGlobalListener(),
            this._keepShow(),
            this._renderMode !== 'richText' && e.get('transitionDuration')
              ? Df(this, '_updatePosition', 50, 'fixRate')
              : Zp(this, '_updatePosition')
        }
      }),
      (t.prototype._initGlobalListener = function () {
        var e = this._tooltipModel,
          n = e.get('triggerOn')
        yH(
          'itemTooltip',
          this._api,
          Tt(function (i, a, o) {
            n !== 'none' &&
              (n.indexOf(i) >= 0
                ? this._tryShow(a, o)
                : i === 'leave' && this._hide(o))
          }, this),
        )
      }),
      (t.prototype._keepShow = function () {
        var e = this._tooltipModel,
          n = this._ecModel,
          i = this._api,
          a = e.get('triggerOn')
        if (
          this._lastX != null &&
          this._lastY != null &&
          a !== 'none' &&
          a !== 'click'
        ) {
          var o = this
          clearTimeout(this._refreshUpdateTimeout),
            (this._refreshUpdateTimeout = setTimeout(function () {
              !i.isDisposed() &&
                o.manuallyShowTip(e, n, i, {
                  x: o._lastX,
                  y: o._lastY,
                  dataByCoordSys: o._lastDataByCoordSys,
                })
            }))
        }
      }),
      (t.prototype.manuallyShowTip = function (e, n, i, a) {
        if (!(a.from === this.uid || Se.node || !i.getDom())) {
          var o = C3(a, i)
          this._ticket = ''
          var s = a.dataByCoordSys,
            l = I_t(a, n, i)
          if (l) {
            var u = l.el.getBoundingRect().clone()
            u.applyTransform(l.el.transform),
              this._tryShow(
                {
                  offsetX: u.x + u.width / 2,
                  offsetY: u.y + u.height / 2,
                  target: l.el,
                  position: a.position,
                  positionDefault: 'bottom',
                },
                o,
              )
          } else if (a.tooltip && a.x != null && a.y != null) {
            var c = E_t
            ;(c.x = a.x),
              (c.y = a.y),
              c.update(),
              (Wt(c).tooltipConfig = {
                name: null,
                option: a.tooltip,
              }),
              this._tryShow(
                {
                  offsetX: a.x,
                  offsetY: a.y,
                  target: c,
                },
                o,
              )
          } else if (s)
            this._tryShow(
              {
                offsetX: a.x,
                offsetY: a.y,
                position: a.position,
                dataByCoordSys: s,
                tooltipOption: a.tooltipOption,
              },
              o,
            )
          else if (a.seriesIndex != null) {
            if (this._manuallyAxisShowTip(e, n, i, a)) return
            var h = _H(a, n),
              f = h.point[0],
              d = h.point[1]
            f != null &&
              d != null &&
              this._tryShow(
                {
                  offsetX: f,
                  offsetY: d,
                  target: h.el,
                  position: a.position,
                  positionDefault: 'bottom',
                },
                o,
              )
          } else
            a.x != null &&
              a.y != null &&
              (i.dispatchAction({
                type: 'updateAxisPointer',
                x: a.x,
                y: a.y,
              }),
              this._tryShow(
                {
                  offsetX: a.x,
                  offsetY: a.y,
                  position: a.position,
                  target: i.getZr().findHover(a.x, a.y).target,
                },
                o,
              ))
        }
      }),
      (t.prototype.manuallyHideTip = function (e, n, i, a) {
        var o = this._tooltipContent
        this._tooltipModel && o.hideLater(this._tooltipModel.get('hideDelay')),
          (this._lastX = this._lastY = this._lastDataByCoordSys = null),
          a.from !== this.uid && this._hide(C3(a, i))
      }),
      (t.prototype._manuallyAxisShowTip = function (e, n, i, a) {
        var o = a.seriesIndex,
          s = a.dataIndex,
          l = n.getComponent('axisPointer').coordSysAxesInfo
        if (!(o == null || s == null || l == null)) {
          var u = n.getSeriesByIndex(o)
          if (u) {
            var c = u.getData(),
              h = _d(
                [c.getItemModel(s), u, (u.coordinateSystem || {}).model],
                this._tooltipModel,
              )
            if (h.get('trigger') === 'axis')
              return (
                i.dispatchAction({
                  type: 'updateAxisPointer',
                  seriesIndex: o,
                  dataIndex: s,
                  position: a.position,
                }),
                !0
              )
          }
        }
      }),
      (t.prototype._tryShow = function (e, n) {
        var i = e.target,
          a = this._tooltipModel
        if (a) {
          ;(this._lastX = e.offsetX), (this._lastY = e.offsetY)
          var o = e.dataByCoordSys
          if (o && o.length) this._showAxisTooltip(o, e)
          else if (i) {
            var s = Wt(i)
            if (s.ssrType === 'legend') return
            this._lastDataByCoordSys = null
            var l, u
            xu(
              i,
              function (c) {
                if (Wt(c).dataIndex != null) return (l = c), !0
                if (Wt(c).tooltipConfig != null) return (u = c), !0
              },
              !0,
            ),
              l
                ? this._showSeriesItemTooltip(e, l, n)
                : u
                ? this._showComponentItemTooltip(e, u, n)
                : this._hide(n)
          } else (this._lastDataByCoordSys = null), this._hide(n)
        }
      }),
      (t.prototype._showOrMove = function (e, n) {
        var i = e.get('showDelay')
        ;(n = Tt(n, this)),
          clearTimeout(this._showTimout),
          i > 0 ? (this._showTimout = setTimeout(n, i)) : n()
      }),
      (t.prototype._showAxisTooltip = function (e, n) {
        var i = this._ecModel,
          a = this._tooltipModel,
          o = [n.offsetX, n.offsetY],
          s = _d([n.tooltipOption], a),
          l = this._renderMode,
          u = [],
          c = Kn('section', {
            blocks: [],
            noHeader: !0,
          }),
          h = [],
          f = new I1()
        R(e, function (y) {
          R(y.dataByAxis, function (_) {
            var x = i.getComponent(_.axisDim + 'Axis', _.axisIndex),
              A = _.value
            if (!(!x || A == null)) {
              var S = vH(A, x.axis, i, _.seriesDataIndices, _.valueLabelOpt),
                b = Kn('section', {
                  header: S,
                  noHeader: !xa(S),
                  sortBlocks: !0,
                  blocks: [],
                })
              c.blocks.push(b),
                R(_.seriesDataIndices, function (T) {
                  var w = i.getSeriesByIndex(T.seriesIndex),
                    M = T.dataIndexInside,
                    C = w.getDataParams(M)
                  if (!(C.dataIndex < 0)) {
                    ;(C.axisDim = _.axisDim),
                      (C.axisIndex = _.axisIndex),
                      (C.axisType = _.axisType),
                      (C.axisId = _.axisId),
                      (C.axisValue = EC(x.axis, {
                        value: A,
                      })),
                      (C.axisValueLabel = S),
                      (C.marker = f.makeTooltipMarker('item', Zu(C.color), l))
                    var E = hR(w.formatTooltip(M, !0, null)),
                      D = E.frag
                    if (D) {
                      var P = _d([w], a).get('valueFormatter')
                      b.blocks.push(
                        P
                          ? Q(
                              {
                                valueFormatter: P,
                              },
                              D,
                            )
                          : D,
                      )
                    }
                    E.text && h.push(E.text), u.push(C)
                  }
                })
            }
          })
        }),
          c.blocks.reverse(),
          h.reverse()
        var d = n.position,
          p = s.get('order'),
          g = mR(c, f, l, p, i.get('useUTC'), s.get('textStyle'))
        g && h.unshift(g)
        var v =
            l === 'richText'
              ? `

`
              : '<br/>',
          m = h.join(v)
        this._showOrMove(s, function () {
          this._updateContentNotChangedOnAxis(e, u)
            ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u)
            : this._showTooltipContent(
                s,
                m,
                u,
                Math.random() + '',
                o[0],
                o[1],
                d,
                null,
                f,
              )
        })
      }),
      (t.prototype._showSeriesItemTooltip = function (e, n, i) {
        var a = this._ecModel,
          o = Wt(n),
          s = o.seriesIndex,
          l = a.getSeriesByIndex(s),
          u = o.dataModel || l,
          c = o.dataIndex,
          h = o.dataType,
          f = u.getData(h),
          d = this._renderMode,
          p = e.positionDefault,
          g = _d(
            [f.getItemModel(c), u, l && (l.coordinateSystem || {}).model],
            this._tooltipModel,
            p
              ? {
                  position: p,
                }
              : null,
          ),
          v = g.get('trigger')
        if (!(v != null && v !== 'item')) {
          var m = u.getDataParams(c, h),
            y = new I1()
          m.marker = y.makeTooltipMarker('item', Zu(m.color), d)
          var _ = hR(u.formatTooltip(c, !1, h)),
            x = g.get('order'),
            A = g.get('valueFormatter'),
            S = _.frag,
            b = S
              ? mR(
                  A
                    ? Q(
                        {
                          valueFormatter: A,
                        },
                        S,
                      )
                    : S,
                  y,
                  d,
                  x,
                  a.get('useUTC'),
                  g.get('textStyle'),
                )
              : _.text,
            T = 'item_' + u.name + '_' + c
          this._showOrMove(g, function () {
            this._showTooltipContent(
              g,
              b,
              m,
              T,
              e.offsetX,
              e.offsetY,
              e.position,
              e.target,
              y,
            )
          }),
            i({
              type: 'showTip',
              dataIndexInside: c,
              dataIndex: f.getRawIndex(c),
              seriesIndex: s,
              from: this.uid,
            })
        }
      }),
      (t.prototype._showComponentItemTooltip = function (e, n, i) {
        var a = this._renderMode === 'html',
          o = Wt(n),
          s = o.tooltipConfig,
          l = s.option || {},
          u = l.encodeHTMLContent
        if (bt(l)) {
          var c = l
          ;(l = {
            content: c,
            formatter: c,
          }),
            (u = !0)
        }
        u && a && l.content && ((l = Vt(l)), (l.content = Fr(l.content)))
        var h = [l],
          f = this._ecModel.getComponent(o.componentMainType, o.componentIndex)
        f && h.push(f),
          h.push({
            formatter: l.content,
          })
        var d = e.positionDefault,
          p = _d(
            h,
            this._tooltipModel,
            d
              ? {
                  position: d,
                }
              : null,
          ),
          g = p.get('content'),
          v = Math.random() + '',
          m = new I1()
        this._showOrMove(p, function () {
          var y = Vt(p.get('formatterParams') || {})
          this._showTooltipContent(
            p,
            g,
            y,
            v,
            e.offsetX,
            e.offsetY,
            e.position,
            n,
            m,
          )
        }),
          i({
            type: 'showTip',
            from: this.uid,
          })
      }),
      (t.prototype._showTooltipContent = function (e, n, i, a, o, s, l, u, c) {
        if (((this._ticket = ''), !(!e.get('showContent') || !e.get('show')))) {
          var h = this._tooltipContent
          h.setEnterable(e.get('enterable'))
          var f = e.get('formatter')
          l = l || e.get('position')
          var d = n,
            p = this._getNearestPoint(
              [o, s],
              i,
              e.get('trigger'),
              e.get('borderColor'),
            ),
            g = p.color
          if (f)
            if (bt(f)) {
              var v = e.ecModel.get('useUTC'),
                m = at(i) ? i[0] : i,
                y = m && m.axisType && m.axisType.indexOf('time') >= 0
              ;(d = f), y && (d = u_(m.axisValue, d, v)), (d = i5(d, i, !0))
            } else if (Nt(f)) {
              var _ = Tt(function (x, A) {
                x === this._ticket &&
                  (h.setContent(A, c, e, g, l),
                  this._updatePosition(e, l, o, s, h, i, u))
              }, this)
              ;(this._ticket = a), (d = f(i, a, _))
            } else d = f
          h.setContent(d, c, e, g, l),
            h.show(e, g),
            this._updatePosition(e, l, o, s, h, i, u)
        }
      }),
      (t.prototype._getNearestPoint = function (e, n, i, a) {
        if (i === 'axis' || at(n))
          return {
            color: a || (this._renderMode === 'html' ? '#fff' : 'none'),
          }
        if (!at(n))
          return {
            color: a || n.color || n.borderColor,
          }
      }),
      (t.prototype._updatePosition = function (e, n, i, a, o, s, l) {
        var u = this._api.getWidth(),
          c = this._api.getHeight()
        n = n || e.get('position')
        var h = o.getSize(),
          f = e.get('align'),
          d = e.get('verticalAlign'),
          p = l && l.getBoundingRect().clone()
        if (
          (l && p.applyTransform(l.transform),
          Nt(n) &&
            (n = n([i, a], s, o.el, p, {
              viewSize: [u, c],
              contentSize: h.slice(),
            })),
          at(n))
        )
          (i = _t(n[0], u)), (a = _t(n[1], c))
        else if (Ut(n)) {
          var g = n
          ;(g.width = h[0]), (g.height = h[1])
          var v = Vn(g, {
            width: u,
            height: c,
          })
          ;(i = v.x), (a = v.y), (f = null), (d = null)
        } else if (bt(n) && l) {
          var m = R_t(n, p, h, e.get('borderWidth'))
          ;(i = m[0]), (a = m[1])
        } else {
          var m = L_t(i, a, o, u, c, f ? null : 20, d ? null : 20)
          ;(i = m[0]), (a = m[1])
        }
        if (
          (f && (i -= E3(f) ? h[0] / 2 : f === 'right' ? h[0] : 0),
          d && (a -= E3(d) ? h[1] / 2 : d === 'bottom' ? h[1] : 0),
          RH(e))
        ) {
          var m = P_t(i, a, o, u, c)
          ;(i = m[0]), (a = m[1])
        }
        o.moveTo(i, a)
      }),
      (t.prototype._updateContentNotChangedOnAxis = function (e, n) {
        var i = this._lastDataByCoordSys,
          a = this._cbParamsList,
          o = !!i && i.length === e.length
        return (
          o &&
            R(i, function (s, l) {
              var u = s.dataByAxis || [],
                c = e[l] || {},
                h = c.dataByAxis || []
              ;(o = o && u.length === h.length),
                o &&
                  R(u, function (f, d) {
                    var p = h[d] || {},
                      g = f.seriesDataIndices || [],
                      v = p.seriesDataIndices || []
                    ;(o =
                      o &&
                      f.value === p.value &&
                      f.axisType === p.axisType &&
                      f.axisId === p.axisId &&
                      g.length === v.length),
                      o &&
                        R(g, function (m, y) {
                          var _ = v[y]
                          o =
                            o &&
                            m.seriesIndex === _.seriesIndex &&
                            m.dataIndex === _.dataIndex
                        }),
                      a &&
                        R(f.seriesDataIndices, function (m) {
                          var y = m.seriesIndex,
                            _ = n[y],
                            x = a[y]
                          _ && x && x.data !== _.data && (o = !1)
                        })
                  })
            }),
          (this._lastDataByCoordSys = e),
          (this._cbParamsList = n),
          !!o
        )
      }),
      (t.prototype._hide = function (e) {
        ;(this._lastDataByCoordSys = null),
          e({
            type: 'hideTip',
            from: this.uid,
          })
      }),
      (t.prototype.dispose = function (e, n) {
        Se.node ||
          !n.getDom() ||
          (Zp(this, '_updatePosition'),
          this._tooltipContent.dispose(),
          Jw('itemTooltip', n))
      }),
      (t.type = 'tooltip'),
      t
    )
  })(dn)
function _d(r, t, e) {
  var n = t.ecModel,
    i
  e ? ((i = new qe(e, n, n)), (i = new qe(t.option, i, n))) : (i = t)
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a]
    o &&
      (o instanceof qe && (o = o.get('tooltip', !0)),
      bt(o) &&
        (o = {
          formatter: o,
        }),
      o && (i = new qe(o, i, n)))
  }
  return i
}
function C3(r, t) {
  return r.dispatchAction || Tt(t.dispatchAction, t)
}
function L_t(r, t, e, n, i, a, o) {
  var s = e.getSize(),
    l = s[0],
    u = s[1]
  return (
    a != null && (r + l + a + 2 > n ? (r -= l + a) : (r += a)),
    o != null && (t + u + o > i ? (t -= u + o) : (t += o)),
    [r, t]
  )
}
function P_t(r, t, e, n, i) {
  var a = e.getSize(),
    o = a[0],
    s = a[1]
  return (
    (r = Math.min(r + o, n) - o),
    (t = Math.min(t + s, i) - s),
    (r = Math.max(r, 0)),
    (t = Math.max(t, 0)),
    [r, t]
  )
}
function R_t(r, t, e, n) {
  var i = e[0],
    a = e[1],
    o = Math.ceil(Math.SQRT2 * n) + 8,
    s = 0,
    l = 0,
    u = t.width,
    c = t.height
  switch (r) {
    case 'inside':
      ;(s = t.x + u / 2 - i / 2), (l = t.y + c / 2 - a / 2)
      break
    case 'top':
      ;(s = t.x + u / 2 - i / 2), (l = t.y - a - o)
      break
    case 'bottom':
      ;(s = t.x + u / 2 - i / 2), (l = t.y + c + o)
      break
    case 'left':
      ;(s = t.x - i - o), (l = t.y + c / 2 - a / 2)
      break
    case 'right':
      ;(s = t.x + u + o), (l = t.y + c / 2 - a / 2)
  }
  return [s, l]
}
function E3(r) {
  return r === 'center' || r === 'middle'
}
function I_t(r, t, e) {
  var n = UT(r).queryOptionMap,
    i = n.keys()[0]
  if (!(!i || i === 'series')) {
    var a = yv(t, i, n.get(i), {
        useDefault: !1,
        enableAll: !1,
        enableNone: !1,
      }),
      o = a.models[0]
    if (o) {
      var s = e.getViewOfComponentModel(o),
        l
      if (
        (s.group.traverse(function (u) {
          var c = Wt(u).tooltipConfig
          if (c && c.name === r.name) return (l = u), !0
        }),
        l)
      )
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l,
        }
    }
  }
}
const O_t = D_t
function N_t(r) {
  ie(Ov),
    r.registerComponentModel(p_t),
    r.registerComponentView(O_t),
    r.registerAction(
      {
        type: 'showTip',
        event: 'showTip',
        update: 'tooltip:manuallyShowTip',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'hideTip',
        event: 'hideTip',
        update: 'tooltip:manuallyHideTip',
      },
      wn,
    )
}
var k_t = ['rect', 'polygon', 'keep', 'clear']
function B_t(r, t) {
  var e = ke(r ? r.brush : [])
  if (e.length) {
    var n = []
    R(e, function (l) {
      var u = l.hasOwnProperty('toolbox') ? l.toolbox : []
      u instanceof Array && (n = n.concat(u))
    })
    var i = r && r.toolbox
    at(i) && (i = i[0]),
      i ||
        ((i = {
          feature: {},
        }),
        (r.toolbox = [i]))
    var a = i.feature || (i.feature = {}),
      o = a.brush || (a.brush = {}),
      s = o.type || (o.type = [])
    s.push.apply(s, n), F_t(s), t && !s.length && s.push.apply(s, k_t)
  }
}
function F_t(r) {
  var t = {}
  R(r, function (e) {
    t[e] = 1
  }),
    (r.length = 0),
    R(t, function (e, n) {
      r.push(n)
    })
}
var D3 = R
function L3(r) {
  if (r) {
    for (var t in r) if (r.hasOwnProperty(t)) return !0
  }
}
function iM(r, t, e) {
  var n = {}
  return (
    D3(t, function (a) {
      var o = (n[a] = i())
      D3(r[a], function (s, l) {
        if (vr.isValidType(l)) {
          var u = {
            type: l,
            visual: s,
          }
          e && e(u, a),
            (o[l] = new vr(u)),
            l === 'opacity' &&
              ((u = Vt(u)),
              (u.type = 'colorAlpha'),
              (o.__hidden.__alphaForOpacity = new vr(u)))
        }
      })
    }),
    n
  )
  function i() {
    var a = function () {}
    a.prototype.__hidden = a.prototype
    var o = new a()
    return o
  }
}
function kH(r, t, e) {
  var n
  R(e, function (i) {
    t.hasOwnProperty(i) && L3(t[i]) && (n = !0)
  }),
    n &&
      R(e, function (i) {
        t.hasOwnProperty(i) && L3(t[i]) ? (r[i] = Vt(t[i])) : delete r[i]
      })
}
function z_t(r, t, e, n, i, a) {
  var o = {}
  R(r, function (h) {
    var f = vr.prepareVisualTypes(t[h])
    o[h] = f
  })
  var s
  function l(h) {
    return mC(e, s, h)
  }
  function u(h, f) {
    Z5(e, s, h, f)
  }
  a == null ? e.each(c) : e.each([a], c)
  function c(h, f) {
    s = a == null ? h : f
    var d = e.getRawDataItem(s)
    if (!(d && d.visualMap === !1))
      for (
        var p = n.call(i, h), g = t[p], v = o[p], m = 0, y = v.length;
        m < y;
        m++
      ) {
        var _ = v[m]
        g[_] && g[_].applyVisual(h, l, u)
      }
  }
}
function U_t(r, t, e, n) {
  var i = {}
  return (
    R(r, function (a) {
      var o = vr.prepareVisualTypes(t[a])
      i[a] = o
    }),
    {
      progress: function (o, s) {
        var l
        n != null && (l = s.getDimensionIndex(n))
        function u(A) {
          return mC(s, h, A)
        }
        function c(A, S) {
          Z5(s, h, A, S)
        }
        for (var h, f = s.getStore(); (h = o.next()) != null; ) {
          var d = s.getRawDataItem(h)
          if (!(d && d.visualMap === !1))
            for (
              var p = n != null ? f.get(l, h) : h,
                g = e(p),
                v = t[g],
                m = i[g],
                y = 0,
                _ = m.length;
              y < _;
              y++
            ) {
              var x = m[y]
              v[x] && v[x].applyVisual(p, u, c)
            }
        }
      },
    }
  )
}
function V_t(r) {
  var t = r.brushType,
    e = {
      point: function (n) {
        return P3[t].point(n, e, r)
      },
      rect: function (n) {
        return P3[t].rect(n, e, r)
      },
    }
  return e
}
var P3 = {
  lineX: R3(0),
  lineY: R3(1),
  rect: {
    point: function (r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1])
    },
    rect: function (r, t, e) {
      return r && e.boundingRect.intersect(r)
    },
  },
  polygon: {
    point: function (r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]) && hu(e.range, r[0], r[1])
    },
    rect: function (r, t, e) {
      var n = e.range
      if (!r || n.length <= 1) return !1
      var i = r.x,
        a = r.y,
        o = r.width,
        s = r.height,
        l = n[0]
      if (
        hu(n, i, a) ||
        hu(n, i + o, a) ||
        hu(n, i, a + s) ||
        hu(n, i + o, a + s) ||
        ee.create(r).contain(l[0], l[1]) ||
        Fd(i, a, i + o, a, n) ||
        Fd(i, a, i, a + s, n) ||
        Fd(i + o, a, i + o, a + s, n) ||
        Fd(i, a + s, i + o, a + s, n)
      )
        return !0
    },
  },
}
function R3(r) {
  var t = ['x', 'y'],
    e = ['width', 'height']
  return {
    point: function (n, i, a) {
      if (n) {
        var o = a.range,
          s = n[r]
        return xd(s, o)
      }
    },
    rect: function (n, i, a) {
      if (n) {
        var o = a.range,
          s = [n[t[r]], n[t[r]] + n[e[r]]]
        return (
          s[1] < s[0] && s.reverse(),
          xd(s[0], o) || xd(s[1], o) || xd(o[0], s) || xd(o[1], s)
        )
      }
    },
  }
}
function xd(r, t) {
  return t[0] <= r && r <= t[1]
}
var I3 = ['inBrush', 'outOfBrush'],
  KS = '__ecBrushSelect',
  aM = '__ecInBrushSelectEvent'
function BH(r) {
  r.eachComponent(
    {
      mainType: 'brush',
    },
    function (t) {
      var e = (t.brushTargetManager = new ME(t.option, r))
      e.setInputRanges(t.areas, r)
    },
  )
}
function G_t(r, t, e) {
  var n = [],
    i,
    a
  r.eachComponent(
    {
      mainType: 'brush',
    },
    function (o) {
      e &&
        e.type === 'takeGlobalCursor' &&
        o.setBrushOption(
          e.key === 'brush'
            ? e.brushOption
            : {
                brushType: !1,
              },
        )
    },
  ),
    BH(r),
    r.eachComponent(
      {
        mainType: 'brush',
      },
      function (o, s) {
        var l = {
          brushId: o.id,
          brushIndex: s,
          brushName: o.name,
          areas: Vt(o.areas),
          selected: [],
        }
        n.push(l)
        var u = o.option,
          c = u.brushLink,
          h = [],
          f = [],
          d = [],
          p = !1
        s || ((i = u.throttleType), (a = u.throttleDelay))
        var g = st(o.areas, function (A) {
            var S = Y_t[A.brushType],
              b = zt(
                {
                  boundingRect: S ? S(A) : void 0,
                },
                A,
              )
            return (b.selectors = V_t(b)), b
          }),
          v = iM(o.option, I3, function (A) {
            A.mappingMethod = 'fixed'
          })
        at(c) &&
          R(c, function (A) {
            h[A] = 1
          })
        function m(A) {
          return c === 'all' || !!h[A]
        }
        function y(A) {
          return !!A.length
        }
        r.eachSeries(function (A, S) {
          var b = (d[S] = [])
          A.subType === 'parallel' ? _(A, S) : x(A, S, b)
        })
        function _(A, S) {
          var b = A.coordinateSystem
          ;(p = p || b.hasAxisBrushed()),
            m(S) &&
              b.eachActiveState(A.getData(), function (T, w) {
                T === 'active' && (f[w] = 1)
              })
        }
        function x(A, S, b) {
          if (
            !(!A.brushSelector || X_t(o, S)) &&
            (R(g, function (w) {
              o.brushTargetManager.controlSeries(w, A, r) && b.push(w),
                (p = p || y(b))
            }),
            m(S) && y(b))
          ) {
            var T = A.getData()
            T.each(function (w) {
              O3(A, b, T, w) && (f[w] = 1)
            })
          }
        }
        r.eachSeries(function (A, S) {
          var b = {
            seriesId: A.id,
            seriesIndex: S,
            seriesName: A.name,
            dataIndex: [],
          }
          l.selected.push(b)
          var T = d[S],
            w = A.getData(),
            M = m(S)
              ? function (C) {
                  return f[C]
                    ? (b.dataIndex.push(w.getRawIndex(C)), 'inBrush')
                    : 'outOfBrush'
                }
              : function (C) {
                  return O3(A, T, w, C)
                    ? (b.dataIndex.push(w.getRawIndex(C)), 'inBrush')
                    : 'outOfBrush'
                }
          ;(m(S) ? p : y(T)) && z_t(I3, v, w, M)
        })
      },
    ),
    H_t(t, i, a, n, e)
}
function H_t(r, t, e, n, i) {
  if (i) {
    var a = r.getZr()
    if (!a[aM]) {
      a[KS] || (a[KS] = W_t)
      var o = Df(a, KS, e, t)
      o(r, n)
    }
  }
}
function W_t(r, t) {
  if (!r.isDisposed()) {
    var e = r.getZr()
    ;(e[aM] = !0),
      r.dispatchAction({
        type: 'brushSelect',
        batch: t,
      }),
      (e[aM] = !1)
  }
}
function O3(r, t, e, n) {
  for (var i = 0, a = t.length; i < a; i++) {
    var o = t[i]
    if (r.brushSelector(n, e, o.selectors, o)) return !0
  }
}
function X_t(r, t) {
  var e = r.option.seriesIndex
  return e != null && e !== 'all' && (at(e) ? re(e, t) < 0 : t !== e)
}
var Y_t = {
  rect: function (r) {
    return N3(r.range)
  },
  polygon: function (r) {
    for (var t, e = r.range, n = 0, i = e.length; n < i; n++) {
      t = t || [
        [1 / 0, -1 / 0],
        [1 / 0, -1 / 0],
      ]
      var a = e[n]
      a[0] < t[0][0] && (t[0][0] = a[0]),
        a[0] > t[0][1] && (t[0][1] = a[0]),
        a[1] < t[1][0] && (t[1][0] = a[1]),
        a[1] > t[1][1] && (t[1][1] = a[1])
    }
    return t && N3(t)
  },
}
function N3(r) {
  return new ee(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0])
}
var $_t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.init = function (e, n) {
      ;(this.ecModel = e),
        (this.api = n),
        this.model,
        (this._brushController = new aE(n.getZr()))
          .on('brush', Tt(this._onBrush, this))
          .mount()
    }),
    (t.prototype.render = function (e, n, i, a) {
      ;(this.model = e), this._updateController(e, n, i, a)
    }),
    (t.prototype.updateTransform = function (e, n, i, a) {
      BH(n), this._updateController(e, n, i, a)
    }),
    (t.prototype.updateVisual = function (e, n, i, a) {
      this.updateTransform(e, n, i, a)
    }),
    (t.prototype.updateView = function (e, n, i, a) {
      this._updateController(e, n, i, a)
    }),
    (t.prototype._updateController = function (e, n, i, a) {
      ;(!a || a.$from !== e.id) &&
        this._brushController
          .setPanels(e.brushTargetManager.makePanelOpts(i))
          .enableBrush(e.brushOption)
          .updateCovers(e.areas.slice())
    }),
    (t.prototype.dispose = function () {
      this._brushController.dispose()
    }),
    (t.prototype._onBrush = function (e) {
      var n = this.model.id,
        i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel)
      ;(!e.isEnd || e.removeOnClick) &&
        this.api.dispatchAction({
          type: 'brush',
          brushId: n,
          areas: Vt(i),
          $from: n,
        }),
        e.isEnd &&
          this.api.dispatchAction({
            type: 'brushEnd',
            brushId: n,
            areas: Vt(i),
            $from: n,
          })
    }),
    (t.type = 'brush'),
    t
  )
})(dn)
const q_t = $_t
var Z_t = '#ddd',
  K_t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.areas = []), (e.brushOption = {}), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option
        !n && kH(i, e, ['inBrush', 'outOfBrush'])
        var a = (i.inBrush = i.inBrush || {})
        ;(i.outOfBrush = i.outOfBrush || {
          color: Z_t,
        }),
          a.hasOwnProperty('liftZ') || (a.liftZ = 5)
      }),
      (t.prototype.setAreas = function (e) {
        e &&
          (this.areas = st(
            e,
            function (n) {
              return k3(this.option, n)
            },
            this,
          ))
      }),
      (t.prototype.setBrushOption = function (e) {
        ;(this.brushOption = k3(this.option, e)),
          (this.brushType = this.brushOption.brushType)
      }),
      (t.type = 'brush'),
      (t.dependencies = [
        'geo',
        'grid',
        'xAxis',
        'yAxis',
        'parallel',
        'series',
      ]),
      (t.defaultOption = {
        seriesIndex: 'all',
        brushType: 'rect',
        brushMode: 'single',
        transformable: !0,
        brushStyle: {
          borderWidth: 1,
          color: 'rgba(210,219,238,0.3)',
          borderColor: '#D2DBEE',
        },
        throttleType: 'fixRate',
        throttleDelay: 0,
        removeOnClick: !0,
        z: 1e4,
      }),
      t
    )
  })(xe)
function k3(r, t) {
  return te(
    {
      brushType: r.brushType,
      brushMode: r.brushMode,
      transformable: r.transformable,
      brushStyle: new qe(r.brushStyle).getItemStyle(),
      removeOnClick: r.removeOnClick,
      z: r.z,
    },
    t,
    !0,
  )
}
const j_t = K_t
var J_t = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
  Q_t = (function (r) {
    X(t, r)
    function t() {
      return (r !== null && r.apply(this, arguments)) || this
    }
    return (
      (t.prototype.render = function (e, n, i) {
        var a, o, s
        n.eachComponent(
          {
            mainType: 'brush',
          },
          function (l) {
            ;(a = l.brushType),
              (o = l.brushOption.brushMode || 'single'),
              (s = s || !!l.areas.length)
          },
        ),
          (this._brushType = a),
          (this._brushMode = o),
          R(e.get('type', !0), function (l) {
            e.setIconStatus(
              l,
              (l === 'keep' ? o === 'multiple' : l === 'clear' ? s : l === a)
                ? 'emphasis'
                : 'normal',
            )
          })
      }),
      (t.prototype.updateView = function (e, n, i) {
        this.render(e, n, i)
      }),
      (t.prototype.getIcons = function () {
        var e = this.model,
          n = e.get('icon', !0),
          i = {}
        return (
          R(e.get('type', !0), function (a) {
            n[a] && (i[a] = n[a])
          }),
          i
        )
      }),
      (t.prototype.onclick = function (e, n, i) {
        var a = this._brushType,
          o = this._brushMode
        i === 'clear'
          ? (n.dispatchAction({
              type: 'axisAreaSelect',
              intervals: [],
            }),
            n.dispatchAction({
              type: 'brush',
              command: 'clear',
              areas: [],
            }))
          : n.dispatchAction({
              type: 'takeGlobalCursor',
              key: 'brush',
              brushOption: {
                brushType: i === 'keep' ? a : a === i ? !1 : i,
                brushMode:
                  i === 'keep' ? (o === 'multiple' ? 'single' : 'multiple') : o,
              },
            })
      }),
      (t.getDefaultOption = function (e) {
        var n = {
          show: !0,
          type: J_t.slice(),
          icon: {
            rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
            polygon:
              'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
            lineX:
              'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
            lineY:
              'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
            keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
            clear:
              'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2',
          },
          title: e.getLocaleModel().get(['toolbox', 'brush', 'title']),
        }
        return n
      }),
      t
    )
  })(Hi)
const txt = Q_t
function ext(r) {
  r.registerComponentView(q_t),
    r.registerComponentModel(j_t),
    r.registerPreprocessor(B_t),
    r.registerVisual(r.PRIORITY.VISUAL.BRUSH, G_t),
    r.registerAction(
      {
        type: 'brush',
        event: 'brush',
        update: 'updateVisual',
      },
      function (t, e) {
        e.eachComponent(
          {
            mainType: 'brush',
            query: t,
          },
          function (n) {
            n.setAreas(t.areas)
          },
        )
      },
    ),
    r.registerAction(
      {
        type: 'brushSelect',
        event: 'brushSelected',
        update: 'none',
      },
      wn,
    ),
    r.registerAction(
      {
        type: 'brushEnd',
        event: 'brushEnd',
        update: 'none',
      },
      wn,
    ),
    ch('brush', txt)
}
var nxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        e
      )
    }
    return (
      (t.type = 'title'),
      (t.defaultOption = {
        z: 6,
        show: !0,
        text: '',
        target: 'blank',
        subtext: '',
        subtarget: 'blank',
        left: 0,
        top: 0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: 'bold',
          color: '#464646',
        },
        subtextStyle: {
          fontSize: 12,
          color: '#6E7079',
        },
      }),
      t
    )
  })(xe),
  rxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        if ((this.group.removeAll(), !!e.get('show'))) {
          var a = this.group,
            o = e.getModel('textStyle'),
            s = e.getModel('subtextStyle'),
            l = e.get('textAlign'),
            u = $t(e.get('textBaseline'), e.get('textVerticalAlign')),
            c = new Ae({
              style: $e(
                o,
                {
                  text: e.get('text'),
                  fill: o.getTextColor(),
                },
                {
                  disableBox: !0,
                },
              ),
              z2: 10,
            }),
            h = c.getBoundingRect(),
            f = e.get('subtext'),
            d = new Ae({
              style: $e(
                s,
                {
                  text: f,
                  fill: s.getTextColor(),
                  y: h.height + e.get('itemGap'),
                  verticalAlign: 'top',
                },
                {
                  disableBox: !0,
                },
              ),
              z2: 10,
            }),
            p = e.get('link'),
            g = e.get('sublink'),
            v = e.get('triggerEvent', !0)
          ;(c.silent = !p && !v),
            (d.silent = !g && !v),
            p &&
              c.on('click', function () {
                jy(p, '_' + e.get('target'))
              }),
            g &&
              d.on('click', function () {
                jy(g, '_' + e.get('subtarget'))
              }),
            (Wt(c).eventData = Wt(d).eventData =
              v
                ? {
                    componentType: 'title',
                    componentIndex: e.componentIndex,
                  }
                : null),
            a.add(c),
            f && a.add(d)
          var m = a.getBoundingRect(),
            y = e.getBoxLayoutParams()
          ;(y.width = m.width), (y.height = m.height)
          var _ = Vn(
            y,
            {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            e.get('padding'),
          )
          l ||
            ((l = e.get('left') || e.get('right')),
            l === 'middle' && (l = 'center'),
            l === 'right'
              ? (_.x += _.width)
              : l === 'center' && (_.x += _.width / 2)),
            u ||
              ((u = e.get('top') || e.get('bottom')),
              u === 'center' && (u = 'middle'),
              u === 'bottom'
                ? (_.y += _.height)
                : u === 'middle' && (_.y += _.height / 2),
              (u = u || 'top')),
            (a.x = _.x),
            (a.y = _.y),
            a.markRedraw()
          var x = {
            align: l,
            verticalAlign: u,
          }
          c.setStyle(x), d.setStyle(x), (m = a.getBoundingRect())
          var A = _.margin,
            S = e.getItemStyle(['color', 'opacity'])
          S.fill = e.get('backgroundColor')
          var b = new ge({
            shape: {
              x: m.x - A[3],
              y: m.y - A[0],
              width: m.width + A[1] + A[3],
              height: m.height + A[0] + A[2],
              r: e.get('borderRadius'),
            },
            style: S,
            subPixelOptimize: !0,
            silent: !0,
          })
          a.add(b)
        }
      }),
      (t.type = 'title'),
      t
    )
  })(dn)
function ixt(r) {
  r.registerComponentModel(nxt), r.registerComponentView(rxt)
}
var axt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), (e.layoutMode = 'box'), e
  }
  return (
    (t.prototype.init = function (e, n, i) {
      this.mergeDefaultAndTheme(e, i), this._initData()
    }),
    (t.prototype.mergeOption = function (e) {
      r.prototype.mergeOption.apply(this, arguments), this._initData()
    }),
    (t.prototype.setCurrentIndex = function (e) {
      e == null && (e = this.option.currentIndex)
      var n = this._data.count()
      this.option.loop
        ? (e = ((e % n) + n) % n)
        : (e >= n && (e = n - 1), e < 0 && (e = 0)),
        (this.option.currentIndex = e)
    }),
    (t.prototype.getCurrentIndex = function () {
      return this.option.currentIndex
    }),
    (t.prototype.isIndexMax = function () {
      return this.getCurrentIndex() >= this._data.count() - 1
    }),
    (t.prototype.setPlayState = function (e) {
      this.option.autoPlay = !!e
    }),
    (t.prototype.getPlayState = function () {
      return !!this.option.autoPlay
    }),
    (t.prototype._initData = function () {
      var e = this.option,
        n = e.data || [],
        i = e.axisType,
        a = (this._names = []),
        o
      i === 'category'
        ? ((o = []),
          R(n, function (u, c) {
            var h = Un(yf(u), ''),
              f
            Ut(u) ? ((f = Vt(u)), (f.value = c)) : (f = c), o.push(f), a.push(h)
          }))
        : (o = n)
      var s =
          {
            category: 'ordinal',
            time: 'time',
            value: 'number',
          }[i] || 'number',
        l = (this._data = new Vr(
          [
            {
              name: 'value',
              type: s,
            },
          ],
          this,
        ))
      l.initData(o, a)
    }),
    (t.prototype.getData = function () {
      return this._data
    }),
    (t.prototype.getCategories = function () {
      if (this.get('axisType') === 'category') return this._names.slice()
    }),
    (t.type = 'timeline'),
    (t.defaultOption = {
      z: 4,
      show: !0,
      axisType: 'time',
      realtime: !0,
      left: '20%',
      top: null,
      right: '20%',
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: 'left',
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: '#000',
      },
      data: [],
    }),
    t
  )
})(xe)
const B3 = axt
var FH = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'timeline.slider'),
    (t.defaultOption = gl(B3.defaultOption, {
      backgroundColor: 'rgba(0,0,0,0)',
      borderColor: '#ccc',
      borderWidth: 0,
      orient: 'horizontal',
      inverse: !1,
      tooltip: {
        trigger: 'item',
      },
      symbol: 'circle',
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: '#DAE1F5',
      },
      label: {
        position: 'auto',
        show: !0,
        interval: 'auto',
        rotate: 0,
        color: '#A4B1D7',
      },
      itemStyle: {
        color: '#A4B1D7',
        borderWidth: 1,
      },
      checkpointStyle: {
        symbol: 'circle',
        symbolSize: 15,
        color: '#316bf3',
        borderColor: '#fff',
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        animation: !0,
        animationDuration: 300,
        animationEasing: 'quinticInOut',
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: 'left',
        playIcon:
          'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
        stopIcon:
          'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
        nextIcon:
          'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',
        prevIcon:
          'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: '#A4B1D7',
        borderColor: '#A4B1D7',
        borderWidth: 1,
      },
      emphasis: {
        label: {
          show: !0,
          color: '#6f778d',
        },
        itemStyle: {
          color: '#316BF3',
        },
        controlStyle: {
          color: '#316BF3',
          borderColor: '#316BF3',
          borderWidth: 2,
        },
      },
      progress: {
        lineStyle: {
          color: '#316BF3',
        },
        itemStyle: {
          color: '#316BF3',
        },
        label: {
          color: '#6f778d',
        },
      },
      data: [],
    })),
    t
  )
})(B3)
In(FH, g_.prototype)
const oxt = FH
var sxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (t.type = 'timeline'), t
})(dn)
const lxt = sxt
var uxt = (function (r) {
  X(t, r)
  function t(e, n, i, a) {
    var o = r.call(this, e, n, i) || this
    return (o.type = a || 'value'), o
  }
  return (
    (t.prototype.getLabelModel = function () {
      return this.model.getModel('label')
    }),
    (t.prototype.isHorizontal = function () {
      return this.model.get('orient') === 'horizontal'
    }),
    t
  )
})(Ra)
const cxt = uxt
var jS = Math.PI,
  F3 = ve(),
  hxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function (e, n) {
        this.api = n
      }),
      (t.prototype.render = function (e, n, i) {
        if (
          ((this.model = e),
          (this.api = i),
          (this.ecModel = n),
          this.group.removeAll(),
          e.get('show', !0))
        ) {
          var a = this._layout(e, i),
            o = this._createGroup('_mainGroup'),
            s = this._createGroup('_labelGroup'),
            l = (this._axis = this._createAxis(a, e))
          ;(e.formatTooltip = function (u) {
            var c = l.scale.getLabel({
              value: u,
            })
            return Kn('nameValue', {
              noName: !0,
              value: c,
            })
          }),
            R(
              ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'],
              function (u) {
                this['_render' + u](a, o, l, e)
              },
              this,
            ),
            this._renderAxisLabel(a, s, l, e),
            this._position(a, e)
        }
        this._doPlayStop(), this._updateTicksStatus()
      }),
      (t.prototype.remove = function () {
        this._clearTimer(), this.group.removeAll()
      }),
      (t.prototype.dispose = function () {
        this._clearTimer()
      }),
      (t.prototype._layout = function (e, n) {
        var i = e.get(['label', 'position']),
          a = e.get('orient'),
          o = dxt(e, n),
          s
        i == null || i === 'auto'
          ? (s =
              a === 'horizontal'
                ? o.y + o.height / 2 < n.getHeight() / 2
                  ? '-'
                  : '+'
                : o.x + o.width / 2 < n.getWidth() / 2
                ? '+'
                : '-')
          : bt(i)
          ? (s = {
              horizontal: {
                top: '-',
                bottom: '+',
              },
              vertical: {
                left: '-',
                right: '+',
              },
            }[a][i])
          : (s = i)
        var l = {
            horizontal: 'center',
            vertical: s >= 0 || s === '+' ? 'left' : 'right',
          },
          u = {
            horizontal: s >= 0 || s === '+' ? 'top' : 'bottom',
            vertical: 'middle',
          },
          c = {
            horizontal: 0,
            vertical: jS / 2,
          },
          h = a === 'vertical' ? o.height : o.width,
          f = e.getModel('controlStyle'),
          d = f.get('show', !0),
          p = d ? f.get('itemSize') : 0,
          g = d ? f.get('itemGap') : 0,
          v = p + g,
          m = e.get(['label', 'rotate']) || 0
        m = (m * jS) / 180
        var y,
          _,
          x,
          A = f.get('position', !0),
          S = d && f.get('showPlayBtn', !0),
          b = d && f.get('showPrevBtn', !0),
          T = d && f.get('showNextBtn', !0),
          w = 0,
          M = h
        A === 'left' || A === 'bottom'
          ? (S && ((y = [0, 0]), (w += v)),
            b && ((_ = [w, 0]), (w += v)),
            T && ((x = [M - p, 0]), (M -= v)))
          : (S && ((y = [M - p, 0]), (M -= v)),
            b && ((_ = [0, 0]), (w += v)),
            T && ((x = [M - p, 0]), (M -= v)))
        var C = [w, M]
        return (
          e.get('inverse') && C.reverse(),
          {
            viewRect: o,
            mainLength: h,
            orient: a,
            rotation: c[a],
            labelRotation: m,
            labelPosOpt: s,
            labelAlign: e.get(['label', 'align']) || l[a],
            labelBaseline:
              e.get(['label', 'verticalAlign']) ||
              e.get(['label', 'baseline']) ||
              u[a],
            playPosition: y,
            prevBtnPosition: _,
            nextBtnPosition: x,
            axisExtent: C,
            controlSize: p,
            controlGap: g,
          }
        )
      }),
      (t.prototype._position = function (e, n) {
        var i = this._mainGroup,
          a = this._labelGroup,
          o = e.viewRect
        if (e.orient === 'vertical') {
          var s = bi(),
            l = o.x,
            u = o.y + o.height
          ho(s, s, [-l, -u]),
            ec(s, s, -jS / 2),
            ho(s, s, [l, u]),
            (o = o.clone()),
            o.applyTransform(s)
        }
        var c = y(o),
          h = y(i.getBoundingRect()),
          f = y(a.getBoundingRect()),
          d = [i.x, i.y],
          p = [a.x, a.y]
        p[0] = d[0] = c[0][0]
        var g = e.labelPosOpt
        if (g == null || bt(g)) {
          var v = g === '+' ? 0 : 1
          _(d, h, c, 1, v), _(p, f, c, 1, 1 - v)
        } else {
          var v = g >= 0 ? 0 : 1
          _(d, h, c, 1, v), (p[1] = d[1] + g)
        }
        i.setPosition(d),
          a.setPosition(p),
          (i.rotation = a.rotation = e.rotation),
          m(i),
          m(a)
        function m(x) {
          ;(x.originX = c[0][0] - x.x), (x.originY = c[1][0] - x.y)
        }
        function y(x) {
          return [
            [x.x, x.x + x.width],
            [x.y, x.y + x.height],
          ]
        }
        function _(x, A, S, b, T) {
          x[b] += S[b][T] - A[b][T]
        }
      }),
      (t.prototype._createAxis = function (e, n) {
        var i = n.getData(),
          a = n.get('axisType'),
          o = fxt(n, a)
        o.getTicks = function () {
          return i.mapArray(['value'], function (u) {
            return {
              value: u,
            }
          })
        }
        var s = i.getDataExtent('value')
        o.setExtent(s[0], s[1]), o.calcNiceTicks()
        var l = new cxt('value', o, e.axisExtent, a)
        return (l.model = n), l
      }),
      (t.prototype._createGroup = function (e) {
        var n = (this[e] = new Ht())
        return this.group.add(n), n
      }),
      (t.prototype._renderAxisLine = function (e, n, i, a) {
        var o = i.getExtent()
        if (a.get(['lineStyle', 'show'])) {
          var s = new rr({
            shape: {
              x1: o[0],
              y1: 0,
              x2: o[1],
              y2: 0,
            },
            style: Q(
              {
                lineCap: 'round',
              },
              a.getModel('lineStyle').getLineStyle(),
            ),
            silent: !0,
            z2: 1,
          })
          n.add(s)
          var l = (this._progressLine = new rr({
            shape: {
              x1: o[0],
              x2: this._currentPointer ? this._currentPointer.x : o[0],
              y1: 0,
              y2: 0,
            },
            style: zt(
              {
                lineCap: 'round',
                lineWidth: s.style.lineWidth,
              },
              a.getModel(['progress', 'lineStyle']).getLineStyle(),
            ),
            silent: !0,
            z2: 1,
          }))
          n.add(l)
        }
      }),
      (t.prototype._renderAxisTick = function (e, n, i, a) {
        var o = this,
          s = a.getData(),
          l = i.scale.getTicks()
        ;(this._tickSymbols = []),
          R(l, function (u) {
            var c = i.dataToCoord(u.value),
              h = s.getItemModel(u.value),
              f = h.getModel('itemStyle'),
              d = h.getModel(['emphasis', 'itemStyle']),
              p = h.getModel(['progress', 'itemStyle']),
              g = {
                x: c,
                y: 0,
                onclick: Tt(o._changeTimeline, o, u.value),
              },
              v = z3(h, f, n, g)
            ;(v.ensureState('emphasis').style = d.getItemStyle()),
              (v.ensureState('progress').style = p.getItemStyle()),
              Ou(v)
            var m = Wt(v)
            h.get('tooltip')
              ? ((m.dataIndex = u.value), (m.dataModel = a))
              : (m.dataIndex = m.dataModel = null),
              o._tickSymbols.push(v)
          })
      }),
      (t.prototype._renderAxisLabel = function (e, n, i, a) {
        var o = this,
          s = i.getLabelModel()
        if (s.get('show')) {
          var l = a.getData(),
            u = i.getViewLabels()
          ;(this._tickLabels = []),
            R(u, function (c) {
              var h = c.tickValue,
                f = l.getItemModel(h),
                d = f.getModel('label'),
                p = f.getModel(['emphasis', 'label']),
                g = f.getModel(['progress', 'label']),
                v = i.dataToCoord(c.tickValue),
                m = new Ae({
                  x: v,
                  y: 0,
                  rotation: e.labelRotation - e.rotation,
                  onclick: Tt(o._changeTimeline, o, h),
                  silent: !1,
                  style: $e(d, {
                    text: c.formattedLabel,
                    align: e.labelAlign,
                    verticalAlign: e.labelBaseline,
                  }),
                })
              ;(m.ensureState('emphasis').style = $e(p)),
                (m.ensureState('progress').style = $e(g)),
                n.add(m),
                Ou(m),
                (F3(m).dataIndex = h),
                o._tickLabels.push(m)
            })
        }
      }),
      (t.prototype._renderControl = function (e, n, i, a) {
        var o = e.controlSize,
          s = e.rotation,
          l = a.getModel('controlStyle').getItemStyle(),
          u = a.getModel(['emphasis', 'controlStyle']).getItemStyle(),
          c = a.getPlayState(),
          h = a.get('inverse', !0)
        f(
          e.nextBtnPosition,
          'next',
          Tt(this._changeTimeline, this, h ? '-' : '+'),
        ),
          f(
            e.prevBtnPosition,
            'prev',
            Tt(this._changeTimeline, this, h ? '+' : '-'),
          ),
          f(
            e.playPosition,
            c ? 'stop' : 'play',
            Tt(this._handlePlayClick, this, !c),
            !0,
          )
        function f(d, p, g, v) {
          if (d) {
            var m = Ta($t(a.get(['controlStyle', p + 'BtnSize']), o), o),
              y = [0, -m / 2, m, m],
              _ = pxt(a, p + 'Icon', y, {
                x: d[0],
                y: d[1],
                originX: o / 2,
                originY: 0,
                rotation: v ? -s : 0,
                rectHover: !0,
                style: l,
                onclick: g,
              })
            ;(_.ensureState('emphasis').style = u), n.add(_), Ou(_)
          }
        }
      }),
      (t.prototype._renderCurrentPointer = function (e, n, i, a) {
        var o = a.getData(),
          s = a.getCurrentIndex(),
          l = o.getItemModel(s).getModel('checkpointStyle'),
          u = this,
          c = {
            onCreate: function (h) {
              ;(h.draggable = !0),
                (h.drift = Tt(u._handlePointerDrag, u)),
                (h.ondragend = Tt(u._handlePointerDragend, u)),
                U3(h, u._progressLine, s, i, a, !0)
            },
            onUpdate: function (h) {
              U3(h, u._progressLine, s, i, a)
            },
          }
        this._currentPointer = z3(
          l,
          l,
          this._mainGroup,
          {},
          this._currentPointer,
          c,
        )
      }),
      (t.prototype._handlePlayClick = function (e) {
        this._clearTimer(),
          this.api.dispatchAction({
            type: 'timelinePlayChange',
            playState: e,
            from: this.uid,
          })
      }),
      (t.prototype._handlePointerDrag = function (e, n, i) {
        this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
      }),
      (t.prototype._handlePointerDragend = function (e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], !0)
      }),
      (t.prototype._pointerChangeTimeline = function (e, n) {
        var i = this._toAxisCoord(e)[0],
          a = this._axis,
          o = Zi(a.getExtent().slice())
        i > o[1] && (i = o[1]),
          i < o[0] && (i = o[0]),
          (this._currentPointer.x = i),
          this._currentPointer.markRedraw()
        var s = this._progressLine
        s && ((s.shape.x2 = i), s.dirty())
        var l = this._findNearestTick(i),
          u = this.model
        ;(n || (l !== u.getCurrentIndex() && u.get('realtime'))) &&
          this._changeTimeline(l)
      }),
      (t.prototype._doPlayStop = function () {
        var e = this
        this._clearTimer(),
          this.model.getPlayState() &&
            (this._timer = setTimeout(function () {
              var n = e.model
              e._changeTimeline(
                n.getCurrentIndex() + (n.get('rewind', !0) ? -1 : 1),
              )
            }, this.model.get('playInterval')))
      }),
      (t.prototype._toAxisCoord = function (e) {
        var n = this._mainGroup.getLocalTransform()
        return ba(e, n, !0)
      }),
      (t.prototype._findNearestTick = function (e) {
        var n = this.model.getData(),
          i = 1 / 0,
          a,
          o = this._axis
        return (
          n.each(['value'], function (s, l) {
            var u = o.dataToCoord(s),
              c = Math.abs(u - e)
            c < i && ((i = c), (a = l))
          }),
          a
        )
      }),
      (t.prototype._clearTimer = function () {
        this._timer && (clearTimeout(this._timer), (this._timer = null))
      }),
      (t.prototype._changeTimeline = function (e) {
        var n = this.model.getCurrentIndex()
        e === '+' ? (e = n + 1) : e === '-' && (e = n - 1),
          this.api.dispatchAction({
            type: 'timelineChange',
            currentIndex: e,
            from: this.uid,
          })
      }),
      (t.prototype._updateTicksStatus = function () {
        var e = this.model.getCurrentIndex(),
          n = this._tickSymbols,
          i = this._tickLabels
        if (n)
          for (var a = 0; a < n.length; a++)
            n && n[a] && n[a].toggleState('progress', a < e)
        if (i)
          for (var a = 0; a < i.length; a++)
            i && i[a] && i[a].toggleState('progress', F3(i[a]).dataIndex <= e)
      }),
      (t.type = 'timeline.slider'),
      t
    )
  })(lxt)
function fxt(r, t) {
  if (((t = t || r.get('type')), t))
    switch (t) {
      case 'category':
        return new wC({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0],
        })
      case 'time':
        return new FV({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get('useUTC'),
        })
      default:
        return new ll()
    }
}
function dxt(r, t) {
  return Vn(
    r.getBoxLayoutParams(),
    {
      width: t.getWidth(),
      height: t.getHeight(),
    },
    r.get('padding'),
  )
}
function pxt(r, t, e, n) {
  var i = n.style,
    a = Sv(r.get(['controlStyle', t]), n || {}, new ee(e[0], e[1], e[2], e[3]))
  return i && a.setStyle(i), a
}
function z3(r, t, e, n, i, a) {
  var o = t.get('color')
  if (i) i.setColor(o), e.add(i), a && a.onUpdate(i)
  else {
    var s = r.get('symbol')
    ;(i = Rn(s, -1, -1, 2, 2, o)),
      i.setStyle('strokeNoScale', !0),
      e.add(i),
      a && a.onCreate(i)
  }
  var l = t.getItemStyle(['color'])
  i.setStyle(l),
    (n = te(
      {
        rectHover: !0,
        z2: 100,
      },
      n,
      !0,
    ))
  var u = Lf(r.get('symbolSize'))
  ;(n.scaleX = u[0] / 2), (n.scaleY = u[1] / 2)
  var c = ic(r.get('symbolOffset'), u)
  c && ((n.x = (n.x || 0) + c[0]), (n.y = (n.y || 0) + c[1]))
  var h = r.get('symbolRotate')
  return (
    (n.rotation = ((h || 0) * Math.PI) / 180 || 0),
    i.attr(n),
    i.updateTransform(),
    i
  )
}
function U3(r, t, e, n, i, a) {
  if (!r.dragging) {
    var o = i.getModel('checkpointStyle'),
      s = n.dataToCoord(i.getData().get('value', e))
    if (a || !o.get('animation', !0))
      r.attr({
        x: s,
        y: 0,
      }),
        t &&
          t.attr({
            shape: {
              x2: s,
            },
          })
    else {
      var l = {
        duration: o.get('animationDuration', !0),
        easing: o.get('animationEasing', !0),
      }
      r.stopAnimation(null, !0),
        r.animateTo(
          {
            x: s,
            y: 0,
          },
          l,
        ),
        t &&
          t.animateTo(
            {
              shape: {
                x2: s,
              },
            },
            l,
          )
    }
  }
}
const vxt = hxt
function gxt(r) {
  r.registerAction(
    {
      type: 'timelineChange',
      event: 'timelineChanged',
      update: 'prepareAndUpdate',
    },
    function (t, e, n) {
      var i = e.getComponent('timeline')
      return (
        i &&
          t.currentIndex != null &&
          (i.setCurrentIndex(t.currentIndex),
          !i.get('loop', !0) &&
            i.isIndexMax() &&
            i.getPlayState() &&
            (i.setPlayState(!1),
            n.dispatchAction({
              type: 'timelinePlayChange',
              playState: !1,
              from: t.from,
            }))),
        e.resetOption('timeline', {
          replaceMerge: i.get('replaceMerge', !0),
        }),
        zt(
          {
            currentIndex: i.option.currentIndex,
          },
          t,
        )
      )
    },
  ),
    r.registerAction(
      {
        type: 'timelinePlayChange',
        event: 'timelinePlayChanged',
        update: 'update',
      },
      function (t, e) {
        var n = e.getComponent('timeline')
        n && t.playState != null && n.setPlayState(t.playState)
      },
    )
}
function mxt(r) {
  var t = r && r.timeline
  at(t) || (t = t ? [t] : []),
    R(t, function (e) {
      e && yxt(e)
    })
}
function yxt(r) {
  var t = r.type,
    e = {
      number: 'value',
      time: 'time',
    }
  if (
    (e[t] && ((r.axisType = e[t]), delete r.type),
    V3(r),
    pu(r, 'controlPosition'))
  ) {
    var n = r.controlStyle || (r.controlStyle = {})
    pu(n, 'position') || (n.position = r.controlPosition),
      n.position === 'none' &&
        !pu(n, 'show') &&
        ((n.show = !1), delete n.position),
      delete r.controlPosition
  }
  R(r.data || [], function (i) {
    Ut(i) &&
      !at(i) &&
      (!pu(i, 'value') && pu(i, 'name') && (i.value = i.name), V3(i))
  })
}
function V3(r) {
  var t = r.itemStyle || (r.itemStyle = {}),
    e = t.emphasis || (t.emphasis = {}),
    n = r.label || r.label || {},
    i = n.normal || (n.normal = {}),
    a = {
      normal: 1,
      emphasis: 1,
    }
  R(n, function (o, s) {
    !a[s] && !pu(i, s) && (i[s] = o)
  }),
    e.label && !pu(n, 'emphasis') && ((n.emphasis = e.label), delete e.label)
}
function pu(r, t) {
  return r.hasOwnProperty(t)
}
function _xt(r) {
  r.registerComponentModel(oxt),
    r.registerComponentView(vxt),
    r.registerSubTypeDefaulter('timeline', function () {
      return 'slider'
    }),
    gxt(r),
    r.registerPreprocessor(mxt)
}
function EE(r, t) {
  if (!r) return !1
  for (var e = at(r) ? r : [r], n = 0; n < e.length; n++)
    if (e[n] && e[n][t]) return !0
  return !1
}
function Mm(r) {
  Xu(r, 'label', ['show'])
}
var Tm = ve(),
  zH = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.createdBySelf = !1), e
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, !1, !0)
      }),
      (t.prototype.isAnimationEnabled = function () {
        if (Se.node) return !1
        var e = this.__hostSeries
        return this.getShallow('animation') && e && e.isAnimationEnabled()
      }),
      (t.prototype.mergeOption = function (e, n) {
        this._mergeOption(e, n, !1, !1)
      }),
      (t.prototype._mergeOption = function (e, n, i, a) {
        var o = this.mainType
        i ||
          n.eachSeries(function (s) {
            var l = s.get(this.mainType, !0),
              u = Tm(s)[o]
            if (!l || !l.data) {
              Tm(s)[o] = null
              return
            }
            u
              ? u._mergeOption(l, n, !0)
              : (a && Mm(l),
                R(l.data, function (c) {
                  c instanceof Array ? (Mm(c[0]), Mm(c[1])) : Mm(c)
                }),
                (u = this.createMarkerModelFromSeries(l, this, n)),
                Q(u, {
                  mainType: this.mainType,
                  seriesIndex: s.seriesIndex,
                  name: s.name,
                  createdBySelf: !0,
                }),
                (u.__hostSeries = s)),
              (Tm(s)[o] = u)
          }, this)
      }),
      (t.prototype.formatTooltip = function (e, n, i) {
        var a = this.getData(),
          o = this.getRawValue(e),
          s = a.getName(e)
        return Kn('section', {
          header: this.name,
          blocks: [
            Kn('nameValue', {
              name: s,
              value: o,
              noName: !s,
              noValue: o == null,
            }),
          ],
        })
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.setData = function (e) {
        this._data = e
      }),
      (t.prototype.getDataParams = function (e, n) {
        var i = g_.prototype.getDataParams.call(this, e, n),
          a = this.__hostSeries
        return (
          a &&
            ((i.seriesId = a.id),
            (i.seriesName = a.name),
            (i.seriesType = a.subType)),
          i
        )
      }),
      (t.getMarkerModelFromSeries = function (e, n) {
        return Tm(e)[n]
      }),
      (t.type = 'marker'),
      (t.dependencies = ['series', 'grid', 'polar', 'geo']),
      t
    )
  })(xe)
In(zH, g_.prototype)
const hl = zH
var xxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markPoint'),
    (t.defaultOption = {
      z: 5,
      symbol: 'pin',
      symbolSize: 50,
      tooltip: {
        trigger: 'item',
      },
      label: {
        show: !0,
        position: 'inside',
      },
      itemStyle: {
        borderWidth: 2,
      },
      emphasis: {
        label: {
          show: !0,
        },
      },
    }),
    t
  )
})(hl)
const Sxt = xxt
function oM(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)))
}
function Axt(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y))
}
function Cm(r, t, e, n, i, a) {
  var o = [],
    s = sl(t, n),
    l = s ? t.getCalculationInfo('stackResultDimension') : n,
    u = DE(t, l, r),
    c = t.indicesOfNearest(l, u)[0]
  ;(o[i] = t.get(e, c)), (o[a] = t.get(l, c))
  var h = t.get(n, c),
    f = Qa(t.get(n, c))
  return (f = Math.min(f, 20)), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, h]
}
var JS = {
  min: Zt(Cm, 'min'),
  max: Zt(Cm, 'max'),
  average: Zt(Cm, 'average'),
  median: Zt(Cm, 'median'),
}
function lv(r, t) {
  if (t) {
    var e = r.getData(),
      n = r.coordinateSystem,
      i = n && n.dimensions
    if (!Axt(t) && !at(t.coord) && at(i)) {
      var a = UH(t, e, n, r)
      if (((t = Vt(t)), t.type && JS[t.type] && a.baseAxis && a.valueAxis)) {
        var o = re(i, a.baseAxis.dim),
          s = re(i, a.valueAxis.dim),
          l = JS[t.type](e, a.baseDataDim, a.valueDataDim, o, s)
        ;(t.coord = l[0]), (t.value = l[1])
      } else
        t.coord = [
          t.xAxis != null ? t.xAxis : t.radiusAxis,
          t.yAxis != null ? t.yAxis : t.angleAxis,
        ]
    }
    if (t.coord == null || !at(i)) t.coord = []
    else
      for (var u = t.coord, c = 0; c < 2; c++)
        JS[u[c]] && (u[c] = DE(e, e.mapDimension(i[c]), u[c]))
    return t
  }
}
function UH(r, t, e, n) {
  var i = {}
  return (
    r.valueIndex != null || r.valueDim != null
      ? ((i.valueDataDim =
          r.valueIndex != null ? t.getDimension(r.valueIndex) : r.valueDim),
        (i.valueAxis = e.getAxis(bxt(n, i.valueDataDim))),
        (i.baseAxis = e.getOtherAxis(i.valueAxis)),
        (i.baseDataDim = t.mapDimension(i.baseAxis.dim)))
      : ((i.baseAxis = n.getBaseAxis()),
        (i.valueAxis = e.getOtherAxis(i.baseAxis)),
        (i.baseDataDim = t.mapDimension(i.baseAxis.dim)),
        (i.valueDataDim = t.mapDimension(i.valueAxis.dim))),
    i
  )
}
function bxt(r, t) {
  var e = r.getData().getDimensionInfo(t)
  return e && e.coordDim
}
function uv(r, t) {
  return r && r.containData && t.coord && !oM(t) ? r.containData(t.coord) : !0
}
function wxt(r, t, e) {
  return r && r.containZone && t.coord && e.coord && !oM(t) && !oM(e)
    ? r.containZone(t.coord, e.coord)
    : !0
}
function VH(r, t) {
  return r
    ? function (e, n, i, a) {
        var o = a < 2 ? e.coord && e.coord[a] : e.value
        return Js(o, t[a])
      }
    : function (e, n, i, a) {
        return Js(e.value, t[a])
      }
}
function DE(r, t, e) {
  if (e === 'average') {
    var n = 0,
      i = 0
    return (
      r.each(t, function (a, o) {
        isNaN(a) || ((n += a), i++)
      }),
      n / i
    )
  } else
    return e === 'median'
      ? r.getMedian(t)
      : r.getDataExtent(t)[e === 'max' ? 1 : 0]
}
var QS = ve(),
  Mxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.init = function () {
        this.markerGroupMap = Pt()
      }),
      (t.prototype.render = function (e, n, i) {
        var a = this,
          o = this.markerGroupMap
        o.each(function (s) {
          QS(s).keep = !1
        }),
          n.eachSeries(function (s) {
            var l = hl.getMarkerModelFromSeries(s, a.type)
            l && a.renderSeries(s, l, n, i)
          }),
          o.each(function (s) {
            !QS(s).keep && a.group.remove(s.group)
          })
      }),
      (t.prototype.markKeep = function (e) {
        QS(e).keep = !0
      }),
      (t.prototype.toggleBlurSeries = function (e, n) {
        var i = this
        R(e, function (a) {
          var o = hl.getMarkerModelFromSeries(a, i.type)
          if (o) {
            var s = o.getData()
            s.eachItemGraphicEl(function (l) {
              l && (n ? fU(l) : $T(l))
            })
          }
        })
      }),
      (t.type = 'marker'),
      t
    )
  })(dn)
const LE = Mxt
function G3(r, t, e) {
  var n = t.coordinateSystem
  r.each(function (i) {
    var a = r.getItemModel(i),
      o,
      s = _t(a.get('x'), e.getWidth()),
      l = _t(a.get('y'), e.getHeight())
    if (!isNaN(s) && !isNaN(l)) o = [s, l]
    else if (t.getMarkerPosition)
      o = t.getMarkerPosition(r.getValues(r.dimensions, i))
    else if (n) {
      var u = r.get(n.dimensions[0], i),
        c = r.get(n.dimensions[1], i)
      o = n.dataToPoint([u, c])
    }
    isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), r.setItemLayout(i, o)
  })
}
var Txt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.updateTransform = function (e, n, i) {
      n.eachSeries(function (a) {
        var o = hl.getMarkerModelFromSeries(a, 'markPoint')
        o &&
          (G3(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout())
      }, this)
    }),
    (t.prototype.renderSeries = function (e, n, i, a) {
      var o = e.coordinateSystem,
        s = e.id,
        l = e.getData(),
        u = this.markerGroupMap,
        c = u.get(s) || u.set(s, new Cv()),
        h = Cxt(o, e, n)
      n.setData(h),
        G3(n.getData(), e, a),
        h.each(function (f) {
          var d = h.getItemModel(f),
            p = d.getShallow('symbol'),
            g = d.getShallow('symbolSize'),
            v = d.getShallow('symbolRotate'),
            m = d.getShallow('symbolOffset'),
            y = d.getShallow('symbolKeepAspect')
          if (Nt(p) || Nt(g) || Nt(v) || Nt(m)) {
            var _ = n.getRawValue(f),
              x = n.getDataParams(f)
            Nt(p) && (p = p(_, x)),
              Nt(g) && (g = g(_, x)),
              Nt(v) && (v = v(_, x)),
              Nt(m) && (m = m(_, x))
          }
          var A = d.getModel('itemStyle').getItemStyle(),
            S = bv(l, 'color')
          A.fill || (A.fill = S),
            h.setItemVisual(f, {
              symbol: p,
              symbolSize: g,
              symbolRotate: v,
              symbolOffset: m,
              symbolKeepAspect: y,
              style: A,
            })
        }),
        c.updateData(h),
        this.group.add(c.group),
        h.eachItemGraphicEl(function (f) {
          f.traverse(function (d) {
            Wt(d).dataModel = n
          })
        }),
        this.markKeep(c),
        (c.group.silent = n.get('silent') || e.get('silent'))
    }),
    (t.type = 'markPoint'),
    t
  )
})(LE)
function Cxt(r, t, e) {
  var n
  r
    ? (n = st(r && r.dimensions, function (s) {
        var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {}
        return Q(Q({}, l), {
          name: s,
          ordinalMeta: null,
        })
      }))
    : (n = [
        {
          name: 'value',
          type: 'float',
        },
      ])
  var i = new Vr(n, e),
    a = st(e.get('data'), Zt(lv, t))
  r && (a = Ne(a, Zt(uv, r)))
  var o = VH(!!r, n)
  return i.initData(a, null, o), i
}
const Ext = Txt
function Dxt(r) {
  r.registerComponentModel(Sxt),
    r.registerComponentView(Ext),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markPoint') && (t.markPoint = t.markPoint || {})
    })
}
var Lxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markLine'),
    (t.defaultOption = {
      z: 5,
      symbol: ['circle', 'arrow'],
      symbolSize: [8, 16],
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: 'item',
      },
      label: {
        show: !0,
        position: 'end',
        distance: 5,
      },
      lineStyle: {
        type: 'dashed',
      },
      emphasis: {
        label: {
          show: !0,
        },
        lineStyle: {
          width: 3,
        },
      },
      animationEasing: 'linear',
    }),
    t
  )
})(hl)
const Pxt = Lxt
var Em = ve(),
  Rxt = function (r, t, e, n) {
    var i = r.getData(),
      a
    if (at(n)) a = n
    else {
      var o = n.type
      if (
        o === 'min' ||
        o === 'max' ||
        o === 'average' ||
        o === 'median' ||
        n.xAxis != null ||
        n.yAxis != null
      ) {
        var s = void 0,
          l = void 0
        if (n.yAxis != null || n.xAxis != null)
          (s = t.getAxis(n.yAxis != null ? 'y' : 'x')),
            (l = nr(n.yAxis, n.xAxis))
        else {
          var u = UH(n, i, t, r)
          s = u.valueAxis
          var c = wV(i, u.valueDataDim)
          l = DE(i, c, o)
        }
        var h = s.dim === 'x' ? 0 : 1,
          f = 1 - h,
          d = Vt(n),
          p = {
            coord: [],
          }
        ;(d.type = null),
          (d.coord = []),
          (d.coord[f] = -1 / 0),
          (p.coord[f] = 1 / 0)
        var g = e.get('precision')
        g >= 0 && be(l) && (l = +l.toFixed(Math.min(g, 20))),
          (d.coord[h] = p.coord[h] = l),
          (a = [
            d,
            p,
            {
              type: o,
              valueIndex: n.valueIndex,
              value: l,
            },
          ])
      } else a = []
    }
    var v = [lv(r, a[0]), lv(r, a[1]), Q({}, a[2])]
    return (v[2].type = v[2].type || null), te(v[2], v[0]), te(v[2], v[1]), v
  }
function b0(r) {
  return !isNaN(r) && !isFinite(r)
}
function H3(r, t, e, n) {
  var i = 1 - r,
    a = n.dimensions[r]
  return b0(t[i]) && b0(e[i]) && t[r] === e[r] && n.getAxis(a).containData(t[r])
}
function Ixt(r, t) {
  if (r.type === 'cartesian2d') {
    var e = t[0].coord,
      n = t[1].coord
    if (e && n && (H3(1, e, n, r) || H3(0, e, n, r))) return !0
  }
  return uv(r, t[0]) && uv(r, t[1])
}
function tA(r, t, e, n, i) {
  var a = n.coordinateSystem,
    o = r.getItemModel(t),
    s,
    l = _t(o.get('x'), i.getWidth()),
    u = _t(o.get('y'), i.getHeight())
  if (!isNaN(l) && !isNaN(u)) s = [l, u]
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(r.getValues(r.dimensions, t))
    else {
      var c = a.dimensions,
        h = r.get(c[0], t),
        f = r.get(c[1], t)
      s = a.dataToPoint([h, f])
    }
    if (oc(a, 'cartesian2d')) {
      var d = a.getAxis('x'),
        p = a.getAxis('y'),
        c = a.dimensions
      b0(r.get(c[0], t))
        ? (s[0] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]))
        : b0(r.get(c[1], t)) &&
          (s[1] = p.toGlobalCoord(p.getExtent()[e ? 0 : 1]))
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
  }
  r.setItemLayout(t, s)
}
var Oxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.updateTransform = function (e, n, i) {
      n.eachSeries(function (a) {
        var o = hl.getMarkerModelFromSeries(a, 'markLine')
        if (o) {
          var s = o.getData(),
            l = Em(o).from,
            u = Em(o).to
          l.each(function (c) {
            tA(l, c, !0, a, i), tA(u, c, !1, a, i)
          }),
            s.each(function (c) {
              s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)])
            }),
            this.markerGroupMap.get(a.id).updateLayout()
        }
      }, this)
    }),
    (t.prototype.renderSeries = function (e, n, i, a) {
      var o = e.coordinateSystem,
        s = e.id,
        l = e.getData(),
        u = this.markerGroupMap,
        c = u.get(s) || u.set(s, new QC())
      this.group.add(c.group)
      var h = Nxt(o, e, n),
        f = h.from,
        d = h.to,
        p = h.line
      ;(Em(n).from = f), (Em(n).to = d), n.setData(p)
      var g = n.get('symbol'),
        v = n.get('symbolSize'),
        m = n.get('symbolRotate'),
        y = n.get('symbolOffset')
      at(g) || (g = [g, g]),
        at(v) || (v = [v, v]),
        at(m) || (m = [m, m]),
        at(y) || (y = [y, y]),
        h.from.each(function (x) {
          _(f, x, !0), _(d, x, !1)
        }),
        p.each(function (x) {
          var A = p.getItemModel(x).getModel('lineStyle').getLineStyle()
          p.setItemLayout(x, [f.getItemLayout(x), d.getItemLayout(x)]),
            A.stroke == null && (A.stroke = f.getItemVisual(x, 'style').fill),
            p.setItemVisual(x, {
              fromSymbolKeepAspect: f.getItemVisual(x, 'symbolKeepAspect'),
              fromSymbolOffset: f.getItemVisual(x, 'symbolOffset'),
              fromSymbolRotate: f.getItemVisual(x, 'symbolRotate'),
              fromSymbolSize: f.getItemVisual(x, 'symbolSize'),
              fromSymbol: f.getItemVisual(x, 'symbol'),
              toSymbolKeepAspect: d.getItemVisual(x, 'symbolKeepAspect'),
              toSymbolOffset: d.getItemVisual(x, 'symbolOffset'),
              toSymbolRotate: d.getItemVisual(x, 'symbolRotate'),
              toSymbolSize: d.getItemVisual(x, 'symbolSize'),
              toSymbol: d.getItemVisual(x, 'symbol'),
              style: A,
            })
        }),
        c.updateData(p),
        h.line.eachItemGraphicEl(function (x) {
          ;(Wt(x).dataModel = n),
            x.traverse(function (A) {
              Wt(A).dataModel = n
            })
        })
      function _(x, A, S) {
        var b = x.getItemModel(A)
        tA(x, A, S, e, a)
        var T = b.getModel('itemStyle').getItemStyle()
        T.fill == null && (T.fill = bv(l, 'color')),
          x.setItemVisual(A, {
            symbolKeepAspect: b.get('symbolKeepAspect'),
            symbolOffset: $t(b.get('symbolOffset', !0), y[S ? 0 : 1]),
            symbolRotate: $t(b.get('symbolRotate', !0), m[S ? 0 : 1]),
            symbolSize: $t(b.get('symbolSize'), v[S ? 0 : 1]),
            symbol: $t(b.get('symbol', !0), g[S ? 0 : 1]),
            style: T,
          })
      }
      this.markKeep(c), (c.group.silent = n.get('silent') || e.get('silent'))
    }),
    (t.type = 'markLine'),
    t
  )
})(LE)
function Nxt(r, t, e) {
  var n
  r
    ? (n = st(r && r.dimensions, function (u) {
        var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {}
        return Q(Q({}, c), {
          name: u,
          ordinalMeta: null,
        })
      }))
    : (n = [
        {
          name: 'value',
          type: 'float',
        },
      ])
  var i = new Vr(n, e),
    a = new Vr(n, e),
    o = new Vr([], e),
    s = st(e.get('data'), Zt(Rxt, t, r, e))
  r && (s = Ne(s, Zt(Ixt, r)))
  var l = VH(!!r, n)
  return (
    i.initData(
      st(s, function (u) {
        return u[0]
      }),
      null,
      l,
    ),
    a.initData(
      st(s, function (u) {
        return u[1]
      }),
      null,
      l,
    ),
    o.initData(
      st(s, function (u) {
        return u[2]
      }),
    ),
    (o.hasItemOption = !0),
    {
      from: i,
      to: a,
      line: o,
    }
  )
}
const kxt = Oxt
function Bxt(r) {
  r.registerComponentModel(Pxt),
    r.registerComponentView(kxt),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markLine') && (t.markLine = t.markLine || {})
    })
}
var Fxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.createMarkerModelFromSeries = function (e, n, i) {
      return new t(e, n, i)
    }),
    (t.type = 'markArea'),
    (t.defaultOption = {
      z: 1,
      tooltip: {
        trigger: 'item',
      },
      animation: !1,
      label: {
        show: !0,
        position: 'top',
      },
      itemStyle: {
        borderWidth: 0,
      },
      emphasis: {
        label: {
          show: !0,
          position: 'top',
        },
      },
    }),
    t
  )
})(hl)
const zxt = Fxt
var Dm = ve(),
  Uxt = function (r, t, e, n) {
    var i = n[0],
      a = n[1]
    if (!(!i || !a)) {
      var o = lv(r, i),
        s = lv(r, a),
        l = o.coord,
        u = s.coord
      ;(l[0] = nr(l[0], -1 / 0)),
        (l[1] = nr(l[1], -1 / 0)),
        (u[0] = nr(u[0], 1 / 0)),
        (u[1] = nr(u[1], 1 / 0))
      var c = ET([{}, o, s])
      return (
        (c.coord = [o.coord, s.coord]),
        (c.x0 = o.x),
        (c.y0 = o.y),
        (c.x1 = s.x),
        (c.y1 = s.y),
        c
      )
    }
  }
function w0(r) {
  return !isNaN(r) && !isFinite(r)
}
function W3(r, t, e, n) {
  var i = 1 - r
  return w0(t[i]) && w0(e[i])
}
function Vxt(r, t) {
  var e = t.coord[0],
    n = t.coord[1],
    i = {
      coord: e,
      x: t.x0,
      y: t.y0,
    },
    a = {
      coord: n,
      x: t.x1,
      y: t.y1,
    }
  return oc(r, 'cartesian2d')
    ? e && n && (W3(1, e, n) || W3(0, e, n))
      ? !0
      : wxt(r, i, a)
    : uv(r, i) || uv(r, a)
}
function X3(r, t, e, n, i) {
  var a = n.coordinateSystem,
    o = r.getItemModel(t),
    s,
    l = _t(o.get(e[0]), i.getWidth()),
    u = _t(o.get(e[1]), i.getHeight())
  if (!isNaN(l) && !isNaN(u)) s = [l, u]
  else {
    if (n.getMarkerPosition) {
      var c = r.getValues(['x0', 'y0'], t),
        h = r.getValues(['x1', 'y1'], t),
        f = a.clampData(c),
        d = a.clampData(h),
        p = []
      e[0] === 'x0'
        ? (p[0] = f[0] > d[0] ? h[0] : c[0])
        : (p[0] = f[0] > d[0] ? c[0] : h[0]),
        e[1] === 'y0'
          ? (p[1] = f[1] > d[1] ? h[1] : c[1])
          : (p[1] = f[1] > d[1] ? c[1] : h[1]),
        (s = n.getMarkerPosition(p, e, !0))
    } else {
      var g = r.get(e[0], t),
        v = r.get(e[1], t),
        m = [g, v]
      a.clampData && a.clampData(m, m), (s = a.dataToPoint(m, !0))
    }
    if (oc(a, 'cartesian2d')) {
      var y = a.getAxis('x'),
        _ = a.getAxis('y'),
        g = r.get(e[0], t),
        v = r.get(e[1], t)
      w0(g)
        ? (s[0] = y.toGlobalCoord(y.getExtent()[e[0] === 'x0' ? 0 : 1]))
        : w0(v) &&
          (s[1] = _.toGlobalCoord(_.getExtent()[e[1] === 'y0' ? 0 : 1]))
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u)
  }
  return s
}
var Y3 = [
    ['x0', 'y0'],
    ['x1', 'y0'],
    ['x1', 'y1'],
    ['x0', 'y1'],
  ],
  Gxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.updateTransform = function (e, n, i) {
        n.eachSeries(function (a) {
          var o = hl.getMarkerModelFromSeries(a, 'markArea')
          if (o) {
            var s = o.getData()
            s.each(function (l) {
              var u = st(Y3, function (h) {
                return X3(s, l, h, a, i)
              })
              s.setItemLayout(l, u)
              var c = s.getItemGraphicEl(l)
              c.setShape('points', u)
            })
          }
        }, this)
      }),
      (t.prototype.renderSeries = function (e, n, i, a) {
        var o = e.coordinateSystem,
          s = e.id,
          l = e.getData(),
          u = this.markerGroupMap,
          c =
            u.get(s) ||
            u.set(s, {
              group: new Ht(),
            })
        this.group.add(c.group), this.markKeep(c)
        var h = Hxt(o, e, n)
        n.setData(h),
          h.each(function (f) {
            var d = st(Y3, function (T) {
                return X3(h, f, T, e, a)
              }),
              p = o.getAxis('x').scale,
              g = o.getAxis('y').scale,
              v = p.getExtent(),
              m = g.getExtent(),
              y = [p.parse(h.get('x0', f)), p.parse(h.get('x1', f))],
              _ = [g.parse(h.get('y0', f)), g.parse(h.get('y1', f))]
            Zi(y), Zi(_)
            var x = !(v[0] > y[1] || v[1] < y[0] || m[0] > _[1] || m[1] < _[0]),
              A = !x
            h.setItemLayout(f, {
              points: d,
              allClipped: A,
            })
            var S = h.getItemModel(f).getModel('itemStyle').getItemStyle(),
              b = bv(l, 'color')
            S.fill || ((S.fill = b), bt(S.fill) && (S.fill = zy(S.fill, 0.4))),
              S.stroke || (S.stroke = b),
              h.setItemVisual(f, 'style', S)
          }),
          h
            .diff(Dm(c).data)
            .add(function (f) {
              var d = h.getItemLayout(f)
              if (!d.allClipped) {
                var p = new si({
                  shape: {
                    points: d.points,
                  },
                })
                h.setItemGraphicEl(f, p), c.group.add(p)
              }
            })
            .update(function (f, d) {
              var p = Dm(c).data.getItemGraphicEl(d),
                g = h.getItemLayout(f)
              g.allClipped
                ? p && c.group.remove(p)
                : (p
                    ? we(
                        p,
                        {
                          shape: {
                            points: g.points,
                          },
                        },
                        n,
                        f,
                      )
                    : (p = new si({
                        shape: {
                          points: g.points,
                        },
                      })),
                  h.setItemGraphicEl(f, p),
                  c.group.add(p))
            })
            .remove(function (f) {
              var d = Dm(c).data.getItemGraphicEl(f)
              c.group.remove(d)
            })
            .execute(),
          h.eachItemGraphicEl(function (f, d) {
            var p = h.getItemModel(d),
              g = h.getItemVisual(d, 'style')
            f.useStyle(h.getItemVisual(d, 'style')),
              mr(f, Zn(p), {
                labelFetcher: n,
                labelDataIndex: d,
                defaultText: h.getName(d) || '',
                inheritColor: bt(g.fill) ? zy(g.fill, 1) : '#000',
              }),
              gr(f, p),
              fn(f, null, null, p.get(['emphasis', 'disabled'])),
              (Wt(f).dataModel = n)
          }),
          (Dm(c).data = h),
          (c.group.silent = n.get('silent') || e.get('silent'))
      }),
      (t.type = 'markArea'),
      t
    )
  })(LE)
function Hxt(r, t, e) {
  var n,
    i,
    a = ['x0', 'y0', 'x1', 'y1']
  if (r) {
    var o = st(r && r.dimensions, function (u) {
      var c = t.getData(),
        h = c.getDimensionInfo(c.mapDimension(u)) || {}
      return Q(Q({}, h), {
        name: u,
        ordinalMeta: null,
      })
    })
    ;(i = st(a, function (u, c) {
      return {
        name: u,
        type: o[c % 2].type,
      }
    })),
      (n = new Vr(i, e))
  } else
    (i = [
      {
        name: 'value',
        type: 'float',
      },
    ]),
      (n = new Vr(i, e))
  var s = st(e.get('data'), Zt(Uxt, t, r, e))
  r && (s = Ne(s, Zt(Vxt, r)))
  var l = r
    ? function (u, c, h, f) {
        var d = u.coord[Math.floor(f / 2)][f % 2]
        return Js(d, i[f])
      }
    : function (u, c, h, f) {
        return Js(u.value, i[f])
      }
  return n.initData(s, null, l), (n.hasItemOption = !0), n
}
const Wxt = Gxt
function Xxt(r) {
  r.registerComponentModel(zxt),
    r.registerComponentView(Wxt),
    r.registerPreprocessor(function (t) {
      EE(t.series, 'markArea') && (t.markArea = t.markArea || {})
    })
}
var Yxt = function (r, t) {
    if (t === 'all')
      return {
        type: 'all',
        title: r.getLocaleModel().get(['legend', 'selector', 'all']),
      }
    if (t === 'inverse')
      return {
        type: 'inverse',
        title: r.getLocaleModel().get(['legend', 'selector', 'inverse']),
      }
  },
  $xt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i),
          (e.selected = e.selected || {}),
          this._updateSelector(e)
      }),
      (t.prototype.mergeOption = function (e, n) {
        r.prototype.mergeOption.call(this, e, n), this._updateSelector(e)
      }),
      (t.prototype._updateSelector = function (e) {
        var n = e.selector,
          i = this.ecModel
        n === !0 && (n = e.selector = ['all', 'inverse']),
          at(n) &&
            R(n, function (a, o) {
              bt(a) &&
                (a = {
                  type: a,
                }),
                (n[o] = te(a, Yxt(i, a.type)))
            })
      }),
      (t.prototype.optionUpdated = function () {
        this._updateData(this.ecModel)
        var e = this._data
        if (e[0] && this.get('selectedMode') === 'single') {
          for (var n = !1, i = 0; i < e.length; i++) {
            var a = e[i].get('name')
            if (this.isSelected(a)) {
              this.select(a), (n = !0)
              break
            }
          }
          !n && this.select(e[0].get('name'))
        }
      }),
      (t.prototype._updateData = function (e) {
        var n = [],
          i = []
        e.eachRawSeries(function (l) {
          var u = l.name
          i.push(u)
          var c
          if (l.legendVisualProvider) {
            var h = l.legendVisualProvider,
              f = h.getAllNames()
            e.isSeriesFiltered(l) || (i = i.concat(f)),
              f.length ? (n = n.concat(f)) : (c = !0)
          } else c = !0
          c && zT(l) && n.push(l.name)
        }),
          (this._availableNames = i)
        var a = this.get('data') || n,
          o = Pt(),
          s = st(
            a,
            function (l) {
              return (
                (bt(l) || be(l)) &&
                  (l = {
                    name: l,
                  }),
                o.get(l.name)
                  ? null
                  : (o.set(l.name, !0), new qe(l, this, this.ecModel))
              )
            },
            this,
          )
        this._data = Ne(s, function (l) {
          return !!l
        })
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.select = function (e) {
        var n = this.option.selected,
          i = this.get('selectedMode')
        if (i === 'single') {
          var a = this._data
          R(a, function (o) {
            n[o.get('name')] = !1
          })
        }
        n[e] = !0
      }),
      (t.prototype.unSelect = function (e) {
        this.get('selectedMode') !== 'single' && (this.option.selected[e] = !1)
      }),
      (t.prototype.toggleSelected = function (e) {
        var n = this.option.selected
        n.hasOwnProperty(e) || (n[e] = !0),
          this[n[e] ? 'unSelect' : 'select'](e)
      }),
      (t.prototype.allSelect = function () {
        var e = this._data,
          n = this.option.selected
        R(e, function (i) {
          n[i.get('name', !0)] = !0
        })
      }),
      (t.prototype.inverseSelect = function () {
        var e = this._data,
          n = this.option.selected
        R(e, function (i) {
          var a = i.get('name', !0)
          n.hasOwnProperty(a) || (n[a] = !0), (n[a] = !n[a])
        })
      }),
      (t.prototype.isSelected = function (e) {
        var n = this.option.selected
        return (
          !(n.hasOwnProperty(e) && !n[e]) && re(this._availableNames, e) >= 0
        )
      }),
      (t.prototype.getOrient = function () {
        return this.get('orient') === 'vertical'
          ? {
              index: 1,
              name: 'vertical',
            }
          : {
              index: 0,
              name: 'horizontal',
            }
      }),
      (t.type = 'legend.plain'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        z: 4,
        show: !0,
        orient: 'horizontal',
        left: 'center',
        top: 0,
        align: 'auto',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: 'inherit',
        symbolKeepAspect: !0,
        inactiveColor: '#ccc',
        inactiveBorderColor: '#ccc',
        inactiveBorderWidth: 'auto',
        itemStyle: {
          color: 'inherit',
          opacity: 'inherit',
          borderColor: 'inherit',
          borderWidth: 'auto',
          borderCap: 'inherit',
          borderJoin: 'inherit',
          borderDashOffset: 'inherit',
          borderMiterLimit: 'inherit',
        },
        lineStyle: {
          width: 'auto',
          color: 'inherit',
          inactiveColor: '#ccc',
          inactiveWidth: 2,
          opacity: 'inherit',
          type: 'inherit',
          cap: 'inherit',
          join: 'inherit',
          dashOffset: 'inherit',
          miterLimit: 'inherit',
        },
        textStyle: {
          color: '#333',
        },
        selectedMode: !0,
        selector: !1,
        selectorLabel: {
          show: !0,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: 'sans-serif',
          color: '#666',
          borderWidth: 1,
          borderColor: '#666',
        },
        emphasis: {
          selectorLabel: {
            show: !0,
            color: '#eee',
            backgroundColor: '#666',
          },
        },
        selectorPosition: 'auto',
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: !1,
        },
      }),
      t
    )
  })(xe)
const sM = $xt
var eh = Zt,
  lM = R,
  Lm = Ht,
  qxt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e.newlineDisabled = !1), e
    }
    return (
      (t.prototype.init = function () {
        this.group.add((this._contentGroup = new Lm())),
          this.group.add((this._selectorGroup = new Lm())),
          (this._isFirstRender = !0)
      }),
      (t.prototype.getContentGroup = function () {
        return this._contentGroup
      }),
      (t.prototype.getSelectorGroup = function () {
        return this._selectorGroup
      }),
      (t.prototype.render = function (e, n, i) {
        var a = this._isFirstRender
        if (
          ((this._isFirstRender = !1), this.resetInner(), !!e.get('show', !0))
        ) {
          var o = e.get('align'),
            s = e.get('orient')
          ;(!o || o === 'auto') &&
            (o =
              e.get('left') === 'right' && s === 'vertical' ? 'right' : 'left')
          var l = e.get('selector', !0),
            u = e.get('selectorPosition', !0)
          l &&
            (!u || u === 'auto') &&
            (u = s === 'horizontal' ? 'end' : 'start'),
            this.renderInner(o, e, n, i, l, s, u)
          var c = e.getBoxLayoutParams(),
            h = {
              width: i.getWidth(),
              height: i.getHeight(),
            },
            f = e.get('padding'),
            d = Vn(c, h, f),
            p = this.layoutInner(e, o, d, a, l, u),
            g = Vn(
              zt(
                {
                  width: p.width,
                  height: p.height,
                },
                c,
              ),
              h,
              f,
            )
          ;(this.group.x = g.x - p.x),
            (this.group.y = g.y - p.y),
            this.group.markRedraw(),
            this.group.add((this._backgroundEl = DH(p, e)))
        }
      }),
      (t.prototype.resetInner = function () {
        this.getContentGroup().removeAll(),
          this._backgroundEl && this.group.remove(this._backgroundEl),
          this.getSelectorGroup().removeAll()
      }),
      (t.prototype.renderInner = function (e, n, i, a, o, s, l) {
        var u = this.getContentGroup(),
          c = Pt(),
          h = n.get('selectedMode'),
          f = []
        i.eachRawSeries(function (d) {
          !d.get('legendHoverLink') && f.push(d.id)
        }),
          lM(
            n.getData(),
            function (d, p) {
              var g = d.get('name')
              if (
                !this.newlineDisabled &&
                (g === '' ||
                  g ===
                    `
`)
              ) {
                var v = new Lm()
                ;(v.newline = !0), u.add(v)
                return
              }
              var m = i.getSeriesByName(g)[0]
              if (!c.get(g))
                if (m) {
                  var y = m.getData(),
                    _ = y.getVisual('legendLineStyle') || {},
                    x = y.getVisual('legendIcon'),
                    A = y.getVisual('style'),
                    S = this._createItem(m, g, p, d, n, e, _, A, x, h, a)
                  S.on('click', eh($3, g, null, a, f))
                    .on('mouseover', eh(uM, m.name, null, a, f))
                    .on('mouseout', eh(cM, m.name, null, a, f)),
                    i.ssr &&
                      S.eachChild(function (b) {
                        var T = Wt(b)
                        ;(T.seriesIndex = m.seriesIndex),
                          (T.dataIndex = p),
                          (T.ssrType = 'legend')
                      }),
                    c.set(g, !0)
                } else
                  i.eachRawSeries(function (b) {
                    if (!c.get(g) && b.legendVisualProvider) {
                      var T = b.legendVisualProvider
                      if (!T.containName(g)) return
                      var w = T.indexOfName(g),
                        M = T.getItemVisual(w, 'style'),
                        C = T.getItemVisual(w, 'legendIcon'),
                        E = wi(M.fill)
                      E &&
                        E[3] === 0 &&
                        ((E[3] = 0.2),
                        (M = Q(Q({}, M), {
                          fill: Wo(E, 'rgba'),
                        })))
                      var D = this._createItem(b, g, p, d, n, e, {}, M, C, h, a)
                      D.on('click', eh($3, null, g, a, f))
                        .on('mouseover', eh(uM, null, g, a, f))
                        .on('mouseout', eh(cM, null, g, a, f)),
                        i.ssr &&
                          D.eachChild(function (P) {
                            var L = Wt(P)
                            ;(L.seriesIndex = b.seriesIndex),
                              (L.dataIndex = p),
                              (L.ssrType = 'legend')
                          }),
                        c.set(g, !0)
                    }
                  }, this)
            },
            this,
          ),
          o && this._createSelector(o, n, a, s, l)
      }),
      (t.prototype._createSelector = function (e, n, i, a, o) {
        var s = this.getSelectorGroup()
        lM(e, function (u) {
          var c = u.type,
            h = new Ae({
              style: {
                x: 0,
                y: 0,
                align: 'center',
                verticalAlign: 'middle',
              },
              onclick: function () {
                i.dispatchAction({
                  type: c === 'all' ? 'legendAllSelect' : 'legendInverseSelect',
                })
              },
            })
          s.add(h)
          var f = n.getModel('selectorLabel'),
            d = n.getModel(['emphasis', 'selectorLabel'])
          mr(
            h,
            {
              normal: f,
              emphasis: d,
            },
            {
              defaultText: u.title,
            },
          ),
            Ou(h)
        })
      }),
      (t.prototype._createItem = function (e, n, i, a, o, s, l, u, c, h, f) {
        var d = e.visualDrawType,
          p = o.get('itemWidth'),
          g = o.get('itemHeight'),
          v = o.isSelected(n),
          m = a.get('symbolRotate'),
          y = a.get('symbolKeepAspect'),
          _ = a.get('icon')
        c = _ || c || 'roundRect'
        var x = Zxt(c, a, l, u, d, v, f),
          A = new Lm(),
          S = a.getModel('textStyle')
        if (Nt(e.getLegendIcon) && (!_ || _ === 'inherit'))
          A.add(
            e.getLegendIcon({
              itemWidth: p,
              itemHeight: g,
              icon: c,
              iconRotate: m,
              itemStyle: x.itemStyle,
              lineStyle: x.lineStyle,
              symbolKeepAspect: y,
            }),
          )
        else {
          var b =
            _ === 'inherit' && e.getData().getVisual('symbol')
              ? m === 'inherit'
                ? e.getData().getVisual('symbolRotate')
                : m
              : 0
          A.add(
            Kxt({
              itemWidth: p,
              itemHeight: g,
              icon: c,
              iconRotate: b,
              itemStyle: x.itemStyle,
              lineStyle: x.lineStyle,
              symbolKeepAspect: y,
            }),
          )
        }
        var T = s === 'left' ? p + 5 : -5,
          w = s,
          M = o.get('formatter'),
          C = n
        bt(M) && M ? (C = M.replace('{name}', n ?? '')) : Nt(M) && (C = M(n))
        var E = v ? S.getTextColor() : a.get('inactiveColor')
        A.add(
          new Ae({
            style: $e(
              S,
              {
                text: C,
                x: T,
                y: g / 2,
                fill: E,
                align: w,
                verticalAlign: 'middle',
              },
              {
                inheritColor: E,
              },
            ),
          }),
        )
        var D = new ge({
            shape: A.getBoundingRect(),
            style: {
              fill: 'transparent',
            },
          }),
          P = a.getModel('tooltip')
        return (
          P.get('show') &&
            Sf({
              el: D,
              componentModel: o,
              itemName: n,
              itemTooltipOption: P.option,
            }),
          A.add(D),
          A.eachChild(function (L) {
            L.silent = !0
          }),
          (D.silent = !h),
          this.getContentGroup().add(A),
          Ou(A),
          (A.__legendDataIndex = i),
          A
        )
      }),
      (t.prototype.layoutInner = function (e, n, i, a, o, s) {
        var l = this.getContentGroup(),
          u = this.getSelectorGroup()
        ku(e.get('orient'), l, e.get('itemGap'), i.width, i.height)
        var c = l.getBoundingRect(),
          h = [-c.x, -c.y]
        if ((u.markRedraw(), l.markRedraw(), o)) {
          ku('horizontal', u, e.get('selectorItemGap', !0))
          var f = u.getBoundingRect(),
            d = [-f.x, -f.y],
            p = e.get('selectorButtonGap', !0),
            g = e.getOrient().index,
            v = g === 0 ? 'width' : 'height',
            m = g === 0 ? 'height' : 'width',
            y = g === 0 ? 'y' : 'x'
          s === 'end' ? (d[g] += c[v] + p) : (h[g] += f[v] + p),
            (d[1 - g] += c[m] / 2 - f[m] / 2),
            (u.x = d[0]),
            (u.y = d[1]),
            (l.x = h[0]),
            (l.y = h[1])
          var _ = {
            x: 0,
            y: 0,
          }
          return (
            (_[v] = c[v] + p + f[v]),
            (_[m] = Math.max(c[m], f[m])),
            (_[y] = Math.min(0, f[y] + d[1 - g])),
            _
          )
        } else return (l.x = h[0]), (l.y = h[1]), this.group.getBoundingRect()
      }),
      (t.prototype.remove = function () {
        this.getContentGroup().removeAll(), (this._isFirstRender = !0)
      }),
      (t.type = 'legend.plain'),
      t
    )
  })(dn)
function Zxt(r, t, e, n, i, a, o) {
  function s(v, m) {
    v.lineWidth === 'auto' && (v.lineWidth = m.lineWidth > 0 ? 2 : 0),
      lM(v, function (y, _) {
        v[_] === 'inherit' && (v[_] = m[_])
      })
  }
  var l = t.getModel('itemStyle'),
    u = l.getItemStyle(),
    c = r.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke',
    h = l.getShallow('decal')
  ;(u.decal = !h || h === 'inherit' ? n.decal : rf(h, o)),
    u.fill === 'inherit' && (u.fill = n[i]),
    u.stroke === 'inherit' && (u.stroke = n[c]),
    u.opacity === 'inherit' && (u.opacity = (i === 'fill' ? n : e).opacity),
    s(u, n)
  var f = t.getModel('lineStyle'),
    d = f.getLineStyle()
  if (
    (s(d, e),
    u.fill === 'auto' && (u.fill = n.fill),
    u.stroke === 'auto' && (u.stroke = n.fill),
    d.stroke === 'auto' && (d.stroke = n.fill),
    !a)
  ) {
    var p = t.get('inactiveBorderWidth'),
      g = u[c]
    ;(u.lineWidth =
      p === 'auto' ? (n.lineWidth > 0 && g ? 2 : 0) : u.lineWidth),
      (u.fill = t.get('inactiveColor')),
      (u.stroke = t.get('inactiveBorderColor')),
      (d.stroke = f.get('inactiveColor')),
      (d.lineWidth = f.get('inactiveWidth'))
  }
  return {
    itemStyle: u,
    lineStyle: d,
  }
}
function Kxt(r) {
  var t = r.icon || 'roundRect',
    e = Rn(
      t,
      0,
      0,
      r.itemWidth,
      r.itemHeight,
      r.itemStyle.fill,
      r.symbolKeepAspect,
    )
  return (
    e.setStyle(r.itemStyle),
    (e.rotation = ((r.iconRotate || 0) * Math.PI) / 180),
    e.setOrigin([r.itemWidth / 2, r.itemHeight / 2]),
    t.indexOf('empty') > -1 &&
      ((e.style.stroke = e.style.fill),
      (e.style.fill = '#fff'),
      (e.style.lineWidth = 2)),
    e
  )
}
function $3(r, t, e, n) {
  cM(r, t, e, n),
    e.dispatchAction({
      type: 'legendToggleSelect',
      name: r ?? t,
    }),
    uM(r, t, e, n)
}
function GH(r) {
  for (
    var t = r.getZr().storage.getDisplayList(), e, n = 0, i = t.length;
    n < i && !(e = t[n].states.emphasis);

  )
    n++
  return e && e.hoverLayer
}
function uM(r, t, e, n) {
  GH(e) ||
    e.dispatchAction({
      type: 'highlight',
      seriesName: r,
      name: t,
      excludeSeriesId: n,
    })
}
function cM(r, t, e, n) {
  GH(e) ||
    e.dispatchAction({
      type: 'downplay',
      seriesName: r,
      name: t,
      excludeSeriesId: n,
    })
}
const HH = qxt
function jxt(r) {
  var t = r.findComponents({
    mainType: 'legend',
  })
  t &&
    t.length &&
    r.filterSeries(function (e) {
      for (var n = 0; n < t.length; n++) if (!t[n].isSelected(e.name)) return !1
      return !0
    })
}
function Sd(r, t, e) {
  var n = {},
    i = r === 'toggleSelected',
    a
  return (
    e.eachComponent('legend', function (o) {
      i && a != null
        ? o[a ? 'select' : 'unSelect'](t.name)
        : r === 'allSelect' || r === 'inverseSelect'
        ? o[r]()
        : (o[r](t.name), (a = o.isSelected(t.name)))
      var s = o.getData()
      R(s, function (l) {
        var u = l.get('name')
        if (
          !(
            u ===
              `
` || u === ''
          )
        ) {
          var c = o.isSelected(u)
          n.hasOwnProperty(u) ? (n[u] = n[u] && c) : (n[u] = c)
        }
      })
    }),
    r === 'allSelect' || r === 'inverseSelect'
      ? {
          selected: n,
        }
      : {
          name: t.name,
          selected: n,
        }
  )
}
function Jxt(r) {
  r.registerAction(
    'legendToggleSelect',
    'legendselectchanged',
    Zt(Sd, 'toggleSelected'),
  ),
    r.registerAction('legendAllSelect', 'legendselectall', Zt(Sd, 'allSelect')),
    r.registerAction(
      'legendInverseSelect',
      'legendinverseselect',
      Zt(Sd, 'inverseSelect'),
    ),
    r.registerAction('legendSelect', 'legendselected', Zt(Sd, 'select')),
    r.registerAction('legendUnSelect', 'legendunselected', Zt(Sd, 'unSelect'))
}
function WH(r) {
  r.registerComponentModel(sM),
    r.registerComponentView(HH),
    r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, jxt),
    r.registerSubTypeDefaulter('legend', function () {
      return 'plain'
    }),
    Jxt(r)
}
var Qxt = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.setScrollDataIndex = function (e) {
      this.option.scrollDataIndex = e
    }),
    (t.prototype.init = function (e, n, i) {
      var a = Mf(e)
      r.prototype.init.call(this, e, n, i), q3(this, e, a)
    }),
    (t.prototype.mergeOption = function (e, n) {
      r.prototype.mergeOption.call(this, e, n), q3(this, this.option, e)
    }),
    (t.type = 'legend.scroll'),
    (t.defaultOption = gl(sM.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: 'end',
      pageFormatter: '{current}/{total}',
      pageIcons: {
        horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
        vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z'],
      },
      pageIconColor: '#2f4554',
      pageIconInactiveColor: '#aaa',
      pageIconSize: 15,
      pageTextStyle: {
        color: '#333',
      },
      animationDurationUpdate: 800,
    })),
    t
  )
})(sM)
function q3(r, t, e) {
  var n = r.getOrient(),
    i = [1, 1]
  ;(i[n.index] = 0),
    ol(t, e, {
      type: 'box',
      ignoreSize: !!i,
    })
}
const t1t = Qxt
var Z3 = Ht,
  eA = ['width', 'height'],
  nA = ['x', 'y'],
  e1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type), (e.newlineDisabled = !0), (e._currentIndex = 0), e
      )
    }
    return (
      (t.prototype.init = function () {
        r.prototype.init.call(this),
          this.group.add((this._containerGroup = new Z3())),
          this._containerGroup.add(this.getContentGroup()),
          this.group.add((this._controllerGroup = new Z3()))
      }),
      (t.prototype.resetInner = function () {
        r.prototype.resetInner.call(this),
          this._controllerGroup.removeAll(),
          this._containerGroup.removeClipPath(),
          (this._containerGroup.__rectSize = null)
      }),
      (t.prototype.renderInner = function (e, n, i, a, o, s, l) {
        var u = this
        r.prototype.renderInner.call(this, e, n, i, a, o, s, l)
        var c = this._controllerGroup,
          h = n.get('pageIconSize', !0),
          f = at(h) ? h : [h, h]
        p('pagePrev', 0)
        var d = n.getModel('pageTextStyle')
        c.add(
          new Ae({
            name: 'pageText',
            style: {
              text: 'xx/xx',
              fill: d.getTextColor(),
              font: d.getFont(),
              verticalAlign: 'middle',
              align: 'center',
            },
            silent: !0,
          }),
        ),
          p('pageNext', 1)
        function p(g, v) {
          var m = g + 'DataIndex',
            y = Sv(
              n.get('pageIcons', !0)[n.getOrient().name][v],
              {
                onclick: Tt(u._pageGo, u, m, n, a),
              },
              {
                x: -f[0] / 2,
                y: -f[1] / 2,
                width: f[0],
                height: f[1],
              },
            )
          ;(y.name = g), c.add(y)
        }
      }),
      (t.prototype.layoutInner = function (e, n, i, a, o, s) {
        var l = this.getSelectorGroup(),
          u = e.getOrient().index,
          c = eA[u],
          h = nA[u],
          f = eA[1 - u],
          d = nA[1 - u]
        o && ku('horizontal', l, e.get('selectorItemGap', !0))
        var p = e.get('selectorButtonGap', !0),
          g = l.getBoundingRect(),
          v = [-g.x, -g.y],
          m = Vt(i)
        o && (m[c] = i[c] - g[c] - p)
        var y = this._layoutContentAndController(e, a, m, u, c, f, d, h)
        if (o) {
          if (s === 'end') v[u] += y[c] + p
          else {
            var _ = g[c] + p
            ;(v[u] -= _), (y[h] -= _)
          }
          ;(y[c] += g[c] + p),
            (v[1 - u] += y[d] + y[f] / 2 - g[f] / 2),
            (y[f] = Math.max(y[f], g[f])),
            (y[d] = Math.min(y[d], g[d] + v[1 - u])),
            (l.x = v[0]),
            (l.y = v[1]),
            l.markRedraw()
        }
        return y
      }),
      (t.prototype._layoutContentAndController = function (
        e,
        n,
        i,
        a,
        o,
        s,
        l,
        u,
      ) {
        var c = this.getContentGroup(),
          h = this._containerGroup,
          f = this._controllerGroup
        ku(
          e.get('orient'),
          c,
          e.get('itemGap'),
          a ? i.width : null,
          a ? null : i.height,
        ),
          ku('horizontal', f, e.get('pageButtonItemGap', !0))
        var d = c.getBoundingRect(),
          p = f.getBoundingRect(),
          g = (this._showController = d[o] > i[o]),
          v = [-d.x, -d.y]
        n || (v[a] = c[u])
        var m = [0, 0],
          y = [-p.x, -p.y],
          _ = $t(e.get('pageButtonGap', !0), e.get('itemGap', !0))
        if (g) {
          var x = e.get('pageButtonPosition', !0)
          x === 'end' ? (y[a] += i[o] - p[o]) : (m[a] += p[o] + _)
        }
        ;(y[1 - a] += d[s] / 2 - p[s] / 2),
          c.setPosition(v),
          h.setPosition(m),
          f.setPosition(y)
        var A = {
          x: 0,
          y: 0,
        }
        if (
          ((A[o] = g ? i[o] : d[o]),
          (A[s] = Math.max(d[s], p[s])),
          (A[l] = Math.min(0, p[l] + y[1 - a])),
          (h.__rectSize = i[o]),
          g)
        ) {
          var S = {
            x: 0,
            y: 0,
          }
          ;(S[o] = Math.max(i[o] - p[o] - _, 0)),
            (S[s] = A[s]),
            h.setClipPath(
              new ge({
                shape: S,
              }),
            ),
            (h.__rectSize = S[o])
        } else
          f.eachChild(function (T) {
            T.attr({
              invisible: !0,
              silent: !0,
            })
          })
        var b = this._getPageInfo(e)
        return (
          b.pageIndex != null &&
            we(
              c,
              {
                x: b.contentPosition[0],
                y: b.contentPosition[1],
              },
              g ? e : null,
            ),
          this._updatePageInfoView(e, b),
          A
        )
      }),
      (t.prototype._pageGo = function (e, n, i) {
        var a = this._getPageInfo(n)[e]
        a != null &&
          i.dispatchAction({
            type: 'legendScroll',
            scrollDataIndex: a,
            legendId: n.id,
          })
      }),
      (t.prototype._updatePageInfoView = function (e, n) {
        var i = this._controllerGroup
        R(['pagePrev', 'pageNext'], function (c) {
          var h = c + 'DataIndex',
            f = n[h] != null,
            d = i.childOfName(c)
          d &&
            (d.setStyle(
              'fill',
              f
                ? e.get('pageIconColor', !0)
                : e.get('pageIconInactiveColor', !0),
            ),
            (d.cursor = f ? 'pointer' : 'default'))
        })
        var a = i.childOfName('pageText'),
          o = e.get('pageFormatter'),
          s = n.pageIndex,
          l = s != null ? s + 1 : 0,
          u = n.pageCount
        a &&
          o &&
          a.setStyle(
            'text',
            bt(o)
              ? o
                  .replace('{current}', l == null ? '' : l + '')
                  .replace('{total}', u == null ? '' : u + '')
              : o({
                  current: l,
                  total: u,
                }),
          )
      }),
      (t.prototype._getPageInfo = function (e) {
        var n = e.get('scrollDataIndex', !0),
          i = this.getContentGroup(),
          a = this._containerGroup.__rectSize,
          o = e.getOrient().index,
          s = eA[o],
          l = nA[o],
          u = this._findTargetItemIndex(n),
          c = i.children(),
          h = c[u],
          f = c.length,
          d = f ? 1 : 0,
          p = {
            contentPosition: [i.x, i.y],
            pageCount: d,
            pageIndex: d - 1,
            pagePrevDataIndex: null,
            pageNextDataIndex: null,
          }
        if (!h) return p
        var g = x(h)
        p.contentPosition[o] = -g.s
        for (var v = u + 1, m = g, y = g, _ = null; v <= f; ++v)
          (_ = x(c[v])),
            ((!_ && y.e > m.s + a) || (_ && !A(_, m.s))) &&
              (y.i > m.i ? (m = y) : (m = _),
              m &&
                (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i),
                ++p.pageCount)),
            (y = _)
        for (var v = u - 1, m = g, y = g, _ = null; v >= -1; --v)
          (_ = x(c[v])),
            (!_ || !A(y, _.s)) &&
              m.i < y.i &&
              ((y = m),
              p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i),
              ++p.pageCount,
              ++p.pageIndex),
            (m = _)
        return p
        function x(S) {
          if (S) {
            var b = S.getBoundingRect(),
              T = b[l] + S[l]
            return {
              s: T,
              e: T + b[s],
              i: S.__legendDataIndex,
            }
          }
        }
        function A(S, b) {
          return S.e >= b && S.s <= b + a
        }
      }),
      (t.prototype._findTargetItemIndex = function (e) {
        if (!this._showController) return 0
        var n,
          i = this.getContentGroup(),
          a
        return (
          i.eachChild(function (o, s) {
            var l = o.__legendDataIndex
            a == null && l != null && (a = s), l === e && (n = s)
          }),
          n ?? a
        )
      }),
      (t.type = 'legend.scroll'),
      t
    )
  })(HH)
const n1t = e1t
function r1t(r) {
  r.registerAction('legendScroll', 'legendscroll', function (t, e) {
    var n = t.scrollDataIndex
    n != null &&
      e.eachComponent(
        {
          mainType: 'legend',
          subType: 'scroll',
          query: t,
        },
        function (i) {
          i.setScrollDataIndex(n)
        },
      )
  })
}
function i1t(r) {
  ie(WH), r.registerComponentModel(t1t), r.registerComponentView(n1t), r1t(r)
}
function a1t(r) {
  ie(WH), ie(i1t)
}
var o1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'dataZoom.inside'),
    (t.defaultOption = gl(sv.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0,
    })),
    t
  )
})(sv)
const s1t = o1t
var PE = ve()
function l1t(r, t, e) {
  PE(r).coordSysRecordMap.each(function (n) {
    var i = n.dataZoomInfoMap.get(t.uid)
    i && (i.getRange = e)
  })
}
function u1t(r, t) {
  for (
    var e = PE(r).coordSysRecordMap, n = e.keys(), i = 0;
    i < n.length;
    i++
  ) {
    var a = n[i],
      o = e.get(a),
      s = o.dataZoomInfoMap
    if (s) {
      var l = t.uid,
        u = s.get(l)
      u && (s.removeKey(l), s.keys().length || XH(e, o))
    }
  }
}
function XH(r, t) {
  if (t) {
    r.removeKey(t.model.uid)
    var e = t.controller
    e && e.dispose()
  }
}
function c1t(r, t) {
  var e = {
      model: t,
      containsPoint: Zt(f1t, t),
      dispatchAction: Zt(h1t, r),
      dataZoomInfoMap: null,
      controller: null,
    },
    n = (e.controller = new Rv(r.getZr()))
  return (
    R(['pan', 'zoom', 'scrollMove'], function (i) {
      n.on(i, function (a) {
        var o = []
        e.dataZoomInfoMap.each(function (s) {
          if (a.isAvailableBehavior(s.model.option)) {
            var l = (s.getRange || {})[i],
              u =
                l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a)
            !s.model.get('disabled', !0) &&
              u &&
              o.push({
                dataZoomId: s.model.id,
                start: u[0],
                end: u[1],
              })
          }
        }),
          o.length && e.dispatchAction(o)
      })
    }),
    e
  )
}
function h1t(r, t) {
  r.isDisposed() ||
    r.dispatchAction({
      type: 'dataZoom',
      animation: {
        easing: 'cubicOut',
        duration: 100,
      },
      batch: t,
    })
}
function f1t(r, t, e, n) {
  return r.coordinateSystem.containPoint([e, n])
}
function d1t(r) {
  var t,
    e = 'type_',
    n = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1,
    },
    i = !0
  return (
    r.each(function (a) {
      var o = a.model,
        s = o.get('disabled', !0) ? !1 : o.get('zoomLock', !0) ? 'move' : !0
      n[e + s] > n[e + t] && (t = s),
        (i = i && o.get('preventDefaultMouseMove', !0))
    }),
    {
      controlType: t,
      opt: {
        zoomOnMouseWheel: !0,
        moveOnMouseMove: !0,
        moveOnMouseWheel: !0,
        preventDefaultMouseMove: !!i,
      },
    }
  )
}
function p1t(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function (t, e) {
    var n = PE(e),
      i = n.coordSysRecordMap || (n.coordSysRecordMap = Pt())
    i.each(function (a) {
      a.dataZoomInfoMap = null
    }),
      t.eachComponent(
        {
          mainType: 'dataZoom',
          subType: 'inside',
        },
        function (a) {
          var o = TH(a)
          R(o.infoList, function (s) {
            var l = s.model.uid,
              u = i.get(l) || i.set(l, c1t(e, s.model)),
              c = u.dataZoomInfoMap || (u.dataZoomInfoMap = Pt())
            c.set(a.uid, {
              dzReferCoordSysInfo: s,
              model: a,
              getRange: null,
            })
          })
        },
      ),
      i.each(function (a) {
        var o = a.controller,
          s,
          l = a.dataZoomInfoMap
        if (l) {
          var u = l.keys()[0]
          u != null && (s = l.get(u))
        }
        if (!s) {
          XH(i, a)
          return
        }
        var c = d1t(l)
        o.enable(c.controlType, c.opt),
          o.setPointerChecker(a.containsPoint),
          Df(a, 'dispatchAction', s.model.get('throttle', !0), 'fixRate')
      })
  })
}
var v1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataZoom.inside'), e
    }
    return (
      (t.prototype.render = function (e, n, i) {
        if ((r.prototype.render.apply(this, arguments), e.noTarget())) {
          this._clear()
          return
        }
        ;(this.range = e.getPercentRange()),
          l1t(i, e, {
            pan: Tt(rA.pan, this),
            zoom: Tt(rA.zoom, this),
            scrollMove: Tt(rA.scrollMove, this),
          })
      }),
      (t.prototype.dispose = function () {
        this._clear(), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        u1t(this.api, this.dataZoomModel), (this.range = null)
      }),
      (t.type = 'dataZoom.inside'),
      t
    )
  })(AE),
  rA = {
    zoom: function (r, t, e, n) {
      var i = this.range,
        a = i.slice(),
        o = r.axisModels[0]
      if (o) {
        var s = iA[t](null, [n.originX, n.originY], o, e, r),
          l =
            ((s.signal > 0
              ? s.pixelStart + s.pixelLength - s.pixel
              : s.pixel - s.pixelStart) /
              s.pixelLength) *
              (a[1] - a[0]) +
            a[0],
          u = Math.max(1 / n.scale, 0)
        ;(a[0] = (a[0] - l) * u + l), (a[1] = (a[1] - l) * u + l)
        var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan()
        if (
          (lc(0, a, [0, 100], 0, c.minSpan, c.maxSpan),
          (this.range = a),
          i[0] !== a[0] || i[1] !== a[1])
        )
          return a
      }
    },
    pan: K3(function (r, t, e, n, i, a) {
      var o = iA[n]([a.oldX, a.oldY], [a.newX, a.newY], t, i, e)
      return (o.signal * (r[1] - r[0]) * o.pixel) / o.pixelLength
    }),
    scrollMove: K3(function (r, t, e, n, i, a) {
      var o = iA[n]([0, 0], [a.scrollDelta, a.scrollDelta], t, i, e)
      return o.signal * (r[1] - r[0]) * a.scrollDelta
    }),
  }
function K3(r) {
  return function (t, e, n, i) {
    var a = this.range,
      o = a.slice(),
      s = t.axisModels[0]
    if (s) {
      var l = r(o, s, t, e, n, i)
      if (
        (lc(l, o, [0, 100], 'all'),
        (this.range = o),
        a[0] !== o[0] || a[1] !== o[1])
      )
        return o
    }
  }
}
var iA = {
  grid: function (r, t, e, n, i) {
    var a = e.axis,
      o = {},
      s = i.model.coordinateSystem.getRect()
    return (
      (r = r || [0, 0]),
      a.dim === 'x'
        ? ((o.pixel = t[0] - r[0]),
          (o.pixelLength = s.width),
          (o.pixelStart = s.x),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - r[1]),
          (o.pixelLength = s.height),
          (o.pixelStart = s.y),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  polar: function (r, t, e, n, i) {
    var a = e.axis,
      o = {},
      s = i.model.coordinateSystem,
      l = s.getRadiusAxis().getExtent(),
      u = s.getAngleAxis().getExtent()
    return (
      (r = r ? s.pointToCoord(r) : [0, 0]),
      (t = s.pointToCoord(t)),
      e.mainType === 'radiusAxis'
        ? ((o.pixel = t[0] - r[0]),
          (o.pixelLength = l[1] - l[0]),
          (o.pixelStart = l[0]),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - r[1]),
          (o.pixelLength = u[1] - u[0]),
          (o.pixelStart = u[0]),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  singleAxis: function (r, t, e, n, i) {
    var a = e.axis,
      o = i.model.coordinateSystem.getRect(),
      s = {}
    return (
      (r = r || [0, 0]),
      a.orient === 'horizontal'
        ? ((s.pixel = t[0] - r[0]),
          (s.pixelLength = o.width),
          (s.pixelStart = o.x),
          (s.signal = a.inverse ? 1 : -1))
        : ((s.pixel = t[1] - r[1]),
          (s.pixelLength = o.height),
          (s.pixelStart = o.y),
          (s.signal = a.inverse ? -1 : 1)),
      s
    )
  },
}
const g1t = v1t
function YH(r) {
  bE(r), r.registerComponentModel(s1t), r.registerComponentView(g1t), p1t(r)
}
var m1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.type = 'dataZoom.slider'),
    (t.layoutMode = 'box'),
    (t.defaultOption = gl(sv.defaultOption, {
      show: !0,
      right: 'ph',
      top: 'ph',
      width: 'ph',
      height: 'ph',
      left: null,
      bottom: null,
      borderColor: '#d2dbee',
      borderRadius: 3,
      backgroundColor: 'rgba(47,69,84,0)',
      dataBackground: {
        lineStyle: {
          color: '#d2dbee',
          width: 0.5,
        },
        areaStyle: {
          color: '#d2dbee',
          opacity: 0.2,
        },
      },
      selectedDataBackground: {
        lineStyle: {
          color: '#8fb0f7',
          width: 0.5,
        },
        areaStyle: {
          color: '#8fb0f7',
          opacity: 0.2,
        },
      },
      fillerColor: 'rgba(135,175,274,0.2)',
      handleIcon:
        'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
      handleSize: '100%',
      handleStyle: {
        color: '#fff',
        borderColor: '#ACB8D1',
      },
      moveHandleSize: 7,
      moveHandleIcon:
        'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
      moveHandleStyle: {
        color: '#D2DBEE',
        opacity: 0.7,
      },
      showDetail: !0,
      showDataShadow: 'auto',
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: '#6E7079',
      },
      brushSelect: !0,
      brushStyle: {
        color: 'rgba(135,175,274,0.15)',
      },
      emphasis: {
        handleStyle: {
          borderColor: '#8FB0F7',
        },
        moveHandleStyle: {
          color: '#8FB0F7',
        },
      },
    })),
    t
  )
})(sv)
const y1t = m1t
var Ad = ge,
  j3 = 7,
  _1t = 1,
  aA = 30,
  x1t = 7,
  bd = 'horizontal',
  J3 = 'vertical',
  S1t = 5,
  A1t = ['line', 'bar', 'candlestick', 'scatter'],
  b1t = {
    easing: 'cubicOut',
    duration: 100,
    delay: 0,
  },
  w1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._displayables = {}), e
    }
    return (
      (t.prototype.init = function (e, n) {
        ;(this.api = n),
          (this._onBrush = Tt(this._onBrush, this)),
          (this._onBrushEnd = Tt(this._onBrushEnd, this))
      }),
      (t.prototype.render = function (e, n, i, a) {
        if (
          (r.prototype.render.apply(this, arguments),
          Df(this, '_dispatchZoomAction', e.get('throttle'), 'fixRate'),
          (this._orient = e.getOrient()),
          e.get('show') === !1)
        ) {
          this.group.removeAll()
          return
        }
        if (e.noTarget()) {
          this._clear(), this.group.removeAll()
          return
        }
        ;(!a || a.type !== 'dataZoom' || a.from !== this.uid) &&
          this._buildView(),
          this._updateView()
      }),
      (t.prototype.dispose = function () {
        this._clear(), r.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        Zp(this, '_dispatchZoomAction')
        var e = this.api.getZr()
        e.off('mousemove', this._onBrush), e.off('mouseup', this._onBrushEnd)
      }),
      (t.prototype._buildView = function () {
        var e = this.group
        e.removeAll(),
          (this._brushing = !1),
          (this._displayables.brushRect = null),
          this._resetLocation(),
          this._resetInterval()
        var n = (this._displayables.sliderGroup = new Ht())
        this._renderBackground(),
          this._renderHandle(),
          this._renderDataShadow(),
          e.add(n),
          this._positionGroup()
      }),
      (t.prototype._resetLocation = function () {
        var e = this.dataZoomModel,
          n = this.api,
          i = e.get('brushSelect'),
          a = i ? x1t : 0,
          o = this._findCoordRect(),
          s = {
            width: n.getWidth(),
            height: n.getHeight(),
          },
          l =
            this._orient === bd
              ? {
                  right: s.width - o.x - o.width,
                  top: s.height - aA - j3 - a,
                  width: o.width,
                  height: aA,
                }
              : {
                  right: j3,
                  top: o.y,
                  width: aA,
                  height: o.height,
                },
          u = Mf(e.option)
        R(['right', 'top', 'width', 'height'], function (h) {
          u[h] === 'ph' && (u[h] = l[h])
        })
        var c = Vn(u, s)
        ;(this._location = {
          x: c.x,
          y: c.y,
        }),
          (this._size = [c.width, c.height]),
          this._orient === J3 && this._size.reverse()
      }),
      (t.prototype._positionGroup = function () {
        var e = this.group,
          n = this._location,
          i = this._orient,
          a = this.dataZoomModel.getFirstTargetAxisModel(),
          o = a && a.get('inverse'),
          s = this._displayables.sliderGroup,
          l = (this._dataShadowInfo || {}).otherAxisInverse
        s.attr(
          i === bd && !o
            ? {
                scaleY: l ? 1 : -1,
                scaleX: 1,
              }
            : i === bd && o
            ? {
                scaleY: l ? 1 : -1,
                scaleX: -1,
              }
            : i === J3 && !o
            ? {
                scaleY: l ? -1 : 1,
                scaleX: 1,
                rotation: Math.PI / 2,
              }
            : {
                scaleY: l ? -1 : 1,
                scaleX: -1,
                rotation: Math.PI / 2,
              },
        )
        var u = e.getBoundingRect([s])
        ;(e.x = n.x - u.x), (e.y = n.y - u.y), e.markRedraw()
      }),
      (t.prototype._getViewExtent = function () {
        return [0, this._size[0]]
      }),
      (t.prototype._renderBackground = function () {
        var e = this.dataZoomModel,
          n = this._size,
          i = this._displayables.sliderGroup,
          a = e.get('brushSelect')
        i.add(
          new Ad({
            silent: !0,
            shape: {
              x: 0,
              y: 0,
              width: n[0],
              height: n[1],
            },
            style: {
              fill: e.get('backgroundColor'),
            },
            z2: -40,
          }),
        )
        var o = new Ad({
            shape: {
              x: 0,
              y: 0,
              width: n[0],
              height: n[1],
            },
            style: {
              fill: 'transparent',
            },
            z2: 0,
            onclick: Tt(this._onClickPanel, this),
          }),
          s = this.api.getZr()
        a
          ? (o.on('mousedown', this._onBrushStart, this),
            (o.cursor = 'crosshair'),
            s.on('mousemove', this._onBrush),
            s.on('mouseup', this._onBrushEnd))
          : (s.off('mousemove', this._onBrush),
            s.off('mouseup', this._onBrushEnd)),
          i.add(o)
      }),
      (t.prototype._renderDataShadow = function () {
        var e = (this._dataShadowInfo = this._prepareDataShadowInfo())
        if (((this._displayables.dataShadowSegs = []), !e)) return
        var n = this._size,
          i = this._shadowSize || [],
          a = e.series,
          o = a.getRawData(),
          s = a.getShadowDim && a.getShadowDim(),
          l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim
        if (l == null) return
        var u = this._shadowPolygonPts,
          c = this._shadowPolylinePts
        if (
          o !== this._shadowData ||
          l !== this._shadowDim ||
          n[0] !== i[0] ||
          n[1] !== i[1]
        ) {
          var h = o.getDataExtent(l),
            f = (h[1] - h[0]) * 0.3
          h = [h[0] - f, h[1] + f]
          var d = [0, n[1]],
            p = [0, n[0]],
            g = [
              [n[0], 0],
              [0, 0],
            ],
            v = [],
            m = p[1] / (o.count() - 1),
            y = 0,
            _ = Math.round(o.count() / n[0]),
            x
          o.each([l], function (w, M) {
            if (_ > 0 && M % _) {
              y += m
              return
            }
            var C = w == null || isNaN(w) || w === '',
              E = C ? 0 : Re(w, h, d, !0)
            C && !x && M
              ? (g.push([g[g.length - 1][0], 0]),
                v.push([v[v.length - 1][0], 0]))
              : !C && x && (g.push([y, 0]), v.push([y, 0])),
              g.push([y, E]),
              v.push([y, E]),
              (y += m),
              (x = C)
          }),
            (u = this._shadowPolygonPts = g),
            (c = this._shadowPolylinePts = v)
        }
        ;(this._shadowData = o),
          (this._shadowDim = l),
          (this._shadowSize = [n[0], n[1]])
        var A = this.dataZoomModel
        function S(w) {
          var M = A.getModel(w ? 'selectedDataBackground' : 'dataBackground'),
            C = new Ht(),
            E = new si({
              shape: {
                points: u,
              },
              segmentIgnoreThreshold: 1,
              style: M.getModel('areaStyle').getAreaStyle(),
              silent: !0,
              z2: -20,
            }),
            D = new li({
              shape: {
                points: c,
              },
              segmentIgnoreThreshold: 1,
              style: M.getModel('lineStyle').getLineStyle(),
              silent: !0,
              z2: -19,
            })
          return C.add(E), C.add(D), C
        }
        for (var b = 0; b < 3; b++) {
          var T = S(b === 1)
          this._displayables.sliderGroup.add(T),
            this._displayables.dataShadowSegs.push(T)
        }
      }),
      (t.prototype._prepareDataShadowInfo = function () {
        var e = this.dataZoomModel,
          n = e.get('showDataShadow')
        if (n !== !1) {
          var i,
            a = this.ecModel
          return (
            e.eachTargetAxis(function (o, s) {
              var l = e.getAxisProxy(o, s).getTargetSeriesModels()
              R(
                l,
                function (u) {
                  if (!i && !(n !== !0 && re(A1t, u.get('type')) < 0)) {
                    var c = a.getComponent(Ws(o), s).axis,
                      h = M1t(o),
                      f,
                      d = u.coordinateSystem
                    h != null &&
                      d.getOtherAxis &&
                      (f = d.getOtherAxis(c).inverse),
                      (h = u.getData().mapDimension(h)),
                      (i = {
                        thisAxis: c,
                        series: u,
                        thisDim: o,
                        otherDim: h,
                        otherAxisInverse: f,
                      })
                  }
                },
                this,
              )
            }, this),
            i
          )
        }
      }),
      (t.prototype._renderHandle = function () {
        var e = this.group,
          n = this._displayables,
          i = (n.handles = [null, null]),
          a = (n.handleLabels = [null, null]),
          o = this._displayables.sliderGroup,
          s = this._size,
          l = this.dataZoomModel,
          u = this.api,
          c = l.get('borderRadius') || 0,
          h = l.get('brushSelect'),
          f = (n.filler = new Ad({
            silent: h,
            style: {
              fill: l.get('fillerColor'),
            },
            textConfig: {
              position: 'inside',
            },
          }))
        o.add(f),
          o.add(
            new Ad({
              silent: !0,
              subPixelOptimize: !0,
              shape: {
                x: 0,
                y: 0,
                width: s[0],
                height: s[1],
                r: c,
              },
              style: {
                stroke: l.get('dataBackgroundColor') || l.get('borderColor'),
                lineWidth: _1t,
                fill: 'rgba(0,0,0,0)',
              },
            }),
          ),
          R(
            [0, 1],
            function (_) {
              var x = l.get('handleIcon')
              !t0[x] &&
                x.indexOf('path://') < 0 &&
                x.indexOf('image://') < 0 &&
                (x = 'path://' + x)
              var A = Rn(x, -1, 0, 2, 2, null, !0)
              A.attr({
                cursor: Q3(this._orient),
                draggable: !0,
                drift: Tt(this._onDragMove, this, _),
                ondragend: Tt(this._onDragEnd, this),
                onmouseover: Tt(this._showDataInfo, this, !0),
                onmouseout: Tt(this._showDataInfo, this, !1),
                z2: 5,
              })
              var S = A.getBoundingRect(),
                b = l.get('handleSize')
              ;(this._handleHeight = _t(b, this._size[1])),
                (this._handleWidth = (S.width / S.height) * this._handleHeight),
                A.setStyle(l.getModel('handleStyle').getItemStyle()),
                (A.style.strokeNoScale = !0),
                (A.rectHover = !0),
                (A.ensureState('emphasis').style = l
                  .getModel(['emphasis', 'handleStyle'])
                  .getItemStyle()),
                Ou(A)
              var T = l.get('handleColor')
              T != null && (A.style.fill = T), o.add((i[_] = A))
              var w = l.getModel('textStyle')
              e.add(
                (a[_] = new Ae({
                  silent: !0,
                  invisible: !0,
                  style: $e(w, {
                    x: 0,
                    y: 0,
                    text: '',
                    verticalAlign: 'middle',
                    align: 'center',
                    fill: w.getTextColor(),
                    font: w.getFont(),
                  }),
                  z2: 10,
                })),
              )
            },
            this,
          )
        var d = f
        if (h) {
          var p = _t(l.get('moveHandleSize'), s[1]),
            g = (n.moveHandle = new ge({
              style: l.getModel('moveHandleStyle').getItemStyle(),
              silent: !0,
              shape: {
                r: [0, 0, 2, 2],
                y: s[1] - 0.5,
                height: p,
              },
            })),
            v = p * 0.8,
            m = (n.moveHandleIcon = Rn(
              l.get('moveHandleIcon'),
              -v / 2,
              -v / 2,
              v,
              v,
              '#fff',
              !0,
            ))
          ;(m.silent = !0),
            (m.y = s[1] + p / 2 - 0.5),
            (g.ensureState('emphasis').style = l
              .getModel(['emphasis', 'moveHandleStyle'])
              .getItemStyle())
          var y = Math.min(s[1] / 2, Math.max(p, 10))
          ;(d = n.moveZone =
            new ge({
              invisible: !0,
              shape: {
                y: s[1] - y,
                height: p + y,
              },
            })),
            d
              .on('mouseover', function () {
                u.enterEmphasis(g)
              })
              .on('mouseout', function () {
                u.leaveEmphasis(g)
              }),
            o.add(g),
            o.add(m),
            o.add(d)
        }
        d.attr({
          draggable: !0,
          cursor: Q3(this._orient),
          drift: Tt(this._onDragMove, this, 'all'),
          ondragstart: Tt(this._showDataInfo, this, !0),
          ondragend: Tt(this._onDragEnd, this),
          onmouseover: Tt(this._showDataInfo, this, !0),
          onmouseout: Tt(this._showDataInfo, this, !1),
        })
      }),
      (t.prototype._resetInterval = function () {
        var e = (this._range = this.dataZoomModel.getPercentRange()),
          n = this._getViewExtent()
        this._handleEnds = [
          Re(e[0], [0, 100], n, !0),
          Re(e[1], [0, 100], n, !0),
        ]
      }),
      (t.prototype._updateInterval = function (e, n) {
        var i = this.dataZoomModel,
          a = this._handleEnds,
          o = this._getViewExtent(),
          s = i.findRepresentativeAxisProxy().getMinMaxSpan(),
          l = [0, 100]
        lc(
          n,
          a,
          o,
          i.get('zoomLock') ? 'all' : e,
          s.minSpan != null ? Re(s.minSpan, l, o, !0) : null,
          s.maxSpan != null ? Re(s.maxSpan, l, o, !0) : null,
        )
        var u = this._range,
          c = (this._range = Zi([Re(a[0], o, l, !0), Re(a[1], o, l, !0)]))
        return !u || u[0] !== c[0] || u[1] !== c[1]
      }),
      (t.prototype._updateView = function (e) {
        var n = this._displayables,
          i = this._handleEnds,
          a = Zi(i.slice()),
          o = this._size
        R(
          [0, 1],
          function (d) {
            var p = n.handles[d],
              g = this._handleHeight
            p.attr({
              scaleX: g / 2,
              scaleY: g / 2,
              x: i[d] + (d ? -1 : 1),
              y: o[1] / 2 - g / 2,
            })
          },
          this,
        ),
          n.filler.setShape({
            x: a[0],
            y: 0,
            width: a[1] - a[0],
            height: o[1],
          })
        var s = {
          x: a[0],
          width: a[1] - a[0],
        }
        n.moveHandle &&
          (n.moveHandle.setShape(s),
          n.moveZone.setShape(s),
          n.moveZone.getBoundingRect(),
          n.moveHandleIcon && n.moveHandleIcon.attr('x', s.x + s.width / 2))
        for (
          var l = n.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0;
          c < l.length;
          c++
        ) {
          var h = l[c],
            f = h.getClipPath()
          f || ((f = new ge()), h.setClipPath(f)),
            f.setShape({
              x: u[c],
              y: 0,
              width: u[c + 1] - u[c],
              height: o[1],
            })
        }
        this._updateDataInfo(e)
      }),
      (t.prototype._updateDataInfo = function (e) {
        var n = this.dataZoomModel,
          i = this._displayables,
          a = i.handleLabels,
          o = this._orient,
          s = ['', '']
        if (n.get('showDetail')) {
          var l = n.findRepresentativeAxisProxy()
          if (l) {
            var u = l.getAxisModel().axis,
              c = this._range,
              h = e
                ? l.calculateDataWindow({
                    start: c[0],
                    end: c[1],
                  }).valueWindow
                : l.getDataValueWindow()
            s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)]
          }
        }
        var f = Zi(this._handleEnds.slice())
        d.call(this, 0), d.call(this, 1)
        function d(p) {
          var g = Nu(i.handles[p].parent, this.group),
            v = s_(p === 0 ? 'right' : 'left', g),
            m = this._handleWidth / 2 + S1t,
            y = ba([f[p] + (p === 0 ? -m : m), this._size[1] / 2], g)
          a[p].setStyle({
            x: y[0],
            y: y[1],
            verticalAlign: o === bd ? 'middle' : v,
            align: o === bd ? v : 'center',
            text: s[p],
          })
        }
      }),
      (t.prototype._formatLabel = function (e, n) {
        var i = this.dataZoomModel,
          a = i.get('labelFormatter'),
          o = i.get('labelPrecision')
        ;(o == null || o === 'auto') && (o = n.getPixelPrecision())
        var s =
          e == null || isNaN(e)
            ? ''
            : n.type === 'category' || n.type === 'time'
            ? n.scale.getLabel({
                value: Math.round(e),
              })
            : e.toFixed(Math.min(o, 20))
        return Nt(a) ? a(e, s) : bt(a) ? a.replace('{value}', s) : s
      }),
      (t.prototype._showDataInfo = function (e) {
        e = this._dragging || e
        var n = this._displayables,
          i = n.handleLabels
        i[0].attr('invisible', !e),
          i[1].attr('invisible', !e),
          n.moveHandle &&
            this.api[e ? 'enterEmphasis' : 'leaveEmphasis'](n.moveHandle, 1)
      }),
      (t.prototype._onDragMove = function (e, n, i, a) {
        ;(this._dragging = !0), jo(a.event)
        var o = this._displayables.sliderGroup.getLocalTransform(),
          s = ba([n, i], o, !0),
          l = this._updateInterval(e, s[0]),
          u = this.dataZoomModel.get('realtime')
        this._updateView(!u), l && u && this._dispatchZoomAction(!0)
      }),
      (t.prototype._onDragEnd = function () {
        ;(this._dragging = !1), this._showDataInfo(!1)
        var e = this.dataZoomModel.get('realtime')
        !e && this._dispatchZoomAction(!1)
      }),
      (t.prototype._onClickPanel = function (e) {
        var n = this._size,
          i = this._displayables.sliderGroup.transformCoordToLocal(
            e.offsetX,
            e.offsetY,
          )
        if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
          var a = this._handleEnds,
            o = (a[0] + a[1]) / 2,
            s = this._updateInterval('all', i[0] - o)
          this._updateView(), s && this._dispatchZoomAction(!1)
        }
      }),
      (t.prototype._onBrushStart = function (e) {
        var n = e.offsetX,
          i = e.offsetY
        ;(this._brushStart = new Qt(n, i)),
          (this._brushing = !0),
          (this._brushStartTime = +new Date())
      }),
      (t.prototype._onBrushEnd = function (e) {
        if (this._brushing) {
          var n = this._displayables.brushRect
          if (((this._brushing = !1), !!n)) {
            n.attr('ignore', !0)
            var i = n.shape,
              a = +new Date()
            if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
              var o = this._getViewExtent(),
                s = [0, 100]
              ;(this._range = Zi([
                Re(i.x, o, s, !0),
                Re(i.x + i.width, o, s, !0),
              ])),
                (this._handleEnds = [i.x, i.x + i.width]),
                this._updateView(),
                this._dispatchZoomAction(!1)
            }
          }
        }
      }),
      (t.prototype._onBrush = function (e) {
        this._brushing &&
          (jo(e.event), this._updateBrushRect(e.offsetX, e.offsetY))
      }),
      (t.prototype._updateBrushRect = function (e, n) {
        var i = this._displayables,
          a = this.dataZoomModel,
          o = i.brushRect
        o ||
          ((o = i.brushRect =
            new Ad({
              silent: !0,
              style: a.getModel('brushStyle').getItemStyle(),
            })),
          i.sliderGroup.add(o)),
          o.attr('ignore', !1)
        var s = this._brushStart,
          l = this._displayables.sliderGroup,
          u = l.transformCoordToLocal(e, n),
          c = l.transformCoordToLocal(s.x, s.y),
          h = this._size
        ;(u[0] = Math.max(Math.min(h[0], u[0]), 0)),
          o.setShape({
            x: c[0],
            y: 0,
            width: u[0] - c[0],
            height: h[1],
          })
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var n = this._range
        this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          animation: e ? b1t : null,
          start: n[0],
          end: n[1],
        })
      }),
      (t.prototype._findCoordRect = function () {
        var e,
          n = TH(this.dataZoomModel).infoList
        if (!e && n.length) {
          var i = n[0].model.coordinateSystem
          e = i.getRect && i.getRect()
        }
        if (!e) {
          var a = this.api.getWidth(),
            o = this.api.getHeight()
          e = {
            x: a * 0.2,
            y: o * 0.2,
            width: a * 0.6,
            height: o * 0.6,
          }
        }
        return e
      }),
      (t.type = 'dataZoom.slider'),
      t
    )
  })(AE)
function M1t(r) {
  var t = {
    x: 'y',
    y: 'x',
    radius: 'angle',
    angle: 'radius',
  }
  return t[r]
}
function Q3(r) {
  return r === 'vertical' ? 'ns-resize' : 'ew-resize'
}
const T1t = w1t
function $H(r) {
  r.registerComponentModel(y1t), r.registerComponentView(T1t), bE(r)
}
function C1t(r) {
  ie(YH), ie($H)
}
var E1t = {
    get: function (r, t, e) {
      var n = Vt((D1t[r] || {})[t])
      return e && at(n) ? n[n.length - 1] : n
    },
  },
  D1t = {
    color: {
      active: ['#006edd', '#e0ffff'],
      inactive: ['rgba(0,0,0,0)'],
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0],
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0],
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0],
    },
    symbol: {
      active: ['circle', 'roundRect', 'diamond'],
      inactive: ['none'],
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0],
    },
  }
const qH = E1t
var tk = vr.mapVisual,
  L1t = vr.eachVisual,
  P1t = at,
  ek = R,
  R1t = Zi,
  I1t = Re,
  O1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e.stateList = ['inRange', 'outOfRange']),
        (e.replacableOptionKeys = [
          'inRange',
          'outOfRange',
          'target',
          'controller',
          'color',
        ]),
        (e.layoutMode = {
          type: 'box',
          ignoreSize: !0,
        }),
        (e.dataBound = [-1 / 0, 1 / 0]),
        (e.targetVisuals = {}),
        (e.controllerVisuals = {}),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n, i) {
        this.mergeDefaultAndTheme(e, i)
      }),
      (t.prototype.optionUpdated = function (e, n) {
        var i = this.option
        !n && kH(i, e, this.replacableOptionKeys),
          (this.textStyleModel = this.getModel('textStyle')),
          this.resetItemSize(),
          this.completeVisualOption()
      }),
      (t.prototype.resetVisual = function (e) {
        var n = this.stateList
        ;(e = Tt(e, this)),
          (this.controllerVisuals = iM(this.option.controller, n, e)),
          (this.targetVisuals = iM(this.option.target, n, e))
      }),
      (t.prototype.getItemSymbol = function () {
        return null
      }),
      (t.prototype.getTargetSeriesIndices = function () {
        var e = this.option.seriesIndex,
          n = []
        return (
          e == null || e === 'all'
            ? this.ecModel.eachSeries(function (i, a) {
                n.push(a)
              })
            : (n = ke(e)),
          n
        )
      }),
      (t.prototype.eachTargetSeries = function (e, n) {
        R(
          this.getTargetSeriesIndices(),
          function (i) {
            var a = this.ecModel.getSeriesByIndex(i)
            a && e.call(n, a)
          },
          this,
        )
      }),
      (t.prototype.isTargetSeries = function (e) {
        var n = !1
        return (
          this.eachTargetSeries(function (i) {
            i === e && (n = !0)
          }),
          n
        )
      }),
      (t.prototype.formatValueText = function (e, n, i) {
        var a = this.option,
          o = a.precision,
          s = this.dataBound,
          l = a.formatter,
          u
        ;(i = i || ['<', '>']), at(e) && ((e = e.slice()), (u = !0))
        var c = n ? e : u ? [h(e[0]), h(e[1])] : h(e)
        if (bt(l))
          return l
            .replace('{value}', u ? c[0] : c)
            .replace('{value2}', u ? c[1] : c)
        if (Nt(l)) return u ? l(e[0], e[1]) : l(e)
        if (u)
          return e[0] === s[0]
            ? i[0] + ' ' + c[1]
            : e[1] === s[1]
            ? i[1] + ' ' + c[0]
            : c[0] + ' - ' + c[1]
        return c
        function h(f) {
          return f === s[0]
            ? 'min'
            : f === s[1]
            ? 'max'
            : (+f).toFixed(Math.min(o, 20))
        }
      }),
      (t.prototype.resetExtent = function () {
        var e = this.option,
          n = R1t([e.min, e.max])
        this._dataExtent = n
      }),
      (t.prototype.getDataDimensionIndex = function (e) {
        var n = this.option.dimension
        if (n != null) return e.getDimensionIndex(n)
        for (var i = e.dimensions, a = i.length - 1; a >= 0; a--) {
          var o = i[a],
            s = e.getDimensionInfo(o)
          if (!s.isCalculationCoord) return s.storeDimIndex
        }
      }),
      (t.prototype.getExtent = function () {
        return this._dataExtent.slice()
      }),
      (t.prototype.completeVisualOption = function () {
        var e = this.ecModel,
          n = this.option,
          i = {
            inRange: n.inRange,
            outOfRange: n.outOfRange,
          },
          a = n.target || (n.target = {}),
          o = n.controller || (n.controller = {})
        te(a, i), te(o, i)
        var s = this.isCategory()
        l.call(this, a),
          l.call(this, o),
          u.call(this, a, 'inRange', 'outOfRange'),
          c.call(this, o)
        function l(h) {
          P1t(n.color) &&
            !h.inRange &&
            (h.inRange = {
              color: n.color.slice().reverse(),
            }),
            (h.inRange = h.inRange || {
              color: e.get('gradientColor'),
            })
        }
        function u(h, f, d) {
          var p = h[f],
            g = h[d]
          p &&
            !g &&
            ((g = h[d] = {}),
            ek(p, function (v, m) {
              if (vr.isValidType(m)) {
                var y = qH.get(m, 'inactive', s)
                y != null &&
                  ((g[m] = y),
                  m === 'color' &&
                    !g.hasOwnProperty('opacity') &&
                    !g.hasOwnProperty('colorAlpha') &&
                    (g.opacity = [0, 0]))
              }
            }))
        }
        function c(h) {
          var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol,
            d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize,
            p = this.get('inactiveColor'),
            g = this.getItemSymbol(),
            v = g || 'roundRect'
          ek(
            this.stateList,
            function (m) {
              var y = this.itemSize,
                _ = h[m]
              _ ||
                (_ = h[m] =
                  {
                    color: s ? p : [p],
                  }),
                _.symbol == null && (_.symbol = (f && Vt(f)) || (s ? v : [v])),
                _.symbolSize == null &&
                  (_.symbolSize = (d && Vt(d)) || (s ? y[0] : [y[0], y[0]])),
                (_.symbol = tk(_.symbol, function (S) {
                  return S === 'none' ? v : S
                }))
              var x = _.symbolSize
              if (x != null) {
                var A = -1 / 0
                L1t(x, function (S) {
                  S > A && (A = S)
                }),
                  (_.symbolSize = tk(x, function (S) {
                    return I1t(S, [0, A], [0, y[0]], !0)
                  }))
              }
            },
            this,
          )
        }
      }),
      (t.prototype.resetItemSize = function () {
        this.itemSize = [
          parseFloat(this.get('itemWidth')),
          parseFloat(this.get('itemHeight')),
        ]
      }),
      (t.prototype.isCategory = function () {
        return !!this.option.categories
      }),
      (t.prototype.setSelected = function (e) {}),
      (t.prototype.getSelected = function () {
        return null
      }),
      (t.prototype.getValueState = function (e) {
        return null
      }),
      (t.prototype.getVisualMeta = function (e) {
        return null
      }),
      (t.type = 'visualMap'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        show: !0,
        z: 4,
        seriesIndex: 'all',
        min: 0,
        max: 200,
        left: 0,
        right: null,
        top: null,
        bottom: 0,
        itemWidth: null,
        itemHeight: null,
        inverse: !1,
        orient: 'vertical',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        contentColor: '#5793f3',
        inactiveColor: '#aaa',
        borderWidth: 0,
        padding: 5,
        textGap: 10,
        precision: 0,
        textStyle: {
          color: '#333',
        },
      }),
      t
    )
  })(xe)
const M0 = O1t
var nk = [20, 140],
  N1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        r.prototype.optionUpdated.apply(this, arguments),
          this.resetExtent(),
          this.resetVisual(function (i) {
            ;(i.mappingMethod = 'linear'), (i.dataExtent = this.getExtent())
          }),
          this._resetRange()
      }),
      (t.prototype.resetItemSize = function () {
        r.prototype.resetItemSize.apply(this, arguments)
        var e = this.itemSize
        ;(e[0] == null || isNaN(e[0])) && (e[0] = nk[0]),
          (e[1] == null || isNaN(e[1])) && (e[1] = nk[1])
      }),
      (t.prototype._resetRange = function () {
        var e = this.getExtent(),
          n = this.option.range
        !n || n.auto
          ? ((e.auto = 1), (this.option.range = e))
          : at(n) &&
            (n[0] > n[1] && n.reverse(),
            (n[0] = Math.max(n[0], e[0])),
            (n[1] = Math.min(n[1], e[1])))
      }),
      (t.prototype.completeVisualOption = function () {
        r.prototype.completeVisualOption.apply(this, arguments),
          R(
            this.stateList,
            function (e) {
              var n = this.option.controller[e].symbolSize
              n && n[0] !== n[1] && (n[0] = n[1] / 3)
            },
            this,
          )
      }),
      (t.prototype.setSelected = function (e) {
        ;(this.option.range = e.slice()), this._resetRange()
      }),
      (t.prototype.getSelected = function () {
        var e = this.getExtent(),
          n = Zi((this.get('range') || []).slice())
        return (
          n[0] > e[1] && (n[0] = e[1]),
          n[1] > e[1] && (n[1] = e[1]),
          n[0] < e[0] && (n[0] = e[0]),
          n[1] < e[0] && (n[1] = e[0]),
          n
        )
      }),
      (t.prototype.getValueState = function (e) {
        var n = this.option.range,
          i = this.getExtent()
        return (n[0] <= i[0] || n[0] <= e) && (n[1] >= i[1] || e <= n[1])
          ? 'inRange'
          : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var n = []
        return (
          this.eachTargetSeries(function (i) {
            var a = [],
              o = i.getData()
            o.each(
              this.getDataDimensionIndex(o),
              function (s, l) {
                e[0] <= s && s <= e[1] && a.push(l)
              },
              this,
            ),
              n.push({
                seriesId: i.id,
                dataIndex: a,
              })
          }, this),
          n
        )
      }),
      (t.prototype.getVisualMeta = function (e) {
        var n = rk(this, 'outOfRange', this.getExtent()),
          i = rk(this, 'inRange', this.option.range.slice()),
          a = []
        function o(d, p) {
          a.push({
            value: d,
            color: e(d, p),
          })
        }
        for (
          var s = 0, l = 0, u = i.length, c = n.length;
          l < c && (!i.length || n[l] <= i[0]);
          l++
        )
          n[l] < i[s] && o(n[l], 'outOfRange')
        for (var h = 1; s < u; s++, h = 0)
          h && a.length && o(i[s], 'outOfRange'), o(i[s], 'inRange')
        for (var h = 1; l < c; l++)
          (!i.length || i[i.length - 1] < n[l]) &&
            (h && (a.length && o(a[a.length - 1].value, 'outOfRange'), (h = 0)),
            o(n[l], 'outOfRange'))
        var f = a.length
        return {
          stops: a,
          outerColors: [
            f ? a[0].color : 'transparent',
            f ? a[f - 1].color : 'transparent',
          ],
        }
      }),
      (t.type = 'visualMap.continuous'),
      (t.defaultOption = gl(M0.defaultOption, {
        align: 'auto',
        calculable: !1,
        hoverLink: !0,
        realtime: !0,
        handleIcon:
          'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
        handleSize: '120%',
        handleStyle: {
          borderColor: '#fff',
          borderWidth: 1,
        },
        indicatorIcon: 'circle',
        indicatorSize: '50%',
        indicatorStyle: {
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0,0,0,0.2)',
        },
      })),
      t
    )
  })(M0)
function rk(r, t, e) {
  if (e[0] === e[1]) return e.slice()
  for (
    var n = 200, i = (e[1] - e[0]) / n, a = e[0], o = [], s = 0;
    s <= n && a < e[1];
    s++
  )
    o.push(a), (a += i)
  return o.push(e[1]), o
}
const k1t = N1t
var B1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (
      (e.type = t.type),
      (e.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1,
      }),
      e
    )
  }
  return (
    (t.prototype.init = function (e, n) {
      ;(this.ecModel = e), (this.api = n)
    }),
    (t.prototype.render = function (e, n, i, a) {
      if (((this.visualMapModel = e), e.get('show') === !1)) {
        this.group.removeAll()
        return
      }
      this.doRender(e, n, i, a)
    }),
    (t.prototype.renderBackground = function (e) {
      var n = this.visualMapModel,
        i = wf(n.get('padding') || 0),
        a = e.getBoundingRect()
      e.add(
        new ge({
          z2: -1,
          silent: !0,
          shape: {
            x: a.x - i[3],
            y: a.y - i[0],
            width: a.width + i[3] + i[1],
            height: a.height + i[0] + i[2],
          },
          style: {
            fill: n.get('backgroundColor'),
            stroke: n.get('borderColor'),
            lineWidth: n.get('borderWidth'),
          },
        }),
      )
    }),
    (t.prototype.getControllerVisual = function (e, n, i) {
      i = i || {}
      var a = i.forceState,
        o = this.visualMapModel,
        s = {}
      if (n === 'color') {
        var l = o.get('contentColor')
        s.color = l
      }
      function u(d) {
        return s[d]
      }
      function c(d, p) {
        s[d] = p
      }
      var h = o.controllerVisuals[a || o.getValueState(e)],
        f = vr.prepareVisualTypes(h)
      return (
        R(f, function (d) {
          var p = h[d]
          i.convertOpacityToAlpha &&
            d === 'opacity' &&
            ((d = 'colorAlpha'), (p = h.__alphaForOpacity)),
            vr.dependsOn(d, n) && p && p.applyVisual(e, u, c)
        }),
        s[n]
      )
    }),
    (t.prototype.positionGroup = function (e) {
      var n = this.visualMapModel,
        i = this.api
      p_(e, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight(),
      })
    }),
    (t.prototype.doRender = function (e, n, i, a) {}),
    (t.type = 'visualMap'),
    t
  )
})(dn)
const ZH = B1t
var ik = [
  ['left', 'right', 'width'],
  ['top', 'bottom', 'height'],
]
function KH(r, t, e) {
  var n = r.option,
    i = n.align
  if (i != null && i !== 'auto') return i
  for (
    var a = {
        width: t.getWidth(),
        height: t.getHeight(),
      },
      o = n.orient === 'horizontal' ? 1 : 0,
      s = ik[o],
      l = [0, null, 10],
      u = {},
      c = 0;
    c < 3;
    c++
  )
    (u[ik[1 - o][c]] = l[c]), (u[s[c]] = c === 2 ? e[0] : n[s[c]])
  var h = [
      ['x', 'width', 3],
      ['y', 'height', 0],
    ][o],
    f = Vn(u, a, n.padding)
  return s[
    (f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1
  ]
}
function cy(r, t) {
  return (
    R(r || [], function (e) {
      e.dataIndex != null &&
        ((e.dataIndexInside = e.dataIndex), (e.dataIndex = null)),
        (e.highlightKey = 'visualMap' + (t ? t.componentIndex : ''))
    }),
    r
  )
}
var Ga = Re,
  F1t = R,
  ak = Math.min,
  oA = Math.max,
  z1t = 12,
  U1t = 6,
  V1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (
        (e.type = t.type),
        (e._shapes = {}),
        (e._dataInterval = []),
        (e._handleEnds = []),
        (e._hoverLinkDataIndices = []),
        e
      )
    }
    return (
      (t.prototype.init = function (e, n) {
        r.prototype.init.call(this, e, n),
          (this._hoverLinkFromSeriesMouseOver = Tt(
            this._hoverLinkFromSeriesMouseOver,
            this,
          )),
          (this._hideIndicator = Tt(this._hideIndicator, this))
      }),
      (t.prototype.doRender = function (e, n, i, a) {
        ;(!a || a.type !== 'selectDataRange' || a.from !== this.uid) &&
          this._buildView()
      }),
      (t.prototype._buildView = function () {
        this.group.removeAll()
        var e = this.visualMapModel,
          n = this.group
        ;(this._orient = e.get('orient')),
          (this._useHandle = e.get('calculable')),
          this._resetInterval(),
          this._renderBar(n)
        var i = e.get('text')
        this._renderEndsText(n, i, 0),
          this._renderEndsText(n, i, 1),
          this._updateView(!0),
          this.renderBackground(n),
          this._updateView(),
          this._enableHoverLinkToSeries(),
          this._enableHoverLinkFromSeries(),
          this.positionGroup(n)
      }),
      (t.prototype._renderEndsText = function (e, n, i) {
        if (n) {
          var a = n[1 - i]
          a = a != null ? a + '' : ''
          var o = this.visualMapModel,
            s = o.get('textGap'),
            l = o.itemSize,
            u = this._shapes.mainGroup,
            c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u),
            h = this._applyTransform(i === 0 ? 'bottom' : 'top', u),
            f = this._orient,
            d = this.visualMapModel.textStyleModel
          this.group.add(
            new Ae({
              style: $e(d, {
                x: c[0],
                y: c[1],
                verticalAlign: f === 'horizontal' ? 'middle' : h,
                align: f === 'horizontal' ? h : 'center',
                text: a,
              }),
            }),
          )
        }
      }),
      (t.prototype._renderBar = function (e) {
        var n = this.visualMapModel,
          i = this._shapes,
          a = n.itemSize,
          o = this._orient,
          s = this._useHandle,
          l = KH(n, this.api, a),
          u = (i.mainGroup = this._createBarGroup(l)),
          c = new Ht()
        u.add(c),
          c.add((i.outOfRange = ok())),
          c.add(
            (i.inRange = ok(
              null,
              s ? lk(this._orient) : null,
              Tt(this._dragHandle, this, 'all', !1),
              Tt(this._dragHandle, this, 'all', !0),
            )),
          ),
          c.setClipPath(
            new ge({
              shape: {
                x: 0,
                y: 0,
                width: a[0],
                height: a[1],
                r: 3,
              },
            }),
          )
        var h = n.textStyleModel.getTextRect('国'),
          f = oA(h.width, h.height)
        s &&
          ((i.handleThumbs = []),
          (i.handleLabels = []),
          (i.handleLabelPoints = []),
          this._createHandle(n, u, 0, a, f, o),
          this._createHandle(n, u, 1, a, f, o)),
          this._createIndicator(n, u, a, f, o),
          e.add(u)
      }),
      (t.prototype._createHandle = function (e, n, i, a, o, s) {
        var l = Tt(this._dragHandle, this, i, !1),
          u = Tt(this._dragHandle, this, i, !0),
          c = Ta(e.get('handleSize'), a[0]),
          h = Rn(e.get('handleIcon'), -c / 2, -c / 2, c, c, null, !0),
          f = lk(this._orient)
        h.attr({
          cursor: f,
          draggable: !0,
          drift: l,
          ondragend: u,
          onmousemove: function (m) {
            jo(m.event)
          },
        }),
          (h.x = a[0] / 2),
          h.useStyle(e.getModel('handleStyle').getItemStyle()),
          h.setStyle({
            strokeNoScale: !0,
            strokeFirst: !0,
          }),
          (h.style.lineWidth *= 2),
          (h.ensureState('emphasis').style = e
            .getModel(['emphasis', 'handleStyle'])
            .getItemStyle()),
          yu(h, !0),
          n.add(h)
        var d = this.visualMapModel.textStyleModel,
          p = new Ae({
            cursor: f,
            draggable: !0,
            drift: l,
            onmousemove: function (m) {
              jo(m.event)
            },
            ondragend: u,
            style: $e(d, {
              x: 0,
              y: 0,
              text: '',
            }),
          })
        ;(p.ensureState('blur').style = {
          opacity: 0.1,
        }),
          (p.stateTransition = {
            duration: 200,
          }),
          this.group.add(p)
        var g = [c, 0],
          v = this._shapes
        ;(v.handleThumbs[i] = h),
          (v.handleLabelPoints[i] = g),
          (v.handleLabels[i] = p)
      }),
      (t.prototype._createIndicator = function (e, n, i, a, o) {
        var s = Ta(e.get('indicatorSize'), i[0]),
          l = Rn(e.get('indicatorIcon'), -s / 2, -s / 2, s, s, null, !0)
        l.attr({
          cursor: 'move',
          invisible: !0,
          silent: !0,
          x: i[0] / 2,
        })
        var u = e.getModel('indicatorStyle').getItemStyle()
        if (l instanceof yr) {
          var c = l.style
          l.useStyle(
            Q(
              {
                image: c.image,
                x: c.x,
                y: c.y,
                width: c.width,
                height: c.height,
              },
              u,
            ),
          )
        } else l.useStyle(u)
        n.add(l)
        var h = this.visualMapModel.textStyleModel,
          f = new Ae({
            silent: !0,
            invisible: !0,
            style: $e(h, {
              x: 0,
              y: 0,
              text: '',
            }),
          })
        this.group.add(f)
        var d = [(o === 'horizontal' ? a / 2 : U1t) + i[0] / 2, 0],
          p = this._shapes
        ;(p.indicator = l),
          (p.indicatorLabel = f),
          (p.indicatorLabelPoint = d),
          (this._firstShowIndicator = !0)
      }),
      (t.prototype._dragHandle = function (e, n, i, a) {
        if (this._useHandle) {
          if (((this._dragging = !n), !n)) {
            var o = this._applyTransform([i, a], this._shapes.mainGroup, !0)
            this._updateInterval(e, o[1]),
              this._hideIndicator(),
              this._updateView()
          }
          n === !this.visualMapModel.get('realtime') &&
            this.api.dispatchAction({
              type: 'selectDataRange',
              from: this.uid,
              visualMapId: this.visualMapModel.id,
              selected: this._dataInterval.slice(),
            }),
            n
              ? !this._hovering && this._clearHoverLinkToSeries()
              : sk(this.visualMapModel) &&
                this._doHoverLinkToSeries(this._handleEnds[e], !1)
        }
      }),
      (t.prototype._resetInterval = function () {
        var e = this.visualMapModel,
          n = (this._dataInterval = e.getSelected()),
          i = e.getExtent(),
          a = [0, e.itemSize[1]]
        this._handleEnds = [Ga(n[0], i, a, !0), Ga(n[1], i, a, !0)]
      }),
      (t.prototype._updateInterval = function (e, n) {
        n = n || 0
        var i = this.visualMapModel,
          a = this._handleEnds,
          o = [0, i.itemSize[1]]
        lc(n, a, o, e, 0)
        var s = i.getExtent()
        this._dataInterval = [Ga(a[0], o, s, !0), Ga(a[1], o, s, !0)]
      }),
      (t.prototype._updateView = function (e) {
        var n = this.visualMapModel,
          i = n.getExtent(),
          a = this._shapes,
          o = [0, n.itemSize[1]],
          s = e ? o : this._handleEnds,
          l = this._createBarVisual(this._dataInterval, i, s, 'inRange'),
          u = this._createBarVisual(i, i, o, 'outOfRange')
        a.inRange
          .setStyle({
            fill: l.barColor,
          })
          .setShape('points', l.barPoints),
          a.outOfRange
            .setStyle({
              fill: u.barColor,
            })
            .setShape('points', u.barPoints),
          this._updateHandle(s, l)
      }),
      (t.prototype._createBarVisual = function (e, n, i, a) {
        var o = {
            forceState: a,
            convertOpacityToAlpha: !0,
          },
          s = this._makeColorGradient(e, o),
          l = [
            this.getControllerVisual(e[0], 'symbolSize', o),
            this.getControllerVisual(e[1], 'symbolSize', o),
          ],
          u = this._createBarPoints(i, l)
        return {
          barColor: new He(0, 0, 0, 1, s),
          barPoints: u,
          handlesColor: [s[0].color, s[s.length - 1].color],
        }
      }),
      (t.prototype._makeColorGradient = function (e, n) {
        var i = 100,
          a = [],
          o = (e[1] - e[0]) / i
        a.push({
          color: this.getControllerVisual(e[0], 'color', n),
          offset: 0,
        })
        for (var s = 1; s < i; s++) {
          var l = e[0] + o * s
          if (l > e[1]) break
          a.push({
            color: this.getControllerVisual(l, 'color', n),
            offset: s / i,
          })
        }
        return (
          a.push({
            color: this.getControllerVisual(e[1], 'color', n),
            offset: 1,
          }),
          a
        )
      }),
      (t.prototype._createBarPoints = function (e, n) {
        var i = this.visualMapModel.itemSize
        return [
          [i[0] - n[0], e[0]],
          [i[0], e[0]],
          [i[0], e[1]],
          [i[0] - n[1], e[1]],
        ]
      }),
      (t.prototype._createBarGroup = function (e) {
        var n = this._orient,
          i = this.visualMapModel.get('inverse')
        return new Ht(
          n === 'horizontal' && !i
            ? {
                scaleX: e === 'bottom' ? 1 : -1,
                rotation: Math.PI / 2,
              }
            : n === 'horizontal' && i
            ? {
                scaleX: e === 'bottom' ? -1 : 1,
                rotation: -Math.PI / 2,
              }
            : n === 'vertical' && !i
            ? {
                scaleX: e === 'left' ? 1 : -1,
                scaleY: -1,
              }
            : {
                scaleX: e === 'left' ? 1 : -1,
              },
        )
      }),
      (t.prototype._updateHandle = function (e, n) {
        if (this._useHandle) {
          var i = this._shapes,
            a = this.visualMapModel,
            o = i.handleThumbs,
            s = i.handleLabels,
            l = a.itemSize,
            u = a.getExtent()
          F1t(
            [0, 1],
            function (c) {
              var h = o[c]
              h.setStyle('fill', n.handlesColor[c]), (h.y = e[c])
              var f = Ga(e[c], [0, l[1]], u, !0),
                d = this.getControllerVisual(f, 'symbolSize')
              ;(h.scaleX = h.scaleY = d / l[0]), (h.x = l[0] - d / 2)
              var p = ba(i.handleLabelPoints[c], Nu(h, this.group))
              s[c].setStyle({
                x: p[0],
                y: p[1],
                text: a.formatValueText(this._dataInterval[c]),
                verticalAlign: 'middle',
                align:
                  this._orient === 'vertical'
                    ? this._applyTransform('left', i.mainGroup)
                    : 'center',
              })
            },
            this,
          )
        }
      }),
      (t.prototype._showIndicator = function (e, n, i, a) {
        var o = this.visualMapModel,
          s = o.getExtent(),
          l = o.itemSize,
          u = [0, l[1]],
          c = this._shapes,
          h = c.indicator
        if (h) {
          h.attr('invisible', !1)
          var f = {
              convertOpacityToAlpha: !0,
            },
            d = this.getControllerVisual(e, 'color', f),
            p = this.getControllerVisual(e, 'symbolSize'),
            g = Ga(e, s, u, !0),
            v = l[0] - p / 2,
            m = {
              x: h.x,
              y: h.y,
            }
          ;(h.y = g), (h.x = v)
          var y = ba(c.indicatorLabelPoint, Nu(h, this.group)),
            _ = c.indicatorLabel
          _.attr('invisible', !1)
          var x = this._applyTransform('left', c.mainGroup),
            A = this._orient,
            S = A === 'horizontal'
          _.setStyle({
            text: (i || '') + o.formatValueText(n),
            verticalAlign: S ? x : 'middle',
            align: S ? 'center' : x,
          })
          var b = {
              x: v,
              y: g,
              style: {
                fill: d,
              },
            },
            T = {
              style: {
                x: y[0],
                y: y[1],
              },
            }
          if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
            var w = {
              duration: 100,
              easing: 'cubicInOut',
              additive: !0,
            }
            ;(h.x = m.x), (h.y = m.y), h.animateTo(b, w), _.animateTo(T, w)
          } else h.attr(b), _.attr(T)
          this._firstShowIndicator = !1
          var M = this._shapes.handleLabels
          if (M) for (var C = 0; C < M.length; C++) this.api.enterBlur(M[C])
        }
      }),
      (t.prototype._enableHoverLinkToSeries = function () {
        var e = this
        this._shapes.mainGroup
          .on('mousemove', function (n) {
            if (((e._hovering = !0), !e._dragging)) {
              var i = e.visualMapModel.itemSize,
                a = e._applyTransform(
                  [n.offsetX, n.offsetY],
                  e._shapes.mainGroup,
                  !0,
                  !0,
                )
              ;(a[1] = ak(oA(0, a[1]), i[1])),
                e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0])
            }
          })
          .on('mouseout', function () {
            ;(e._hovering = !1), !e._dragging && e._clearHoverLinkToSeries()
          })
      }),
      (t.prototype._enableHoverLinkFromSeries = function () {
        var e = this.api.getZr()
        this.visualMapModel.option.hoverLink
          ? (e.on('mouseover', this._hoverLinkFromSeriesMouseOver, this),
            e.on('mouseout', this._hideIndicator, this))
          : this._clearHoverLinkFromSeries()
      }),
      (t.prototype._doHoverLinkToSeries = function (e, n) {
        var i = this.visualMapModel,
          a = i.itemSize
        if (i.option.hoverLink) {
          var o = [0, a[1]],
            s = i.getExtent()
          e = ak(oA(o[0], e), o[1])
          var l = G1t(i, s, o),
            u = [e - l, e + l],
            c = Ga(e, o, s, !0),
            h = [Ga(u[0], o, s, !0), Ga(u[1], o, s, !0)]
          u[0] < o[0] && (h[0] = -1 / 0),
            u[1] > o[1] && (h[1] = 1 / 0),
            n &&
              (h[0] === -1 / 0
                ? this._showIndicator(c, h[1], '< ', l)
                : h[1] === 1 / 0
                ? this._showIndicator(c, h[0], '> ', l)
                : this._showIndicator(c, c, '≈ ', l))
          var f = this._hoverLinkDataIndices,
            d = []
          ;(n || sk(i)) &&
            (d = this._hoverLinkDataIndices = i.findTargetDataIndices(h))
          var p = Ett(f, d)
          this._dispatchHighDown('downplay', cy(p[0], i)),
            this._dispatchHighDown('highlight', cy(p[1], i))
        }
      }),
      (t.prototype._hoverLinkFromSeriesMouseOver = function (e) {
        var n
        if (
          (xu(
            e.target,
            function (l) {
              var u = Wt(l)
              if (u.dataIndex != null) return (n = u), !0
            },
            !0,
          ),
          !!n)
        ) {
          var i = this.ecModel.getSeriesByIndex(n.seriesIndex),
            a = this.visualMapModel
          if (a.isTargetSeries(i)) {
            var o = i.getData(n.dataType),
              s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex)
            isNaN(s) || this._showIndicator(s, s)
          }
        }
      }),
      (t.prototype._hideIndicator = function () {
        var e = this._shapes
        e.indicator && e.indicator.attr('invisible', !0),
          e.indicatorLabel && e.indicatorLabel.attr('invisible', !0)
        var n = this._shapes.handleLabels
        if (n) for (var i = 0; i < n.length; i++) this.api.leaveBlur(n[i])
      }),
      (t.prototype._clearHoverLinkToSeries = function () {
        this._hideIndicator()
        var e = this._hoverLinkDataIndices
        this._dispatchHighDown('downplay', cy(e, this.visualMapModel)),
          (e.length = 0)
      }),
      (t.prototype._clearHoverLinkFromSeries = function () {
        this._hideIndicator()
        var e = this.api.getZr()
        e.off('mouseover', this._hoverLinkFromSeriesMouseOver),
          e.off('mouseout', this._hideIndicator)
      }),
      (t.prototype._applyTransform = function (e, n, i, a) {
        var o = Nu(n, a ? null : this.group)
        return at(e) ? ba(e, o, i) : s_(e, o, i)
      }),
      (t.prototype._dispatchHighDown = function (e, n) {
        n &&
          n.length &&
          this.api.dispatchAction({
            type: e,
            batch: n,
          })
      }),
      (t.prototype.dispose = function () {
        this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
      }),
      (t.type = 'visualMap.continuous'),
      t
    )
  })(ZH)
function ok(r, t, e, n) {
  return new si({
    shape: {
      points: r,
    },
    draggable: !!e,
    cursor: t,
    drift: e,
    onmousemove: function (i) {
      jo(i.event)
    },
    ondragend: n,
  })
}
function G1t(r, t, e) {
  var n = z1t / 2,
    i = r.get('hoverLinkDataSize')
  return i && (n = Ga(i, t, e, !0) / 2), n
}
function sk(r) {
  var t = r.get('hoverLinkOnHandle')
  return !!(t ?? r.get('realtime'))
}
function lk(r) {
  return r === 'vertical' ? 'ns-resize' : 'ew-resize'
}
const H1t = V1t
var W1t = {
    type: 'selectDataRange',
    event: 'dataRangeSelected',
    update: 'update',
  },
  X1t = function (r, t) {
    t.eachComponent(
      {
        mainType: 'visualMap',
        query: r,
      },
      function (e) {
        e.setSelected(r.selected)
      },
    )
  },
  Y1t = [
    {
      createOnAllSeries: !0,
      reset: function (r, t) {
        var e = []
        return (
          t.eachComponent('visualMap', function (n) {
            var i = r.pipelineContext
            !n.isTargetSeries(r) ||
              (i && i.large) ||
              e.push(
                U_t(
                  n.stateList,
                  n.targetVisuals,
                  Tt(n.getValueState, n),
                  n.getDataDimensionIndex(r.getData()),
                ),
              )
          }),
          e
        )
      },
    },
    {
      createOnAllSeries: !0,
      reset: function (r, t) {
        var e = r.getData(),
          n = []
        t.eachComponent('visualMap', function (i) {
          if (i.isTargetSeries(r)) {
            var a = i.getVisualMeta(Tt($1t, null, r, i)) || {
                stops: [],
                outerColors: [],
              },
              o = i.getDataDimensionIndex(e)
            o >= 0 && ((a.dimension = o), n.push(a))
          }
        }),
          r.getData().setVisual('visualMeta', n)
      },
    },
  ]
function $1t(r, t, e, n) {
  for (
    var i = t.targetVisuals[n],
      a = vr.prepareVisualTypes(i),
      o = {
        color: bv(r.getData(), 'color'),
      },
      s = 0,
      l = a.length;
    s < l;
    s++
  ) {
    var u = a[s],
      c = i[u === 'opacity' ? '__alphaForOpacity' : u]
    c && c.applyVisual(e, h, f)
  }
  return o.color
  function h(d) {
    return o[d]
  }
  function f(d, p) {
    o[d] = p
  }
}
var uk = R
function q1t(r) {
  var t = r && r.visualMap
  at(t) || (t = t ? [t] : []),
    uk(t, function (e) {
      if (e) {
        nh(e, 'splitList') &&
          !nh(e, 'pieces') &&
          ((e.pieces = e.splitList), delete e.splitList)
        var n = e.pieces
        n &&
          at(n) &&
          uk(n, function (i) {
            Ut(i) &&
              (nh(i, 'start') && !nh(i, 'min') && (i.min = i.start),
              nh(i, 'end') && !nh(i, 'max') && (i.max = i.end))
          })
      }
    })
}
function nh(r, t) {
  return r && r.hasOwnProperty && r.hasOwnProperty(t)
}
var ck = !1
function jH(r) {
  ck ||
    ((ck = !0),
    r.registerSubTypeDefaulter('visualMap', function (t) {
      return !t.categories &&
        (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable)
        ? 'continuous'
        : 'piecewise'
    }),
    r.registerAction(W1t, X1t),
    R(Y1t, function (t) {
      r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, t)
    }),
    r.registerPreprocessor(q1t))
}
function JH(r) {
  r.registerComponentModel(k1t), r.registerComponentView(H1t), jH(r)
}
var Z1t = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = t.type), (e._pieceList = []), e
    }
    return (
      (t.prototype.optionUpdated = function (e, n) {
        r.prototype.optionUpdated.apply(this, arguments), this.resetExtent()
        var i = (this._mode = this._determineMode())
        ;(this._pieceList = []),
          K1t[this._mode].call(this, this._pieceList),
          this._resetSelected(e, n)
        var a = this.option.categories
        this.resetVisual(function (o, s) {
          i === 'categories'
            ? ((o.mappingMethod = 'category'), (o.categories = Vt(a)))
            : ((o.dataExtent = this.getExtent()),
              (o.mappingMethod = 'piecewise'),
              (o.pieceList = st(this._pieceList, function (l) {
                return (l = Vt(l)), s !== 'inRange' && (l.visual = null), l
              })))
        })
      }),
      (t.prototype.completeVisualOption = function () {
        var e = this.option,
          n = {},
          i = vr.listVisualTypes(),
          a = this.isCategory()
        R(e.pieces, function (s) {
          R(i, function (l) {
            s.hasOwnProperty(l) && (n[l] = 1)
          })
        }),
          R(
            n,
            function (s, l) {
              var u = !1
              R(
                this.stateList,
                function (c) {
                  u = u || o(e, c, l) || o(e.target, c, l)
                },
                this,
              ),
                !u &&
                  R(this.stateList, function (c) {
                    ;(e[c] || (e[c] = {}))[l] = qH.get(
                      l,
                      c === 'inRange' ? 'active' : 'inactive',
                      a,
                    )
                  })
            },
            this,
          )
        function o(s, l, u) {
          return s && s[l] && s[l].hasOwnProperty(u)
        }
        r.prototype.completeVisualOption.apply(this, arguments)
      }),
      (t.prototype._resetSelected = function (e, n) {
        var i = this.option,
          a = this._pieceList,
          o = (n ? i : e).selected || {}
        if (
          ((i.selected = o),
          R(
            a,
            function (l, u) {
              var c = this.getSelectedMapKey(l)
              o.hasOwnProperty(c) || (o[c] = !0)
            },
            this,
          ),
          i.selectedMode === 'single')
        ) {
          var s = !1
          R(
            a,
            function (l, u) {
              var c = this.getSelectedMapKey(l)
              o[c] && (s ? (o[c] = !1) : (s = !0))
            },
            this,
          )
        }
      }),
      (t.prototype.getItemSymbol = function () {
        return this.get('itemSymbol')
      }),
      (t.prototype.getSelectedMapKey = function (e) {
        return this._mode === 'categories' ? e.value + '' : e.index + ''
      }),
      (t.prototype.getPieceList = function () {
        return this._pieceList
      }),
      (t.prototype._determineMode = function () {
        var e = this.option
        return e.pieces && e.pieces.length > 0
          ? 'pieces'
          : this.option.categories
          ? 'categories'
          : 'splitNumber'
      }),
      (t.prototype.setSelected = function (e) {
        this.option.selected = Vt(e)
      }),
      (t.prototype.getValueState = function (e) {
        var n = vr.findPieceIndex(e, this._pieceList)
        return n != null &&
          this.option.selected[this.getSelectedMapKey(this._pieceList[n])]
          ? 'inRange'
          : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var n = [],
          i = this._pieceList
        return (
          this.eachTargetSeries(function (a) {
            var o = [],
              s = a.getData()
            s.each(
              this.getDataDimensionIndex(s),
              function (l, u) {
                var c = vr.findPieceIndex(l, i)
                c === e && o.push(u)
              },
              this,
            ),
              n.push({
                seriesId: a.id,
                dataIndex: o,
              })
          }, this),
          n
        )
      }),
      (t.prototype.getRepresentValue = function (e) {
        var n
        if (this.isCategory()) n = e.value
        else if (e.value != null) n = e.value
        else {
          var i = e.interval || []
          n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
        }
        return n
      }),
      (t.prototype.getVisualMeta = function (e) {
        if (this.isCategory()) return
        var n = [],
          i = ['', ''],
          a = this
        function o(c, h) {
          var f = a.getRepresentValue({
            interval: c,
          })
          h || (h = a.getValueState(f))
          var d = e(f, h)
          c[0] === -1 / 0
            ? (i[0] = d)
            : c[1] === 1 / 0
            ? (i[1] = d)
            : n.push(
                {
                  value: c[0],
                  color: d,
                },
                {
                  value: c[1],
                  color: d,
                },
              )
        }
        var s = this._pieceList.slice()
        if (!s.length)
          s.push({
            interval: [-1 / 0, 1 / 0],
          })
        else {
          var l = s[0].interval[0]
          l !== -1 / 0 &&
            s.unshift({
              interval: [-1 / 0, l],
            }),
            (l = s[s.length - 1].interval[1]),
            l !== 1 / 0 &&
              s.push({
                interval: [l, 1 / 0],
              })
        }
        var u = -1 / 0
        return (
          R(
            s,
            function (c) {
              var h = c.interval
              h &&
                (h[0] > u && o([u, h[0]], 'outOfRange'),
                o(h.slice()),
                (u = h[1]))
            },
            this,
          ),
          {
            stops: n,
            outerColors: i,
          }
        )
      }),
      (t.type = 'visualMap.piecewise'),
      (t.defaultOption = gl(M0.defaultOption, {
        selected: null,
        minOpen: !1,
        maxOpen: !1,
        align: 'auto',
        itemWidth: 20,
        itemHeight: 14,
        itemSymbol: 'roundRect',
        pieces: null,
        categories: null,
        splitNumber: 5,
        selectedMode: 'multiple',
        itemGap: 10,
        hoverLink: !0,
      })),
      t
    )
  })(M0),
  K1t = {
    splitNumber: function (r) {
      var t = this.option,
        e = Math.min(t.precision, 20),
        n = this.getExtent(),
        i = t.splitNumber
      ;(i = Math.max(parseInt(i, 10), 1)), (t.splitNumber = i)
      for (var a = (n[1] - n[0]) / i; +a.toFixed(e) !== a && e < 5; ) e++
      ;(t.precision = e),
        (a = +a.toFixed(e)),
        t.minOpen &&
          r.push({
            interval: [-1 / 0, n[0]],
            close: [0, 0],
          })
      for (var o = 0, s = n[0]; o < i; s += a, o++) {
        var l = o === i - 1 ? n[1] : s + a
        r.push({
          interval: [s, l],
          close: [1, 1],
        })
      }
      t.maxOpen &&
        r.push({
          interval: [n[1], 1 / 0],
          close: [0, 0],
        }),
        rP(r),
        R(
          r,
          function (u, c) {
            ;(u.index = c), (u.text = this.formatValueText(u.interval))
          },
          this,
        )
    },
    categories: function (r) {
      var t = this.option
      R(
        t.categories,
        function (e) {
          r.push({
            text: this.formatValueText(e, !0),
            value: e,
          })
        },
        this,
      ),
        hk(t, r)
    },
    pieces: function (r) {
      var t = this.option
      R(
        t.pieces,
        function (e, n) {
          Ut(e) ||
            (e = {
              value: e,
            })
          var i = {
            text: '',
            index: n,
          }
          if (
            (e.label != null && (i.text = e.label), e.hasOwnProperty('value'))
          ) {
            var a = (i.value = e.value)
            ;(i.interval = [a, a]), (i.close = [1, 1])
          } else {
            for (
              var o = (i.interval = []),
                s = (i.close = [0, 0]),
                l = [1, 0, 1],
                u = [-1 / 0, 1 / 0],
                c = [],
                h = 0;
              h < 2;
              h++
            ) {
              for (
                var f = [
                    ['gte', 'gt', 'min'],
                    ['lte', 'lt', 'max'],
                  ][h],
                  d = 0;
                d < 3 && o[h] == null;
                d++
              )
                (o[h] = e[f[d]]), (s[h] = l[d]), (c[h] = d === 2)
              o[h] == null && (o[h] = u[h])
            }
            c[0] && o[1] === 1 / 0 && (s[0] = 0),
              c[1] && o[0] === -1 / 0 && (s[1] = 0),
              o[0] === o[1] && s[0] && s[1] && (i.value = o[0])
          }
          ;(i.visual = vr.retrieveVisuals(e)), r.push(i)
        },
        this,
      ),
        hk(t, r),
        rP(r),
        R(
          r,
          function (e) {
            var n = e.close,
              i = [['<', '≤'][n[1]], ['>', '≥'][n[0]]]
            e.text =
              e.text ||
              this.formatValueText(
                e.value != null ? e.value : e.interval,
                !1,
                i,
              )
          },
          this,
        )
    },
  }
function hk(r, t) {
  var e = r.inverse
  ;(r.orient === 'vertical' ? !e : e) && t.reverse()
}
const j1t = Z1t
var J1t = (function (r) {
  X(t, r)
  function t() {
    var e = (r !== null && r.apply(this, arguments)) || this
    return (e.type = t.type), e
  }
  return (
    (t.prototype.doRender = function () {
      var e = this.group
      e.removeAll()
      var n = this.visualMapModel,
        i = n.get('textGap'),
        a = n.textStyleModel,
        o = a.getFont(),
        s = a.getTextColor(),
        l = this._getItemAlign(),
        u = n.itemSize,
        c = this._getViewData(),
        h = c.endsText,
        f = nr(n.get('showLabel', !0), !h)
      h && this._renderEndsText(e, h[0], u, f, l),
        R(
          c.viewPieceList,
          function (d) {
            var p = d.piece,
              g = new Ht()
            ;(g.onclick = Tt(this._onItemClick, this, p)),
              this._enableHoverLink(g, d.indexInModelPieceList)
            var v = n.getRepresentValue(p)
            if ((this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), f)) {
              var m = this.visualMapModel.getValueState(v)
              g.add(
                new Ae({
                  style: {
                    x: l === 'right' ? -i : u[0] + i,
                    y: u[1] / 2,
                    text: p.text,
                    verticalAlign: 'middle',
                    align: l,
                    font: o,
                    fill: s,
                    opacity: m === 'outOfRange' ? 0.5 : 1,
                  },
                }),
              )
            }
            e.add(g)
          },
          this,
        ),
        h && this._renderEndsText(e, h[1], u, f, l),
        ku(n.get('orient'), e, n.get('itemGap')),
        this.renderBackground(e),
        this.positionGroup(e)
    }),
    (t.prototype._enableHoverLink = function (e, n) {
      var i = this
      e.on('mouseover', function () {
        return a('highlight')
      }).on('mouseout', function () {
        return a('downplay')
      })
      var a = function (o) {
        var s = i.visualMapModel
        s.option.hoverLink &&
          i.api.dispatchAction({
            type: o,
            batch: cy(s.findTargetDataIndices(n), s),
          })
      }
    }),
    (t.prototype._getItemAlign = function () {
      var e = this.visualMapModel,
        n = e.option
      if (n.orient === 'vertical') return KH(e, this.api, e.itemSize)
      var i = n.align
      return (!i || i === 'auto') && (i = 'left'), i
    }),
    (t.prototype._renderEndsText = function (e, n, i, a, o) {
      if (n) {
        var s = new Ht(),
          l = this.visualMapModel.textStyleModel
        s.add(
          new Ae({
            style: $e(l, {
              x: a ? (o === 'right' ? i[0] : 0) : i[0] / 2,
              y: i[1] / 2,
              verticalAlign: 'middle',
              align: a ? o : 'center',
              text: n,
            }),
          }),
        ),
          e.add(s)
      }
    }),
    (t.prototype._getViewData = function () {
      var e = this.visualMapModel,
        n = st(e.getPieceList(), function (s, l) {
          return {
            piece: s,
            indexInModelPieceList: l,
          }
        }),
        i = e.get('text'),
        a = e.get('orient'),
        o = e.get('inverse')
      return (
        (a === 'horizontal' ? o : !o)
          ? n.reverse()
          : i && (i = i.slice().reverse()),
        {
          viewPieceList: n,
          endsText: i,
        }
      )
    }),
    (t.prototype._createItemSymbol = function (e, n, i) {
      e.add(
        Rn(
          this.getControllerVisual(n, 'symbol'),
          i[0],
          i[1],
          i[2],
          i[3],
          this.getControllerVisual(n, 'color'),
        ),
      )
    }),
    (t.prototype._onItemClick = function (e) {
      var n = this.visualMapModel,
        i = n.option,
        a = i.selectedMode
      if (a) {
        var o = Vt(i.selected),
          s = n.getSelectedMapKey(e)
        a === 'single' || a === !0
          ? ((o[s] = !0),
            R(o, function (l, u) {
              o[u] = u === s
            }))
          : (o[s] = !o[s]),
          this.api.dispatchAction({
            type: 'selectDataRange',
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: o,
          })
      }
    }),
    (t.type = 'visualMap.piecewise'),
    t
  )
})(ZH)
const Q1t = J1t
function QH(r) {
  r.registerComponentModel(j1t), r.registerComponentView(Q1t), jH(r)
}
function tSt(r) {
  ie(JH), ie(QH)
}
var eSt = {
    label: {
      enabled: !0,
    },
    decal: {
      show: !1,
    },
  },
  fk = ve(),
  nSt = {}
function rSt(r, t) {
  var e = r.getModel('aria')
  if (!e.get('enabled')) return
  var n = Vt(eSt)
  te(n.label, r.getLocaleModel().get('aria'), !1), te(e.option, n, !1), i(), a()
  function i() {
    var u = e.getModel('decal'),
      c = u.get('show')
    if (c) {
      var h = Pt()
      r.eachSeries(function (f) {
        if (!f.isColorBySeries()) {
          var d = h.get(f.type)
          d || ((d = {}), h.set(f.type, d)), (fk(f).scope = d)
        }
      }),
        r.eachRawSeries(function (f) {
          if (r.isSeriesFiltered(f)) return
          if (Nt(f.enableAriaDecal)) {
            f.enableAriaDecal()
            return
          }
          var d = f.getData()
          if (f.isColorBySeries()) {
            var y = fw(f.ecModel, f.name, nSt, r.getSeriesCount()),
              _ = d.getVisual('decal')
            d.setVisual('decal', x(_, y))
          } else {
            var p = f.getRawData(),
              g = {},
              v = fk(f).scope
            d.each(function (A) {
              var S = d.getRawIndex(A)
              g[S] = A
            })
            var m = p.count()
            p.each(function (A) {
              var S = g[A],
                b = p.getName(A) || A + '',
                T = fw(f.ecModel, b, v, m),
                w = d.getItemVisual(S, 'decal')
              d.setItemVisual(S, 'decal', x(w, T))
            })
          }
          function x(A, S) {
            var b = A ? Q(Q({}, S), A) : S
            return (b.dirty = !0), b
          }
        })
    }
  }
  function a() {
    var u = t.getZr().dom
    if (u) {
      var c = r.getLocaleModel().get('aria'),
        h = e.getModel('label')
      if (((h.option = zt(h.option, c)), !!h.get('enabled'))) {
        if (h.get('description')) {
          u.setAttribute('aria-label', h.get('description'))
          return
        }
        var f = r.getSeriesCount(),
          d = h.get(['data', 'maxCount']) || 10,
          p = h.get(['series', 'maxCount']) || 10,
          g = Math.min(f, p),
          v
        if (!(f < 1)) {
          var m = s()
          if (m) {
            var y = h.get(['general', 'withTitle'])
            v = o(y, {
              title: m,
            })
          } else v = h.get(['general', 'withoutTitle'])
          var _ = [],
            x =
              f > 1
                ? h.get(['series', 'multiple', 'prefix'])
                : h.get(['series', 'single', 'prefix'])
          ;(v += o(x, {
            seriesCount: f,
          })),
            r.eachSeries(function (T, w) {
              if (w < g) {
                var M = void 0,
                  C = T.get('name'),
                  E = C ? 'withName' : 'withoutName'
                ;(M =
                  f > 1
                    ? h.get(['series', 'multiple', E])
                    : h.get(['series', 'single', E])),
                  (M = o(M, {
                    seriesId: T.seriesIndex,
                    seriesName: T.get('name'),
                    seriesType: l(T.subType),
                  }))
                var D = T.getData()
                if (D.count() > d) {
                  var P = h.get(['data', 'partialData'])
                  M += o(P, {
                    displayCnt: d,
                  })
                } else M += h.get(['data', 'allData'])
                for (
                  var L = h.get(['data', 'separator', 'middle']),
                    I = h.get(['data', 'separator', 'end']),
                    F = [],
                    k = 0;
                  k < D.count();
                  k++
                )
                  if (k < d) {
                    var V = D.getName(k),
                      H = D.getValues(k),
                      Y = h.get(['data', V ? 'withName' : 'withoutName'])
                    F.push(
                      o(Y, {
                        name: V,
                        value: H.join(L),
                      }),
                    )
                  }
                ;(M += F.join(L) + I), _.push(M)
              }
            })
          var A = h.getModel(['series', 'multiple', 'separator']),
            S = A.get('middle'),
            b = A.get('end')
          ;(v += _.join(S) + b), u.setAttribute('aria-label', v)
        }
      }
    }
  }
  function o(u, c) {
    if (!bt(u)) return u
    var h = u
    return (
      R(c, function (f, d) {
        h = h.replace(new RegExp('\\{\\s*' + d + '\\s*\\}', 'g'), f)
      }),
      h
    )
  }
  function s() {
    var u = r.get('title')
    return u && u.length && (u = u[0]), u && u.text
  }
  function l(u) {
    var c = r.getLocaleModel().get(['series', 'typeNames'])
    return c[u] || c.chart
  }
}
function iSt(r) {
  if (!(!r || !r.aria)) {
    var t = r.aria
    t.show != null && (t.enabled = t.show),
      (t.label = t.label || {}),
      R(['description', 'general', 'series', 'data'], function (e) {
        t[e] != null && (t.label[e] = t[e])
      })
  }
}
function aSt(r) {
  r.registerPreprocessor(iSt), r.registerVisual(r.PRIORITY.VISUAL.ARIA, rSt)
}
var dk = {
    value: 'eq',
    '<': 'lt',
    '<=': 'lte',
    '>': 'gt',
    '>=': 'gte',
    '=': 'eq',
    '!=': 'ne',
    '<>': 'ne',
  },
  oSt = (function () {
    function r(t) {
      var e = (this._condVal = bt(t) ? new RegExp(t) : BJ(t) ? t : null)
      if (e == null) {
        var n = ''
        Ce(n)
      }
    }
    return (
      (r.prototype.evaluate = function (t) {
        var e = typeof t
        return bt(e)
          ? this._condVal.test(t)
          : be(e)
          ? this._condVal.test(t + '')
          : !1
      }),
      r
    )
  })(),
  sSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        return this.value
      }),
      r
    )
  })(),
  lSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (var t = this.children, e = 0; e < t.length; e++)
          if (!t[e].evaluate()) return !1
        return !0
      }),
      r
    )
  })(),
  uSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (var t = this.children, e = 0; e < t.length; e++)
          if (t[e].evaluate()) return !0
        return !1
      }),
      r
    )
  })(),
  cSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        return !this.child.evaluate()
      }),
      r
    )
  })(),
  hSt = (function () {
    function r() {}
    return (
      (r.prototype.evaluate = function () {
        for (
          var t = !!this.valueParser,
            e = this.getValue,
            n = e(this.valueGetterParam),
            i = t ? this.valueParser(n) : null,
            a = 0;
          a < this.subCondList.length;
          a++
        )
          if (!this.subCondList[a].evaluate(t ? i : n)) return !1
        return !0
      }),
      r
    )
  })()
function RE(r, t) {
  if (r === !0 || r === !1) {
    var e = new sSt()
    return (e.value = r), e
  }
  var n = ''
  return (
    t8(r) || Ce(n),
    r.and
      ? pk('and', r, t)
      : r.or
      ? pk('or', r, t)
      : r.not
      ? fSt(r, t)
      : dSt(r, t)
  )
}
function pk(r, t, e) {
  var n = t[r],
    i = ''
  at(n) || Ce(i), n.length || Ce(i)
  var a = r === 'and' ? new lSt() : new uSt()
  return (
    (a.children = st(n, function (o) {
      return RE(o, e)
    })),
    a.children.length || Ce(i),
    a
  )
}
function fSt(r, t) {
  var e = r.not,
    n = ''
  t8(e) || Ce(n)
  var i = new cSt()
  return (i.child = RE(e, t)), i.child || Ce(n), i
}
function dSt(r, t) {
  for (
    var e = '',
      n = t.prepareGetValue(r),
      i = [],
      a = pe(r),
      o = r.parser,
      s = o ? T5(o) : null,
      l = 0;
    l < a.length;
    l++
  ) {
    var u = a[l]
    if (!(u === 'parser' || t.valueGetterAttrMap.get(u))) {
      var c = Et(dk, u) ? dk[u] : u,
        h = r[u],
        f = s ? s(h) : h,
        d = Xrt(c, f) || (c === 'reg' && new oSt(f))
      d || Ce(e), i.push(d)
    }
  }
  i.length || Ce(e)
  var p = new hSt()
  return (
    (p.valueGetterParam = n),
    (p.valueParser = s),
    (p.getValue = t.getValue),
    (p.subCondList = i),
    p
  )
}
function t8(r) {
  return Ut(r) && !Er(r)
}
var pSt = (function () {
  function r(t, e) {
    this._cond = RE(t, e)
  }
  return (
    (r.prototype.evaluate = function () {
      return this._cond.evaluate()
    }),
    r
  )
})()
function vSt(r, t) {
  return new pSt(r, t)
}
var gSt = {
    type: 'echarts:filter',
    transform: function (r) {
      for (
        var t = r.upstream,
          e,
          n = vSt(r.config, {
            valueGetterAttrMap: Pt({
              dimension: !0,
            }),
            prepareGetValue: function (s) {
              var l = '',
                u = s.dimension
              Et(s, 'dimension') || Ce(l)
              var c = t.getDimensionInfo(u)
              return (
                c || Ce(l),
                {
                  dimIdx: c.index,
                }
              )
            },
            getValue: function (s) {
              return t.retrieveValueFromItem(e, s.dimIdx)
            },
          }),
          i = [],
          a = 0,
          o = t.count();
        a < o;
        a++
      )
        (e = t.getRawDataItem(a)), n.evaluate() && i.push(e)
      return {
        data: i,
      }
    },
  },
  mSt = {
    type: 'echarts:sort',
    transform: function (r) {
      var t = r.upstream,
        e = r.config,
        n = '',
        i = ke(e)
      i.length || Ce(n)
      var a = []
      R(i, function (c) {
        var h = c.dimension,
          f = c.order,
          d = c.parser,
          p = c.incomparable
        if (
          (h == null && Ce(n),
          f !== 'asc' && f !== 'desc' && Ce(n),
          p && p !== 'min' && p !== 'max')
        ) {
          var g = ''
          Ce(g)
        }
        if (f !== 'asc' && f !== 'desc') {
          var v = ''
          Ce(v)
        }
        var m = t.getDimensionInfo(h)
        m || Ce(n)
        var y = d ? T5(d) : null
        d && !y && Ce(n),
          a.push({
            dimIdx: m.index,
            parser: y,
            comparator: new E5(f, p),
          })
      })
      var o = t.sourceFormat
      o !== Dr && o !== aa && Ce(n)
      for (var s = [], l = 0, u = t.count(); l < u; l++)
        s.push(t.getRawDataItem(l))
      return (
        s.sort(function (c, h) {
          for (var f = 0; f < a.length; f++) {
            var d = a[f],
              p = t.retrieveValueFromItem(c, d.dimIdx),
              g = t.retrieveValueFromItem(h, d.dimIdx)
            d.parser && ((p = d.parser(p)), (g = d.parser(g)))
            var v = d.comparator.evaluate(p, g)
            if (v !== 0) return v
          }
          return 0
        }),
        {
          data: s,
        }
      )
    },
  }
function ySt(r) {
  r.registerTransform(gSt), r.registerTransform(mSt)
}
var _St = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataset'), e
    }
    return (
      (t.prototype.init = function (e, n, i) {
        r.prototype.init.call(this, e, n, i),
          (this._sourceManager = new R5(this)),
          vR(this)
      }),
      (t.prototype.mergeOption = function (e, n) {
        r.prototype.mergeOption.call(this, e, n), vR(this)
      }),
      (t.prototype.optionUpdated = function () {
        this._sourceManager.dirty()
      }),
      (t.prototype.getSourceManager = function () {
        return this._sourceManager
      }),
      (t.type = 'dataset'),
      (t.defaultOption = {
        seriesLayoutBy: oo,
      }),
      t
    )
  })(xe),
  xSt = (function (r) {
    X(t, r)
    function t() {
      var e = (r !== null && r.apply(this, arguments)) || this
      return (e.type = 'dataset'), e
    }
    return (t.type = 'dataset'), t
  })(dn)
function SSt(r) {
  r.registerComponentModel(_St), r.registerComponentView(xSt)
}
var Ua = vo.CMD
function Sh(r, t) {
  return Math.abs(r - t) < 1e-5
}
function hM(r) {
  var t = r.data,
    e = r.len(),
    n = [],
    i,
    a = 0,
    o = 0,
    s = 0,
    l = 0
  function u(D, P) {
    i && i.length > 2 && n.push(i), (i = [D, P])
  }
  function c(D, P, L, I) {
    ;(Sh(D, L) && Sh(P, I)) || i.push(D, P, L, I, L, I)
  }
  function h(D, P, L, I, F, k) {
    var V = Math.abs(P - D),
      H = (Math.tan(V / 4) * 4) / 3,
      Y = P < D ? -1 : 1,
      K = Math.cos(D),
      ut = Math.sin(D),
      W = Math.cos(P),
      Z = Math.sin(P),
      ft = K * F + L,
      lt = ut * k + I,
      ct = W * F + L,
      At = Z * k + I,
      gt = F * H * Y,
      dt = k * H * Y
    i.push(ft - gt * ut, lt + dt * K, ct + gt * Z, At - dt * W, ct, At)
  }
  for (var f, d, p, g, v = 0; v < e; ) {
    var m = t[v++],
      y = v === 1
    switch (
      (y &&
        ((a = t[v]),
        (o = t[v + 1]),
        (s = a),
        (l = o),
        (m === Ua.L || m === Ua.C || m === Ua.Q) && (i = [s, l])),
      m)
    ) {
      case Ua.M:
        ;(a = s = t[v++]), (o = l = t[v++]), u(s, l)
        break
      case Ua.L:
        ;(f = t[v++]), (d = t[v++]), c(a, o, f, d), (a = f), (o = d)
        break
      case Ua.C:
        i.push(t[v++], t[v++], t[v++], t[v++], (a = t[v++]), (o = t[v++]))
        break
      case Ua.Q:
        ;(f = t[v++]),
          (d = t[v++]),
          (p = t[v++]),
          (g = t[v++]),
          i.push(
            a + (2 / 3) * (f - a),
            o + (2 / 3) * (d - o),
            p + (2 / 3) * (f - p),
            g + (2 / 3) * (d - g),
            p,
            g,
          ),
          (a = p),
          (o = g)
        break
      case Ua.A:
        var _ = t[v++],
          x = t[v++],
          A = t[v++],
          S = t[v++],
          b = t[v++],
          T = t[v++] + b
        v += 1
        var w = !t[v++]
        ;(f = Math.cos(b) * A + _),
          (d = Math.sin(b) * S + x),
          y ? ((s = f), (l = d), u(s, l)) : c(a, o, f, d),
          (a = Math.cos(T) * A + _),
          (o = Math.sin(T) * S + x)
        for (
          var M = ((w ? -1 : 1) * Math.PI) / 2, C = b;
          w ? C > T : C < T;
          C += M
        ) {
          var E = w ? Math.max(C + M, T) : Math.min(C + M, T)
          h(C, E, _, x, A, S)
        }
        break
      case Ua.R:
        ;(s = a = t[v++]),
          (l = o = t[v++]),
          (f = s + t[v++]),
          (d = l + t[v++]),
          u(f, l),
          c(f, l, f, d),
          c(f, d, s, d),
          c(s, d, s, l),
          c(s, l, f, l)
        break
      case Ua.Z:
        i && c(a, o, s, l), (a = s), (o = l)
        break
    }
  }
  return i && i.length > 2 && n.push(i), n
}
function fM(r, t, e, n, i, a, o, s, l, u) {
  if (Sh(r, e) && Sh(t, n) && Sh(i, o) && Sh(a, s)) {
    l.push(o, s)
    return
  }
  var c = 2 / u,
    h = c * c,
    f = o - r,
    d = s - t,
    p = Math.sqrt(f * f + d * d)
  ;(f /= p), (d /= p)
  var g = e - r,
    v = n - t,
    m = i - o,
    y = a - s,
    _ = g * g + v * v,
    x = m * m + y * y
  if (_ < h && x < h) {
    l.push(o, s)
    return
  }
  var A = f * g + d * v,
    S = -f * m - d * y,
    b = _ - A * A,
    T = x - S * S
  if (b < h && A >= 0 && T < h && S >= 0) {
    l.push(o, s)
    return
  }
  var w = [],
    M = []
  il(r, e, i, o, 0.5, w),
    il(t, n, a, s, 0.5, M),
    fM(w[0], M[0], w[1], M[1], w[2], M[2], w[3], M[3], l, u),
    fM(w[4], M[4], w[5], M[5], w[6], M[6], w[7], M[7], l, u)
}
function ASt(r, t) {
  var e = hM(r),
    n = []
  t = t || 1
  for (var i = 0; i < e.length; i++) {
    var a = e[i],
      o = [],
      s = a[0],
      l = a[1]
    o.push(s, l)
    for (var u = 2; u < a.length; ) {
      var c = a[u++],
        h = a[u++],
        f = a[u++],
        d = a[u++],
        p = a[u++],
        g = a[u++]
      fM(s, l, c, h, f, d, p, g, o, t), (s = p), (l = g)
    }
    n.push(o)
  }
  return n
}
function e8(r, t, e) {
  var n = r[t],
    i = r[1 - t],
    a = Math.abs(n / i),
    o = Math.ceil(Math.sqrt(a * e)),
    s = Math.floor(e / o)
  s === 0 && ((s = 1), (o = e))
  for (var l = [], u = 0; u < o; u++) l.push(s)
  var c = o * s,
    h = e - c
  if (h > 0) for (var u = 0; u < h; u++) l[u % o] += 1
  return l
}
function vk(r, t, e) {
  for (
    var n = r.r0,
      i = r.r,
      a = r.startAngle,
      o = r.endAngle,
      s = Math.abs(o - a),
      l = s * i,
      u = i - n,
      c = l > Math.abs(u),
      h = e8([l, u], c ? 0 : 1, t),
      f = (c ? s : u) / h.length,
      d = 0;
    d < h.length;
    d++
  )
    for (var p = (c ? u : s) / h[d], g = 0; g < h[d]; g++) {
      var v = {}
      c
        ? ((v.startAngle = a + f * d),
          (v.endAngle = a + f * (d + 1)),
          (v.r0 = n + p * g),
          (v.r = n + p * (g + 1)))
        : ((v.startAngle = a + p * g),
          (v.endAngle = a + p * (g + 1)),
          (v.r0 = n + f * d),
          (v.r = n + f * (d + 1))),
        (v.clockwise = r.clockwise),
        (v.cx = r.cx),
        (v.cy = r.cy),
        e.push(v)
    }
}
function bSt(r, t, e) {
  for (
    var n = r.width,
      i = r.height,
      a = n > i,
      o = e8([n, i], a ? 0 : 1, t),
      s = a ? 'width' : 'height',
      l = a ? 'height' : 'width',
      u = a ? 'x' : 'y',
      c = a ? 'y' : 'x',
      h = r[s] / o.length,
      f = 0;
    f < o.length;
    f++
  )
    for (var d = r[l] / o[f], p = 0; p < o[f]; p++) {
      var g = {}
      ;(g[u] = f * h),
        (g[c] = p * d),
        (g[s] = h),
        (g[l] = d),
        (g.x += r.x),
        (g.y += r.y),
        e.push(g)
    }
}
function gk(r, t, e, n) {
  return r * n - e * t
}
function wSt(r, t, e, n, i, a, o, s) {
  var l = e - r,
    u = n - t,
    c = o - i,
    h = s - a,
    f = gk(c, h, l, u)
  if (Math.abs(f) < 1e-6) return null
  var d = r - i,
    p = t - a,
    g = gk(d, p, c, h) / f
  return g < 0 || g > 1 ? null : new Qt(g * l + r, g * u + t)
}
function MSt(r, t, e) {
  var n = new Qt()
  Qt.sub(n, e, t), n.normalize()
  var i = new Qt()
  Qt.sub(i, r, t)
  var a = i.dot(n)
  return a
}
function rh(r, t) {
  var e = r[r.length - 1]
  ;(e && e[0] === t[0] && e[1] === t[1]) || r.push(t)
}
function TSt(r, t, e) {
  for (var n = r.length, i = [], a = 0; a < n; a++) {
    var o = r[a],
      s = r[(a + 1) % n],
      l = wSt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y)
    l &&
      i.push({
        projPt: MSt(l, t, e),
        pt: l,
        idx: a,
      })
  }
  if (i.length < 2)
    return [
      {
        points: r,
      },
      {
        points: r,
      },
    ]
  i.sort(function (v, m) {
    return v.projPt - m.projPt
  })
  var u = i[0],
    c = i[i.length - 1]
  if (c.idx < u.idx) {
    var h = u
    ;(u = c), (c = h)
  }
  for (
    var f = [u.pt.x, u.pt.y],
      d = [c.pt.x, c.pt.y],
      p = [f],
      g = [d],
      a = u.idx + 1;
    a <= c.idx;
    a++
  )
    rh(p, r[a].slice())
  rh(p, d), rh(p, f)
  for (var a = c.idx + 1; a <= u.idx + n; a++) rh(g, r[a % n].slice())
  return (
    rh(g, f),
    rh(g, d),
    [
      {
        points: p,
      },
      {
        points: g,
      },
    ]
  )
}
function mk(r) {
  var t = r.points,
    e = [],
    n = []
  e_(t, e, n)
  var i = new ee(e[0], e[1], n[0] - e[0], n[1] - e[1]),
    a = i.width,
    o = i.height,
    s = i.x,
    l = i.y,
    u = new Qt(),
    c = new Qt()
  return (
    a > o
      ? ((u.x = c.x = s + a / 2), (u.y = l), (c.y = l + o))
      : ((u.y = c.y = l + o / 2), (u.x = s), (c.x = s + a)),
    TSt(t, u, c)
  )
}
function T0(r, t, e, n) {
  if (e === 1) n.push(t)
  else {
    var i = Math.floor(e / 2),
      a = r(t)
    T0(r, a[0], i, n), T0(r, a[1], e - i, n)
  }
  return n
}
function CSt(r, t) {
  for (var e = [], n = 0; n < t; n++) e.push(ZT(r))
  return e
}
function ESt(r, t) {
  t.setStyle(r.style), (t.z = r.z), (t.z2 = r.z2), (t.zlevel = r.zlevel)
}
function DSt(r) {
  for (var t = [], e = 0; e < r.length; ) t.push([r[e++], r[e++]])
  return t
}
function LSt(r, t) {
  var e = [],
    n = r.shape,
    i
  switch (r.type) {
    case 'rect':
      bSt(n, t, e), (i = ge)
      break
    case 'sector':
      vk(n, t, e), (i = oi)
      break
    case 'circle':
      vk(
        {
          r0: 0,
          r: n.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: n.cx,
          cy: n.cy,
        },
        t,
        e,
      ),
        (i = oi)
      break
    default:
      var a = r.getComputedTransform(),
        o = a
          ? Math.sqrt(
              Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3]),
            )
          : 1,
        s = st(ASt(r.getUpdatedPathProxy(), o), function (m) {
          return DSt(m)
        }),
        l = s.length
      if (l === 0)
        T0(
          mk,
          {
            points: s[0],
          },
          t,
          e,
        )
      else if (l === t)
        for (var u = 0; u < l; u++)
          e.push({
            points: s[u],
          })
      else {
        var c = 0,
          h = st(s, function (m) {
            var y = [],
              _ = []
            e_(m, y, _)
            var x = (_[1] - y[1]) * (_[0] - y[0])
            return (
              (c += x),
              {
                poly: m,
                area: x,
              }
            )
          })
        h.sort(function (m, y) {
          return y.area - m.area
        })
        for (var f = t, u = 0; u < l; u++) {
          var d = h[u]
          if (f <= 0) break
          var p = u === l - 1 ? f : Math.ceil((d.area / c) * t)
          p < 0 ||
            (T0(
              mk,
              {
                points: d.poly,
              },
              p,
              e,
            ),
            (f -= p))
        }
      }
      i = si
      break
  }
  if (!i) return CSt(r, t)
  for (var g = [], u = 0; u < e.length; u++) {
    var v = new i()
    v.setShape(e[u]), ESt(r, v), g.push(v)
  }
  return g
}
function PSt(r, t) {
  var e = r.length,
    n = t.length
  if (e === n) return [r, t]
  for (
    var i = [],
      a = [],
      o = e < n ? r : t,
      s = Math.min(e, n),
      l = Math.abs(n - e) / 6,
      u = (s - 2) / 6,
      c = Math.ceil(l / u) + 1,
      h = [o[0], o[1]],
      f = l,
      d = 2;
    d < s;

  ) {
    var p = o[d - 2],
      g = o[d - 1],
      v = o[d++],
      m = o[d++],
      y = o[d++],
      _ = o[d++],
      x = o[d++],
      A = o[d++]
    if (f <= 0) {
      h.push(v, m, y, _, x, A)
      continue
    }
    for (var S = Math.min(f, c - 1) + 1, b = 1; b <= S; b++) {
      var T = b / S
      il(p, v, y, x, T, i),
        il(g, m, _, A, T, a),
        (p = i[3]),
        (g = a[3]),
        h.push(i[1], a[1], i[2], a[2], p, g),
        (v = i[5]),
        (m = a[5]),
        (y = i[6]),
        (_ = a[6])
    }
    f -= S - 1
  }
  return o === r ? [h, t] : [r, h]
}
function yk(r, t) {
  for (
    var e = r.length, n = r[e - 2], i = r[e - 1], a = [], o = 0;
    o < t.length;

  )
    (a[o++] = n), (a[o++] = i)
  return a
}
function RSt(r, t) {
  for (
    var e, n, i, a = [], o = [], s = 0;
    s < Math.max(r.length, t.length);
    s++
  ) {
    var l = r[s],
      u = t[s],
      c = void 0,
      h = void 0
    l
      ? u
        ? ((e = PSt(l, u)), (c = e[0]), (h = e[1]), (n = c), (i = h))
        : ((h = yk(i || l, l)), (c = l))
      : ((c = yk(n || u, u)), (h = u)),
      a.push(c),
      o.push(h)
  }
  return [a, o]
}
function _k(r) {
  for (
    var t = 0, e = 0, n = 0, i = r.length, a = 0, o = i - 2;
    a < i;
    o = a, a += 2
  ) {
    var s = r[o],
      l = r[o + 1],
      u = r[a],
      c = r[a + 1],
      h = s * c - u * l
    ;(t += h), (e += (s + u) * h), (n += (l + c) * h)
  }
  return t === 0 ? [r[0] || 0, r[1] || 0] : [e / t / 3, n / t / 3, t]
}
function ISt(r, t, e, n) {
  for (
    var i = (r.length - 2) / 6,
      a = 1 / 0,
      o = 0,
      s = r.length,
      l = s - 2,
      u = 0;
    u < i;
    u++
  ) {
    for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
      var d = f === 0 ? c : ((c + f - 2) % l) + 2,
        p = r[d] - e[0],
        g = r[d + 1] - e[1],
        v = t[f] - n[0],
        m = t[f + 1] - n[1],
        y = v - p,
        _ = m - g
      h += y * y + _ * _
    }
    h < a && ((a = h), (o = u))
  }
  return o
}
function OSt(r) {
  for (var t = [], e = r.length, n = 0; n < e; n += 2)
    (t[n] = r[e - n - 2]), (t[n + 1] = r[e - n - 1])
  return t
}
function NSt(r, t, e, n) {
  for (var i = [], a, o = 0; o < r.length; o++) {
    var s = r[o],
      l = t[o],
      u = _k(s),
      c = _k(l)
    a == null && (a = u[2] < 0 != c[2] < 0)
    var h = [],
      f = [],
      d = 0,
      p = 1 / 0,
      g = [],
      v = s.length
    a && (s = OSt(s))
    for (var m = ISt(s, l, u, c) * 6, y = v - 2, _ = 0; _ < y; _ += 2) {
      var x = ((m + _) % y) + 2
      ;(h[_ + 2] = s[x] - u[0]), (h[_ + 3] = s[x + 1] - u[1])
    }
    if (((h[0] = s[m] - u[0]), (h[1] = s[m + 1] - u[1]), e > 0))
      for (var A = n / e, S = -n / 2; S <= n / 2; S += A) {
        for (
          var b = Math.sin(S), T = Math.cos(S), w = 0, _ = 0;
          _ < s.length;
          _ += 2
        ) {
          var M = h[_],
            C = h[_ + 1],
            E = l[_] - c[0],
            D = l[_ + 1] - c[1],
            P = E * T - D * b,
            L = E * b + D * T
          ;(g[_] = P), (g[_ + 1] = L)
          var I = P - M,
            F = L - C
          w += I * I + F * F
        }
        if (w < p) {
          ;(p = w), (d = S)
          for (var k = 0; k < g.length; k++) f[k] = g[k]
        }
      }
    else
      for (var V = 0; V < v; V += 2)
        (f[V] = l[V] - c[0]), (f[V + 1] = l[V + 1] - c[1])
    i.push({
      from: h,
      to: f,
      fromCp: u,
      toCp: c,
      rotation: -d,
    })
  }
  return i
}
function C0(r) {
  return r.__isCombineMorphing
}
var n8 = '__mOriginal_'
function E0(r, t, e) {
  var n = n8 + t,
    i = r[n] || r[t]
  r[n] || (r[n] = r[t])
  var a = e.replace,
    o = e.after,
    s = e.before
  r[t] = function () {
    var l = arguments,
      u
    return (
      s && s.apply(this, l),
      a ? (u = a.apply(this, l)) : (u = i.apply(this, l)),
      o && o.apply(this, l),
      u
    )
  }
}
function vp(r, t) {
  var e = n8 + t
  r[e] && ((r[t] = r[e]), (r[e] = null))
}
function xk(r, t) {
  for (var e = 0; e < r.length; e++)
    for (var n = r[e], i = 0; i < n.length; ) {
      var a = n[i],
        o = n[i + 1]
      ;(n[i++] = t[0] * a + t[2] * o + t[4]),
        (n[i++] = t[1] * a + t[3] * o + t[5])
    }
}
function r8(r, t) {
  var e = r.getUpdatedPathProxy(),
    n = t.getUpdatedPathProxy(),
    i = RSt(hM(e), hM(n)),
    a = i[0],
    o = i[1],
    s = r.getComputedTransform(),
    l = t.getComputedTransform()
  function u() {
    this.transform = null
  }
  s && xk(a, s),
    l && xk(o, l),
    E0(t, 'updateTransform', {
      replace: u,
    }),
    (t.transform = null)
  var c = NSt(a, o, 10, Math.PI),
    h = []
  E0(t, 'buildPath', {
    replace: function (f) {
      for (var d = t.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
        var m = c[v],
          y = m.from,
          _ = m.to,
          x = m.rotation * d,
          A = m.fromCp,
          S = m.toCp,
          b = Math.sin(x),
          T = Math.cos(x)
        Ym(g, A, S, d)
        for (var w = 0; w < y.length; w += 2) {
          var M = y[w],
            C = y[w + 1],
            E = _[w],
            D = _[w + 1],
            P = M * p + E * d,
            L = C * p + D * d
          ;(h[w] = P * T - L * b + g[0]), (h[w + 1] = P * b + L * T + g[1])
        }
        var I = h[0],
          F = h[1]
        f.moveTo(I, F)
        for (var w = 2; w < y.length; ) {
          var E = h[w++],
            D = h[w++],
            k = h[w++],
            V = h[w++],
            H = h[w++],
            Y = h[w++]
          I === E && F === D && k === H && V === Y
            ? f.lineTo(H, Y)
            : f.bezierCurveTo(E, D, k, V, H, Y),
            (I = H),
            (F = Y)
        }
      }
    },
  })
}
function IE(r, t, e) {
  if (!r || !t) return t
  var n = e.done,
    i = e.during
  r8(r, t), (t.__morphT = 0)
  function a() {
    vp(t, 'buildPath'),
      vp(t, 'updateTransform'),
      (t.__morphT = -1),
      t.createPathProxy(),
      t.dirtyShape()
  }
  return (
    t.animateTo(
      {
        __morphT: 1,
      },
      zt(
        {
          during: function (o) {
            t.dirtyShape(), i && i(o)
          },
          done: function () {
            a(), n && n()
          },
        },
        e,
      ),
    ),
    t
  )
}
function kSt(r, t, e, n, i, a) {
  var o = 16
  ;(r = i === e ? 0 : Math.round((32767 * (r - e)) / (i - e))),
    (t = a === n ? 0 : Math.round((32767 * (t - n)) / (a - n)))
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0,
      h = 0
    ;(r & u) > 0 && (c = 1),
      (t & u) > 0 && (h = 1),
      (s += u * u * ((3 * c) ^ h)),
      h === 0 &&
        (c === 1 && ((r = u - 1 - r), (t = u - 1 - t)),
        (l = r),
        (r = t),
        (t = l))
  }
  return s
}
function D0(r) {
  var t = 1 / 0,
    e = 1 / 0,
    n = -1 / 0,
    i = -1 / 0,
    a = st(r, function (s) {
      var l = s.getBoundingRect(),
        u = s.getComputedTransform(),
        c = l.x + l.width / 2 + (u ? u[4] : 0),
        h = l.y + l.height / 2 + (u ? u[5] : 0)
      return (
        (t = Math.min(c, t)),
        (e = Math.min(h, e)),
        (n = Math.max(c, n)),
        (i = Math.max(h, i)),
        [c, h]
      )
    }),
    o = st(a, function (s, l) {
      return {
        cp: s,
        z: kSt(s[0], s[1], t, e, n, i),
        path: r[l],
      }
    })
  return o
    .sort(function (s, l) {
      return s.z - l.z
    })
    .map(function (s) {
      return s.path
    })
}
function i8(r) {
  return LSt(r.path, r.count)
}
function dM() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0,
  }
}
function BSt(r, t, e) {
  var n = []
  function i(A) {
    for (var S = 0; S < A.length; S++) {
      var b = A[S]
      C0(b) ? i(b.childrenRef()) : b instanceof oe && n.push(b)
    }
  }
  i(r)
  var a = n.length
  if (!a) return dM()
  var o = e.dividePath || i8,
    s = o({
      path: t,
      count: a,
    })
  if (s.length !== a)
    return console.error('Invalid morphing: unmatched splitted path'), dM()
  ;(n = D0(n)), (s = D0(s))
  for (
    var l = e.done, u = e.during, c = e.individualDelay, h = new Uo(), f = 0;
    f < a;
    f++
  ) {
    var d = n[f],
      p = s[f]
    ;(p.parent = t), p.copyTransform(h), c || r8(d, p)
  }
  ;(t.__isCombineMorphing = !0),
    (t.childrenRef = function () {
      return s
    })
  function g(A) {
    for (var S = 0; S < s.length; S++) s[S].addSelfToZr(A)
  }
  E0(t, 'addSelfToZr', {
    after: function (A) {
      g(A)
    },
  }),
    E0(t, 'removeSelfFromZr', {
      after: function (A) {
        for (var S = 0; S < s.length; S++) s[S].removeSelfFromZr(A)
      },
    })
  function v() {
    ;(t.__isCombineMorphing = !1),
      (t.__morphT = -1),
      (t.childrenRef = null),
      vp(t, 'addSelfToZr'),
      vp(t, 'removeSelfFromZr')
  }
  var m = s.length
  if (c)
    for (
      var y = m,
        _ = function () {
          y--, y === 0 && (v(), l && l())
        },
        f = 0;
      f < m;
      f++
    ) {
      var x = c
        ? zt(
            {
              delay: (e.delay || 0) + c(f, m, n[f], s[f]),
              done: _,
            },
            e,
          )
        : e
      IE(n[f], s[f], x)
    }
  else
    (t.__morphT = 0),
      t.animateTo(
        {
          __morphT: 1,
        },
        zt(
          {
            during: function (A) {
              for (var S = 0; S < m; S++) {
                var b = s[S]
                ;(b.__morphT = t.__morphT), b.dirtyShape()
              }
              u && u(A)
            },
            done: function () {
              v()
              for (var A = 0; A < r.length; A++) vp(r[A], 'updateTransform')
              l && l()
            },
          },
          e,
        ),
      )
  return (
    t.__zr && g(t.__zr),
    {
      fromIndividuals: n,
      toIndividuals: s,
      count: m,
    }
  )
}
function FSt(r, t, e) {
  var n = t.length,
    i = [],
    a = e.dividePath || i8
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p]
      C0(g) ? o(g.childrenRef()) : g instanceof oe && i.push(g)
    }
  }
  if (C0(r)) {
    o(r.childrenRef())
    var s = i.length
    if (s < n) for (var l = 0, u = s; u < n; u++) i.push(ZT(i[l++ % s]))
    i.length = n
  } else {
    i = a({
      path: r,
      count: n,
    })
    for (var c = r.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c)
    if (i.length !== n)
      return console.error('Invalid morphing: unmatched splitted path'), dM()
  }
  ;(i = D0(i)), (t = D0(t))
  for (var h = e.individualDelay, u = 0; u < n; u++) {
    var f = h
      ? zt(
          {
            delay: (e.delay || 0) + h(u, n, i[u], t[u]),
          },
          e,
        )
      : e
    IE(i[u], t[u], f)
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length,
  }
}
function Sk(r) {
  return at(r[0])
}
function Ak(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++)
    e.push({
      one: r[i],
      many: [],
    })
  for (var i = 0; i < t.length; i++) {
    var a = t[i].length,
      o = void 0
    for (o = 0; o < a; o++) e[o % n].many.push(t[i][o])
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!e[i].many.length) {
      var l = e[s].many
      if (l.length <= 1)
        if (s) s = 0
        else return e
      var a = l.length,
        u = Math.ceil(a / 2)
      ;(e[i].many = l.slice(u, a)), (e[s].many = l.slice(0, u)), s++
    }
  return e
}
var zSt = {
  clone: function (r) {
    for (
      var t = [],
        e = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count),
        n = 0;
      n < r.count;
      n++
    ) {
      var i = ZT(r.path)
      i.setStyle('opacity', e), t.push(i)
    }
    return t
  },
  split: null,
}
function sA(r, t, e, n, i, a) {
  if (!r.length || !t.length) return
  var o = xf('update', n, i)
  if (!(o && o.duration > 0)) return
  var s = n.getModel('universalTransition').get('delay'),
    l = Object.assign(
      {
        setToFinal: !0,
      },
      o,
    ),
    u,
    c
  Sk(r) && ((u = r), (c = t)), Sk(t) && ((u = t), (c = r))
  function h(m, y, _, x, A) {
    var S = m.many,
      b = m.one
    if (S.length === 1 && !A) {
      var T = y ? S[0] : b,
        w = y ? b : S[0]
      if (C0(T))
        h(
          {
            many: [T],
            one: w,
          },
          !0,
          _,
          x,
          !0,
        )
      else {
        var M = s
          ? zt(
              {
                delay: s(_, x),
              },
              l,
            )
          : l
        IE(T, w, M), a(T, w, T, w, M)
      }
    } else
      for (
        var C = zt(
            {
              dividePath: zSt[e],
              individualDelay:
                s &&
                function (F, k, V, H) {
                  return s(F + _, x)
                },
            },
            l,
          ),
          E = y ? BSt(S, b, C) : FSt(b, S, C),
          D = E.fromIndividuals,
          P = E.toIndividuals,
          L = D.length,
          I = 0;
        I < L;
        I++
      ) {
        var M = s
          ? zt(
              {
                delay: s(I, L),
              },
              l,
            )
          : l
        a(D[I], P[I], y ? S[I] : m.one, y ? m.one : S[I], M)
      }
  }
  for (
    var f = u ? u === r : r.length > t.length,
      d = u ? Ak(c, u) : Ak(f ? t : r, [f ? r : t]),
      p = 0,
      g = 0;
    g < d.length;
    g++
  )
    p += d[g].many.length
  for (var v = 0, g = 0; g < d.length; g++)
    h(d[g], f, v, p), (v += d[g].many.length)
}
function lu(r) {
  if (!r) return []
  if (at(r)) {
    for (var t = [], e = 0; e < r.length; e++) t.push(lu(r[e]))
    return t
  }
  var n = []
  return (
    r.traverse(function (i) {
      i instanceof oe &&
        !i.disableMorphing &&
        !i.invisible &&
        !i.ignore &&
        n.push(i)
    }),
    n
  )
}
var a8 = 1e4,
  USt = 0,
  bk = 1,
  wk = 2,
  VSt = ve()
function GSt(r, t) {
  for (var e = r.dimensions, n = 0; n < e.length; n++) {
    var i = r.getDimensionInfo(e[n])
    if (i && i.otherDims[t] === 0) return e[n]
  }
}
function HSt(r, t, e) {
  var n = r.getDimensionInfo(e),
    i = n && n.ordinalMeta
  if (n) {
    var a = r.get(n.name, t)
    return (i && i.categories[a]) || a + ''
  }
}
function Mk(r, t, e, n) {
  var i = n ? 'itemChildGroupId' : 'itemGroupId',
    a = GSt(r, i)
  if (a) {
    var o = HSt(r, t, a)
    return o
  }
  var s = r.getRawDataItem(t),
    l = n ? 'childGroupId' : 'groupId'
  if (s && s[l]) return s[l] + ''
  if (!n) return e || r.getId(t)
}
function Tk(r) {
  var t = []
  return (
    R(r, function (e) {
      var n = e.data,
        i = e.dataGroupId
      if (!(n.count() > a8))
        for (var a = n.getIndices(), o = 0; o < a.length; o++)
          t.push({
            data: n,
            groupId: Mk(n, o, i, !1),
            childGroupId: Mk(n, o, i, !0),
            divide: e.divide,
            dataIndex: o,
          })
    }),
    t
  )
}
function lA(r, t, e) {
  r.traverse(function (n) {
    n instanceof oe &&
      Je(
        n,
        {
          style: {
            opacity: 0,
          },
        },
        t,
        {
          dataIndex: e,
          isFrom: !0,
        },
      )
  })
}
function uA(r) {
  if (r.parent) {
    var t = r.getComputedTransform()
    r.setLocalTransform(t), r.parent.remove(r)
  }
}
function ih(r) {
  r.stopAnimation(),
    r.isGroup &&
      r.traverse(function (t) {
        t.stopAnimation()
      })
}
function WSt(r, t, e) {
  var n = xf('update', e, t)
  n &&
    r.traverse(function (i) {
      if (i instanceof ea) {
        var a = wnt(i)
        a &&
          i.animateFrom(
            {
              style: a,
            },
            n,
          )
      }
    })
}
function XSt(r, t) {
  var e = r.length
  if (e !== t.length) return !1
  for (var n = 0; n < e; n++) {
    var i = r[n],
      a = t[n]
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return !1
  }
  return !0
}
function o8(r, t, e) {
  var n = Tk(r),
    i = Tk(t)
  function a(_, x, A, S, b) {
    ;(A || _) &&
      x.animateFrom(
        {
          style: A && A !== _ ? Q(Q({}, A.style), _.style) : _.style,
        },
        b,
      )
  }
  var o = !1,
    s = USt,
    l = Pt(),
    u = Pt()
  n.forEach(function (_) {
    _.groupId && l.set(_.groupId, !0),
      _.childGroupId && u.set(_.childGroupId, !0)
  })
  for (var c = 0; c < i.length; c++) {
    var h = i[c].groupId
    if (u.get(h)) {
      s = bk
      break
    }
    var f = i[c].childGroupId
    if (f && l.get(f)) {
      s = wk
      break
    }
  }
  function d(_, x) {
    return function (A) {
      var S = A.data,
        b = A.dataIndex
      return x
        ? S.getId(b)
        : _
        ? s === bk
          ? A.childGroupId
          : A.groupId
        : s === wk
        ? A.childGroupId
        : A.groupId
    }
  }
  var p = XSt(n, i),
    g = {}
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c],
        m = v.data.getItemGraphicEl(v.dataIndex)
      m && (g[m.id] = !0)
    }
  function y(_, x) {
    var A = n[x],
      S = i[_],
      b = S.data.hostModel,
      T = A.data.getItemGraphicEl(A.dataIndex),
      w = S.data.getItemGraphicEl(S.dataIndex)
    if (T === w) {
      w && WSt(w, S.dataIndex, b)
      return
    }
    ;(T && g[T.id]) ||
      (w &&
        (ih(w),
        T
          ? (ih(T), uA(T), (o = !0), sA(lu(T), lu(w), S.divide, b, _, a))
          : lA(w, b, _)))
  }
  new es(n, i, d(!0, p), d(!1, p), null, 'multiple')
    .update(y)
    .updateManyToOne(function (_, x) {
      var A = i[_],
        S = A.data,
        b = S.hostModel,
        T = S.getItemGraphicEl(A.dataIndex),
        w = Ne(
          st(x, function (M) {
            return n[M].data.getItemGraphicEl(n[M].dataIndex)
          }),
          function (M) {
            return M && M !== T && !g[M.id]
          },
        )
      T &&
        (ih(T),
        w.length
          ? (R(w, function (M) {
              ih(M), uA(M)
            }),
            (o = !0),
            sA(lu(w), lu(T), A.divide, b, _, a))
          : lA(T, b, A.dataIndex))
    })
    .updateOneToMany(function (_, x) {
      var A = n[x],
        S = A.data.getItemGraphicEl(A.dataIndex)
      if (!(S && g[S.id])) {
        var b = Ne(
            st(_, function (w) {
              return i[w].data.getItemGraphicEl(i[w].dataIndex)
            }),
            function (w) {
              return w && w !== S
            },
          ),
          T = i[_[0]].data.hostModel
        b.length &&
          (R(b, function (w) {
            return ih(w)
          }),
          S
            ? (ih(S), uA(S), (o = !0), sA(lu(S), lu(b), A.divide, T, _[0], a))
            : R(b, function (w) {
                return lA(w, T, _[0])
              }))
      }
    })
    .updateManyToMany(function (_, x) {
      new es(
        x,
        _,
        function (A) {
          return n[A].data.getId(n[A].dataIndex)
        },
        function (A) {
          return i[A].data.getId(i[A].dataIndex)
        },
      )
        .update(function (A, S) {
          y(_[A], x[S])
        })
        .execute()
    })
    .execute(),
    o &&
      R(t, function (_) {
        var x = _.data,
          A = x.hostModel,
          S = A && e.getViewOfSeriesModel(A),
          b = xf('update', A, 0)
        S &&
          A.isAnimationEnabled() &&
          b &&
          b.duration > 0 &&
          S.group.traverse(function (T) {
            T instanceof oe &&
              !T.animators.length &&
              T.animateFrom(
                {
                  style: {
                    opacity: 0,
                  },
                },
                b,
              )
          })
      })
}
function Ck(r) {
  var t = r.getModel('universalTransition').get('seriesKey')
  return t || r.id
}
function Ek(r) {
  return at(r) ? r.sort().join(',') : r
}
function Ds(r) {
  if (r.hostModel)
    return r.hostModel.getModel('universalTransition').get('divideShape')
}
function YSt(r, t) {
  var e = Pt(),
    n = Pt(),
    i = Pt()
  return (
    R(r.oldSeries, function (a, o) {
      var s = r.oldDataGroupIds[o],
        l = r.oldData[o],
        u = Ck(a),
        c = Ek(u)
      n.set(c, {
        dataGroupId: s,
        data: l,
      }),
        at(u) &&
          R(u, function (h) {
            i.set(h, {
              key: c,
              dataGroupId: s,
              data: l,
            })
          })
    }),
    R(t.updatedSeries, function (a) {
      if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
        var o = a.get('dataGroupId'),
          s = a.getData(),
          l = Ck(a),
          u = Ek(l),
          c = n.get(u)
        if (c)
          e.set(u, {
            oldSeries: [
              {
                dataGroupId: c.dataGroupId,
                divide: Ds(c.data),
                data: c.data,
              },
            ],
            newSeries: [
              {
                dataGroupId: o,
                divide: Ds(s),
                data: s,
              },
            ],
          })
        else if (at(l)) {
          var h = []
          R(l, function (p) {
            var g = n.get(p)
            g.data &&
              h.push({
                dataGroupId: g.dataGroupId,
                divide: Ds(g.data),
                data: g.data,
              })
          }),
            h.length &&
              e.set(u, {
                oldSeries: h,
                newSeries: [
                  {
                    dataGroupId: o,
                    data: s,
                    divide: Ds(s),
                  },
                ],
              })
        } else {
          var f = i.get(l)
          if (f) {
            var d = e.get(f.key)
            d ||
              ((d = {
                oldSeries: [
                  {
                    dataGroupId: f.dataGroupId,
                    data: f.data,
                    divide: Ds(f.data),
                  },
                ],
                newSeries: [],
              }),
              e.set(f.key, d)),
              d.newSeries.push({
                dataGroupId: o,
                data: s,
                divide: Ds(s),
              })
          }
        }
      }
    }),
    e
  )
}
function Dk(r, t) {
  for (var e = 0; e < r.length; e++) {
    var n =
      (t.seriesIndex != null && t.seriesIndex === r[e].seriesIndex) ||
      (t.seriesId != null && t.seriesId === r[e].id)
    if (n) return e
  }
}
function $St(r, t, e, n) {
  var i = [],
    a = []
  R(ke(r.from), function (o) {
    var s = Dk(t.oldSeries, o)
    s >= 0 &&
      i.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: t.oldData[s],
        divide: Ds(t.oldData[s]),
        groupIdDim: o.dimension,
      })
  }),
    R(ke(r.to), function (o) {
      var s = Dk(e.updatedSeries, o)
      if (s >= 0) {
        var l = e.updatedSeries[s].getData()
        a.push({
          dataGroupId: t.oldDataGroupIds[s],
          data: l,
          divide: Ds(l),
          groupIdDim: o.dimension,
        })
      }
    }),
    i.length > 0 && a.length > 0 && o8(i, a, n)
}
function qSt(r) {
  r.registerUpdateLifecycle('series:beforeupdate', function (t, e, n) {
    R(ke(n.seriesTransition), function (i) {
      R(ke(i.to), function (a) {
        for (var o = n.updatedSeries, s = 0; s < o.length; s++)
          ((a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex) ||
            (a.seriesId != null && a.seriesId === o[s].id)) &&
            (o[s][iy] = !0)
      })
    })
  }),
    r.registerUpdateLifecycle('series:transition', function (t, e, n) {
      var i = VSt(e)
      if (i.oldSeries && n.updatedSeries && n.optionChanged) {
        var a = n.seriesTransition
        if (a)
          R(ke(a), function (d) {
            $St(d, i, n, e)
          })
        else {
          var o = YSt(i, n)
          R(o.keys(), function (d) {
            var p = o.get(d)
            o8(p.oldSeries, p.newSeries, e)
          })
        }
        R(n.updatedSeries, function (d) {
          d[iy] && (d[iy] = !1)
        })
      }
      for (
        var s = t.getSeries(),
          l = (i.oldSeries = []),
          u = (i.oldDataGroupIds = []),
          c = (i.oldData = []),
          h = 0;
        h < s.length;
        h++
      ) {
        var f = s[h].getData()
        f.count() < a8 &&
          (l.push(s[h]), u.push(s[h].get('dataGroupId')), c.push(f))
      }
    })
}
ie([ult])
ie([nlt])
ie([
  Ilt,
  jlt,
  cut,
  jut,
  pct,
  lht,
  zht,
  Mft,
  Qft,
  ldt,
  _dt,
  bpt,
  Kpt,
  uvt,
  Dvt,
  kvt,
  tgt,
  cgt,
  bgt,
  Pgt,
  Wgt,
  Dmt,
])
ie(Jmt)
ie(Ryt)
ie(e4)
ie(Zyt)
ie(V4)
ie(n0t)
ie(h0t)
ie(f_t)
ie(N_t)
ie(Ov)
ie(ext)
ie(ixt)
ie(_xt)
ie(Dxt)
ie(Bxt)
ie(Xxt)
ie(a1t)
ie(C1t)
ie(YH)
ie($H)
ie(tSt)
ie(JH)
ie(QH)
ie(aSt)
ie(ySt)
ie(SSt)
ie(qSt)
ie(xst)
const ZSt = {
    class: 'm-card-hd',
  },
  KSt = {
    class: 'm-card-hd-title',
  },
  jSt = {
    class: 'm-card-bd-content',
  },
  ml = {
    __name: 'index',
    props: {
      width: {
        type: Number,
        default: 398,
      },
      height: {
        type: Number,
        default: 100,
      },
      title: {
        type: String,
        default: '标题',
      },
    },
    setup(r) {
      const t = r,
        e = Ql(() => `width:${t.width}px;height:${t.height}px;`)
      return (n, i) => (
        en(),
        sn(
          'div',
          {
            class: 'm-card',
            style: fy(e.value),
          },
          [
            wt('div', ZSt, [
              wt('div', KSt, Si(r.title), 1),
              i[0] ||
                (i[0] = wt(
                  'div',
                  {
                    class: 'm-card-hd-dot',
                  },
                  [
                    wt('div', {
                      class: 'dot dot1',
                    }),
                    wt('div', {
                      class: 'dot dot2',
                    }),
                    wt('div', {
                      class: 'dot dot3',
                    }),
                  ],
                  -1,
                )),
            ]),
            wt(
              'div',
              {
                class: 'm-card-bd',
                style: fy(e.value),
              },
              [wt('div', jSt, [Bh(n.$slots, 'default')])],
              4,
            ),
          ],
          4,
        )
      )
    },
  }
var cA = null
function JSt(r) {
  return (
    cA ||
      (cA = (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (t) {
          return setTimeout(t, 16)
        }
      ).bind(window)),
    cA(r)
  )
}
var hA = null
function QSt(r) {
  hA ||
    (hA = (
      window.cancelAnimationFrame ||
      window.webkitCancelAnimationFrame ||
      window.mozCancelAnimationFrame ||
      function (t) {
        clearTimeout(t)
      }
    ).bind(window)),
    hA(r)
}
function tAt(r) {
  var t = document.createElement('style')
  return (
    t.styleSheet
      ? (t.styleSheet.cssText = r)
      : t.appendChild(document.createTextNode(r)),
    (document.querySelector('head') || document.body).appendChild(t),
    t
  )
}
function Pm(r, t) {
  t === void 0 && (t = {})
  var e = document.createElement(r)
  return (
    Object.keys(t).forEach(function (n) {
      e[n] = t[n]
    }),
    e
  )
}
function s8(r, t, e) {
  var n = window.getComputedStyle(r, e || null) || {
    display: 'none',
  }
  return n[t]
}
function pM(r) {
  if (!document.documentElement.contains(r))
    return {
      detached: !0,
      rendered: !1,
    }
  for (var t = r; t !== document; ) {
    if (s8(t, 'display') === 'none')
      return {
        detached: !1,
        rendered: !1,
      }
    t = t.parentNode
  }
  return {
    detached: !1,
    rendered: !0,
  }
}
var eAt =
    '.resize-triggers{visibility:hidden;opacity:0;pointer-events:none}.resize-contract-trigger,.resize-contract-trigger:before,.resize-expand-trigger,.resize-triggers{content:"";position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden}.resize-contract-trigger,.resize-expand-trigger{background:#eee;overflow:auto}.resize-contract-trigger:before{width:200%;height:200%}',
  vM = 0,
  hy = null
function nAt(r, t) {
  r.__resize_mutation_handler__ || (r.__resize_mutation_handler__ = aAt.bind(r))
  var e = r.__resize_listeners__
  if (!e) {
    if (((r.__resize_listeners__ = []), window.ResizeObserver)) {
      var n = r.offsetWidth,
        i = r.offsetHeight,
        a = new ResizeObserver(function () {
          ;(!r.__resize_observer_triggered__ &&
            ((r.__resize_observer_triggered__ = !0),
            r.offsetWidth === n && r.offsetHeight === i)) ||
            L0(r)
        }),
        o = pM(r),
        s = o.detached,
        l = o.rendered
      ;(r.__resize_observer_triggered__ = s === !1 && l === !1),
        (r.__resize_observer__ = a),
        a.observe(r)
    } else if (r.attachEvent && r.addEventListener)
      (r.__resize_legacy_resize_handler__ = function () {
        L0(r)
      }),
        r.attachEvent('onresize', r.__resize_legacy_resize_handler__),
        document.addEventListener(
          'DOMSubtreeModified',
          r.__resize_mutation_handler__,
        )
    else if (
      (vM || (hy = tAt(eAt)),
      oAt(r),
      (r.__resize_rendered__ = pM(r).rendered),
      window.MutationObserver)
    ) {
      var u = new MutationObserver(r.__resize_mutation_handler__)
      u.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0,
      }),
        (r.__resize_mutation_observer__ = u)
    }
  }
  r.__resize_listeners__.push(t), vM++
}
function rAt(r, t) {
  var e = r.__resize_listeners__
  if (e) {
    if ((t && e.splice(e.indexOf(t), 1), !e.length || !t)) {
      if (r.detachEvent && r.removeEventListener) {
        r.detachEvent('onresize', r.__resize_legacy_resize_handler__),
          document.removeEventListener(
            'DOMSubtreeModified',
            r.__resize_mutation_handler__,
          )
        return
      }
      r.__resize_observer__
        ? (r.__resize_observer__.unobserve(r),
          r.__resize_observer__.disconnect(),
          (r.__resize_observer__ = null))
        : (r.__resize_mutation_observer__ &&
            (r.__resize_mutation_observer__.disconnect(),
            (r.__resize_mutation_observer__ = null)),
          r.removeEventListener('scroll', OE),
          r.removeChild(r.__resize_triggers__.triggers),
          (r.__resize_triggers__ = null)),
        (r.__resize_listeners__ = null)
    }
    !--vM && hy && hy.parentNode.removeChild(hy)
  }
}
function iAt(r) {
  var t = r.__resize_last__,
    e = t.width,
    n = t.height,
    i = r.offsetWidth,
    a = r.offsetHeight
  return i !== e || a !== n
    ? {
        width: i,
        height: a,
      }
    : null
}
function aAt() {
  var r = pM(this),
    t = r.rendered,
    e = r.detached
  t !== this.__resize_rendered__ &&
    (!e &&
      this.__resize_triggers__ &&
      (NE(this), this.addEventListener('scroll', OE, !0)),
    (this.__resize_rendered__ = t),
    L0(this))
}
function OE() {
  var r = this
  NE(this),
    this.__resize_raf__ && QSt(this.__resize_raf__),
    (this.__resize_raf__ = JSt(function () {
      var t = iAt(r)
      t && ((r.__resize_last__ = t), L0(r))
    }))
}
function L0(r) {
  !r ||
    !r.__resize_listeners__ ||
    r.__resize_listeners__.forEach(function (t) {
      t.call(r, r)
    })
}
function oAt(r) {
  var t = s8(r, 'position')
  ;(!t || t === 'static') && (r.style.position = 'relative'),
    (r.__resize_old_position__ = t),
    (r.__resize_last__ = {})
  var e = Pm('div', {
      className: 'resize-triggers',
    }),
    n = Pm('div', {
      className: 'resize-expand-trigger',
    }),
    i = Pm('div'),
    a = Pm('div', {
      className: 'resize-contract-trigger',
    })
  n.appendChild(i),
    e.appendChild(n),
    e.appendChild(a),
    r.appendChild(e),
    (r.__resize_triggers__ = {
      triggers: e,
      expand: n,
      expandChild: i,
      contract: a,
    }),
    NE(r),
    r.addEventListener('scroll', OE, !0),
    (r.__resize_last__ = {
      width: r.offsetWidth,
      height: r.offsetHeight,
    })
}
function NE(r) {
  var t = r.__resize_triggers__,
    e = t.expand,
    n = t.expandChild,
    i = t.contract,
    a = i.scrollWidth,
    o = i.scrollHeight,
    s = e.offsetWidth,
    l = e.offsetHeight,
    u = e.scrollWidth,
    c = e.scrollHeight
  ;(i.scrollLeft = a),
    (i.scrollTop = o),
    (n.style.width = s + 1 + 'px'),
    (n.style.height = l + 1 + 'px'),
    (e.scrollLeft = u),
    (e.scrollTop = c)
}
var Ha = function () {
  return (
    (Ha =
      Object.assign ||
      function (r) {
        for (var t, e = 1, n = arguments.length; e < n; e++)
          for (var i in (t = arguments[e]))
            Object.prototype.hasOwnProperty.call(t, i) && (r[i] = t[i])
        return r
      }),
    Ha.apply(this, arguments)
  )
}
var sAt = [
  'getWidth',
  'getHeight',
  'getDom',
  'getOption',
  'resize',
  'dispatchAction',
  'convertToPixel',
  'convertFromPixel',
  'containPixel',
  'getDataURL',
  'getConnectedDataURL',
  'appendData',
  'clear',
  'isDisposed',
  'dispose',
]
function lAt(r) {
  return (
    (t = Object.create(null)),
    sAt.forEach(function (e) {
      t[e] = (function (n) {
        return function () {
          for (var i = [], a = 0; a < arguments.length; a++) i[a] = arguments[a]
          if (!r.value) throw new Error('ECharts is not initialized yet.')
          return r.value[n].apply(r.value, i)
        }
      })(e)
    }),
    t
  )
  var t
}
var uAt = {
    autoresize: [Boolean, Object],
  },
  cAt = /^on[^a-z]/,
  Lk = function (r) {
    return cAt.test(r)
  }
function Rm(r, t) {
  var e = m8(r) ? La(r) : r
  return e && typeof e == 'object' && 'value' in e ? e.value || t : e || t
}
var hAt = 'ecLoadingOptions',
  fAt = {
    loading: Boolean,
    loadingOptions: Object,
  },
  wd = null,
  l8 = 'x-vue-echarts',
  Pk = [],
  Md = []
;(function (r, t) {
  if (r && typeof document < 'u') {
    var e,
      n = t.prepend === !0 ? 'prepend' : 'append',
      i = t.singleTag === !0,
      a =
        typeof t.container == 'string'
          ? document.querySelector(t.container)
          : document.getElementsByTagName('head')[0]
    if (i) {
      var o = Pk.indexOf(a)
      o === -1 && ((o = Pk.push(a) - 1), (Md[o] = {})),
        (e = Md[o] && Md[o][n] ? Md[o][n] : (Md[o][n] = s()))
    } else e = s()
    r.charCodeAt(0) === 65279 && (r = r.substring(1)),
      e.styleSheet
        ? (e.styleSheet.cssText += r)
        : e.appendChild(document.createTextNode(r))
  }
  function s() {
    var l = document.createElement('style')
    if ((l.setAttribute('type', 'text/css'), t.attributes))
      for (var u = Object.keys(t.attributes), c = 0; c < u.length; c++)
        l.setAttribute(u[c], t.attributes[u[c]])
    var h = n === 'prepend' ? 'afterbegin' : 'beforeend'
    return a.insertAdjacentElement(h, l), l
  }
})(
  `x-vue-echarts{display:flex;flex-direction:column;width:100%;height:100%;min-width:0}
.vue-echarts-inner{flex-grow:1;min-width:0;width:auto!important;height:auto!important}
`,
  {},
)
var dAt = (function () {
    if (wd != null) return wd
    if (typeof HTMLElement > 'u' || typeof customElements > 'u')
      return (wd = !1)
    try {
      new Function(
        'tag',
        `class EChartsElement extends HTMLElement {
  __dispose = null;

  disconnectedCallback() {
    if (this.__dispose) {
      this.__dispose();
      this.__dispose = null;
    }
  }
}

if (customElements.get(tag) == null) {
  customElements.define(tag, EChartsElement);
}
`,
      )(l8)
    } catch {
      return (wd = !1)
    }
    return (wd = !0)
  })(),
  pAt = 'ecTheme',
  vAt = 'ecInitOptions',
  gAt = 'ecUpdateOptions',
  Rk = /(^&?~?!?)native:/,
  uc = p8({
    name: 'echarts',
    props: Ha(
      Ha(
        {
          option: Object,
          theme: {
            type: [Object, String],
          },
          initOptions: Object,
          updateOptions: Object,
          group: String,
          manualUpdate: Boolean,
        },
        uAt,
      ),
      fAt,
    ),
    emits: {},
    inheritAttrs: !1,
    setup: function (r, t) {
      var e = t.attrs,
        n = hh(),
        i = hh(),
        a = hh(),
        o = hh(),
        s = dh(pAt, null),
        l = dh(vAt, null),
        u = dh(gAt, null),
        c = v8(r),
        h = c.autoresize,
        f = c.manualUpdate,
        d = c.loading,
        p = c.loadingOptions,
        g = Ql(function () {
          return o.value || r.option || null
        }),
        v = Ql(function () {
          return r.theme || Rm(s, {})
        }),
        m = Ql(function () {
          return r.initOptions || Rm(l, {})
        }),
        y = Ql(function () {
          return r.updateOptions || Rm(u, {})
        }),
        _ = Ql(function () {
          return (function (C) {
            var E = {}
            for (var D in C) Lk(D) || (E[D] = C[D])
            return E
          })(e)
        }),
        x = {},
        A = g8().proxy.$listeners,
        S = {}
      function b(C) {
        if (i.value) {
          var E = (a.value = kat(i.value, v.value, m.value))
          r.group && (E.group = r.group),
            Object.keys(S).forEach(function (P) {
              var L = S[P]
              if (L) {
                var I = P.toLowerCase()
                I.charAt(0) === '~' && ((I = I.substring(1)), (L.__once__ = !0))
                var F = E
                if (
                  (I.indexOf('zr:') === 0 &&
                    ((F = E.getZr()), (I = I.substring(3))),
                  L.__once__)
                ) {
                  delete L.__once__
                  var k = L
                  L = function () {
                    for (var V = [], H = 0; H < arguments.length; H++)
                      V[H] = arguments[H]
                    k.apply(void 0, V), F.off(I, L)
                  }
                }
                F.on(I, L)
              }
            }),
            h.value
              ? so(function () {
                  E && !E.isDisposed() && E.resize(), D()
                })
              : D()
        }
        function D() {
          var P = C || g.value
          P && E.setOption(P, y.value)
        }
      }
      function T() {
        a.value && (a.value.dispose(), (a.value = void 0))
      }
      A
        ? Object.keys(A).forEach(function (C) {
            Rk.test(C) ? (x[C.replace(Rk, '$1')] = A[C]) : (S[C] = A[C])
          })
        : Object.keys(e)
            .filter(function (C) {
              return Lk(C)
            })
            .forEach(function (C) {
              var E = C.charAt(2).toLowerCase() + C.slice(3)
              if (E.indexOf('native:') !== 0)
                E.substring(E.length - 4) === 'Once' &&
                  (E = '~'.concat(E.substring(0, E.length - 4))),
                  (S[E] = e[C])
              else {
                var D = 'on'
                  .concat(E.charAt(7).toUpperCase())
                  .concat(E.slice(8))
                x[D] = e[C]
              }
            })
      var w = null
      Td(
        f,
        function (C) {
          typeof w == 'function' && (w(), (w = null)),
            C ||
              (w = Td(
                function () {
                  return r.option
                },
                function (E, D) {
                  E &&
                    (a.value
                      ? a.value.setOption(
                          E,
                          Ha(
                            {
                              notMerge: E !== D,
                            },
                            y.value,
                          ),
                        )
                      : b())
                },
                {
                  deep: !0,
                },
              ))
        },
        {
          immediate: !0,
        },
      ),
        Td(
          [v, m],
          function () {
            T(), b()
          },
          {
            deep: !0,
          },
        ),
        WE(function () {
          r.group && a.value && (a.value.group = r.group)
        })
      var M = lAt(a)
      return (
        (function (C, E, D) {
          var P = dh(hAt, {}),
            L = Ql(function () {
              return Ha(Ha({}, Rm(P, {})), D == null ? void 0 : D.value)
            })
          WE(function () {
            var I = C.value
            I && (E.value ? I.showLoading(L.value) : I.hideLoading())
          })
        })(a, d, p),
        (function (C, E, D) {
          var P = null
          Td([D, C, E], function (L, I, F) {
            var k = L[0],
              V = L[1],
              H = L[2]
            if (k && V && H) {
              var Y = H === !0 ? {} : H,
                K = Y.throttle,
                ut = K === void 0 ? 100 : K,
                W = Y.onResize,
                Z = function () {
                  V.resize(), W == null || W()
                }
              ;(P = ut ? __(Z, ut) : Z), nAt(k, P)
            }
            F(function () {
              k && P && rAt(k, P)
            })
          })
        })(a, h, i),
        Ea(function () {
          b()
        }),
        Da(function () {
          dAt && n.value ? (n.value.__dispose = T) : T()
        }),
        Ha(
          {
            chart: a,
            root: n,
            inner: i,
            setOption: function (C, E) {
              r.manualUpdate && (o.value = C),
                a.value ? a.value.setOption(C, E || {}) : b(C)
            },
            nonEventAttrs: _,
            nativeListeners: x,
          },
          M,
        )
      )
    },
    render: function () {
      var r = Ha(Ha({}, this.nonEventAttrs), this.nativeListeners)
      return (
        (r.ref = 'root'),
        (r.class = r.class ? ['echarts'].concat(r.class) : 'echarts'),
        XE(l8, r, [
          XE('div', {
            ref: 'inner',
            class: 'vue-echarts-inner',
          }),
        ])
      )
    },
  })
function yl(r, t = 500) {
  let e = null,
    n = je(!1)
  const i = () => {
    n.value ||
      (r(),
      (n.value = !0),
      (e = setTimeout(() => {
        n.value = !1
      }, t)))
  }
  return (
    window.addEventListener('resize', i),
    {
      destroy() {
        window.removeEventListener('resize', i), clearTimeout(e)
      },
    }
  )
}
const mAt = {
    __name: 'BulkCommoditySalesChart',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#ffffff',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          xAxis: [
            {
              type: 'category',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['农产品', '能源', '金属', '化工', '木材'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '',
              data: [100, 120, 150, 110, 100],
              type: 'bar',
              barWidth: 4,
              stack: 'b',
              z: 3,
              yAxisIndex: 0,
              showBackground: !1,
              backgroundStyle: {
                color: 'rgba(180, 180, 180, 0.2)',
              },
              label: {
                show: !0,
                position: 'top',
                distance: 15,
                color: '#ffffff',
                fontSize: 10,
              },
              itemStyle: {
                borderRadius: 2,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#19FFC6',
                  },
                  {
                    offset: 1,
                    color: '#33AAFF',
                  },
                ]),
              },
            },
            {
              type: 'custom',
              renderItem: (o, s) => {
                const l = s.value(0),
                  u = s.value(1),
                  c = s.coord([l, u]),
                  h = c[1]
                return {
                  type: 'image',
                  style: {
                    x: c[0] - 4.5,
                    y: h - 9,
                    width: 10,
                    height: 10,
                    image:
                      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAAXNSR0IArs4c6QAAAL1JREFUOE9j/P///38GMgAjSKOMdxRJWp9sXcYA18giJMLw99MHhv9//mA1hJGZhYGZX4Dhz7s3DCgaGVlYGDjVtBi+37rO8P/PbxTNjCysDJyqWgzfb18Dy6FoBKmEKfh17wZcM0iMTUkDrgmkDkMjSJCFnZ3hwbr5KDYqBCUy/Pn5Ey6GVSMzMxPDw01LUDTK+8Uw/P37j0YayXIqWYGDHuTInsQbHeAE8PEDw/+/JCYAUtIcPDpI0QRTCwDhurXXJ/EmUwAAAABJRU5ErkJggg==',
                  },
                }
              },
              xAxisIndex: 1,
              data: [100, 120, 150, 110, 100],
            },
            {
              type: 'bar',
              barWidth: 32,
              xAxisIndex: 1,
              barGap: '-220%',
              data: [150, 150, 150, 150, 150],
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'rgba(255,255,255,0.8)',
                },
              },
              itemStyle: {
                color: 'rgba(122,140,153,0.6)',
                opacity: 0.1,
              },
              z: 0,
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '大宗商品销售额',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  yAt = './assets/ring2-a1b91808.png',
  _At = './assets/ring3-fe0f60d7.png',
  xAt = './assets/ring4-f2e324d6.png'
const SAt = {
    name: 'ThreePie',
    props: {
      data: {
        type: Array,
        default: () => [],
      },
      colors: {
        type: Array,
        default: () => [2161326, 15380744, 3122407, 65535, 16536624],
      },
      opacity: {
        type: Number,
        default: 0.5,
      },
      delay: {
        type: Number,
        default: 5e3,
      },
      loopComplete: {
        type: Function,
        default: () => {},
      },
    },
    computed: {
      currentData() {
        return {
          ...this.data[this.activeIndex],
          count: this.count,
        }
      },
    },
    data() {
      return (
        (this.scene = null),
        (this.camera = null),
        (this.renderer = null),
        (this.controls = null),
        (this.axes = null),
        (this.pieGroup = new un()),
        {
          width: 300,
          height: 200,
          activeIndex: 0,
          count: 0,
          timer: null,
        }
      )
    },
    mounted() {
      ;(this.width = this.$refs.pieDom.offsetWidth),
        (this.height = this.$refs.pieDom.offsetHeight),
        (this.count = this.data.map(r => r.value).reduce((r, t) => r + t, 0)),
        this.init()
    },
    beforeUnmount() {
      clearInterval(this.timer), this.destroy()
    },
    methods: {
      init() {
        ;(this.scene = new hB()),
          this.initCamera(),
          this.initRenderer(),
          this.initLight(),
          this.initAxes(),
          this.initControls(),
          this.createPlane({
            url: yAt,
            width: 5,
            position: new U(0, 0, -0.01),
            color: '#00ffff',
          }),
          this.createPlane({
            url: _At,
            width: 6.5,
            position: new U(0, 0, -0.02),
            color: '#00ffff',
          }),
          this.createPlane({
            url: xAt,
            width: 5.5,
            position: new U(0, 0, -0.03),
            animate: !0,
            color: '#00ffff',
          }),
          this.createPie(),
          this.loop()
      },
      createPlane(r) {
        let t = {
            url: 'texture/ring1.png',
            width: 5.5,
            z: 0,
            position: new U(0, 0, 0),
            animate: !1,
            color: null,
          },
          e = Object.assign(t, r)
        const n = new Ti(e.width, e.width),
          i = new on({
            map: this.getTexture(e.url),
            transparent: !0,
            side: dr,
            depthTest: !1,
          })
        e.color && (i.color = new qt(e.color))
        const a = new De(n, i)
        a.position.copy(e.position),
          (a.rotation.x = (-1 * Math.PI) / 2),
          e.animate &&
            Sn.to(a.rotation, {
              z: 2 * Math.PI,
              repeat: -1,
              ease: 'none',
              duration: 3,
            }),
          this.scene.add(a)
      },
      getTexture(r) {
        const t = new ZM().load(r)
        return (t.wrapS = t.wrapT = Jn), t
      },
      createPie() {
        let r = 0,
          t = 0
        for (var e = 0; e < this.data.length; e++) {
          let n = this.data[e].value / this.count
          e == 0 ? (r = 0) : (r = t + 1e-4), (t = t + 2 * Math.PI * n - 1e-4)
          let i = this.addRing({
            startAngle: r,
            endAngle: t,
            color: new qt(this.colors[e % this.colors.length]),
          })
          ;(i.name = 'ring' + e), this.pieGroup.add(i)
        }
        this.scene.add(this.pieGroup),
          this.chooseRing(this.activeIndex, !0),
          (this.timer = setInterval(() => {
            this.loopChange()
          }, this.delay))
      },
      loopChange() {
        let r = this.activeIndex + 1
        r >= this.data.length &&
          ((r = 0), this.loopComplete && this.loopComplete()),
          this.chooseRing(r)
      },
      chooseRing(r = 0, t = !1) {
        let e = r - 1 < 0 ? this.data.length - 1 : r - 1,
          n = this.pieGroup.children[e]
        ;(this.prevMesh = n), (this.activeIndex = r)
        let i = this.pieGroup.children[r]
        t ||
          (Sn.to(n.scale, {
            z: 1,
          }),
          Sn.to(n.material, {
            opacity: this.opacity,
          })),
          Sn.to(i.scale, {
            z: 2,
          }),
          Sn.to(i.material, {
            opacity: 0.8,
          })
      },
      addRing(r = {}) {
        let t = {
            innerRadius: 1.5,
            outerRadius: 2,
            thickness: 0.5,
            startAngle: 0,
            endAngle: Math.PI / 2,
            color: 65535,
            segments: 120,
          },
          e = Object.assign(t, r),
          n = new wu()
        n.arc(0, 0, e.outerRadius, e.startAngle, e.endAngle)
        let i = n.getPoints(e.segments),
          a = new wu()
        a.arc(0, 0, e.innerRadius, e.endAngle, e.startAngle, !0)
        let o = a.getPoints(e.segments),
          s = new wu(i.concat(o))
        const l = {
            steps: 1,
            depth: e.thickness,
            bevelEnabled: !0,
            bevelThickness: 0,
            bevelSize: 0,
            bevelOffset: 0,
            bevelSegments: 0,
          },
          u = new B0(s, l)
        let c = new CB({
          color: e.color,
          transparent: !0,
          opacity: this.opacity,
          side: dr,
        })
        const h = new De(u, c.clone())
        return (h.renderOrder = 10), (h.rotation.x = (-1 * Math.PI) / 2), h
      },
      initCamera() {
        var r = this.width / this.height
        ;(this.camera = new wr(30, r, 0.1, 1500)),
          this.camera.position.set(
            6.023813305272227,
            4.838542633695233,
            6.111272698256137,
          ),
          this.camera.lookAt(0, 0, 0)
      },
      initRenderer() {
        ;(this.renderer = new cB({
          antialias: !0,
          alpha: !0,
        })),
          this.renderer.setPixelRatio(window.devicePixelRatio),
          this.renderer.setSize(this.width, this.height),
          this.$refs.pieDom.appendChild(this.renderer.domElement)
      },
      initLight() {
        let r = new Ay(16777215, 2)
        r.position.set(200, 300, 200)
        let t = new Ay(16777215, 2)
        t.position.set(-200, -300, -200)
        let e = new PB(16777215, 2)
        this.scene.add(r), this.scene.add(t), this.scene.add(e)
      },
      initAxes() {
        ;(this.axes = new RB(0)), this.scene.add(this.axes)
      },
      initControls() {
        ;(this.controls = new FB(this.camera, this.renderer.domElement)),
          (this.controls.maxPolarAngle = Math.PI),
          (this.controls.autoRotate = !1),
          (this.controls.enableDamping = !0),
          (this.controls.enabled = !1)
      },
      loop() {
        this.renderer.setAnimationLoop(() => {
          this.renderer.render(this.scene, this.camera),
            this.controls && this.controls.update()
        })
      },
      start() {
        this.loop(),
          (this.controls.enabled = !0),
          (this.timer = setInterval(() => {
            this.loopChange()
          }, this.delay))
      },
      stop() {
        clearInterval(this.timer),
          this.controls && (this.controls.enabled = !1),
          this.renderer && this.renderer.setAnimationLoop(null)
      },
      getScene() {
        return this.scene
      },
      getRender() {
        return this.renderer
      },
      resize() {
        ;(this.width = this.$refs.pieDom.offsetWidth),
          (this.height = this.$refs.pieDom.offsetHeight)
        let r = this.width / this.height
        ;(this.camera.aspect = r),
          this.camera.updateProjectionMatrix(),
          this.renderer.setSize(this.width, this.height),
          this.renderer.setPixelRatio(window.devicePixelRatio)
      },
      destroy() {
        this.prevMesh &&
          (Sn.set(this.prevMesh.scale, {
            z: 1,
          }),
          Sn.set(this.prevMesh.material, {
            opacity: this.opacity,
          })),
          this.stop(),
          window.removeEventListener('resize', () => {
            this.resize()
          }),
          this.renderer &&
            (va(this.pieGroup),
            this.renderer.dispose(),
            this.renderer.forceContextLoss(),
            this.controls.dispose(),
            (this.$refs.pieDom.innerHTML = ''),
            (this.scene = null),
            (this.camera = null),
            (this.renderer = null),
            (this.controls = null),
            (this.axes = null))
      },
    },
  },
  AAt = {
    class: 'three-pie-wrap',
  },
  bAt = {
    class: 'three-pie',
    ref: 'pieDom',
  },
  wAt = {
    class: 'three-pie-slot',
  }
function MAt(r, t, e, n, i, a) {
  return (
    en(),
    sn('div', AAt, [
      wt('div', bAt, null, 512),
      wt('div', wAt, [
        Bh(r.$slots, 'default', {
          data: a.currentData,
        }),
      ]),
    ])
  )
}
const TAt = X0(SAt, [['render', MAt]])
const CAt = {
    class: 'pie-chat-wrap',
  },
  EAt = {
    class: 'pie-chat',
  },
  DAt = {
    class: 'pieCanvas-content',
  },
  LAt = {
    class: 'pieCanvas-content-value',
  },
  PAt = {
    class: 'pieCanvas-content-name',
  },
  RAt = {
    class: 'pie-legend',
  },
  IAt = {
    class: 'name',
  },
  OAt = {
    class: 'value',
  },
  NAt = {
    __name: 'YearlyEconomyTrend',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je(null),
        i = yM({
          pieDataColor: ['#17E6C3', '#40CFFF', '#1979FF', '#FFC472'],
          pieData: [
            {
              name: '类型1',
              value: 400,
            },
            {
              name: '类型2',
              value: 250,
            },
            {
              name: '类型3',
              value: 200,
            },
            {
              name: '类型4',
              value: 150,
            },
          ],
        })
      function a(l) {
        return Number(((l.data.value / l.data.count) * 100).toFixed(2))
      }
      const o = () => {
          ;(e.value = t.value.offsetHeight - 2),
            console.log('resize'),
            so(() => {
              setTimeout(() => {
                n.value && n.value.resize()
              })
            })
        },
        {destroy: s} = yl(o)
      return (
        Ea(() => {
          so(() => {
            o()
          })
        }),
        Da(() => {
          s()
        }),
        (l, u) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '年度经济增长点',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    wt('div', CAt, [
                      wt('div', EAt, [
                        ye(
                          TAt,
                          {
                            ref_key: 'pie',
                            ref: n,
                            data: i.pieData,
                            delay: 3e3,
                            colors: i.pieDataColor,
                            opacity: 0.6,
                            class: 'pieCanvas',
                          },
                          {
                            default: Qn(c => [
                              wt('div', DAt, [
                                wt('div', LAt, [
                                  ye(
                                    La(bT),
                                    {
                                      startVal: 0,
                                      endVal: a(c),
                                      decimals: 2,
                                      duration: 1e3,
                                      autoplay: !0,
                                    },
                                    null,
                                    8,
                                    ['endVal'],
                                  ),
                                  u[0] || (u[0] = ko(' % ')),
                                ]),
                                wt('div', PAt, Si(c.data.name), 1),
                              ]),
                            ]),
                            _: 1,
                          },
                          8,
                          ['data', 'colors'],
                        ),
                      ]),
                      wt('div', RAt, [
                        (en(!0),
                        sn(
                          _M,
                          null,
                          xM(
                            i.pieData,
                            (c, h) => (
                              en(),
                              sn(
                                'div',
                                {
                                  class: 'pie-legend-item',
                                  key: h,
                                },
                                [
                                  wt(
                                    'div',
                                    {
                                      class: 'icon',
                                      style: fy({
                                        borderColor: i.pieDataColor[h],
                                      }),
                                    },
                                    null,
                                    4,
                                  ),
                                  wt('div', IAt, Si(c.name), 1),
                                  wt('div', OAt, [
                                    ko(Si(c.value), 1),
                                    u[1] ||
                                      (u[1] = wt(
                                        'span',
                                        {
                                          class: 'unit',
                                        },
                                        '亿',
                                        -1,
                                      )),
                                  ]),
                                ],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ]),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  kAt = {
    __name: 'EconomicTrendChart',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          color: ['#6BC7F6'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 1,
                padding: [0, 0, 0, 0],
              },
              data: [
                '2023/04',
                '2023/05',
                '2023/06',
                '2023/07',
                '2023/08',
                '2023/09',
                '2023/10',
                '2023/11',
                '2023/12',
                '2024/01',
                '2024/02',
                '2024/03',
              ],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              data: [
                500, 1e3, 300, 1300, 500, 1330, 620, 400, 700, 1300, 300, 1234,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 10,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '近年经济情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  BAt = {
    __name: 'DistrictEconomicIncome',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          color: ['#6BC7F6'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['南山区', '天河区', '福田区', '龙岗区', '宝安区'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !1,
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '',
              type: 'pictorialBar',
              symbol:
                'path://M0,10 L10,10 C5.5,10 5.5,5 5,0 C4.5,5 4.5,10 0,10 z',
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 10,
              },
              data: [
                {
                  value: 8e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 7500,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(25, 255, 198, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(0, 204, 187, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 6e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 5800,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(25, 255, 198, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(0, 204, 187, 0.10)',
                      },
                    ]),
                  },
                },
                {
                  value: 5e3,
                  itemStyle: {
                    color: new He(0, 0, 0, 1, [
                      {
                        offset: 0,
                        color: 'rgba(64, 175, 255, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(64, 175, 255, 0.10)',
                      },
                    ]),
                  },
                },
              ],
            },
            {
              name: '',
              type: 'custom',
              z: 3,
              xAxisIndex: 1,
              renderItem: (o, s) => {
                const l = s.value(0),
                  u = s.value(1),
                  c = s.coord([l, u]),
                  h = c[1]
                return {
                  type: 'image',
                  style: {
                    x: c[0] - 5,
                    y: h - 5,
                    width: 10,
                    height: 10,
                    image:
                      'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAcfSURBVHgB1Zh5bFRFHMdn3rHbCr3+MFG0lEOEQKQQoyY06TYagZIeYoEQQIwaRSkVFYGkKKWtrAEUkBYixmAUmxC0aXbbtCAo2xKJGhJL1XhAQ7cef9rt9qL7Lmfezmx/b/YtQv/SSX47x3tv5jPfmZ35zSD0Hw0YTTJYloVJsGjsqFAoo3k0iXBLYGLjJSXrsyP64NPItPIxRost08ojNWXHX0YRku4jRGEFSwGvB4fOBoN9EJDUJ5G8iSYLBoDsuKik3GfEtBrSgg/dTsA44JXlI1+2B0M2OppQNpWi+BaAcEnF+rzB4cgJUs6AcIR0ucejqsGMrMyL8xfMDe+tro7QJ9tra7N++fHnRWNj4w9oulZomGbZRGtSIDNn6rb2U6euw+bc4HAKKIn1TCosLqsyDX03SWdTIK9HPVr40OLGmpqaKPhMYnWZLLa4PVNVldffG94Q042nLGRNx6QOWZbrQh3BBva+K5wbGIeSi1aU7tZ1401aripqY1FRwds1O3YMsldlriiAs1jeYGUmb3xT1eu5v177bZdu6BtoXlHk+lB7ax2Es4EYIE6lFoHaw6HuSE/f+UWg+Rh7BqEkAQ4GDmWB2Fi6cnXl6MjIPrsnklzfdaZ1D4dyBXNAFZdtJT07SMszMqa82NH8WRN7pgAYiZnM64Q9Z6rRtM6hOGRxxdp1Q0PR9204WXmtqyN4hD2zUikmrVi7dmb07+hlks0GSskADLMYDiV/bgHjiukAymCmP16+avPY2Oh+OueyMtIebGtu7oNgEhJCdGDoXQqlyMqnDEoBysgsz8E8xLwsVoW0yt6B6UQHzwU+P6Z61Ebyh8geHBo7IYokAbVwUUmJjyTKyTvhBfNm+4EiigClgAY9wBQASC0NlMGO2dNhyZJH/FQxui4+tuJJH/xnOhQzNOtlGntVz8mjhw71A6UkFzjVRSUOw/NwXvJ8wsjaF/WQ5Ye2GdNv7IY7jMTV8i0rm0HiJ2h++qx7m1DyUgB7DIdLEQAVAKECg53jo4ALfQWNXLXla9bkcDgbzN4eJMNe1WUZt37U0BAWYKBqigugFwynF5SJcy1pOGu2b4+S/baHtj0cHd6YpBj5z9hqKbLaBdSCywKEUoE6ucQOEwsS+4rYW6xMdVGMd9CxKKuq2mpnTLTIAUaDaZozaJzm8VxhRXC/lAGgB0BSgA+I5RObyt4vIHac2D2CuqL6ic5nZGRetBkwXuSyXOA8+js/f8EV5FzZ3SrkkJsBEAy0bKdLPRIQJDEic+bNjm/qFspzzDH2gu1PHaipGUQTq7e41Yh/iAKUOsxGE2qLUwPWgw8kHAIrG4HKkeC0ce8ACbGjMhYPo9QBKmmBumBZ0jPHULLJb/tTu/z+LJcP4YYMN+VelDp8jZxbFBa+TwhA2mRKkWVDGEpku8Mk9HT/lIfce0orM0AZTVMvwU21EWKNwjd8z+RQPJjdl7sXMoYwL0yAEQnttWR0dKQQQHEg2FONGW3oT2IvMHU4UDcr+wu8B6FMEXI8pi1kTSXOBgoHIweK7wnxRk3TSkn2KOitxCqC6w+cb38QewN00gCNx24Cl3AQNU33xcVRAkmKTcuZ9onNbFn5bMzF+aQLjXLlaOPjwGICkJHC7Lo3VVVNNyyj1FYJKxeStqTTpz8cICWdJJv1zaXvKoWe8QY4kAgHIcW0AWIHFG372vXfbVdbIgeVCx0tyXOMBtmj1tI4FtMq/YcPZwkKGQBu3AUEqhUTgPl3Ouis8Xzlq7mkLQaG3uMiOcBoQagtEKKqUeft3PkL1Wji32eCnmtCOiaAxkBaF5QzQYyu9vVWk7byCFUgdKatE4oEHUU7nTHF+xxd07SYtmVpeUUlkN0QVBOH0A1KnPgJ5ZeVrnpJ1+iJCUfuTM/YhoQAh9L2t9tbWvo8HrmeFoyOje0rrli9DiVP3JigFo1vALhxQV0OZXdw2cqKdSPjo/tpGwo5Y7a0OA7A8REEijmvA5aT45sZP76lpXt3ng+0HEPO/U50YeApCa6BcJE16SjQDttQilQXam+rg9+4npIAoN0gPPDSw8nc+/L2Hm9o6EfOjVhGzhFwrFEcyO/3Z5699G01ufvYYr8oSXVdZ9rqCYjudoeRCizx7NHi0ldihg2XTVzgsKIqJ++fNafpeMM7/eA9UTWDpc1acpcRutxdqY3HtsS9BxxR4lcER1gHsNvNj9sJGkLaHia5VJkZHY4cNO0TVDzIkhQk1wZdXk96z8P5c38gdxkDtL4dtbXZvVf7ciORAR/dRSwLLbSYO0Nc6M6sqTnPtjU38fXKSnUdhW8ChYX3cNHykkKi+1YEAG8pWCikeNU6shx1IhcX57bAOBy8x+Kw8ROV4TMxOSdYFvVGZiDmaJJALu6ssIQw2czxlbuy7v6Y7CoRJPhjk71pRP8GDA2Wu6Xd8v/b8A8dvJWPIScuiwAAAABJRU5ErkJggg==',
                  },
                }
              },
              data: [8e3, 7500, 6e3, 5800, 5e3],
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'left-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '各区经济收益',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  FAt = {
    __name: 'PurposeSpecialFunds',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          grid: {
            left: '5%',
            top: '10%',
            width: '90%',
            height: '86%',
          },
          legend: {
            top: '8%',
            icon: 'circle',
            itemWidth: 8,
            itemHeight: 8,
            textStyle: {
              color: '#90979c',
              fontSize: 12,
              lineHeight: 20,
            },
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
              lineHeight: 156,
            },
          },
          color: ['#6BC7F6', '#44E6A2'],
          xAxis: [
            {
              type: 'value',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#407A80',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#CFDAE6',
                fontSize: 10,
                interval: 0,
              },
            },
          ],
          yAxis: [
            {
              type: 'category',
              inverse: !0,
              axisLabel: {
                color: '#CFDAE6',
                fontSize: 10,
                interval: 0,
                show: !1,
                verticalAlign: 'top',
              },
              axisLine: {
                show: !1,
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              data: ['扶贫资金', '医疗卫生', '渔业资金', '社区改造'],
            },
            {
              inverse: !0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          color: [
            'rgba(115,208,255,1)',
            'rgba(77, 255, 181, 1)',
            'rgba(230, 230, 230, 1)',
            'rgba(255, 200, 89, 1)',
          ],
          series: [
            {
              data: [
                {
                  value: 100,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(3,65,128,1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(115,208,255,1)',
                      },
                    ]),
                  },
                },
                {
                  value: 80,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(11, 77, 44, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(77, 255, 181, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 60,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(117, 117, 117, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(230, 230, 230, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 50,
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(153, 105, 38, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(255, 200, 89, 1)',
                      },
                    ]),
                  },
                },
              ],
              type: 'bar',
              barWidth: 7,
              yAxisIndex: 0,
              showBackground: !1,
              z: 2,
              label: {
                show: !0,
                position: 'middle',
                padding: [-18, 0, 0, 0],
                color: '#16C1A6',
                fontSize: 12,
                formatter:
                  '{title|{b}}                                                                              {value|{c}}  {unit|万元}',
                rich: {
                  title: {
                    color: '#FFFFFF',
                    fontSize: 10,
                  },
                  value: {
                    fontSize: 10,
                  },
                  unit: {
                    color: '#717477',
                    fontSize: 10,
                  },
                },
              },
              itemStyle: {
                borderRadius: 0,
                borderWidth: 2,
                borderColor: 'rgba(26, 57, 77,1)',
              },
            },
            {
              name: '背景',
              type: 'bar',
              yAxisIndex: 1,
              barGap: '-100%',
              data: [120, 120, 120, 120],
              barWidth: 10,
              z: 0,
              itemStyle: {
                color: 'none',
                borderColor: 'rgba(172,191,188,0.4)',
                borderWidth: 1,
                borderRadius: 0,
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '专项资金用途',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  }
const zAt = {
    class: 'population-proportion',
  },
  UAt = {
    class: 'population-proportion-chart',
  },
  VAt = {
    class: 'pie-legend',
  },
  GAt = {
    class: 'name',
  },
  HAt = {
    class: 'value',
  },
  WAt = {
    __name: 'ProportionPopulationConsumption',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = yM({
          pieDataColor: ['#17E6C3', '#40CFFF', '#1979FF', '#FFC472'],
          pieData: [
            {
              name: '类型1',
              value: 40,
            },
            {
              name: '类型2',
              value: 25,
            },
            {
              name: '类型3',
              value: 20,
            },
            {
              name: '类型4',
              value: 15,
            },
          ],
        }),
        i = je({
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          series: [
            {
              name: '',
              type: 'pie',
              itemStyle: {
                borderWidth: 5,
                borderColor: 'rgba(26, 57, 77,1)',
              },
              label: {
                show: !1,
              },
              radius: ['55%', '70%'],
              color: [
                '#c487ee',
                '#deb140',
                '#49dff0',
                '#034079',
                '#6f81da',
                '#00ffb4',
              ],
              data: [
                {
                  value: 40,
                  name: '类型1',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(3,65,128,1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(115,208,255,1)',
                      },
                    ]),
                  },
                },
                {
                  value: 25,
                  name: '类型2',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(11, 77, 44, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(77, 255, 181, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 20,
                  name: '类型3',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(117, 117, 117, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(230, 230, 230, 1)',
                      },
                    ]),
                  },
                },
                {
                  value: 15,
                  name: '类型4',
                  itemStyle: {
                    color: new He(0, 0, 1, 1, [
                      {
                        offset: 0,
                        color: 'rgba(153, 105, 38, 1)',
                      },
                      {
                        offset: 1,
                        color: 'rgba(255, 200, 89, 1)',
                      },
                    ]),
                  },
                },
              ],
            },
          ],
        }),
        a = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: o} = yl(a)
      return (
        Ea(() => {
          so(() => {
            a()
          })
        }),
        Da(() => {
          o()
        }),
        (s, l) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '人群消费占比',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    wt('div', zAt, [
                      wt('div', UAt, [
                        ye(
                          La(uc),
                          {
                            ref: 'vChart',
                            option: i.value,
                            autoresize: !0,
                          },
                          null,
                          8,
                          ['option'],
                        ),
                        l[0] ||
                          (l[0] = wt(
                            'div',
                            {
                              class: 'label-name',
                            },
                            '消费占比',
                            -1,
                          )),
                      ]),
                      wt('div', VAt, [
                        (en(!0),
                        sn(
                          _M,
                          null,
                          xM(
                            n.pieData,
                            (u, c) => (
                              en(),
                              sn(
                                'div',
                                {
                                  class: 'pie-legend-item',
                                  key: c,
                                },
                                [
                                  wt(
                                    'div',
                                    {
                                      class: 'icon',
                                      style: fy({
                                        borderColor: n.pieDataColor[c],
                                      }),
                                    },
                                    null,
                                    4,
                                  ),
                                  wt('div', GAt, Si(u.name), 1),
                                  wt('div', HAt, [
                                    ko(Si(u.value), 1),
                                    l[1] ||
                                      (l[1] = wt(
                                        'span',
                                        {
                                          class: 'unit',
                                        },
                                        '%',
                                        -1,
                                      )),
                                  ]),
                                ],
                              )
                            ),
                          ),
                          128,
                        )),
                      ]),
                    ]),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  XAt = {
    __name: 'ElectricityUsage',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '万度',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          legend: {
            top: '4%',
            icon: 'circle',
            itemWidth: 8,
            itemHeight: 8,
            textStyle: {
              color: '#90979c',
              fontSize: 12,
              lineHeight: 20,
            },
            data: ['2022年', '2023年'],
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0.2,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
              lineHeight: 156,
            },
          },
          color: ['#6BC7F6', '#44E6A2'],
          xAxis: [
            {
              type: 'category',
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 1,
                padding: [0, 0, 0, 0],
              },
              data: [
                '2023/04',
                '2023/05',
                '2023/06',
                '2023/07',
                '2023/08',
                '2023/09',
                '2023/10',
                '2023/11',
                '2023/12',
                '2024/01',
                '2024/02',
                '2024/03',
              ],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '2022年',
              data: [
                1200, 700, 500, 700, 1300, 500, 200, 500, 1200, 700, 400, 1100,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              xAxisIndex: 1,
              z: 3,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(115, 208, 255, 1)',
                shadowBlur: 20,
                shadowOffsetY: 0,
                width: 1,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
            },
            {
              name: '2023年',
              data: [
                500, 900, 1100, 600, 400, 600, 1300, 900, 700, 1e3, 500, 300,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              xAxisIndex: 1,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(69, 233, 164, 1)',
                shadowBlur: 20,
                shadowOffsetY: 0,
                width: 1,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#45E9A4',
                  },
                  {
                    offset: 1,
                    color: 'rgba(19,99,61,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
            {
              name: '2022年',
              data: [
                1200, 700, 500, 700, 1300, 500, 200, 500, 1200, 700, 400, 1100,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(115, 208, 255, 1)',
                  },
                  {
                    offset: 1,
                    color: 'rgba(18,60,98,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
            {
              name: '2023年',
              data: [
                500, 900, 1100, 600, 400, 600, 1300, 900, 700, 1e3, 500, 300,
              ],
              type: 'line',
              smooth: !0,
              symbol:
                'image://data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAQ5JREFUOE+1la1OQ0EQRs8kCFIQdVCCxIBpCK1AInkDHC+B4QkwvASub4GsaE0NGCRpKhGFVDQZ+Mjem9vNbkphmWTMfjNnd3b2x0iYuxuwH7wNbIewBfAGzORm5nG6ElfM3QU6AXZSkzXG3oEnMxO8thWgux8DR2tAsfxiZs/VYA38Jazi1NBvYCizv+HK4vCRyrfQgIsf7Nm6+bSnjwIeAGeZaGnXQDfoE+ABmGbixwKeAoeJAMHuv3w30ubATQb6KqDKjZPEuAXOMysZAncJbS7gJbCVEAdAKwP8AK4S2vJfgMVLLt6UDtAreWx0W8od7OJXryq16OPwR2j6+WpAyz2wDagape7vARt9AZ+G3HmhiKS3xwAAAABJRU5ErkJggg==',
              symbolSize: 10,
              showSymbol: !1,
              yAxisIndex: 0,
              z: 0,
              emphasis: {
                focus: 'none',
                itemStyle: {
                  color: 'white',
                },
              },
              label: {
                show: !0,
                position: 'top',
                distance: 10,
                color: '#ffffff',
                fontSize: 8,
              },
              lineStyle: {
                shadowColor: 'rgba(0, 0, 0, 0.4)',
                shadowBlur: 3,
                shadowOffsetY: 10,
                width: 3,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#44E6A2',
                  },
                  {
                    offset: 1,
                    color: 'rgba(19,99,61,1)',
                  },
                ]),
              },
              areaStyle: {
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: 'rgba(25, 255, 236, 0.4)',
                  },
                  {
                    color: 'rgba(51, 153, 255, 0)',
                    offset: 1,
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '用电情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  YAt = {
    __name: 'QuarterlyGrowthSituation',
    setup(r) {
      const t = je(null),
        e = je(200),
        n = je({
          title: {
            text: '亿元',
            left: '5%',
            top: '8%',
            textStyle: {
              color: '#D3F8F2',
              fontSize: 8,
            },
          },
          grid: {
            left: '12%',
            top: '25%',
            width: '82%',
            height: '55%',
          },
          tooltip: {
            trigger: 'axis',
            axisPointer: {
              type: 'shadow',
              shadowStyle: {
                opacity: 0,
              },
            },
            backgroundColor: 'rgba(0,0,0,1)',
            borderWidth: 1,
            borderColor: '#999999',
            textStyle: {
              color: '#ffffff',
              fontSize: 10,
            },
          },
          xAxis: [
            {
              type: 'category',
              interval: 0,
              axisLine: {
                show: !1,
                lineStyle: {
                  color: '#435459',
                },
              },
              axisTick: {
                show: !1,
              },
              splitLine: {
                show: !1,
              },
              axisLabel: {
                color: '#ffffff',
                fontSize: 10,
                interval: 0,
                padding: [0, 0, 0, 0],
              },
              data: ['一季度', '二季度', '三季度', '四季度'],
            },
            {
              axisLine: {
                show: !1,
                lineStyle: {
                  color: 'rgba(0,0,0,0)',
                },
              },
              data: [],
            },
          ],
          yAxis: {
            type: 'value',
            axisLine: {
              show: !1,
            },
            axisTick: {
              show: !1,
            },
            splitLine: {
              show: !0,
              lineStyle: {
                type: [2, 2],
                dashOffset: 5,
                color: ['rgba(255, 255, 255, 1)'],
                opacity: 1,
                width: 0.3,
              },
            },
            axisLabel: {
              color: '#8B9EA4',
              fontSize: 9,
            },
          },
          series: [
            {
              name: '类型1',
              data: [100, 120, 130, 110],
              type: 'bar',
              barWidth: 4,
              label: {
                show: !1,
              },
              itemStyle: {
                borderRadius: 0,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#79EBCF',
                  },
                  {
                    offset: 1,
                    color: '#0B6360',
                  },
                ]),
              },
            },
            {
              name: '类型2',
              data: [60, 100, 150, 90],
              type: 'bar',
              barWidth: 4,
              barGap: 2,
              label: {
                show: !1,
              },
              itemStyle: {
                borderRadius: 0,
                color: new He(0, 0, 0, 1, [
                  {
                    offset: 0,
                    color: '#40AEFE',
                  },
                  {
                    offset: 1,
                    color: '#25567A',
                  },
                ]),
              },
            },
          ],
        }),
        i = () => {
          e.value = t.value.offsetHeight - 2
        },
        {destroy: a} = yl(i)
      return (
        Ea(() => {
          so(() => {
            i()
          })
        }),
        Da(() => {
          a()
        }),
        (o, s) => (
          en(),
          sn(
            'div',
            {
              class: 'right-card',
              ref_key: 'cardRef',
              ref: t,
            },
            [
              ye(
                ml,
                {
                  title: '各季度增长情况',
                  height: e.value,
                },
                {
                  default: Qn(() => [
                    ye(
                      La(uc),
                      {
                        ref: 'vChart',
                        option: n.value,
                        autoresize: !0,
                      },
                      null,
                      8,
                      ['option'],
                    ),
                  ]),
                  _: 1,
                },
                8,
                ['height'],
              ),
            ],
            512,
          )
        )
      )
    },
  },
  $At = './assets/bg-2e5c39b6.jpg',
  qAt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYQAAAAoCAMAAADJyn3AAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAHhQTFRFGleXGlaWGlWUGVSSGVOQGFKOGFCLF0+IF02GFkuDFUmAFUd8FEV5E0N2EkFyEj9uET1rEDtnDzhjDjZfDTRbDTFYDC9UCy1QCitMCShJCSZFCCRBByI+BiA6Bh43BRw0BBsxBBkuAxcsAxYpAhQnAhMlARIjAREhh/IA4wAAALtJREFUeJzt0WtWAQAABeF7yauoPCqSktD+d8gu5s98K5hzphGupQuUDugCpUO6QOkDXaB0RBcoHdMFSid0gdIpXaB0RhcofaQLlD7RBUrndIHSBV2g9JkuUPpCFyh9pQuULukCpSu6QOmaLlC6oQuUvtEFSt/pAqUfdIHSLV2gdEcXKP2kC5Tu6QKlX3SB0gNdoPSbLlD6QxcoPcIBuk/4pQuUnugCpX90gdIzXaD0QhcovdIFSv/pAuUGYfADNSroY60AAAAASUVORK5CYII=',
  ZAt = './assets/topFace-09e0583a.png',
  KAt = './assets/quan1-85173a16.png',
  jAt = './assets/quan2-3159cd1f.png',
  JAt = './assets/quan3-0cc4c03d.png',
  QAt = './assets/quan4-7496b968.png',
  tbt = './assets/diffuse-65cced71.png',
  ebt = './assets/particle-073bb0c5.png',
  nbt = './assets/flyline10-82d946ae.png',
  Ik =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAD0SURBVHgB7dEBDcAgEACxZ/5NTgkg40JaC137mgesf57wDSlCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTEHKbcBaYZyb5dAAAAAElFTkSuQmCC',
  rbt = './assets/pathLine2-d4134d4b.png',
  ibt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADzSURBVHgB7dEBDcAwDMCw9vw5f4MRTTYF73/NC3bnBd+QIiRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSIyQGCExQmKExAiJERIjJEZIjJAYITFCYoTECIkREiMkRkiMkBghMUJihMQIiRESIyRGSMwBQCIExogIrTYAAAAASUVORK5CYII=',
  abt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAFPSURBVHgB7ddhbcMwEAXglyEoBEPoGARCIYTBymBhMAgrhDFoIZTBIATC21lxtGhdYieOW7u6T7L6x5HvfPXJBpRSSj0jko2MGqWTJL7tQMkkgSN/tSiRBG5cNQadjB1KI0GfeOsDJXHVmFKjFBLseSaRM0rg2q3PAbn7c8Cn2Dn5HnwJ7p3hWuSI/QHvFiRi5xrkhv+3W59P5ITz7danRi4YdsCn5NGOGdZufRo8kgSwi6zGIPoe9oI4bzIM4tkkjngExh3wqaoYrBRTkRbbslW5bzuWnTswnRorVFiB/dPVII1rVVWvWGjxX4t9qzRIZy9rpD34vH2+zrnIaN03dtj3+zXw27TPYvrvUxcXsMH8ZjRu7pw0z2JOt9sh+MU7GJCUwdZG1ejcwg03LP8oqa9RItvew9i325P7Tf6yY3/1GdbcQymllFJKKaUy9gO4eI9ILG1riwAAAABJRU5ErkJggg==',
  obt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA0ESURBVHgB7Z3/VRu7E8XFO+9/kgpIKoAOEioAKoBUAFSAqSCkAkwFQAVABUAFhAoIFfjt3bzl+TlGtndG0oz2fs6ZY/L94R2v9u6MpJG0FkKYBELIXP4KhJB3oUAIiUCBEBKBAiEkAgVCSAQKhJAIFAghESgQQiJQIIREoEAIiUCBEBKBAiEkAgVCSAQKhJAIFAghESgQQiJQIIREoEAIiUCBEBKBAiEkAgVCSAQKhJAIfweSlA8fPoRPnz6Fra2t9u+NjY23/wyfsBg/f/58+/z161d4fn5++/vh4aH9JOlYC9wXSw089F+/fg2bm5tvosBnSjqhwO7u7lrx4G+iAwUiAA//7u5uKwh8LooGuehEcn19HW5vb9+iEFkdCmRFECF2dnZaQaSODlpAIBDKxcVF+0lWY0Jb3s7OziaeeXp6mpyfn08aobu67wXNlbPFDQ9WLUAsBwcHkyYSumqDzObKWRP28vIyqQ1EFQrlT+M8SA+Qy9dGE0lCE1HCzc1N288i/+FK0RaspjTrPRqhsJ/y21w5a8ZqTLPmMfTUa3ApFuYqMEQrpcY0ax5d6tUIxc2wtjauFC2xw8PDtze/NH0YQpo1SzfqVbINC5grZ3sZUgTk1NPg39LvHUqaNcv9/f2Q0i5Xzq5s01FjlibVEn33eDyeDJmTkxMz7ZzQXDm7tM2LGrMgZWj6JL2vMcQ0axbc45qjSZW1WBjHv7y8XKp48PT0NIxGo9AHfD86sKsUKaL6FrVRXcn66+vruyXr+N719fW3znFXMm8N/Jbj4+NwdXUVasSNmpcxhP1VQPoleQO+l2bhe/F2Re0WOrbNwy2KVp3hOxC5kB7iu3ENK32hSlMuV85GH5wmakz6gLH+vtfFgwo6QRwdHbViyP37cU1ce1FamRq0gcaLwJC5cnauIQKgPyGh77Bv90a39lBAuIhuJaIL2qKifokrZ/8wvDml4gAaw75WDSle7shSkUhcOfs/gzg035C1T4LhgUVU0XihLAPapkS6qWyunH2z/f199fQB31dZ/jzXIBS8DHIIBfcUbeXp/syYK2dbww1PRTPk6+peSA0d+xxCcSwSV84mFQfAG8/T/dAwRJQcS4mdisSPs9p9jllqnxVeZMtUH0hw2ifx4SgaL5U48L1INbzci9SWsn/iUCT2ndSY53iPoUeN2D1PFU2cDQHbdhCjSqnEwaix2DBokQJpoWhGs+1g3/KRRY3D9dbLm9Zk7CxoWwe/365zqxYeLsPAFvuoGe4Z7p02DgocbTrWFQFqglnkIUwEprQUi8SMR3N7TqXolA9tAjClafdLpEsOEps9p7RHTygOfdMWieFiUVsOafc7KI50pi0So6OKdpxBmNWE4khvmiIxmmrZcUZzlITiyGeaIjGYatlwBOUNWmCkxcrvGoppjm4ZS7XKO6E5aoUoZOE3Dc0wfK6VARhbl1PeCWyaoEFla6HdmeaL7vv371Z+V/mbqkUFyzvdm+Zmekbas6wDWtGDnXI7hj6EBkY67OUurvW2qXlHEq+mNdlroAzF901kv8OmaS1wM/DyK3NhregxwPMq3JhWqlU4ipS5sEb0YGpl3ypo5/wX1Rq5Ympl37TaulQUKXJG4cnJSZDy48ePdtt9Yhu0EY6YkKJxrmRf3L1R2DH3ZZgVl3bYS82uZ48gGofUM3r4AgcEoc0k4OCgptMfSpBVkdJSBPz/c/tMk5tGFClUZ5fvYhpDuxzW9WsaZfG5O+tZU6z9/f0gAWnV7e1tID45Ozt79zzGZSnRWc+mRml6JTkqjWbDpFGkwObieS6kkV5x5Mq/oS8iJWealS3FkqZXSK04cuUfpFjSNDl3mpVFidL0ip3zeky6KWDmkcz0F5FODg7xUJuaTWPId2NjI4uvWVIs6eTg1dVVIPWANOv6+jpI2NvbCznIIpCdnZ0gQXoziT3G43GQsLm5GXKwFn6HkqQ0OWNo0qzQl7W1tUDqAqUjeC7w2QdEoY8fP4bUJI8gW1tbInFwYrBO8IA/PDyEvkBYTT8kpCa5QCTiAEyv6kXattvb2yE1yQUi7aAzgtSLtG2RnaQmuUAknSlpGCa2QdtKarOk2ckyZOmD9IXiqB9JG+cYyUoqEHSk+o5SgMfHx0DqRtLGiCCS52sZkgpEmiOy/1E/0iwhdZqVPIJIkK4dIPaRCiR1Rz2pQKTqZh+kfqQV2q5TLIlAED0YQepH2s6DTbG49mM4SNp6fX09pCSpQCSlAIwew0EiENcRRAIjyHB4fX0NfRlsH0Ry04gvJNmCa4FIYIo1HCy3tVmBEGIBCoSQCBQIKc5oNGpXjfaxz58/h5RQIIREoEAIiWBWIKmH7whZhqQCkQzfpS4hIGQZzAokx5YuhCwiqUCen59DX3Js6ULIIsxGkBwL8glZRFKBSAoOpevZCdHAbAQBjCKkNEkFYn29MSGLMJtiAQqElCZ5iiURSa4t7kk5rKfRf4fEIM3qexMYQern/v6+/cRzcnd31+6FJt2SVJukR1idnZ1NJDQiyXLUFi2/oW3foxHO5PLycnJ0dJT1VNtZyxJBJGB3eO6PVSexnf+RPcCmT7TFc4AIg+1K8Xeu5yKpAqUHeN7c3BR7e9DSGtpWQo7sIssRbC8vL6KjtrAohmvU66N5xkNfMPiTerEUyFLuLjlJCMJiZ70+plOnPuTa+T+LQKS54v7+fiB1IT35OOfR4MnzOGk/BIfO4/D5HL7S8hjaVAKeqRx+ZokgyBelhYvSsw6JHQ4ODsT7NufaeTPbklvpiaaHh4eB1IE0Zc59sFKWUIXJHilMs/ybNN0GmScO890cad45Go1y3hhaAjs/P59IeHp6yupv1l1NLi4uggSkWVxE5RfU5En7krnTq6wCkQ7NQRxHR0eB+ATikFbvSl+yfcgaslCEJoFDvn4N6ZGn9AqWfeM46WgWo4hPkB5Lo8fp6WkoQVZF4u0v7awzivgyjFxJowfINTk4bdkjCIoOpXkko4gvNKLHeDwudixfdlVqzImUeqPQVjONeY/CbV3kouK1AIBrRexbBe1c5sJaUQRLMgvePFrEDg4OJhqUXHIbCl5Y5e2CDjtTLXum1TE3kCWUu7hWFGGqZc80Xn6gcPSAFb242o1kqmXHTk5OJhqgbsvA7ynrQGzrl1Ux8LYZvGm2p5HUubgD4r2zOpDzsj9SzrT6HcBI9ICVd0Jjdr0DtV6cZS9j0jq7DmMvOhNOtH0ILQy9fQZj0nUe02B42NBvM+OIWocdoKNo6bfVbFqdcoAoZOz32XEGYVUr1QIUSXrTFAcw2Ic05YxqqgUoknSmLQ6jS6rNOaSaagGKRN+0xWF4steeU9qpFuBEop5pi8P48LxJp9TKUADrtXQMw+eao1Udu7u7ln+3WcfanFQDHsIjN7xgtOY5pnGwlZNp59pThiQYG1N3aYjmWjPk06BtHfx+2w4irPdtHG40J7fDw8NJCtCmTioezDvYq8aH4pDfc+3RxA5nNXMunGz7EcuObKH40cvvsmiIGtqjiB0OB0zcOLqUSJzktSYtZdToxOFwwMSVs9F1zlqVvBjnH9KwMO6Z9tzGPJwOmLhytrV5ItHKa7sHBd9X++RiJ4xU6VQF4oC5cvbNcMO7htUSx7zBAPwb16opouQUBq7hfKjdlbP/M+SzmiMisVliXAf/vWeh5BRGJ44KJmldOZvMVtkBEB1ZL29FiAKlHCk73/PAC6WSCgZXziazPmUUeEMiqlirJYIoMPsN33JFi2kq2xvAlbNJTGsHQLyl0bEv8ebENXFt+FBCFB0YZq9pT4C1f/8YNM0bT7z7+CzYxf7h4aG1u7u7t3/jUwJ2toevjSDC5uZm+wmzcDQdzu8YjUahJgYvkKbTmrVRIRBs4z/9+fr6Ovd/u76+3j74nShgFs9oxG/Y29vLfn5gDgYtEDxwiB6kPxDFt2/fip3dkZrsB+hYAtGD9ANR4/j4OGxvb1crjg7zHaUUprlF5tDAQMCASnFcOatmKRYA1Q5Gxwa4tt+Vsyqmud59KGAJwUC3dHXlrJohRRiPxxMSB+nUwNf0u3JW3RBNcpdheAD3hMdJBAqkMwrlNxTGH+bK2eQ2xNQLnW/0MSiMuebK2WwGoaBGq+bRLhRoYnMLnqcSNVfOFjG8WRFVahALo8VqxmLFFWkerNBElvDlyxf1AsdUYKb7+vo6XF1dVVkvlRIKRAAEAsHs7Oy0FbVWBIMyEIjh8fGx/ay9FCQlFIginUggmq4UPXX1LR5+lNE/Pz+3n4gQFIQeFEhiIJBOKF3JOsrYu2izKOogGnSl8SiL70rkIYbub5IOCoSQCIMudydkERQIIREoEEIiUCCERKBACIlAgRASgQIhJAIFQkgECoSQCBQIIREoEEIiUCCERKBACIlAgRASgQIhJAIFQkgECoSQCBQIIREoEEIiUCCERKBACIlAgRAS4R+Py6dcyrAs4QAAAABJRU5ErkJggg==',
  sbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAnCSURBVHgB7d3tURtXGwbgR563AN4OtgToADrAFYRUYKjASgV2KrBTAUkF0AHuQOrATgUn53iXQBxE9LHfuq6ZM/J4BKPhz3Pv2fusIgAAAAAAAAAAAAAAgGlYBDALKaVP+eU8pu2PxWJxHUDnBACYiRwATvLLQ15VTNM6r7McAL4F0Lk3AcxCMzgvoh6kU7PO68Lwh/7YAYCZyTsBp1HvBExJufL/EkBv7ADAzDSD9Cam48bwB4CW5J2AZRq/ZQAA7coD9nMar9sABqMDADOW6pMBd3mdxrisQ+MfBqUDADPWDNi3Ma6TAevQ+IfB2QGAI5DqkwFlJ+AkhvX9qKLSHwD0JIeAqzQ8T/kDgL6lYU8GLAMAGEYa5mTAxwAAhpOH8UleD6k/q1SfRgAAhpQHctUM5j6GfxUAwDjkwXya19fUna+GPwCMUOr2ZMBlAADjlLo5GbAMAGDcUrsnAzT+AWAqUjsnAx4CAJiOdPjJgFVS+gOA6WlCwD4nAzT+AWDK8iC/TLvT+AeAqUu7nQxYBgAwD3mwf9xi+Gv8A8Dc5AF/98rw1/gHgDlK9RcHrV4Y/uX/qgAA5in9+2SA4Q8AxyAP/PNnAeA8AIDjkAf/tcY/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwGFSSpdlBQAwOXmGn+T1KXaVf+gq1d4HADAZeXZXea3Kil09CwDFhwAARi/P7NNm+Kc2AkDxUBJFAACjlOf0ux9mdysB4PsvEgIAYHzKLfuX5nbsakMAKL4qBwLAODyW/TbM7FYDwCPlQAAYUKrLfg+vzOpOAkChHAgAA0j/LPvtHADexGGuk3IgAPQqz92f8stdXlXs6dAAUJyWDyEEAED3mlvwn/M6iQO0EQCKKuoQcB4AQOvS05P9ltGCtgJAUUUdApQDAaBFzS572fK/ipa0GQAeLYUAAGhHKftFPfxPo0VdBICihIDbsl0RAMBe2ij7bdJVACjKw4KcEACAPbRV9tukywBQVFH3AlrdtgCAOWuz7LdJ1wGgqKLeCbgOAGCjxyf7RYtlv036CACPPigHAsDLnjX9e9k17zMAFMqBAPCDVH/JXrnyr6InfQeAQjkQABrN7vhtdFT222SIAFBUoRwIwJFrvlRvGQMYKgAUVSgHAnCEmsf6lvv9g83AIQPAI+VAAI5Gcwu83O8/jwGNIQAUyoEAzF7zpXm9lv02GUsAKJQDAZitPN/eRX3MbxQXu2MKAMW3AIB5+n+MyJgCwG95XSwWi3UAwMzk+bbMLxcxkovdsQSAX/If5iovOwAAzFaec/f55SyvdQxs6ABQBv7PTSoCgNlrdrrLTsCXGNCQAWAd9Zb/5wCAI1JCQF5lJ+DXGMhQAWAd9fAfNP0AwJDyHCwPAvolBjBEAPg9rzNlPwD4uxz4NnouB/YdAErZ762yHwA8yXPx+8Vx9FgO7DMA3Cj7AcDL+i4H9hEAytV+ud//MQCAjfosB3YdANZR3++/DwBgK32UA7sMAPeh7AcAe+m6HNhVAPg1f/ALZT8A2F+X5cAuAsBNs3UBABzoWTlwHS1qMwAo+wFAB5oQ0Go5sK0AsA5lPwDoTLmt3mY5sI0AcB/KfgDQi6YceBMHOjQAKPsBQM+a2+3dPDkwpXSVXqfoBwADyrO4ymv1yqxebfrZfXYAlP0AYASelQN/j7Zs2AFYlbQRAMCo5Pm83GUH4LVf9GMAeDD8AWC8yu35tgOA7X4AmIA8s0/TUy/goACwDABgMp6VA/cKAJclBAQAMDl5hp/k9SEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6XUqrKCgDgOOTBf5LXKq+H8u8AAOYvD/1P6cmnAADmLQ/89+nf3gcAME950L9Lm/0UAMC85AF/ml73tbwnAIB5aBr/q/TfynuqAACmLT01/rdV3utkAABMWR7mt2l3twEATFN6ufG/LScDAGBq0uuN/21dBwAwDem/G/+7cDIAAMYubd/431Y5HlgFADBOaffG/7ZWyckAABintF/jf1t3AQCMSzqs8b+tDwEAjENPw/+RkwEAMLQ8kM9T/84DGJVFAEcj1e38cm++in59y+tssVisAxgFAQCOxIDD/9E66hDwLYDBvQngWJTn9VcxnKr5DMAICABwBFLdxh/DE/rOk5MBANC91G/jf1tOBsDAdABgxvKgvYzxbrtfLBaL+wAGIQDATKW69PeQ11gfyetkAAxIBwBmKD01/sf8PP7y2e6SLw6CQdgBgBnKQ7Vc+U/la3m/5F2AswB6ZQcAZiaNp/G/rdPkZAAA7C+Ns/G/rfcB9MYtAJiJNO7G/7au8u2A3wLo3P8CmJOfY9r+DAAAAAAAAAAAAAAAAOCZvwCgkvxAcNS/iwAAAABJRU5ErkJggg==',
  lbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAD/CAMAAABb2Q/2AAAAsVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+3mHKcAAAAO3RSTlMABQoPExgdISgxJTYsQDtTRUr+9vpOWXJdaWVhgIx2om2n6oiWmYTKr5G68J22eqvBfeHZ5c++1LPdxUM4ZWUAAAZvSURBVGjerdrZdpswFAXQmnk0EMB4Ajwbz2Mc1///Yb0SuLg1km66mtfsdRBXRyIP+fH205IURZZa7794h7KqKZKEkrqFCgVpOSpOKoaJljZWOm1VwUnTRUv7/0sbvc62r2FlgJOy0o6x0kVL30NJiUh0ZkfHZuLXGWj/PTNArzPu68hMr4/MVEGqMlJaWNkDKWGukM4IK70uTipq3NVBthASMoWb1CJS644cIoG2OJDIQUYlm4KDH7mWxDJoKfX+3iSyooxEMqRSyhVlJFJp9YY2SGZoiyGZkMh+YtPRN4eWDqQCckSl1CoxIxKkQTMVSWp+pyeUQY4WbSqftuG9S+kkqWupitwkgdZSe5VSo5SeMgOpiaWqmfuVb1BZUUbkU6pyHdokJSJPs0AoZcjU7WRBMhWgQjnkSqmW2dB3ailx5HAW1FJqzJRLOd3Gjo6R7cVTym+y9aecbr1KCjLdae7hMt0090yupBAq/yLld1lHapa7WMVEElqNnimnr1JiS3+Rxqal8aVCZZp3+FJ+ylnRBalSyperA1IGM7ScFwNbIJXvSSOY3/u2QaTSIKVXudp2uVIupW7Eq3kHLetMmSu3RQ8p8/XoVQJtGieVu55A0lfXHY9m6iqhQpkg5fhNtljySKSGkPNxry2SKpGdec6VciUtIvtIOV5nbQekypLKUx4ep1rKHNk9PPZIWdRSEcmTi5KDYjl0HatZSn/IO1Kag/E9E0m1kkVSSlUg++Mic02UvD8WCKkbZn/3ORVLrZSLb0kdIdf06brGkspT9tZf6T9KiSmL25Aj5Ve5Bml8VyqNUn2u8zP1cfJ2mQmlRuToeJnRp2v/TdpE+jaVKk86IH8iZfJAy/UjRcrdkUhLIC0iH1j5uMwDnFyec7TcBrYjkDrIrJI6RuYYaYK8YqRh2vvP61gkNSpPy69t0EbI9pDK+iDx5GUbU6kJ5OIyKQKc/LnZ4TKnZ5R0zHZ63qxxmatreItdkbQM011NwqPHk1WVcJIWxJ2dJzuQDl5aukjOr5O159oYOYmWT6ny5Sb6xMktSkI9fSp9jMw30VcHpCGW4QeRpki2vyM34bITtHmSFqSSPkaO8TKMvujT4WZiSZ3IYBx+XLoI6WKljZVOJQccqbxJhyeNSv4cBLRMfBnDPD8HMVIuqTQwmRjpx7BHF5GkVYoP8EZ9DyG9UkJBOdJ6le3/JB2okleA7OFlWVBmQ0C6IDfhF5UOS2oaLUjnXkqXJ+kWUTnCyTA6j7qwSSxJBw+yew8/zgmVhqaxpe91d7XUEXIQ+zRTZUnYokEpq41XBPKaVZKb2aeSbDxb0hukAzK8iCSMs5J72CS+hMzeGuSJSJsnYfAgP64nsp0Mqfwhh1Q6fDkqZTcWy1v4McHIAZWLpC5Tk4QqeThJNzP5jgzPC6iISPaTI8gpXxovstx4kYR1iiUUJDtGONnLHiDTPU/qpdx/W9KCsiQUuTuicnXqieWJyqFIxiCXYXRd0YIypUPlcBmGRMJHli+TWvIzB8liCeucLWiV2dKv5Ga2SKjUm6RGpFfJOZRJIPsZXk5LmdF7kSVJ6fbTz0p6bGnWcgu140lakPQzjCbbVCxPIEOBtF5kXhaUKeH2HA1XX7DOfLXvYeWJL6EgtewEzVKt5GJG5LiqcrM0XuWsklqjpKWjMgQ5EshsSjMPAul7IOdfUbQ5zKHKIC2uvEThBGTCl1C6LchNQWTMlynIj7DYTkG6PLmv5YAre/vVU2YCeVrlP4nMsfKep3A8GFIH2flL2oxMUuThbFzJfZ8ldQfkiMpos8tXWDkm0ufJxfwpT0J5OMM61wcoPUiDKRMiP4ic8WU3mW6pvEFBhbI4RyALjLxSOYfSs2VM5P0KTz9CQblykKQ5kdHxLpIZkVEUVrLNkC6VOyIf9y3IgCHNV7mD0nPlfjXekXUudzkcJLb0+iDXE5ycVXItkqdapgypUNk7zQ63/y2Hv+U4zVjSKmVxm8A8P29COS+Ov+WgUcog/VouK+nwJawTl0nlmitdpNRrWc8TLW2OpJOvukROh6pITZ33+q8STodpNUgFZFz2k3SenCPPfZctkOT+pKeDyCO5Q0CW/3vyJu3qZgC5Jrdi7Dram6xGT+9kuEOie135Ur4dOfLlOoOsLjCr/rzXki6U/nVBvkf0c1Qu809Z9w4+8GeYUnrqkWm+LvMXnJRTlwruvBIAAAAASUVORK5CYII=',
  ubt = './assets/focus_bg-b6803e2d.png',
  cbt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAOVBMVEUAAAD///////////////////////////////////////////////////////////////////////8KOjVvAAAAEnRSTlMA3yDvvxBAn3CAYFCQzzCgj6+a/gWFAAAIxklEQVR42uzBgQAAAACAoP2pF6kCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGB27gRJcRiGAqi8O2sH3f+wM1XM1lOAHZwQKfnvBF3tjyxbBgAAAAAAAAAAAAAAAAAAAAAAAAAAAACAvfBPxkz+lro8xEBwMfyd87dumAkugx9xfhkswRXwUyb1CMH58UvTEgm0CjOVcYlLA4FCMTkOVQFABs4nLo5/ylTEdUxCP6BGyJ7vPBVxNd8TKBA6x3+EugCgDJxGTPyvnkp4HURAtOj5O18RAETgLKLn/7lQDgAicA7W8wN9OQCIwBmEhR/y5QAgAieQHT/mwj4BYJMJpIgTPxVLAXibwdRYhrDwC6kmANgHFBsc/7V+D+AWBpeDRws3LojFAKAI6BUdl4zFAKAIaBUWLnOFADRb8JL0INZwjUiv+MkYw00MtoFDZMdVRqpgY8zdbXL8Doc7gQMsXMnRCvPQ3RyvthB8lp24WqSV5v7L8DoTtoGPmg3XG+kNc+/RCIg1OK7nB3pP6G9cz+Hh6MdkruZzoAZ2TR3oCD6i40pujNTMfhkkQJSlemAbaBOhN0iAHImr+Egbqo1AIthZalj+tgggARIkrjBF2kFvkIDDpUMvZnuDBBwrcVkXaDe2QwKO1HGRt7QrO2EwcJhOxFiuNzgNHqM7/ON/Zz2XYDy8g0HCx7/2Khpzgc1ZJ2gcZ00pjPjOwKf/5WOgDwqjoDhewiRt18382kSwoUXet7Rmg8Pgx2SJ9dYaYUXpvAoNoA90iOD5FYc2YCPB8CtfdJgvfsXgGyPbWOReu3VoA/bXy13/UgLwQ8MbsEbw+hcS4LAJtEui17+QgBtBo174+hN1GArsyBqZ/f+/vrAJNGjYADwJ4XES2Mus4pgdDE4COzHS7n8fswZToV1kfk7UxH3GTGAP1qj5t2b0gTtI/NRIwozoAzdnNTSANY2goG5FlaTqX2qd/POqLlZNA3CXcRTcVtL2ifLa/mDZrIobgH9ZhxLwkQIg9td5M0rAdqzGqzWPErCZpOkE8JvFd8a3YmW/AVj/NkDcxYVwSVsHeBecytwKZNR1gHcZE4F9H4IZEm5SdXkllldaAIgiToIbsGoLAJHHSbBdUlsAiKKaCbZgRm8BeF4CHEGlQXEBIIrYA1olzQWAyOA2sJHTXACIMq4C2gxq3oE9FpyGh8yCJe0ldOQHfFaS3+M5fWPAQhvofI/Vrxb1X6V5rH6DUXcL+L0NdCli9VeatO8AROHX6o9Y/fXsGX5swzO7ERc/b+n17wBEA1b/bQlvqq7NqD8DQAt7hh0A3jfgGvXaRtWDQGjmlc8BoJFDC3BpM1qAaxvwnu7auhPcA8MP9u40yU0ghgIw6s2AWcy7/2EzNUmq8iMzeNwNSNb7jgCNpFYvVNh4ss63xEu3fYusAV3LrAF9K+ZuhaGm7pwE+NZzEuDbwMsVfFt5rNK3jQPAt2R+RzgdcSagIyeEA8A34X4w37gh0DkOAOe4FOAcTwXR+0ic0vjGpoZzbGo4xwHgHLtazrGp4RybGr4FNjV8K9zg6lvhTQe+cYezc9zh7NzGc66+zdzh7FvkjaeuLTzo7NudfSDfeNuRc7ztyLnIWaBrvPHSuZGTAN9unAT4JvivqSMXFrAGdG20//NDqpG4I9S1bP0H6OqUh6ns+RZ/v9SjPKKxCdTGEqCVXB7R3EJ6AM8ENJHLLVrcTDeCXYB6eUzRaBMtgdvBGrx9s48vgAsBVXKfTAfQGyeBh7RRo5EyMAv7wFVyhOkzFSMzQKUVphupwgxQqcByFT2CGaBWhOHtFGI7fqkwGQ4BI5gBqhXYDQECrgPUS2ZDwGh47CrSw+pyioArwQ3kCJu9gBEsAZsYYLIdGIQlYBsZgMHDdQNYAjayWnyUAQwArRQYLKdni6NWqwRzdeDIAHBKCIhKP6cgDAAtJWtJIDEANFVgKwn0YABoK5lKAgEMAOc9UlHXDsrCANDchC89OmUeDADt5WimDOjxJWEAqHusFm5bWmBmqNoy2/iwggBcBjxCgYVCMIuVSGXPBOjvByWwAjxKjvof7g02EpVNdwC69wYM+MCNYIfZlI+AAfpjlGk5qh4BA5gADlageAQMYAI43KR3BAz4xBthDpUFSvPsDTDRqLAuRHwn5e4SOeGDqTVrq3pAX60VBADXAM4x4VuydKdbBCwAzjND2efW4zezhxiNCYLvPXJ3ovyAxqz0zpao6JEHAVgAnuwOaEkDfcQfvA7oRD32pNCdICR80Nucel8D9sjYHa6PfP9XmbBrDt2hQgLf/3VW7BtCd5g8YN/a0WFW4MI80Ee+/6utuGwIlBl8/9dbcc0QKAl8/yqsuGAIlAS+fy0GPEfG3DWRe8FfXABSYMCT5Bba/LPuE+d/agx4WhpDq5/X6GlF0z3iedvLqeCe8LzI/v+JguAn0rjUdx717UnxLMz4GbmN4eUN6de3oGn/89wXt+G+dD8QwfJfrz7iFXHehr6U0HCQRZZ/lwiCKiIyp2dygKK9SPSvPKFafQ6YeP7jOqOgUm0OiOp/YvPewoo6lfOAjZ//j+kKAntn09n8Ua8uCHTfW5n9DVgEL3u9FzQz++vRy0EDIEfO/U14OQ90OxKjvxEvDoGXfgOT2Pr5xc6d4zAIAwEUDdjsm+D+h02X1pZFgcN7V5ivGRr8REUJFLxRFR3/pypI4JMSjb8m7VESQP4NGIz/6dqjuTWA7voJk0+/KsyxIIDkDYij8Vcjfw1k/pYeVru/MssR7gmgu4LLX6ecBj5pu9Vfr37dEgHw79r5aATwcu2yxiCAl9uX6YxBAC/X9cs4DWfcmkYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMC3PTgkAAAAABD0/7UrbAAAAAAAAAAAAAAAAAAAAAAAAHAKGbwwCsmp53wAAAAASUVORK5CYII=',
  hbt = './assets/focus_move_bg-cf41417a.png'
class fbt {
  constructor() {
    this.init()
  }
  init() {
    ;(this.instance = new Hq()), this.instance.addLoader(wp, 'FileLoader')
    let t = '/',
      e = [
        {
          type: 'Texture',
          name: 'bg',
          path: $At,
        },
        {
          type: 'Texture',
          name: 'face',
          path: ZAt,
        },
        {
          type: 'Texture',
          name: 'side',
          path: qAt,
        },
        {
          type: 'Texture',
          name: 'quan1',
          path: KAt,
        },
        {
          type: 'Texture',
          name: 'quan2',
          path: jAt,
        },
        {
          type: 'Texture',
          name: 'quan3',
          path: JAt,
        },
        {
          type: 'Texture',
          name: 'quan4',
          path: QAt,
        },
        {
          type: 'Texture',
          name: 'diffuse',
          path: tbt,
        },
        {
          type: 'Texture',
          name: 'particle',
          path: ebt,
        },
        {
          type: 'Texture',
          name: 'mapFlyline',
          path: nbt,
        },
        {
          type: 'Texture',
          name: 'flyline',
          path: Ik,
        },
        {
          type: 'Texture',
          name: 'pathLine',
          path: Ik,
        },
        {
          type: 'Texture',
          name: 'pathLine2',
          path: ibt,
        },
        {
          type: 'Texture',
          name: 'pathLine3',
          path: rbt,
        },
        {
          type: 'File',
          name: 'mapJson',
          path: t + './packages/3DMap/zhejiang-map/assets/json/zj.json',
        },
        {
          type: 'File',
          name: 'mapStroke',
          path: t + './packages/3DMap/zhejiang-map/assets/json/zj-stroke.json',
        },
        {
          type: 'File',
          name: 'hotmapData',
          path:
            t + './packages/3DMap/zhejiang-map/assets/json/hotPoint.geojson',
        },
        {
          type: 'Texture',
          name: 'flyLineFocus',
          path: obt,
        },
        {
          type: 'Texture',
          name: 'arrow',
          path: abt,
        },
        {
          type: 'Texture',
          name: 'focusArrows',
          path: sbt,
        },
        {
          type: 'Texture',
          name: 'focusBar',
          path: lbt,
        },
        {
          type: 'Texture',
          name: 'focusBg',
          path: ubt,
        },
        {
          type: 'Texture',
          name: 'focusMidQuan',
          path: cbt,
        },
        {
          type: 'Texture',
          name: 'focusMoveBg',
          path: hbt,
        },
      ]
    this.instance.loadAll(e)
  }
}
var kE = {},
  BE =
    (Mb && Mb.__values) ||
    function (r) {
      var t = typeof Symbol == 'function' && Symbol.iterator,
        e = t && r[t],
        n = 0
      if (e) return e.call(r)
      if (r && typeof r.length == 'number')
        return {
          next: function () {
            return (
              r && n >= r.length && (r = void 0),
              {
                value: r && r[n++],
                done: !r,
              }
            )
          },
        }
      throw new TypeError(
        t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
      )
    }
Object.defineProperty(kE, '__esModule', {
  value: !0,
})
kE.elRectification = P0
var fA = null,
  cv = '',
  gM = '',
  mM = '',
  dA = null,
  Ok = null,
  Or = 1,
  Ah = !1,
  FE = {
    isAutofitRunnig: !1,
    init: function (r, t) {
      r === void 0 && (r = {}),
        t === void 0 && (t = !0),
        t && console.log('autofit.js is running')
      var e = r,
        n = e.dw,
        i = n === void 0 ? 1920 : n,
        a = e.dh,
        o = a === void 0 ? 1080 : a,
        s = e.el,
        l = s === void 0 ? (typeof r == 'string' ? r : 'body') : s,
        u = e.resize,
        c = u === void 0 ? !0 : u,
        h = e.ignore,
        f = h === void 0 ? [] : h,
        d = e.transition,
        p = d === void 0 ? 'none' : d,
        g = e.delay,
        v = g === void 0 ? 0 : g,
        m = e.limit,
        y = m === void 0 ? 0.1 : m,
        _ = e.cssMode,
        x = _ === void 0 ? 'scale' : _
      fA = l
      var A = document.querySelector(l)
      if (!A) {
        console.error("autofit: '".concat(l, "' is not exist"))
        return
      }
      var S = document.createElement('style'),
        b = document.createElement('style')
      ;(S.lang = 'text/css'),
        (b.lang = 'text/css'),
        (S.id = 'autofit-style'),
        (b.id = 'ignoreStyle'),
        (S.innerHTML = 'body {overflow: hidden;}')
      var T = document.querySelector('body')
      T.appendChild(S),
        T.appendChild(b),
        (A.style.height = ''.concat(o, 'px')),
        (A.style.width = ''.concat(i, 'px')),
        (A.style.transformOrigin = '0 0'),
        (A.style.overflow = 'hidden'),
        pA(i, o, A, f, y, x),
        (dA = function () {
          clearTimeout(Ok),
            v != 0
              ? (Ok = setTimeout(function () {
                  pA(i, o, A, f, y, x), Ah && P0(cv, mM, gM)
                }, v))
              : (pA(i, o, A, f, y, x), Ah && P0(cv, mM, gM))
        }),
        c && window.addEventListener('resize', dA),
        (this.isAutofitRunnig = !0),
        setTimeout(function () {
          A.style.transition = ''.concat(p, 's')
        })
    },
    off: function (r) {
      var t
      r === void 0 && (r = 'body')
      try {
        ;(Ah = !1),
          window.removeEventListener('resize', dA),
          (t = document.querySelector('#autofit-style')) === null ||
            t === void 0 ||
            t.remove()
        var e = document.querySelector('#ignoreStyle')
        e && e.remove()
        var n = document.querySelector(fA || r)
        n && (n.style = ''), Ah && dbt()
      } catch (i) {
        console.error('autofit: Failed to remove normally', i),
          (this.isAutofitRunnig = !1)
      }
      this.isAutofitRunnig && console.log('autofit.js is off')
    },
    elRectification: null,
  }
function P0(r, t, e) {
  var n, i
  t === void 0 && (t = !0),
    e === void 0 && (e = 1),
    FE.isAutofitRunnig ||
      console.error('autofit.js：autofit has not been initialized yet'),
    !r && console.error('autofit.js：bad selector: '.concat(r)),
    (cv = r),
    (gM = e),
    (mM = t)
  var a = Array.from(document.querySelectorAll(r))
  if (a.length == 0) {
    console.error('autofit.js：elRectification found no element')
    return
  }
  try {
    for (var o = BE(a), s = o.next(); !s.done; s = o.next()) {
      var l = s.value,
        u = Or == 1 ? 1 : Number(Or) * Number(e)
      Ah ||
        ((l.originalWidth = l.clientWidth),
        (l.originalHeight = l.clientHeight)),
        t
          ? ((l.style.width = ''.concat(l.originalWidth * u, 'px')),
            (l.style.height = ''.concat(l.originalHeight * u, 'px')))
          : ((l.style.width = ''.concat(100 * u, '%')),
            (l.style.height = ''.concat(100 * u, '%'))),
        (l.style.transform = 'scale('.concat(1 / Number(Or), ')')),
        (l.style.transformOrigin = '0 0')
    }
  } catch (c) {
    n = {
      error: c,
    }
  } finally {
    try {
      s && !s.done && (i = o.return) && i.call(o)
    } finally {
      if (n) throw n.error
    }
  }
  Ah = !0
}
function dbt() {
  var r, t
  if (cv)
    try {
      for (
        var e = BE(Array.from(document.querySelectorAll(cv))), n = e.next();
        !n.done;
        n = e.next()
      ) {
        var i = n.value
        ;(i.style.width = ''), (i.style.height = ''), (i.style.transform = '')
      }
    } catch (a) {
      r = {
        error: a,
      }
    } finally {
      try {
        n && !n.done && (t = e.return) && t.call(e)
      } finally {
        if (r) throw r.error
      }
    }
}
function pA(r, t, e, n, i, a) {
  var o, s
  a === void 0 && (a = 'scale')
  var l = document.documentElement.clientHeight,
    u = document.documentElement.clientWidth
  ;(Or = u / l < r / t ? u / r : l / t),
    (Or = Math.abs(1 - Or) > i ? Or.toFixed(2) : 1)
  var c = Math.round(l / Number(Or)),
    h = Math.round(u / Number(Or))
  ;(e.style.height = ''.concat(c, 'px')),
    (e.style.width = ''.concat(h, 'px')),
    a === 'zoom'
      ? (e.style.zoom = ''.concat(Or))
      : (e.style.transform = 'scale('.concat(Or, ')'))
  var f = document.querySelector('#ignoreStyle')
  f.innerHTML = ''
  try {
    for (var d = BE(n), p = d.next(); !p.done; p = d.next()) {
      var g = p.value,
        v = g,
        m = v.el || v.dom
      if ((typeof v == 'string' && (m = v), !m)) {
        console.error('autofit: bad selector: '.concat(m))
        continue
      }
      var y = v.scale ? v.scale : 1 / Number(Or),
        _ = y != Or ? v.fontSize : 'autofit',
        x = y != Or ? v.width : 'autofit',
        A = y != Or ? v.height : 'autofit',
        S = new RegExp(''.concat(m, '( |{)'), 'gm'),
        b = S.test(f.innerHTML)
      b ||
        ((f.innerHTML += `
`
          .concat(
            m,
            ` {
      transform: scale(`,
          )
          .concat(
            y,
            `)!important;
      transform-origin: 0 0;
      width: `,
          )
          .concat(
            x,
            `!important;
      height: `,
          )
          .concat(
            A,
            `!important;
    }`,
          )),
        _ &&
          (f.innerHTML += `
`
            .concat(m, ' div ,')
            .concat(m, ' span,')
            .concat(m, ' a,')
            .concat(
              m,
              ` * {
        font-size: `,
            )
            .concat(
              _,
              `px;
      }`,
            )))
    }
  } catch (T) {
    o = {
      error: T,
    }
  } finally {
    try {
      p && !p.done && (s = d.return) && s.call(d)
    } finally {
      if (o) throw o.error
    }
  }
}
FE.elRectification = P0
var pbt = (kE.default = FE)
const vbt = [
    {
      name: '告警点#01',
      level: '差',
      value: 84.9,
      centroid: [119.16164693, 27.58366386],
    },
    {
      name: '告警点#02',
      level: '极好',
      value: 12.5,
      centroid: [122.24179543, 30.01102572],
    },
  ],
  gbt = {
    startPoint: {
      type: 'start',
      name: '出发点：上庄',
      weight: 50,
      trainCarriageNum: 15,
      staffNum: 30,
      goods: '钢铁',
      carrierCompany: 'xxx铁路公司',
      position: [118.06147249, 29.09437053],
    },
    endPoint: {
      type: 'end',
      name: '终点：温州',
      weight: 50,
      trainCarriageNum: 15,
      staffNum: 30,
      goods: '钢铁',
      carrierCompany: 'xxx铁路公司',
      position: [120.69660819, 27.98703907],
    },
    coordinates: [
      [118.06147249, 29.09437053],
      [118.0956414, 29.09402359],
      [118.13796938, 29.07640924],
      [118.19642225, 29.0535061],
      [118.23673457, 29.03588484],
      [118.25487517, 29.02178567],
      [118.31937461, 29.01649799],
      [118.3596869, 28.99710752],
      [118.37782752, 28.97595002],
      [118.40806161, 28.97418682],
      [118.44837378, 28.96360633],
      [118.49876403, 28.94244211],
      [118.52899822, 28.92127359],
      [118.66807481, 28.92833024],
      [118.70435566, 28.93009433],
      [118.77087071, 28.92480197],
      [118.80715149, 28.90892329],
      [118.85955716, 28.90715884],
      [118.92607201, 28.94420596],
      [118.96235299, 28.97242348],
      [118.98452452, 28.97947666],
      [119.03491463, 28.97066011],
      [119.06917992, 28.98652936],
      [119.09135159, 28.99710752],
      [119.19616307, 29.00239608],
      [119.28686544, 29.03412255],
      [119.40578655, 29.09578486],
      [119.50656697, 29.09930731],
      [119.56098837, 29.0975461],
      [119.63355037, 29.10987389],
      [119.69200306, 29.11515685],
      [119.73836221, 29.13100395],
      [119.77464363, 29.15036932],
      [119.82704933, 29.15917056],
      [119.89961165, 29.18908909],
      [119.95201847, 29.26120993],
      [119.96123083, 29.29514243],
      [120.00510185, 29.24251983],
      [120.0626832154384, 29.220984539819884],
      [120.09993742, 29.22210696],
      [120.26445654, 29.21971398],
      [120.33849027, 29.19817389],
      [120.37413582, 29.15986946],
      [120.40703949, 29.10957315],
      [120.43171697, 28.98732283],
      [120.45639466, 28.94894001],
      [120.56607363, 28.9153434],
      [120.62639697, 28.88413668],
      [120.72236446, 28.59563483],
      [120.76349295, 28.43175891],
      [120.78268673, 28.39075924],
      [120.77994446, 28.33526374],
      [120.80462206, 28.2676651],
      [120.78268575, 28.19035693],
      [120.74155543, 28.08154798],
      [120.73389575, 28.06827078],
      [120.67590086, 28.06740345],
      [120.64444606, 28.06653608],
      [120.61814852, 28.0513999],
      [120.59521892, 28.02477031],
      [120.59373218, 28.01024159],
      [120.60435526, 27.98605162],
      [120.61609654, 27.9761766],
      [120.64908394, 27.97765792],
      [120.69660819, 27.98703907],
    ],
  },
  mbt = {
    startPoint: {
      type: 'start',
      name: '出发点：绍兴',
      weight: 150,
      trainCarriageNum: 10,
      staffNum: 20,
      goods: '卷材',
      carrierCompany: 'yyy铁路公司',
      position: [120.35689132, 30.12687758],
    },
    endPoint: {
      type: 'end',
      name: '终点：台州',
      weight: 150,
      trainCarriageNum: 10,
      staffNum: 30,
      goods: '卷材',
      carrierCompany: 'yyy铁路公司',
      position: [121.37717601, 28.64967864],
    },
    coordinates: [
      [120.35689132, 30.12687758],
      [120.43682248, 30.11874389],
      [120.55201739, 30.09840659],
      [120.70012505, 30.05364984],
      [120.78710885, 30.04958005],
      [120.9211109, 30.03736966],
      [121.01044568, 30.06178894],
      [121.06451676, 30.08009946],
      [121.1373952, 30.10044051],
      [121.2267299, 30.08823638],
      [121.29725698, 30.03329919],
      [121.39599494, 29.98240432],
      [121.46887301, 29.96000233],
      [121.52764563, 29.94370674],
      [121.53704885, 29.89888038],
      [121.5252938, 29.84383863],
      [121.60757555, 29.84179941],
      [121.63578675, 29.84383863],
      [121.60522392, 29.77040247],
      [121.5440996, 29.68874383],
      [121.45476474, 29.62541263],
      [121.42420266, 29.58044402],
      [121.41479865, 29.52931891],
      [121.40069301, 29.4965853],
      [121.44065772, 29.4290389],
      [121.42184961, 29.32622424],
      [121.40539271, 29.27702104],
      [121.41009399, 29.2216391],
      [121.41714604, 29.15390948],
      [121.40539083, 29.0881897],
      [121.34426671, 29.03476155],
      [121.29959906, 28.98747511],
      [121.26198414, 28.93605246],
      [121.25728198, 28.89283758],
      [121.23377263, 28.85372318],
      [121.2525793, 28.78575252],
      [121.31370255, 28.76720739],
      [121.35601859, 28.75072007],
      [121.38422909, 28.71979934],
      [121.37717601, 28.64967864],
    ],
  }
const ybt = {
    class: 'large-screen',
  },
  _bt = {
    class: 'large-screen-wrap',
    id: 'large-screen',
  },
  xbt = {
    class: 'top-menu',
  },
  Sbt = {
    class: 'top-count-card',
  },
  Abt = {
    class: 'left-wrap',
  },
  bbt = {
    class: 'left-wrap-3d',
  },
  wbt = {
    class: 'right-wrap',
  },
  Mbt = {
    class: 'right-wrap-3d',
  },
  Tbt = {
    class: 'bottom-tray',
  },
  Cbt = {
    class: 'bottom-menu',
  },
  Ebt = {
    class: 'bottom-radar',
  },
  Dbt = {
    class: 'loading',
  },
  Lbt = {
    class: 'loading-progress',
  },
  Pbt = {
    class: 'value',
  },
  Ubt = {
    __name: 'index',
    setup(r) {
      const t = hh(null),
        e = je(null),
        n = yM({
          progress: 0,
          activeIndex: '1',
          totalView: [
            {
              icon: 'xiaoshoujine',
              zh: '2024年生产总值',
              en: 'Gross Domestic Product in 2024',
              value: 31500,
              unit: '亿元',
            },
            {
              icon: 'zongxiaoliang',
              zh: '2024年常驻人数',
              en: 'resident population in 2024',
              value: 15e3,
              unit: '万人',
            },
          ],
          bottomMenuIndex: 0,
          bottomMenuStatus: {
            bar: !0,
            point: !1,
            path: !1,
            hotmap: !1,
          },
        })
      Ea(() => {
        Ee.$on('mapPlayComplete', s),
          (t.value = pbt.init({
            dh: 1080,
            dw: 1920,
            el: '#large-screen',
            resize: !0,
          })),
          i(async () => {
            Ee.$emit('loadMap', t.value), await a(), e.value.play()
          })
      }),
        Da(() => {
          Ee.$off('mapPlayComplete', s)
        })
      function i(d) {
        t.value = new fbt()
        let p = {
          progress: 0,
        }
        t.value.instance.on('onProgress', (g, v, m) => {
          let y = Math.floor((v / m) * 100)
          Sn.to(p, {
            progress: y,
            onUpdate: () => {
              n.progress = Math.floor(p.progress)
            },
          })
        }),
          t.value.instance.on('onLoad', () => {
            d && d()
          })
      }
      async function a() {
        return new Promise((d, p) => {
          let g = Sn.timeline()
          g.to('.loading-text span', {
            y: '200%',
            opacity: 0,
            ease: 'power4.inOut',
            duration: 2,
            stagger: 0.2,
          }),
            g.to(
              '.loading-progress',
              {
                opacity: 0,
                ease: 'power4.inOut',
                duration: 2,
              },
              '<',
            ),
            g.to(
              '.loading',
              {
                opacity: 0,
                ease: 'power4.inOut',
                onComplete: () => {
                  d()
                },
              },
              '-=1',
            )
        })
      }
      function o(d) {
        n.activeIndex = d
      }
      function s() {
        let d = Sn.timeline({
            paused: !1,
          }),
          p = Sn.utils.toArray('.left-card'),
          g = Sn.utils.toArray('.right-card'),
          v = Sn.utils.toArray('.count-card')
        d.addLabel('start', 0.5),
          d.addLabel('menu', 0.5),
          d.addLabel('card', 1),
          d.addLabel('countCard', 3),
          d.to(
            '.m-header',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            'start',
          ),
          d.to(
            '.bottom-tray',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            'start',
          ),
          d.to(
            '.top-menu',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            '-=1',
          ),
          d.to(
            '.bottom-radar',
            {
              y: 0,
              opacity: 1,
              duration: 1.5,
              ease: 'power4.out',
            },
            '-=2',
          ),
          d.to(
            p,
            {
              x: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          ),
          d.to(
            g,
            {
              x: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          ),
          d.to(
            v,
            {
              y: 0,
              opacity: 1,
              stagger: 0.2,
              duration: 1.5,
              ease: 'power4.out',
            },
            'card',
          )
      }
      function l() {
        let d = jF.filter((p, g) => g < 7)
        Ee.$emit('createBar', d)
      }
      function u() {
        Ee.$emit('createPoint', vbt)
      }
      function c() {
        let d = Math.random() > 0.5 ? gbt : mbt
        Ee.$emit('createPath', d)
      }
      function h() {
        Ee.$emit('createHeatmap')
      }
      function f(d) {
        n.bottomMenuStatus[d] = !n.bottomMenuStatus[d]
        const p = {
            bar: () => {
              Ee.$emit('destroyBar')
            },
            point: () => {
              Ee.$emit('destroyPoint')
            },
            path: () => {
              Ee.$emit('destroyPath')
            },
            hotmap: () => {
              Ee.$emit('destroyHeatmap')
            },
          },
          g = {
            bar: () => {
              l()
            },
            point: () => {
              u()
            },
            path: () => {
              c()
            },
            hotmap: () => {
              h()
            },
          }
        n.bottomMenuStatus[d] ? g[d] && g[d]() : p[d] && p[d]()
      }
      return (d, p) => (
        en(),
        sn('div', ybt, [
          ye(
            Nj,
            {
              ref_key: 'mapSceneRef',
              ref: e,
            },
            null,
            512,
          ),
          wt('div', _bt, [
            Of(
              ye(
                tJ,
                {
                  title: '浙江省数据可视化平台',
                  'sub-text': 'Zhejiang Province Data Visualization Platform',
                },
                {
                  left: Qn(
                    () =>
                      p[4] ||
                      (p[4] = [
                        wt(
                          'div',
                          {
                            class: 'm-header-weather',
                          },
                          [wt('span', null, '小雨'), wt('span', null, '27℃')],
                          -1,
                        ),
                      ]),
                  ),
                  right: Qn(
                    () =>
                      p[5] ||
                      (p[5] = [
                        wt(
                          'div',
                          {
                            class: 'm-header-date',
                          },
                          [
                            wt('span', null, '2024-10-12'),
                            wt('span', null, '17:53:16'),
                          ],
                          -1,
                        ),
                      ]),
                  ),
                  _: 1,
                },
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                xbt,
                [
                  ye(
                    pJ,
                    {
                      'default-active': n.activeIndex,
                      onSelect: o,
                    },
                    {
                      default: Qn(() => [
                        ye(
                          Bc,
                          {
                            index: '1',
                          },
                          {
                            default: Qn(
                              () => p[6] || (p[6] = [ko('经济概览')]),
                            ),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '2',
                          },
                          {
                            default: Qn(() => p[7] || (p[7] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '3',
                          },
                          {
                            default: Qn(() => p[8] || (p[8] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        p[12] ||
                          (p[12] = wt(
                            'div',
                            {
                              class: 'top-menu-mid-space',
                            },
                            null,
                            -1,
                          )),
                        ye(
                          Bc,
                          {
                            index: '4',
                          },
                          {
                            default: Qn(() => p[9] || (p[9] = [ko('导航栏')])),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '5',
                          },
                          {
                            default: Qn(
                              () => p[10] || (p[10] = [ko('导航栏')]),
                            ),
                            _: 1,
                          },
                        ),
                        ye(
                          Bc,
                          {
                            index: '6',
                          },
                          {
                            default: Qn(
                              () => p[11] || (p[11] = [ko('导航栏')]),
                            ),
                            _: 1,
                          },
                        ),
                      ]),
                      _: 1,
                    },
                    8,
                    ['default-active'],
                  ),
                ],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                Sbt,
                [
                  (en(!0),
                  sn(
                    _M,
                    null,
                    xM(
                      n.totalView,
                      (g, v) => (
                        en(),
                        _8(
                          fJ,
                          {
                            info: g,
                            key: v,
                          },
                          null,
                          8,
                          ['info'],
                        )
                      ),
                    ),
                    128,
                  )),
                ],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                Abt,
                [wt('div', bbt, [ye(mAt), ye(NAt), ye(kAt), ye(BAt)])],
                512,
              ),
              [[Nf, !0]],
            ),
            Of(
              wt(
                'div',
                wbt,
                [wt('div', Mbt, [ye(FAt), ye(WAt), ye(XAt), ye(YAt)])],
                512,
              ),
              [[Nf, !0]],
            ),
            wt('div', Tbt, [
              ye(Oy, {
                class: 'bottom-svg-line-left',
                width: 721,
                height: 57,
                color: '#30DCFF',
                strokeWidth: 2,
                dir: [0, 1],
                length: 50,
                path: 'M1 56.6105C1 31.5123 185.586 10.0503 451.904 1.35519C458.942 1.12543 465.781 4.00883 470.505 9.22964L484.991 25.2383C487.971 28.4775 492.938 30.4201 498.254 30.4201H720.142',
              }),
              ye(Oy, {
                class: 'bottom-svg-line-left bottom-svg-line-right',
                width: 721,
                height: 57,
                color: '#30DCFF',
                strokeWidth: 2,
                dir: [0, 1],
                length: 50,
                path: 'M1 56.6105C1 31.5123 185.586 10.0503 451.904 1.35519C458.942 1.12543 465.781 4.00883 470.505 9.22964L484.991 25.2383C487.971 28.4775 492.938 30.4201 498.254 30.4201H720.142',
              }),
              p[17] ||
                (p[17] = wt(
                  'div',
                  {
                    class: 'bottom-tray-arrow',
                  },
                  [
                    wt('img', {
                      src: YE,
                      alt: '',
                    }),
                    wt('img', {
                      src: $E,
                      alt: '',
                    }),
                  ],
                  -1,
                )),
              wt('div', Cbt, [
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.bar,
                      },
                    ]),
                    onClick: p[0] || (p[0] = g => f('bar')),
                  },
                  p[13] || (p[13] = [wt('span', null, '柱状图', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.point,
                      },
                    ]),
                    onClick: p[1] || (p[1] = g => f('point')),
                  },
                  p[14] || (p[14] = [wt('span', null, '告警点位', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.path,
                      },
                    ]),
                    onClick: p[2] || (p[2] = g => f('path')),
                  },
                  p[15] || (p[15] = [wt('span', null, '轨道路线', -1)]),
                  2,
                ),
                wt(
                  'div',
                  {
                    class: fh([
                      'bottom-menu-item',
                      {
                        'is-active': n.bottomMenuStatus.hotmap,
                      },
                    ]),
                    onClick: p[3] || (p[3] = g => f('hotmap')),
                  },
                  p[16] || (p[16] = [wt('span', null, '热力图', -1)]),
                  2,
                ),
              ]),
              p[18] ||
                (p[18] = wt(
                  'div',
                  {
                    class: 'bottom-tray-arrow is-reverse',
                  },
                  [
                    wt('img', {
                      src: YE,
                      alt: '',
                    }),
                    wt('img', {
                      src: $E,
                      alt: '',
                    }),
                  ],
                  -1,
                )),
            ]),
            wt('div', Ebt, [ye(xJ)]),
            p[19] ||
              (p[19] = wt(
                'div',
                {
                  class: 'large-screen-left-zsline',
                },
                null,
                -1,
              )),
            p[20] ||
              (p[20] = wt(
                'div',
                {
                  class: 'large-screen-right-zsline',
                },
                null,
                -1,
              )),
          ]),
          wt('div', Dbt, [
            p[22] ||
              (p[22] = y8(
                '<div class="loading-text"><span style="--index:1;">L</span><span style="--index:2;">O</span><span style="--index:3;">A</span><span style="--index:4;">D</span><span style="--index:5;">I</span><span style="--index:6;">N</span><span style="--index:7;">G</span></div>',
                1,
              )),
            wt('div', Lbt, [
              wt('span', Pbt, Si(n.progress), 1),
              p[21] ||
                (p[21] = wt(
                  'span',
                  {
                    class: 'unit',
                  },
                  '%',
                  -1,
                )),
            ]),
          ]),
        ])
      )
    },
  }
export {Ubt as default}
